{
  "openapi" : "3.1.0",
  "components" : {
    "schemas" : {
      "Account" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "authScheme" : {
            "$ref" : "#/components/schemas/AccountAuthScheme"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "managedByLdap" : {
            "type" : "boolean"
          },
          "fullName" : {
            "type" : [ "string", "null" ],
            "description" : "Full name of LDAP/OIDC users"
          },
          "distinguishedName" : {
            "type" : [ "string", "null" ],
            "description" : "Distinguished name (DN) of LDAP users"
          },
          "managedByOidcProvider" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/AccountOidcInfo"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "username", "roles", "authScheme" ]
      },
      "AccountAuthScheme" : {
        "type" : "string",
        "enum" : [ "password", "ldap", "oidc", "api_token" ]
      },
      "AccountOidcInfo" : {
        "type" : "object",
        "properties" : {
          "oidcRefreshTokenPresent" : {
            "type" : "boolean"
          },
          "oidcRefreshExpiry" : {
            "type" : [ "string", "null" ]
          },
          "oidcUpdateExpiry" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AccountRequest" : {
        "description" : "Request to create a new croit user.",
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Login name of the user."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "AclEntry" : {
        "type" : "object",
        "description" : "An ACL entry for a bucket, see S3 documentation for details.",
        "required" : [ "grantee", "permission" ],
        "properties" : {
          "grantee" : {
            "$ref" : "#/components/schemas/AclEntryGrantee"
          },
          "userId" : {
            "type" : [ "string", "null" ],
            "description" : "Only meaningful if grantee == SINGLE_USER."
          },
          "displayName" : {
            "type" : [ "string", "null" ],
            "description" : "Informational. Not used when setting ACLs."
          },
          "permission" : {
            "type" : "object"
          }
        }
      },
      "AclEntryGrantee" : {
        "type" : "string",
        "enum" : [ "ALL_USERS", "AUTHENTICATED_USERS", "SINGLE_USER", "LOG_DELIVERY" ]
      },
      "ActiveDirectorySmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "domain", "netbiosDomainName", "serviceDnsName", "domainController", "dnsServers", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : "string",
            "description" : "Active Directory domain/realm, e.g., MY-ORG.LOCAL"
          },
          "netbiosDomainName" : {
            "type" : "string",
            "description" : "NetBIOS domain name, e.g., MY-ORG"
          },
          "serviceDnsName" : {
            "type" : "string",
            "description" : "Service DNS name which will be used as NetBIOS name by which an SMB server is known."
          },
          "domainController" : {
            "type" : "string",
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Try to join with adcli+sssd. The image running on the server needs to support this."
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AdminCephPermissions" : {
        "type" : "object"
      },
      "ApiTokenInfo" : {
        "description" : "Information about an API token.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Account ID of the API token."
          },
          "name" : {
            "type" : "string",
            "description" : "Descriptive name of the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Roles for the API token."
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry time of the API token (optional, if omitted, the token doesn't expire)."
          }
        },
        "required" : [ "name", "roles" ]
      },
      "ApiTokenRequest" : {
        "description" : "Request to create a new API token.",
        "type" : "object",
        "required" : [ "name", "roles" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Descriptive name for the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Time when api token is supposed to expire (optional)."
          }
        }
      },
      "ApiTokenUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin role also needs viewer role."
          }
        }
      },
      "ApiWarning" : {
        "type" : "object",
        "required" : [ "id", "message" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "message" : {
            "type" : "string"
          }
        }
      },
      "ArchConfig" : {
        "type" : "object",
        "properties" : {
          "x86_64" : {
            "type" : "boolean",
            "description" : "Whether x86_64 images are enabled."
          },
          "arm64" : {
            "type" : "boolean",
            "description" : "Whether arm64 images are enabled."
          }
        }
      },
      "AuditInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "category" : {
            "type" : "string"
          },
          "operation" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "method" : {
            "$ref" : "#/components/schemas/AuditLogMethod"
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "endpoint" : {
            "type" : "string"
          },
          "queryParams" : {
            "type" : "string"
          },
          "body" : {
            "type" : "string"
          }
        },
        "required" : [ "time", "category", "operation", "username", "ip", "method", "endpoint", "queryParams", "body" ]
      },
      "AuditLogMethod" : {
        "type" : "string",
        "enum" : [ "POST", "GET", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS" ]
      },
      "AvailableConfigTemplate" : {
        "type" : "object",
        "required" : [ "name", "template" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "template" : {
            "type" : "string"
          }
        }
      },
      "AvailableMigrationTasks" : {
        "type" : "object",
        "properties" : {
          "mimic" : {
            "type" : "boolean"
          },
          "nautilus" : {
            "type" : "boolean"
          },
          "octopus" : {
            "type" : "boolean"
          },
          "pacific" : {
            "type" : "boolean"
          },
          "quincy" : {
            "type" : "boolean"
          },
          "reef" : {
            "type" : "boolean"
          },
          "switchTarget" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BackendStatus" : {
        "description" : "Status overview of the croit backend. Does not contain Ceph information.",
        "type" : "object",
        "properties" : {
          "doSetup" : {
            "type" : "boolean",
            "description" : "Cluster setup required"
          },
          "cephConfigured" : {
            "type" : "boolean",
            "description" : "True if Ceph is configured and ceph status can be queried"
          },
          "daosConfigured" : {
            "type" : "boolean",
            "description" : "True if DAOS is configured"
          },
          "status" : {
            "description" : "Croit health check",
            "type" : "string",
            "$ref" : "#/components/schemas/CroitHealthStatus"
          },
          "oktaOAuth" : {
            "type" : "boolean",
            "description" : "Auth via Okta available"
          },
          "versions" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitApiVersion"
            },
            "description" : "Available croit versions"
          },
          "currentVersion" : {
            "type" : "string",
            "description" : "Running croit version"
          },
          "currentVersionParsed" : {
            "description" : "Running croit version (parsed)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "useCustomLogo" : {
            "type" : "boolean",
            "description" : "Custom logo available at /api/extra-files/logo[-small].svg"
          },
          "backends" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CroitBackendConfiguration"
            },
            "description" : "Manage multiple croit clusters that share a centralized login system. This list may or may not contain the current cluster"
          },
          "multiMdsEnabled" : {
            "type" : "boolean",
            "description" : "Multi MDS is enabled"
          },
          "multiRgwEnabled" : {
            "type" : "boolean",
            "description" : "Multi RGW is enabled"
          },
          "error" : {
            "type" : [ "string", "null" ],
            "description" : "Error message to display in case there are critical errors in croit."
          },
          "errorLong" : {
            "type" : [ "string", "null" ],
            "description" : "Longer error message to display in case there are critical errors in croit."
          }
        },
        "required" : [ "status", "versions", "currentVersion" ]
      },
      "BackupRestoreRequest" : {
        "type" : "object",
        "required" : [ "encryptionKey", "croitApiToken", "backupUuid" ],
        "properties" : {
          "encryptionKey" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "croitApiToken" : {
            "type" : "string"
          },
          "backupUuid" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "BondRequest" : {
        "type" : "object",
        "required" : [ "name", "nics" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "activePassive" : {
            "type" : "boolean"
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BondUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "activePassive" : {
            "type" : [ "boolean", "null" ]
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BootDiskRequest" : {
        "type" : "object",
        "properties" : {
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to install croit on."
          },
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that the disk is on. Used as a sanity check that the correct disk is selected."
          }
        }
      },
      "BucketCreationRequest" : {
        "description" : "Create an S3 bucket.",
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "User id of the owner"
          },
          "placement" : {
            "type" : [ "string", "null" ],
            "description" : "Name of a placement policy as returned by /placements"
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "expectedNumberOfObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Expected number of objects to pre-shard the bucket. If in doubt: don't set this as setting a too large value will degrade performance."
          },
          "endpoint" : {
            "type" : [ "string", "null" ],
            "description" : "The S3 endpoint (full URL) used to create this bucket, this effectively controls the zonegroup in which the bucket is created."
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "BucketDeletionRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "deleteData" : {
            "type" : [ "boolean", "null" ]
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BucketDetails" : {
        "type" : "object",
        "required" : [ "cors", "acl", "versioning" ],
        "properties" : {
          "cors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CORSRuleResponse"
            }
          },
          "acl" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
          }
        }
      },
      "BucketUpdateRequest" : {
        "description" : "Update an S3 bucket.",
        "type" : "object",
        "properties" : {
          "owner" : {
            "type" : [ "string", "null" ],
            "description" : "Change owner to this uid."
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CORSRuleResponse" : {
        "description" : "S3 CORS rule",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "string", "null" ],
            "description" : "Unique identifier for the rule"
          },
          "allowedMethods" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed HTTP methods"
          },
          "allowedOrigins" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed origins"
          },
          "allowedHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed headers"
          },
          "exposeHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Exposed headers"
          },
          "maxAgeSeconds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max age in seconds for preflight requests"
          }
        },
        "required" : [ "allowedMethods", "allowedOrigins", "allowedHeaders", "exposeHeaders" ]
      },
      "Category" : {
        "type" : "string",
        "enum" : [ "CEPH", "BACKUP", "CRUSH", "MON", "MGR", "OSD", "PG", "RGW", "NFS", "ISCSI", "SMB", "OS", "CROIT", "RBD_MIRROR", "MDS", "NVMEOF" ]
      },
      "CephConfChangeRequest" : {
        "type" : "object",
        "properties" : {
          "value" : { },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CephConfDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "CephConfigDumpLevel" : {
        "type" : "string",
        "enum" : [ "BASIC", "ADVANCED", "DEV", "UNKNOWN" ]
      },
      "CephConfigResponse" : {
        "type" : "object",
        "required" : [ "name", "value", "description", "default", "level", "seeAlso" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "value" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "description" : {
            "type" : "string"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephConfigUnit"
            }, {
              "type" : "null"
            } ]
          },
          "default" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "level" : {
            "$ref" : "#/components/schemas/CephConfigDumpLevel"
          },
          "seeAlso" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "canUpdateAtRuntime" : {
            "type" : [ "boolean", "null" ]
          },
          "currentValue" : { },
          "currentValueFormatted" : { },
          "defaultValue" : { },
          "defaultValueFormatted" : { }
        }
      },
      "CephConfigType" : {
        "type" : "string",
        "enum" : [ "STRING", "INT", "DOUBLE", "BOOL", "TEXT_FILE" ]
      },
      "CephConfigUnit" : {
        "type" : "string",
        "enum" : [ "BYTES", "SECONDS" ]
      },
      "CephConfigValueReply" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CephConfigType"
          },
          "value" : { }
        }
      },
      "CephDashboardRole" : {
        "type" : "object",
        "required" : [ "scopes_permissions", "name" ],
        "properties" : {
          "scopes_permissions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephDashboardUser" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "integer",
            "format" : "int64"
          },
          "name" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "croitImport" : {
            "type" : "boolean"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFSSnapshotSchedule" : {
        "description" : "Object containing all information for an CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a millisecond-precision timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "Comma-separated string of CephFS directories to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "pathsFormatted", "failedSnapshots" ]
      },
      "CephFlagReponse" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "recommendedState" : {
            "type" : "boolean"
          },
          "currentState" : {
            "type" : "boolean"
          }
        }
      },
      "CephFsDirectoryEntries" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFsDirectoryEntriesWithStats" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            }
          }
        }
      },
      "CephFsFileType" : {
        "type" : "string",
        "enum" : [ "FILE", "DIR", "SYMLINK", "UNKNOWN" ]
      },
      "CephFsFileUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "absolutePath" : {
            "type" : [ "string", "null" ],
            "description" : "New absolute path of the file to rename or move the file."
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Permissions in Unix notation."
          }
        }
      },
      "CephFsLayout" : {
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsMonitoredDir" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-cephfs-dir-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of bytes. Deprecated, use value returned by /stats API."
          },
          "quotaFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of files. Deprecated, use value returned by /stats API"
          }
        }
      },
      "CephFsNewDirectoryRequest" : {
        "type" : "object",
        "required" : [ "dir" ],
        "properties" : {
          "dir" : {
            "type" : "string"
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "null to use the default pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsPathPermission" : {
        "type" : "object",
        "required" : [ "path", "permissions" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephfsPathPermissionType"
          }
        }
      },
      "CephFsQuota" : {
        "type" : "object",
        "properties" : {
          "maxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephFsResponse" : {
        "type" : "object",
        "required" : [ "path", "sizeFormatted", "dirFilesFormatted", "modeFormatted", "quotaMaxBytesFormatted" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "fullPath" : {
            "type" : [ "string", "null" ]
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephFsFileType"
            }, {
              "type" : "null"
            } ]
          },
          "dirBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirSubdirs" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "symlinkPath" : {
            "type" : [ "string", "null" ]
          },
          "isDir" : {
            "type" : [ "boolean", "null" ]
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "dirFilesFormatted" : {
            "type" : "string"
          },
          "modeFormatted" : {
            "type" : "string"
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string"
          }
        }
      },
      "CephFsSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a CephFS snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\".",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot.",
            "minItems" : 1
          }
        }
      },
      "CephFsSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          }
        }
      },
      "CephFsUploadRequest" : {
        "type" : "object",
        "required" : [ "file", "path" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "path" : {
            "type" : "string"
          }
        }
      },
      "CephHealth" : {
        "type" : "string",
        "enum" : [ "HEALTH_OK", "HEALTH_WARN", "HEALTH_ERR", "HEALTH_UNKNOWN" ]
      },
      "CephHealthCheckDetailMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          }
        }
      },
      "CephHealthCheckSummaryMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephModule" : {
        "type" : "object",
        "required" : [ "name", "error_string", "module_options" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "can_run" : {
            "type" : "boolean"
          },
          "error_string" : {
            "type" : "string"
          },
          "module_options" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephModuleOption"
            }
          }
        }
      },
      "CephModuleOption" : {
        "type" : "object",
        "required" : [ "name", "type", "level", "default_value", "min", "max", "enum_allowed", "desc", "long_desc", "tags", "see_also" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string"
          },
          "level" : {
            "type" : "string"
          },
          "flags" : {
            "type" : "integer",
            "format" : "int32"
          },
          "default_value" : {
            "type" : "string"
          },
          "min" : {
            "type" : "string"
          },
          "max" : {
            "type" : "string"
          },
          "enum_allowed" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "desc" : {
            "type" : "string"
          },
          "long_desc" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "see_also" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephModuleStatus" : {
        "type" : "object",
        "required" : [ "enabled_modules", "disabled_modules" ],
        "properties" : {
          "enabled_modules" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "disabled_modules" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephModule"
            }
          }
        }
      },
      "CephMutedStatusCheck" : {
        "type" : "object",
        "required" : [ "code", "summary" ],
        "properties" : {
          "code" : {
            "type" : "string",
            "description" : "Name of the muted status check.",
            "examples" : [ "SLOW_OPS" ]
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Indicates whether this check will stay muted once it's resolved."
          },
          "summary" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPermissions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "raw" : "#/components/schemas/RawCephPermissions",
            "admin" : "#/components/schemas/AdminCephPermissions",
            "rbd" : "#/components/schemas/RbdCephPermissions",
            "cephfs" : "#/components/schemas/CephfsCephPermissions"
          }
        },
        "type" : "object"
      },
      "CephPgStat" : {
        "type" : "object",
        "required" : [ "pgid", "state", "acting", "up" ],
        "properties" : {
          "pgid" : {
            "type" : "string"
          },
          "state" : {
            "type" : "string"
          },
          "last_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "last_deep_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "acting" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "acting_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPoolDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "stats", "hints", "redundancy", "unprotectedUntilFormatted", "quotaMaxBytesFormatted", "quotaMaxObjectsFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgpNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "crushRule" : {
            "type" : "integer",
            "format" : "int32"
          },
          "stats" : {
            "$ref" : "#/components/schemas/PoolStatsResponse"
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "erasureCodingOverwriteSupportMissing" : {
            "type" : "boolean",
            "description" : "Indicates whether this pool is missing the ec_overwrites flag."
          },
          "fastRead" : {
            "type" : "boolean",
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "unprotectedUntil" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Time until the no_delete flag on the pool will be set again if it was temporarily disabled. null if pool is currently protected."
          },
          "deleteProtected" : {
            "type" : "boolean",
            "description" : "True if pool is currently protected from deletion."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to display in the UI."
          },
          "redundancy" : {
            "type" : "string"
          },
          "unprotectedUntilFormatted" : {
            "type" : "string",
            "description" : "Like unprotectedUntil, but formatted into a human-readable string."
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxBytes formatted to be human-readable and to show usage percentage"
          },
          "quotaMaxObjectsFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxObjects formatted to be more easily readable and to show usage percentage"
          }
        }
      },
      "CephPoolSurvey" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "application" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "pgNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "crushRule" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "unprotect" : {
            "type" : [ "boolean", "null" ]
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "fastRead" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "compression" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionSettings"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephRelease" : {
        "type" : "string",
        "enum" : [ "luminous", "mimic", "nautilus", "octopus", "pacific", "quincy", "reef" ]
      },
      "CephReleaseCount" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "$ref" : "#/components/schemas/CephRelease"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephReleases" : {
        "type" : "object",
        "required" : [ "mon", "mgr", "osd", "mds", "overall", "other" ],
        "properties" : {
          "mon" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mgr" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "osd" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "overall" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "other" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/CephReleaseCount"
              }
            }
          }
        }
      },
      "CephStatus" : {
        "type" : "object",
        "required" : [ "fsid", "health" ],
        "properties" : {
          "fsid" : {
            "type" : "string"
          },
          "quorumNamesCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "health" : {
            "$ref" : "#/components/schemas/CephStatusHealth"
          },
          "osdMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusOsdmap"
            }, {
              "type" : "null"
            } ]
          },
          "mgrMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusMgrMap"
            }, {
              "type" : "null"
            } ]
          },
          "pgMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusPgMap"
            }, {
              "type" : "null"
            } ]
          },
          "numOfMons" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusCheck" : {
        "type" : "object",
        "required" : [ "severity", "summary" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "summary" : {
            "$ref" : "#/components/schemas/CephHealthCheckSummaryMessage"
          },
          "detail" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephHealthCheckDetailMessage"
            }
          },
          "muted" : {
            "type" : "boolean",
            "description" : "Indicates whether this check is muted."
          }
        }
      },
      "CephStatusHealth" : {
        "type" : "object",
        "required" : [ "status", "checks" ],
        "properties" : {
          "status" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "checks" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephStatusCheck"
            }
          },
          "mutes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephMutedStatusCheck"
            },
            "description" : "List of muted status checks. null indicates that the current ceph version doesn't support muting status checks."
          }
        }
      },
      "CephStatusMgrMap" : {
        "type" : "object",
        "properties" : {
          "available" : {
            "type" : [ "boolean", "null" ]
          },
          "standbysCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusOsdmap" : {
        "type" : "object",
        "properties" : {
          "numUpOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusPgMap" : {
        "type" : "object",
        "properties" : {
          "bytesUsed" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "bytesTotal" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringBytesPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringObjectsPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dataBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephUserRequest" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions" ],
        "properties" : {
          "user" : {
            "type" : "string",
            "description" : "A fully qualified Ceph user name, i.e., usually client.XYZ"
          },
          "comment" : {
            "type" : "string",
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "Permissions for this keyring",
            "type" : "object",
            "$ref" : "#/components/schemas/CephPermissions"
          }
        }
      },
      "CephUserResponse" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions", "rawPermissions" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "comment" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephPermissions"
          },
          "rawPermissions" : {
            "$ref" : "#/components/schemas/RawCephPermissions"
          }
        }
      },
      "CephUserUpdate" : {
        "type" : "object",
        "properties" : {
          "comment" : {
            "type" : [ "string", "null" ],
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "New permissions for this keyring",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephPermissions"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephVersionConfiguration" : {
        "type" : "object",
        "required" : [ "cephVersion" ],
        "properties" : {
          "cephVersion" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "CephfsCephPermissions" : {
        "type" : "object",
        "required" : [ "pools", "paths" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            }
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsPathPermission"
            }
          }
        }
      },
      "CephfsClientInfo" : {
        "description" : "A Ceph client connected to CephFS, can be either a Kernel or libcephfs client.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numLeases" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of open files"
          },
          "numCaps" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of CephFS caps"
          },
          "state" : {
            "type" : "string",
            "description" : "Connection state"
          },
          "requestLoadAverage" : {
            "type" : "number",
            "format" : "double",
            "description" : "Load caused by this client's requests"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP the client is connecting from"
          },
          "cephUser" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph user name used by this client"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname reported by the client"
          },
          "mountpoint" : {
            "type" : [ "string", "null" ],
            "description" : "Subtree mounted by the client"
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Client Ceph or kernel version"
          }
        },
        "required" : [ "state", "ip" ]
      },
      "CephfsPathPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE", "READ_WRITE_PLACEMENT", "READ_WRITE_SNAPSHOT", "READ_WRITE_PLACEMENT_SNAPSHOT" ]
      },
      "CephfsSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "files" : {
            "type" : "integer",
            "format" : "int64"
          },
          "dirs" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "ChangeRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "createdBy" : {
            "$ref" : "#/components/schemas/ChangeRequestUser"
          },
          "affectedObject" : {
            "type" : "string"
          },
          "changes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ChangeRequestItem"
            }
          },
          "state" : {
            "$ref" : "#/components/schemas/ChangeRequestStatus"
          }
        },
        "required" : [ "description", "createdBy", "affectedObject", "changes", "state" ]
      },
      "ChangeRequestItem" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "type" : "string"
          }
        }
      },
      "ChangeRequestStatus" : {
        "type" : "string",
        "enum" : [ "PENDING", "APPROVED", "REJECTED" ]
      },
      "ChangeRequestUser" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CloneRequest" : {
        "description" : "Details for a clone creation request",
        "type" : "object",
        "required" : [ "pool", "name" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool in which to store the clone (can be different from the parent image)"
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the new clone"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace for the new clone. Requires v2 cloning, i.e., all clients must be at least Mimic or kernel 4.19"
          }
        }
      },
      "CloudConfigBackupConfig" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "CloudConfigBackupStatus" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "lastBackupTimestamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp of the last backup, null if never backed up."
          },
          "lastBackupSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the last backup in byte, null if never backed up."
          },
          "lastBackupChecksum" : {
            "type" : [ "string", "null" ],
            "description" : "SHA256 checksum of the encrypted data of the last backup, null if never backed up."
          },
          "clusterId" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "backupEncryptionKey" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "cephFsid" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "ClusterCreationRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "ClusterDeployRequest" : {
        "type" : "object",
        "required" : [ "mons" ],
        "properties" : {
          "mons" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MonitorRequest"
            }
          }
        }
      },
      "ClusterImportRequest" : {
        "type" : "object",
        "required" : [ "adminKey", "mons" ],
        "properties" : {
          "adminKey" : {
            "type" : "string"
          },
          "mons" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "minItems" : 1
          }
        }
      },
      "ClusterStatus" : {
        "description" : "A croit cluster status report consisting of two parts: information about croit-related services and general Ceph services. Both states are gathered independently so you still get information about croit services if your Ceph cluster is down.",
        "type" : "object",
        "required" : [ "timestamp", "cephLastUpdated", "placementGroups", "servers", "mds", "utilizationByDeviceClass", "radosgws", "iscsi", "nfsGateways", "smbGateways", "nvmeofGateways", "licenseValidUntil", "croitUptime" ],
        "properties" : {
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "The timestamp at which this status report was created. Note that the Ceph state can be up to 30 seconds older if Ceph is slow to respond."
          },
          "cephLastUpdated" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Age of the Ceph status in seconds (relative to `timestamp`). Note that this can be negative, i.e., fresher than the other data."
          },
          "cephStatus" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "healthDetails" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusHealth"
            }, {
              "type" : "null"
            } ]
          },
          "placementGroups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PlacementGroupOverview"
            }
          },
          "recoveryTimeRemaining" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "servers" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "mds" : {
            "$ref" : "#/components/schemas/MdsOnlineStatus"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/DeviceClassUtilization"
            }
          },
          "radosgws" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nfsGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "smbGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nvmeofGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "licenseActive" : {
            "type" : "boolean"
          },
          "licenseValidUntil" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "croitUptime" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "ConfigTemplateRequest" : {
        "type" : "object",
        "properties" : {
          "predefinedTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Use a pre-defined template. Either this or customTemplate must be set."
          },
          "customTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Set a completely custom template. Either this or customTemplate must be set."
          }
        }
      },
      "ConfigTemplateResponse" : {
        "type" : "object",
        "required" : [ "id", "description", "currentTemplateName", "currentTemplate", "availableTemplates" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "currentTemplateName" : {
            "type" : "string"
          },
          "currentTemplate" : {
            "type" : "string"
          },
          "availableTemplates" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AvailableConfigTemplate"
            }
          }
        }
      },
      "CpuArchitecture" : {
        "type" : "string",
        "enum" : [ "AMD64", "ARM64" ]
      },
      "CreateDaosContainerRequest" : {
        "type" : "object",
        "required" : [ "name", "type", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the container. Allowed are alphanumeric characters (a-z, A-Z, 0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "type" : {
            "description" : "Type of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Chunk size for the container."
          },
          "objectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default object class for the container."
          },
          "directoryObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default directory object class for the container."
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default file object class for the container."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on container creation. Some properties can only be set when creating a container."
          }
        }
      },
      "CreateDaosPoolRequest" : {
        "type" : "object",
        "required" : [ "name", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the pool. Allowed are alphanumeric characters (a-zA-Z0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the pool in bytes."
          },
          "scmPerc" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Percentage of SCM as percent points. NVMes will thereby get 100 minus this value as percentage."
          },
          "nranks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of ranks to use (which are then chosen automatically). Cannot be used together with ranks."
          },
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ranks to use. Cannot be used together with nranks."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on pool creation. Some properties can only be set when creating a pool."
          }
        }
      },
      "CroitApiVersion" : {
        "type" : "object",
        "required" : [ "version", "releaseDate", "infoUrl" ],
        "properties" : {
          "version" : {
            "type" : "string"
          },
          "releaseDate" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "infoUrl" : {
            "type" : "string"
          }
        }
      },
      "CroitAutoUpdateConfigRequest" : {
        "description" : "Schedule the automatic update of the croit docker image.",
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "custom" : {
            "type" : "boolean",
            "description" : "If true, customized docker registry and docker image settings are used, otherwise the croit defaults."
          },
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryUsername" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry username. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryPassword" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry password. Ignored for PUT requests if \"custom\" is set to true."
          },
          "imageName" : {
            "type" : "string",
            "description" : "The name of the docker image. Ignored for PUT requests if \"custom\" is set to true."
          },
          "croitTag" : {
            "type" : "string",
            "description" : "The docker image tag. Ignored for PUT requests if \"custom\" is set to true."
          }
        },
        "required" : [ "imageName", "croitTag" ]
      },
      "CroitBackendConfiguration" : {
        "description" : "A croit backend configured in the config file.",
        "type" : "object",
        "required" : [ "name", "url" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Display name of the croit cluster"
          },
          "url" : {
            "type" : "string",
            "description" : "API endpoint"
          }
        }
      },
      "CroitDependency" : {
        "type" : "object",
        "required" : [ "id", "dependency", "link", "license", "text" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "dependency" : {
            "type" : "string"
          },
          "link" : {
            "type" : "string"
          },
          "license" : {
            "type" : "string"
          },
          "text" : {
            "type" : "string"
          }
        }
      },
      "CroitHealthStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DB_ERROR", "INTERNAL_ERROR" ]
      },
      "CroitServiceType" : {
        "type" : "string",
        "enum" : [ "osd", "mon", "mgr", "radosgw", "mds", "nfs_gateway", "iscsi", "smb", "rbd_mirror", "daos_server", "daos_agent", "nvmf_tgt", "unknown" ]
      },
      "CroitUser" : {
        "type" : "object",
        "required" : [ "userName", "roles", "providerName", "idString", "name" ],
        "properties" : {
          "userName" : {
            "type" : "string"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean"
          },
          "isApiToken" : {
            "type" : "boolean"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "providerName" : {
            "type" : "string"
          },
          "idString" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          }
        }
      },
      "CroitVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "patch" : {
            "type" : "string"
          },
          "cephRelease" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephRelease"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "patch" ]
      },
      "CrushBucketType" : {
        "type" : "string",
        "enum" : [ "OSD", "HOST", "CHASSIS", "RACK", "ROW", "PDU", "POD", "ROOM", "DATACENTER", "ZONE", "REGION", "ROOT", "UNKNOWN" ]
      },
      "CrushNode" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OsdStatus"
            }, {
              "type" : "null"
            } ]
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushBucketType"
          },
          "children" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "used" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "reweight" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "diskId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalGuid" : {
            "type" : [ "string", "null" ]
          },
          "pgs" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "CrushRuleOp" : {
        "type" : "string",
        "enum" : [ "TAKE", "CHOOSE", "CHOOSE_INDEP", "CHOOSELEAF", "CHOOSELEAF_INDEP", "EMIT", "NOOP", "UNKNOWN", "TUNING" ]
      },
      "CrushRuleResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushRuleType"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "steps" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleStep"
            }
          },
          "typeLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "type", "steps", "typeLabel" ]
      },
      "CrushRuleStep" : {
        "type" : "object",
        "required" : [ "op", "crushMapTextFormat" ],
        "properties" : {
          "op" : {
            "$ref" : "#/components/schemas/CrushRuleOp"
          },
          "crushMapTextFormat" : {
            "type" : "string"
          }
        }
      },
      "CrushRuleType" : {
        "type" : "string",
        "enum" : [ "REPLICATED", "ERASURE" ]
      },
      "CrushTree" : {
        "type" : "object",
        "required" : [ "nodes", "stray" ],
        "properties" : {
          "nodes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          },
          "stray" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          }
        }
      },
      "DaosAclEntry" : {
        "discriminator" : {
          "propertyName" : "kind",
          "mapping" : {
            "raw" : "#/components/schemas/RawDaosAcl",
            "parsed" : "#/components/schemas/ParsedDaosAcl"
          }
        },
        "type" : "object"
      },
      "DaosAclFlag" : {
        "type" : "string",
        "enum" : [ "G" ]
      },
      "DaosAclPermission" : {
        "type" : "string",
        "enum" : [ "r", "w", "c", "d", "t", "T", "a", "A", "o" ]
      },
      "DaosAclPrincipalType" : {
        "type" : "string",
        "enum" : [ "PosixUser", "PosixGroup", "PosixOther", "User", "Group" ]
      },
      "DaosAclResponse" : {
        "type" : "object",
        "required" : [ "entries", "entriesRaw", "ownerUser", "ownerGroup" ],
        "properties" : {
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries parsed into structured JSON. If the ACL failed to be parsed, it's mapped into an entry of kind \"RawDaosAcl\"."
          },
          "entriesRaw" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "ACL entries how they are reported by DAOS, without any parsing done to them."
          },
          "ownerUser" : {
            "type" : "string",
            "description" : "User that owns the pool."
          },
          "ownerGroup" : {
            "type" : "string",
            "description" : "Group that owns the pool."
          }
        }
      },
      "DaosAclType" : {
        "type" : "string",
        "enum" : [ "A" ]
      },
      "DaosCapacity" : {
        "type" : "object",
        "properties" : {
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total NVMe capacity in GB."
          },
          "scm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total SCM capacity in GB."
          }
        }
      },
      "DaosCertificateCreationRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosCertificateResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the certificate, or -1 if it's a DAOS system certificate."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the certificate."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the certificate."
          },
          "expiry" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry of the certificate. If possible, check the CRT file instead."
          },
          "type" : {
            "description" : "Type of certificate.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosCertificateType"
          }
        },
        "required" : [ "name", "description", "expiry", "type" ]
      },
      "DaosCertificateType" : {
        "type" : "string",
        "enum" : [ "CA", "SERVER", "ADMIN", "AGENT", "CLIENT" ]
      },
      "DaosCertificateUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosClientCreationServerRequest" : {
        "description" : "Server to add as a client to a DAOS cluster.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. Can be left empty for clients."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of targets. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of threads. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "version" : {
            "$ref" : "#/components/schemas/DaosVersion"
          },
          "upgradeVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "provider" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32"
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosServerConfig"
            }
          }
        },
        "required" : [ "clusterName", "name", "description", "version", "provider", "servers" ]
      },
      "DaosContainerDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          },
          "pool" : {
            "description" : "UUID of the pool the container resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "type" : {
            "description" : "Container type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "typeRaw" : {
            "type" : "string",
            "description" : "Container type, as reported by DAOS directly."
          },
          "latestSnapshot" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "redundancyFactor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Redundancy factor of the container."
          },
          "numHandles" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "openTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "closeModifyTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "objectClass" : {
            "type" : [ "string", "null" ]
          },
          "dirObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "hints" : {
            "type" : [ "string", "null" ]
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        },
        "required" : [ "name", "pool", "uuid", "type", "typeRaw" ]
      },
      "DaosContainerListResponse" : {
        "type" : "object",
        "required" : [ "uuid", "name" ],
        "properties" : {
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          }
        }
      },
      "DaosContainerType" : {
        "type" : "string",
        "enum" : [ "POSIX", "HDF5", "PYTHON", "SPARK", "DATABASE", "ROOT", "SEISMIC", "METEO", "UNKNOWN" ]
      },
      "DaosCreationRequest" : {
        "description" : "Request to create a new DAOS cluster.",
        "type" : "object",
        "required" : [ "clusterName", "name", "description", "provider", "servers" ],
        "properties" : {
          "clusterName" : {
            "type" : "string",
            "description" : "Name of the DAOS cluster."
          },
          "name" : {
            "type" : "string",
            "description" : "Optional human-readable name for the cluster."
          },
          "description" : {
            "type" : "string",
            "description" : "Optional description for the cluster."
          },
          "provider" : {
            "type" : "string",
            "description" : "Interface provider."
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of targets for this engine."
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of threads (typically targets divided by 4)"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCreationServerRequest"
            },
            "description" : "List of servers to use for DAOS."
          }
        }
      },
      "DaosCreationServerRequest" : {
        "type" : "object",
        "description" : "Server to add as part of the new DAOS cluster",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "isAccessPoint" : {
            "type" : "boolean",
            "description" : "Whether this is an access point."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. If empty, 1 nics per NUMA node will be automatically selected."
          },
          "scms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of SCMs/PMEMs to use. If not provided, all available will be used."
          },
          "nvmes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of NVMe to use. If not provided, all available will be used."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of targets. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of threads. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosDiskCreationRequest" : {
        "type" : "object",
        "required" : [ "name", "pool", "container" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the new DAOS disk in croit."
          },
          "pool" : {
            "description" : "UUID of the DAOS pool that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes for the disk."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DAOS object class to use for the disk."
          }
        }
      },
      "DaosDiskInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "path" : {
            "type" : "string"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "path" ]
      },
      "DaosEngineConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "numaNode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nic" : {
            "$ref" : "#/components/schemas/DaosNic"
          },
          "scms" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          },
          "nvmes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          }
        },
        "required" : [ "nic", "scms", "nvmes" ]
      },
      "DaosMemberState" : {
        "type" : "string",
        "enum" : [ "AwaitFormat", "Starting", "Ready", "Joined", "Stopping", "Stopped", "Excluded", "AdminExcluded", "Errored", "Unresponsive", "Unknown" ]
      },
      "DaosNic" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "mac" ]
      },
      "DaosPoolDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "state" : {
            "description" : "Pool state parsed as an enum. Unrecognized values are mapped to \"Unknown\"",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "Pool state, as reported by DAOS directly."
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "leader" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rebuild" : {
            "description" : "Rebuild status of the pool, if available.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPoolRebuildResponse"
            }, {
              "type" : "null"
            } ]
          },
          "targetsTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total targets."
          },
          "targetsActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active targets."
          },
          "targetsDisabled" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of disabled targets."
          },
          "enginesTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of engines that manage the pool."
          },
          "version" : {
            "type" : "integer",
            "format" : "int32"
          },
          "upgradeLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "tierStats" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolTierStatsResponse"
            },
            "description" : "Data usage per storage tier."
          }
        },
        "required" : [ "uuid", "name", "state", "stateRaw", "tierStats" ]
      },
      "DaosPoolRebuildResponse" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS pool rebuild status."
          },
          "state" : {
            "description" : "DAOS pool rebuild state, parsed into an enum. Unrecognized values are mapped to \"UNKNOWN\".",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolRebuildState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "DAOS pool rebuild state, as reported directly from DAOS."
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "record" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "state", "stateRaw" ]
      },
      "DaosPoolRebuildState" : {
        "type" : "string",
        "enum" : [ "IDLE", "DONE", "BUSY", "UNKNOWN" ]
      },
      "DaosPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "uuid" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name/label of the pool."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "DaosPoolStorageMediaType" : {
        "type" : "string",
        "enum" : [ "SCM", "NVME", "UNKNOWN" ]
      },
      "DaosPoolTierStatsResponse" : {
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total space available, in bytes."
          },
          "free" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Free space available, in bytes."
          },
          "min" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Minimum space used across NVMes, in bytes."
          },
          "max" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Maximum space used across NVMes, in bytes."
          },
          "mean" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Mean space used across NVMes, in bytes."
          },
          "mediaType" : {
            "description" : "Storage media type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolStorageMediaType"
          },
          "mediaTypeRaw" : {
            "type" : "string",
            "description" : "Storage media type, as reported by DAOS directly."
          }
        },
        "required" : [ "mediaType", "mediaTypeRaw" ]
      },
      "DaosPosixDiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the DAOS disk."
          },
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in."
          },
          "pool" : {
            "description" : "Label of the DAOS pool where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "poolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in."
          },
          "containerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class."
          },
          "nvmeofDisks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF disks that use this disk."
          },
          "nvmeofGateways" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF clusters that use this disk."
          },
          "nvmeofGatewayLabels" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of names of NVMe-oF clusters that use this disk."
          },
          "error" : {
            "description" : "Configuration errors for this cluster, if any.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HintResponse"
            }, {
              "type" : "null"
            } ]
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          },
          "usedByNvmeof" : {
            "type" : "boolean",
            "description" : "True if this disk is currently being used in a NVMe-oF cluster."
          }
        },
        "required" : [ "name", "pool", "container", "poolLabel", "containerLabel", "nvmeofDisks", "nvmeofGateways", "nvmeofGatewayLabels", "sizeFormatted" ]
      },
      "DaosProperty" : {
        "type" : "object",
        "required" : [ "name", "description", "type", "allowed" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "editable" : {
            "type" : "boolean"
          },
          "type" : {
            "$ref" : "#/components/schemas/DaosPropertyType"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPropertyUnit"
            }, {
              "type" : "null"
            } ]
          },
          "allowed" : {
            "type" : "array",
            "items" : { }
          }
        }
      },
      "DaosPropertyResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property."
          },
          "description" : {
            "type" : "string",
            "description" : "Description for the property as reported by DAOS."
          },
          "value" : {
            "type" : "array",
            "description" : "Value of the property, may be arbitrary JSON."
          }
        }
      },
      "DaosPropertyType" : {
        "type" : "string",
        "enum" : [ "String", "Enum", "EnumList", "Int", "IntList" ]
      },
      "DaosPropertyUnit" : {
        "type" : "string",
        "enum" : [ "Percentage", "Bytes", "Seconds" ]
      },
      "DaosRanksRequest" : {
        "type" : "object",
        "properties" : {
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "The list of ranks to work on. If empty or omitted, all ranks are used."
          }
        }
      },
      "DaosServerConfig" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "provider" : {
            "type" : [ "string", "null" ]
          },
          "isAccessPoint" : {
            "type" : "boolean"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "engines" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosEngineConfig"
            }
          },
          "isClientNode" : {
            "type" : "boolean"
          }
        },
        "required" : [ "engines" ]
      },
      "DaosSystemMemberResponse" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the server"
          },
          "addr" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/DaosMemberState"
          },
          "stateRaw" : {
            "type" : "string"
          },
          "faultDomain" : {
            "type" : "string"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "incarnation" : {
            "type" : "integer",
            "format" : "int64"
          },
          "uuid" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "fabricUri" : {
            "type" : "string"
          },
          "fabricContexts" : {
            "type" : "integer",
            "format" : "int32"
          },
          "info" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "string"
          }
        },
        "required" : [ "addr", "state", "stateRaw", "faultDomain", "uuid", "fabricUri", "info", "lastUpdate" ]
      },
      "DaosVerificationError" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationErrorOrWarning" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationResult" : {
        "type" : "object",
        "required" : [ "warnings", "errors", "daosConfig" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationErrorOrWarning"
            }
          },
          "errors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationError"
            }
          },
          "daosConfig" : {
            "$ref" : "#/components/schemas/DaosConfig"
          }
        }
      },
      "DaosVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "DashboardRoleCreateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ]
          },
          "permissions" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          }
        }
      },
      "DashboardRolePermission" : {
        "type" : "string",
        "enum" : [ "read", "create", "update", "delete" ]
      },
      "DashboardRoleUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "addPerms" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "delPerms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DashboardUserCreateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DashboardUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          },
          "passwordHash" : {
            "type" : [ "string", "null" ]
          },
          "setRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "addRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "delRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DataPoint" : {
        "description" : "One point in a plot",
        "type" : "object",
        "properties" : {
          "v" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Value, see unit property of the axis"
          },
          "t" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unix timestamp in seconds"
          }
        }
      },
      "DefaultImageRequest" : {
        "type" : "object",
        "properties" : {
          "overrideServers" : {
            "type" : "boolean"
          },
          "default" : {
            "$ref" : "#/components/schemas/UUID"
          }
        },
        "required" : [ "default" ]
      },
      "DefaultImageResponse" : {
        "type" : "object",
        "required" : [ "uuid" ],
        "properties" : {
          "uuid" : {
            "type" : "string"
          }
        }
      },
      "DeleteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "acl" : {
            "description" : "ACL to delete. May be provided instead of the principal, the principal of this ACL will then be used.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosAclEntry"
            }, {
              "type" : "null"
            } ]
          },
          "principal" : {
            "type" : [ "string", "null" ],
            "description" : "Principal whose ACL is to be removed. May be provided as alternative to the ACL."
          },
          "isGroup" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether the principal is a group or user. Only needs to be provided when providing the principal name instead of the entire ACL."
          }
        }
      },
      "DeleteDiskRequest" : {
        "type" : "object",
        "properties" : {
          "deleteData" : {
            "type" : "boolean",
            "description" : "Delete RBD image in Ceph"
          }
        }
      },
      "DestroyedOsdId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "host" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DestroyedOsdIds" : {
        "type" : "object",
        "required" : [ "destroyedOsds" ],
        "properties" : {
          "destroyedOsds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DestroyedOsdId"
            }
          }
        }
      },
      "DeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "DiskDeleteRequest" : {
        "description" : "Request to wipe a disk",
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server containing the disk"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk"
          },
          "serial" : {
            "type" : "string",
            "description" : "Serial of the disk (confirmation to prevent wiping the wrong disk by mistake)"
          },
          "destroy" : {
            "type" : "boolean",
            "description" : "Whether to destroy the corresponding OSD in the CRUSH map. Defaults to false."
          }
        },
        "required" : [ "serial" ]
      },
      "DiskDeleteRequestWrapper" : {
        "description" : "Request to wipe several disks",
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskDeleteRequest"
            }
          }
        }
      },
      "DiskDeviceClass" : {
        "type" : "string",
        "enum" : [ "hdd", "ssd", "nvme", "pmem" ]
      },
      "DiskPathResponse" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk that this path belongs to."
          },
          "devName" : {
            "type" : "string",
            "description" : "Name of the kernel device that represents this path."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the path is active."
          },
          "state" : {
            "type" : "string",
            "description" : "State of the path. Typically only useful for non-active paths."
          }
        },
        "required" : [ "devName", "state" ]
      },
      "DiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "type" : {
            "description" : "Type of disk. Doesn't refer to the disk's model or device class, but if it's a multipath disk or not.",
            "type" : "string",
            "$ref" : "#/components/schemas/DiskType"
          },
          "serial" : {
            "type" : "string"
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "serials" : {
            "type" : "object"
          },
          "wwns" : {
            "type" : "object"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes. See \"sizeFormatted\" for a human-readable string."
          },
          "name" : {
            "type" : "string",
            "description" : "Model name of the disk."
          },
          "pathRaw" : {
            "type" : "string",
            "description" : "Path of the disk. Will be outdated/invalid in case the disk is missing."
          },
          "info" : {
            "type" : [ "string", "null" ]
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdFragmentation" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bootedFrom" : {
            "type" : "boolean"
          },
          "daemonRunning" : {
            "type" : [ "boolean", "null" ]
          },
          "serviceHealth" : {
            "description" : "Current service health of the service associated (if any) with the disk if it is running;can be null if the service or server was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "identifyLed" : {
            "type" : "boolean"
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ],
            "description" : "PCI address for NVMe disks"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this disk belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this disk belongs to one"
          },
          "mpathInfo" : {
            "description" : "Multipath information, if this is a multipath disk.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MultipathInfoResponse"
            }, {
              "type" : "null"
            } ]
          },
          "stats" : {
            "description" : "Disk statistics (when requested)",
            "type" : "object",
            "$ref" : "#/components/schemas/DiskStatsResponse"
          },
          "bootable" : {
            "type" : "boolean",
            "description" : "If this disk has croit isntalled on it and can be booted from"
          },
          "status" : {
            "type" : "string",
            "description" : "Disk role with some extra information related to the role."
          },
          "capacity" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Deprecated, use \"size\" instead. Capacity of the disk rounded to GB."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk as a human-readable string."
          },
          "roleLabel" : {
            "type" : "string",
            "description" : "Pretty name for the disk role."
          },
          "isMultipathed" : {
            "type" : "boolean",
            "description" : "True if this is a multipathed disks."
          },
          "path" : {
            "type" : [ "string", "null" ],
            "description" : "Path of the disk or null if the disk is missing."
          },
          "pathFormatted" : {
            "type" : "string",
            "description" : "Path of the disk, or an info string in case the disk is missing."
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the disk belongs to."
          }
        },
        "required" : [ "hostname", "role", "type", "serial", "serials", "wwns", "name", "pathRaw", "deviceClass", "lastSeen", "serverLastSeen", "smart", "stats", "status", "sizeFormatted", "roleLabel", "pathFormatted", "numaNodeFormatted" ]
      },
      "DiskRole" : {
        "type" : "string",
        "enum" : [ "unassigned", "mon", "osd", "journal", "other", "raid", "deleting", "updating", "mon_unused", "old_osd", "old_mon", "daos_nvme", "daos_scm", "boot" ]
      },
      "DiskSmartStatus" : {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "type" : "string",
            "description" : "SMART health status extracted from the SMART health details."
          },
          "temperature" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Temperature extracted from the SMART health details, in Celsius."
          },
          "details" : {
            "type" : [ "string", "null" ],
            "description" : "SMART health details."
          }
        }
      },
      "DiskStatsResponse" : {
        "type" : "object",
        "properties" : {
          "read" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Reads measured in bytes per second"
          },
          "write" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Writes measured in bytes per second"
          },
          "iopsRead" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Read IOPS"
          },
          "iopsWrite" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Write IOPS"
          },
          "ioLoad" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Overall IO load as percentage"
          },
          "readFormatted" : {
            "type" : "string"
          },
          "writeFormatted" : {
            "type" : "string"
          },
          "iopsReadFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "iopsWriteFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "ioLoadFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "readFormatted", "writeFormatted", "ioLoadFormatted" ]
      },
      "DiskType" : {
        "type" : "string",
        "enum" : [ "normal", "mpath" ]
      },
      "DiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "role" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DiskRole"
            }, {
              "type" : "null"
            } ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "identifyLed" : {
            "type" : [ "boolean", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          }
        }
      },
      "Distribution" : {
        "type" : "string",
        "enum" : [ "DEBIAN", "SUSE", "SLES", "UNKNOWN" ]
      },
      "DownloadableObject" : {
        "type" : "object",
        "required" : [ "fileName", "data", "url" ],
        "properties" : {
          "fileName" : {
            "type" : "string"
          },
          "data" : {
            "type" : "string",
            "writeOnly" : true
          },
          "url" : {
            "type" : "string",
            "format" : "uri"
          },
          "fileContents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "ErasureCodeProfileDump" : {
        "type" : "object",
        "properties" : {
          "k" : {
            "type" : "integer",
            "format" : "int32"
          },
          "m" : {
            "type" : "integer",
            "format" : "int32"
          },
          "plugin" : {
            "type" : "string"
          },
          "technique" : {
            "type" : "string"
          },
          "crush-device-class" : {
            "type" : [ "string", "null" ]
          },
          "crush-failure-domain" : {
            "type" : [ "string", "null" ]
          },
          "crush-root" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "plugin", "technique" ]
      },
      "EventHookEvent" : {
        "type" : "string",
        "enum" : [ "PreNetworkConfig", "PostNetworkConfig", "PreDaemonStart", "PostDaemonStart", "PreFormatDisk", "PostFormatDisk", "PostCephDaemonStart", "OnHealthDegrade", "OnHealthImprove", "OnHealthRecover", "PreCrushMapChange", "PostCrushMapChange", "PostConfigChanged", "OnDhcpLeaseUpdate", "OnPersistentAvailable", "OnCephFsSnapshotComplete", "OnRbdSnapshotComplete", "OnAudit", "OnCroitStartup", "OnCroitAsyncStartup" ]
      },
      "ExportFormats" : {
        "type" : "string",
        "enum" : [ "raw", "cat", "short", "with-unit" ]
      },
      "FieldCondition" : {
        "description" : "Conditions that can be applied to a specific field.",
        "type" : "object",
        "properties" : {
          "_eq" : {
            "type" : [ "string", "null" ],
            "description" : "Equal to the specified value."
          },
          "_neq" : {
            "type" : [ "string", "null" ],
            "description" : "Not equal to the specified value."
          },
          "_gt" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than the specified value."
          },
          "_gte" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than or equal to the specified value."
          },
          "_lt" : {
            "type" : [ "string", "null" ],
            "description" : "Less than the specified value."
          },
          "_lte" : {
            "type" : [ "string", "null" ],
            "description" : "Less than or equal to the specified value."
          },
          "_regex" : {
            "type" : [ "string", "null" ],
            "description" : "Matches the specified regular expression."
          },
          "_in" : {
            "type" : [ "string", "null" ],
            "description" : "Value is in the specified list or contains the specified substring."
          },
          "_contains" : {
            "type" : [ "string", "null" ],
            "description" : "Value contains the specified item(s)."
          },
          "_nin" : {
            "type" : [ "string", "null" ],
            "description" : "Value is not in the specified list."
          }
        }
      },
      "Finding" : {
        "type" : "object",
        "required" : [ "severity", "category", "shortDescription", "description", "id" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/Severity"
          },
          "category" : {
            "$ref" : "#/components/schemas/Category"
          },
          "shortDescription" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "FreeIp" : {
        "type" : "object",
        "required" : [ "ip", "subnetShort" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "subnetShort" : {
            "type" : "string"
          }
        }
      },
      "GeneratedId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "GraphAxisResponse" : {
        "description" : "Collection of plots with the same unit",
        "type" : "object",
        "required" : [ "unit", "graphs" ],
        "properties" : {
          "unit" : {
            "$ref" : "#/components/schemas/StatsUnit"
          },
          "graphs" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Plot"
            }
          }
        }
      },
      "GraphResponse" : {
        "description" : "A single diagram/graph",
        "type" : "object",
        "required" : [ "name", "axis1" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Suggested title for the graph"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Suggested description for the graph"
          },
          "axis1" : {
            "description" : "Data associated with the first y axis",
            "type" : "object",
            "$ref" : "#/components/schemas/GraphAxisResponse"
          },
          "axis2" : {
            "description" : "Optional data associated with the second y axis",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/GraphAxisResponse"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "HaGroup" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServer"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers" ]
      },
      "HaGroupAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "haGroupId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "HaGroupResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServerResponse"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          },
          "serversFormatted" : {
            "type" : "string"
          },
          "serviceLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers", "serversFormatted", "serviceLabel" ]
      },
      "HaGroupServer" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupServerResponse" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ]
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupService" : {
        "type" : "string",
        "enum" : [ "nfs", "rgw", "smb", "iscsi", "none" ]
      },
      "HardwareResponse" : {
        "type" : "object",
        "properties" : {
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "coresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "cpuFreq" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "mainboardSerial" : {
            "type" : [ "string", "null" ]
          },
          "ipmi" : {
            "type" : [ "object", "null" ]
          },
          "ramFormatted" : {
            "type" : "string"
          },
          "cpuFreqFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "ramFormatted", "cpuFreqFormatted" ]
      },
      "HealthCheckMuteRequest" : {
        "description" : "Request to mute a health check.",
        "type" : "object",
        "properties" : {
          "ttl" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Time in seconds until the health check is unmuted."
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Whether or not the health check should stay muted even after it is resolved."
          }
        }
      },
      "HintResponse" : {
        "type" : "object",
        "required" : [ "message", "severity" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "severity" : {
            "$ref" : "#/components/schemas/HintSeverity"
          }
        }
      },
      "HintSeverity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARN", "ERROR" ]
      },
      "HookInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptName" : {
            "type" : "string"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "serverNames" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "scriptName", "event", "serverIds", "serverNames" ]
      },
      "HookPointInfo" : {
        "type" : "object",
        "required" : [ "name", "description", "parameters" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "canChooseServer" : {
            "type" : "boolean",
            "description" : "True for hook points running on Ceph nodes. False for hook points running on the management node."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the hook point."
          },
          "parameters" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookScriptParameter"
            },
            "description" : "Information on parameters passed to the script."
          }
        }
      },
      "HookRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        },
        "required" : [ "event", "serverIds" ]
      },
      "HookScriptParameter" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "HookScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          }
        }
      },
      "HookUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "event" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/EventHookEvent"
            }, {
              "type" : "null"
            } ]
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ImageInfoResponse" : {
        "type" : "object",
        "required" : [ "description" ],
        "properties" : {
          "description" : {
            "type" : "string"
          }
        }
      },
      "ImageListReply" : {
        "type" : "object",
        "properties" : {
          "latestX86" : {
            "description" : "Latest X86_64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "latestArm64" : {
            "description" : "Latest ARM64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultX86" : {
            "description" : "Currently configured default x86_64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultArm64" : {
            "description" : "Currently configured default ARM64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "images" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total number of images. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination offset. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination limit. Only provided when using pagination."
          }
        }
      },
      "ImagePackage" : {
        "type" : "object",
        "required" : [ "name", "version", "release" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "version" : {
            "type" : "string"
          },
          "release" : {
            "type" : "string"
          }
        }
      },
      "ImageResponse" : {
        "type" : "object",
        "required" : [ "flags", "id", "description", "timestamp", "os", "osVersion", "osName", "osRepoVersion", "cpuArchitecture", "cephVersionShort", "kernelVersion", "sambaVersion", "commit", "ganeshaVersion", "flagsFormatted" ],
        "properties" : {
          "flags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "os" : {
            "$ref" : "#/components/schemas/Distribution"
          },
          "osVersion" : {
            "type" : "string"
          },
          "osName" : {
            "type" : "string"
          },
          "osRepoVersion" : {
            "type" : "string"
          },
          "cpuArchitecture" : {
            "$ref" : "#/components/schemas/CpuArchitecture"
          },
          "cephVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephVersion"
            }, {
              "type" : "null"
            } ]
          },
          "cephVersionShort" : {
            "type" : "string"
          },
          "kernelVersion" : {
            "type" : "string"
          },
          "sambaVersion" : {
            "type" : "string"
          },
          "commit" : {
            "type" : "string"
          },
          "ganeshaVersion" : {
            "$ref" : "#/components/schemas/SemanticVersion"
          },
          "daosVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "isDefault" : {
            "type" : "boolean"
          },
          "isDeprecated" : {
            "type" : "boolean"
          },
          "isNightly" : {
            "type" : "boolean"
          },
          "isExtended" : {
            "type" : "boolean"
          },
          "hasSssd" : {
            "type" : "boolean"
          },
          "supportsBoot" : {
            "type" : "boolean"
          },
          "downloaded" : {
            "type" : "boolean"
          },
          "downloading" : {
            "type" : "boolean"
          },
          "fileSize" : {
            "type" : "integer",
            "format" : "int64"
          },
          "progress" : {
            "type" : "integer",
            "format" : "int64"
          },
          "downloadError" : {
            "type" : [ "string", "null" ]
          },
          "flagsFormatted" : {
            "type" : "string"
          }
        }
      },
      "InitialMonServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "hostname", "ips" ]
      },
      "InstallCroitRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/BootDiskRequest"
            }
          }
        }
      },
      "InterfaceResponse" : {
        "type" : "object",
        "required" : [ "ips", "interfaces" ],
        "properties" : {
          "ips" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpResponse"
            }
          },
          "interfaces" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "currentInterface" : {
            "type" : [ "string", "null" ]
          },
          "currentIp" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IpAddressInfo" : {
        "type" : "object",
        "required" : [ "nic", "vlan", "hagroup", "smb" ],
        "properties" : {
          "nic" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicAddressInfo"
            }
          },
          "vlan" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanAddressInfo"
            }
          },
          "hagroup" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupAddressInfo"
            }
          },
          "smb" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbAddressInfo"
            }
          }
        }
      },
      "IpGeneralInfo" : {
        "description" : "Contains generalized information about an IP address.",
        "type" : "object",
        "required" : [ "ip", "type" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/IpType"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server that this IP is configured for"
          },
          "subnet" : {
            "description" : "The subnet the IP address resides in",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkInfo"
            }, {
              "type" : "null"
            } ]
          },
          "subnetShort" : {
            "type" : [ "string", "null" ],
            "description" : "CIDR notation for the subnet (e.g. 10.0.0.0/24)"
          },
          "inDHCPPool" : {
            "type" : "boolean",
            "description" : "True if this IP is part of a DHCP pool configured in croit"
          }
        }
      },
      "IpResponse" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int16"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "IpType" : {
        "type" : "string",
        "enum" : [ "NIC", "SERVER", "VLAN", "HA_GROUP", "SMB" ]
      },
      "IpmiAccess" : {
        "description" : "Access details for an IPMI device",
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Username to use"
          },
          "password" : {
            "type" : "string",
            "description" : "Password to use"
          },
          "keepAdminPassword" : {
            "type" : "boolean",
            "description" : "Whether to change the password to the croit default"
          }
        }
      },
      "IpmiConfig" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "IpmiDevice" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "server" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServerInfo"
            }, {
              "type" : "null"
            } ]
          },
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "ip", "mac", "warnings" ]
      },
      "IpmiDeviceRequest" : {
        "description" : "Request to add an IPMI device that is not managed by croit's DHCP server",
        "type" : "object",
        "required" : [ "ip", "access" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "IP address of the IPMI device"
          },
          "access" : {
            "description" : "How to access this device",
            "type" : "object",
            "$ref" : "#/components/schemas/IpmiAccess"
          }
        }
      },
      "IpmiDeviceState" : {
        "type" : "object",
        "properties" : {
          "power" : {
            "type" : "boolean"
          },
          "sysTemperature" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpuTemperatures" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          },
          "fanSpeeds" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "cpuTemperatures", "fanSpeeds" ]
      },
      "IpmiDeviceStateWrapper" : {
        "type" : "object",
        "required" : [ "warnings" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IpmiInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "ip", "mac" ]
      },
      "IscsiAddDiskToClientRequest" : {
        "type" : "object",
        "required" : [ "pool", "name", "backstore" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB if the image does not exist yet, pass null to add an existing image"
          },
          "backstore" : {
            "$ref" : "#/components/schemas/IscsiBackstore"
          }
        }
      },
      "IscsiBackstore" : {
        "type" : "string",
        "enum" : [ "USER", "KERNEL" ]
      },
      "IscsiClientChangeRequest" : {
        "type" : "object",
        "properties" : {
          "username" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientCreationRequest" : {
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "group" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientLun" : {
        "type" : "object",
        "required" : [ "pool", "image", "wwn" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "wwn" : {
            "type" : "string"
          }
        }
      },
      "IscsiClientResponse" : {
        "type" : "object",
        "required" : [ "name", "group", "username", "password", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "group" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiGatewayConfig" : {
        "type" : "object",
        "required" : [ "iqn", "gateways", "clients", "groups", "disks", "selectedTarget", "targets" ],
        "properties" : {
          "iqn" : {
            "type" : "string"
          },
          "gateways" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiServerResponse"
            }
          },
          "clients" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientResponse"
            }
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGroupResponse"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          },
          "selectedTarget" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "gatewayVersion" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "IscsiGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "IscsiGatewayDisksResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name of the disk."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name where the RBD is located at."
          },
          "wwn" : {
            "type" : "string",
            "description" : "WWN of the disk in iSCSI."
          },
          "lunId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Lun ID of the disk in iSCSI."
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Groups that use this disk."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Host IQNs that use this disk."
          }
        },
        "required" : [ "image", "pool", "wwn", "groups", "hosts" ]
      },
      "IscsiGatewayGroupsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "group" : {
            "type" : "string",
            "description" : "Name of the group."
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Hosts in the group."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this group."
          }
        },
        "required" : [ "group", "members", "luns" ]
      },
      "IscsiGatewayHostsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "iqn" : {
            "type" : "string",
            "description" : "IQN of the host."
          },
          "username" : {
            "type" : "string",
            "description" : "CHAP username."
          },
          "password" : {
            "type" : "string",
            "description" : "CHAP password."
          },
          "group" : {
            "type" : "string",
            "description" : "Group that the host belongs to."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this host."
          }
        },
        "required" : [ "iqn", "username", "password", "group", "luns" ]
      },
      "IscsiGatewayServer" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string",
            "description" : "Client-facing IP address of this gateway, must be configured on the server."
          }
        },
        "required" : [ "ip" ]
      },
      "IscsiGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP of the server used for iSCSI"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "IscsiGatewayService" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServer"
            },
            "minItems" : 1
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiGroupResponse" : {
        "type" : "object",
        "required" : [ "name", "members", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiImageChangeRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB"
          }
        }
      },
      "IscsiImageDetails" : {
        "type" : "object",
        "properties" : {
          "image" : {
            "type" : [ "string", "null" ]
          },
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "backstore" : {
            "type" : [ "string", "null" ]
          },
          "controls" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : { }
          },
          "backstoreParsed" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IscsiBackstore"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IscsiImagesResponse" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "details" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "$ref" : "#/components/schemas/IscsiImageDetails"
            }
          }
        }
      },
      "IscsiServerResponse" : {
        "type" : "object",
        "required" : [ "name", "ip" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "IscsiServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "KeyUpdateRequest" : {
        "description" : "List of SSH keys allowed to access managed servers.",
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "LicenseCephStatus" : {
        "type" : "object",
        "required" : [ "health", "utilizationByDeviceClass" ],
        "properties" : {
          "health" : {
            "type" : "string"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/LicenseDeviceClassUtilization"
            }
          }
        }
      },
      "LicenseDeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "LicenseDiskCapacities" : {
        "type" : "object",
        "properties" : {
          "unassigned" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of unassigned disks."
          },
          "osd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of OSD disks (not including separate DB/WAL partitions)."
          },
          "journal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DB/WAL disks."
          },
          "mon" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of mon disks."
          },
          "daosNvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS NVMes."
          },
          "daosScm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS SCMs."
          },
          "other" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of all other disks."
          }
        }
      },
      "LicenseInfo" : {
        "type" : "object",
        "properties" : {
          "fsid" : {
            "type" : [ "string", "null" ]
          },
          "croitId" : {
            "type" : "string"
          },
          "licenseId" : {
            "type" : "string"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "licenseRestrictions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SignedLicenseData"
            }, {
              "type" : "null"
            } ]
          },
          "registered" : {
            "type" : "boolean"
          },
          "preSetup" : {
            "type" : "boolean"
          }
        },
        "required" : [ "croitId", "licenseId", "validUntil", "nextRefresh" ]
      },
      "LicensePatchRequest" : {
        "type" : "object",
        "properties" : {
          "email" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "LicenseReply" : {
        "description" : "Current license state and usage.",
        "type" : "object",
        "required" : [ "license", "message", "usageFormatted" ],
        "properties" : {
          "license" : {
            "description" : "The currently active license",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseInfo"
          },
          "currentUsage" : {
            "description" : "Cluster usage for licensing purposes",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseUsage"
            }, {
              "type" : "null"
            } ]
          },
          "message" : {
            "type" : "string",
            "description" : "Informational message with license details, e.g., a reason why it is invalid"
          },
          "email" : {
            "type" : [ "string", "null" ],
            "description" : "Configured email address for license notifications."
          },
          "active" : {
            "type" : "boolean",
            "description" : "Whether the license is active"
          },
          "registered" : {
            "type" : "boolean",
            "description" : "Whether the cluster is registered with portal.croit.io"
          },
          "usageFormatted" : {
            "type" : "string",
            "description" : "A string representing current usage and license limits."
          }
        }
      },
      "LicenseUsage" : {
        "description" : "Current cluster usage for licensing purposes.",
        "type" : "object",
        "required" : [ "osds", "rawCapacityGb", "disks", "servers", "rawDaosCapacity" ],
        "properties" : {
          "osds" : {
            "description" : "Number of OSDs by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Raw capacity for ceph by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Used capacity for ceph by device type. (incl. replication overhead)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "netUsageGb" : {
            "description" : "Used capacity for ceph by device type (excl. replication overhead).",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "disks" : {
            "description" : "Raw disk capacity by device type as reported by the nodes, ignoring ceph.",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseDiskCapacities"
          },
          "cephStatus" : {
            "description" : "Cluster status reported by ceph. Contains similar information to rawCapacityGb and usedCapacityGb, but in raw bytes, and with information on data balance across OSDs.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseCephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "servers" : {
            "description" : "Number of servers.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "daosClusters" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of DAOS clusters."
          },
          "daosServers" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of servers running DAOS."
          },
          "rawDaosCapacity" : {
            "description" : "Raw capacity for DAOS by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosCapacity"
          }
        }
      },
      "LogsQLRequest" : {
        "description" : "VictoriaLogs request that wraps PaginationRequest with additional parameters. Used for both LogViewer Websocket and Log export.",
        "type" : "object",
        "required" : [ "query", "type" ],
        "properties" : {
          "query" : {
            "description" : "Base pagination request for filtering, sorting and limiting",
            "type" : "object",
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "type" : {
            "description" : "Type of logs query - either 'tail' to stream recent logs or 'query' for logs within a time range",
            "type" : "string",
            "$ref" : "#/components/schemas/LogsQLRequestType"
          },
          "start" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Start time for query type requests (required for 'query' type)"
          },
          "end" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "End time for query type requests (required for 'query' type)"
          }
        }
      },
      "LogsQLRequestType" : {
        "type" : "string",
        "enum" : [ "tail", "query" ]
      },
      "MainIpRequest" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "ManagedTask" : {
        "description" : "A long-running task that goes on in the background after this task is completed. See tasks endpoints for details",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "ManagedTaskProgress" : {
        "type" : "object",
        "description" : "Progress indication of a background task.",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "ManagedTaskState" : {
        "type" : "string",
        "enum" : [ "WAITING", "RUNNING", "FINISHED", "FAILED", "CANCELED" ]
      },
      "ManagedThreadTask" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "done" : {
            "type" : "boolean"
          },
          "result" : { },
          "cancelled" : {
            "type" : "boolean",
            "writeOnly" : true
          },
          "questionLock" : {
            "type" : "object",
            "writeOnly" : true
          },
          "condition" : {
            "type" : "object",
            "writeOnly" : true
          },
          "question" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestion"
            }, {
              "type" : "null"
            } ]
          },
          "thread" : {
            "type" : "object",
            "writeOnly" : true
          },
          "output" : {
            "type" : "string"
          },
          "interactive" : {
            "type" : "boolean"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "MaxMdsSetting" : {
        "type" : "object",
        "properties" : {
          "maxMds" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Max Mds for CephFS. Shouldn't be higher than the number of servers minus one, to leave at least one standby MDS."
          }
        }
      },
      "MdsOnlineStatus" : {
        "type" : "object",
        "properties" : {
          "active" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standbyReplay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standby" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MdsRankEntry" : {
        "type" : "object",
        "properties" : {
          "filesystemId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "status" ]
      },
      "MgrCrashReport" : {
        "description" : "List of Ceph daemon crashes",
        "type" : "object",
        "required" : [ "crashes" ],
        "properties" : {
          "crashes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            }
          }
        }
      },
      "MgrCrashReportEntry" : {
        "type" : "object",
        "description" : "Summarized report of a crashed Ceph daemon",
        "required" : [ "id", "timestamp" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "process" : {
            "type" : [ "string", "null" ],
            "description" : "ceph process identifier if available, e.g., ceph-osd@123"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Host on which the process was running"
          },
          "archived" : {
            "type" : "boolean",
            "description" : "Whether this crash is archived; crashes without this flag trigger a Ceph health warning."
          }
        }
      },
      "MinCompatClientVersion" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "description" : "Ceph release version to set min compat client to.",
            "type" : "string",
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "MonServiceRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MonitorRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "MonitoredRbd" : {
        "type" : "object",
        "required" : [ "poolName", "rbdName", "namespace" ],
        "properties" : {
          "poolName" : {
            "type" : "string",
            "description" : "The pool image"
          },
          "rbdName" : {
            "type" : "string",
            "description" : "The Rbd image"
          },
          "namespace" : {
            "type" : "string",
            "description" : "The pool namespace"
          }
        }
      },
      "MultiServerServiceResponse" : {
        "type" : "object",
        "required" : [ "id", "name", "type", "state", "multiServer", "typeLabel", "status" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used for systemd."
          },
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServiceState"
          },
          "subState" : {
            "description" : "Service-specific sub-state for MGR and MDS services. Indicates active and standby daemons.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceSubState"
            }, {
              "type" : "null"
            } ]
          },
          "mdsInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MdsRankEntry"
            }, {
              "type" : "null"
            } ]
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "running" : {
            "type" : "boolean"
          },
          "multiServer" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "health" : {
            "description" : "Current service health, can be null if the service was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the DAOS cluster that this service belongs to."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port used by the service. Only available for RGW services."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "TLS/SSL Port used by the service. Only available for RGW services."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "DNS name for an RGW service. Only available for RGW services."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "RGW zone configured for this service. Only available for RGW services."
          },
          "typeLabel" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string",
            "description" : "Extra status information for the service. Only available for MGR, MDS and RGW."
          }
        }
      },
      "MultipartUploadListing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "MultipathInfoResponse" : {
        "type" : "object",
        "required" : [ "paths", "pathsFormatted", "info", "stateLabel" ],
        "properties" : {
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of paths with their information."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "List of paths parsed into a single string."
          },
          "numActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active paths."
          },
          "numTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total paths."
          },
          "numMax" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "maximum number of paths that croit ever saw for this disk."
          },
          "info" : {
            "type" : "string",
            "description" : "Multipath info summarized as a simple string to display in the UI."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "True if all paths are active."
          },
          "stateLabel" : {
            "type" : "string",
            "description" : "Label containing the states of the paths."
          }
        }
      },
      "NetworkInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this network, generated internally"
          },
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool emd address"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : "string",
            "$ref" : "#/components/schemas/NetworkType"
          },
          "description" : {
            "type" : "string",
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null indicates the default MTU of 1500"
          }
        },
        "required" : [ "ip", "type", "description" ]
      },
      "NetworkType" : {
        "type" : "string",
        "enum" : [ "other", "ceph_public", "ceph_internal", "croit", "ipmi" ]
      },
      "NetworkUpdateRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address, required if poolEnd is set"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool end address, required if poolStart is set"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkType"
            }, {
              "type" : "null"
            } ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null sets the default MTU of 1500"
          }
        }
      },
      "NewActiveDirectorySmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path", "roUsers", "rwUsers" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "roUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          }
        }
      },
      "NewNfsGatewayExport" : {
        "type" : "object",
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ],
        "properties" : {
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        }
      },
      "NewNfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewNfsGatewayExport"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewSimpleSmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : "boolean",
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : "boolean",
            "description" : "Enable access for the croit-ro user."
          }
        }
      },
      "NewSmbGatewayShare" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "simple" : "#/components/schemas/NewSimpleSmbGatewayShare",
            "ad" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
          }
        },
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          }
        }
      },
      "NewUserRequest" : {
        "type" : "object",
        "required" : [ "uid", "name" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "tenant" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewVlanRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsExportPermission" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsExportPermissionResponse" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "NfsGatewayExport" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ]
      },
      "NfsGatewayExportResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermissionResponse"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocolsResponse"
          },
          "filesystem" : {
            "type" : "string"
          },
          "accessJoined" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem", "accessJoined" ]
      },
      "NfsGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "Management IP of the server"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "NfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExport"
            }
          }
        }
      },
      "NfsGatewayServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "servers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsProtocols" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NfsProtocolsResponse" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NicAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "NicBondType" : {
        "type" : "string",
        "enum" : [ "lacp", "active_passive" ]
      },
      "NicResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicType"
            }, {
              "type" : "null"
            } ]
          },
          "bondedNics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NICs that are part of this bond"
          },
          "bond" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Bond this NIC is a part of"
          },
          "bondedNicsFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "NICs that are part of this bond (formatted for the frontend to display in a column"
          },
          "bondFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "Bond this NIC is a part of (formatted for the frontend to display in a column"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "vlans" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            }
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "lldp" : {
            "type" : "array",
            "items" : { }
          },
          "bondType" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicBondType"
            }, {
              "type" : "null"
            } ]
          },
          "bondPrimary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "isVirtual" : {
            "type" : "boolean"
          },
          "infinibandMac" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this NIC belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this NIC belongs to one"
          },
          "ipFormatted" : {
            "type" : "string"
          },
          "ip6Formatted" : {
            "type" : "string"
          },
          "vlansJoined" : {
            "type" : "string"
          },
          "speedFormatted" : {
            "type" : "string"
          },
          "neighbor" : {
            "type" : "string"
          },
          "bondTypeLabel" : {
            "type" : "string"
          },
          "port" : {
            "type" : "string",
            "description" : "Port description from LLDP"
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the NIC belongs to"
          }
        },
        "required" : [ "mac", "name", "lastSeen", "serverLastSeen", "vlans", "lldp", "ipFormatted", "ip6Formatted", "vlansJoined", "speedFormatted", "neighbor", "bondTypeLabel", "port", "numaNodeFormatted" ]
      },
      "NicType" : {
        "type" : "string",
        "enum" : [ "normal", "bond", "infiniband" ]
      },
      "NicUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "bond" : {
            "description" : "Updatable bond properties",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/BondUpdateRequest"
            }, {
              "type" : "null"
            } ]
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "Address of the new NIC when replacing NICs. Only applicable for offline servers."
          }
        }
      },
      "NvmeOFBdevType" : {
        "type" : "string",
        "enum" : [ "CEPH", "DAOS" ]
      },
      "NvmeOFCephClusterResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in the NVMe-oF target services."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Client ID to use for this cluster. If null, the croit internal default client for NVMe-oF will be used."
          }
        }
      },
      "NvmeOFDiskCreateRequest" : {
        "type" : "object",
        "required" : [ "type", "subsystems" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the disk to."
          },
          "blockSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NVMe-oF subsystems to attach this disk to."
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "RBD pool name in ceph (required for ceph disks)."
          },
          "image" : {
            "type" : [ "string", "null" ],
            "description" : "RBD image name in ceph (required for ceph disks)."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace in ceph (currently not supported!)."
          },
          "cluster" : {
            "type" : [ "string", "null" ],
            "description" : "RBD cluster configuration that this disk is configured for. If null, the cluster \"croit_cluster\" will be used."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS disk ID in croit. For DAOS disks, either this ID needs to be specified to choose an existing disk, or all of the other DAOS parameters to create a new disk."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the new DAOS disk in croit (required when creating a new DAOS disk)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster ID in croit (required when creating a new DAOS disk)."
          },
          "daosPool" : {
            "description" : "DAOS pool UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "DAOS container UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "totalSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total size in bytes for the disk (required and only applicable when creating a new DAOS disks)."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class to use for the disk (optional when creating a new DAOS disks)."
          }
        }
      },
      "NvmeOFDiskResponse" : {
        "type" : "object",
        "required" : [ "type", "bdevNames", "namespaceNGUID", "namespaceEUI64", "namespaceUUID", "hints", "subsystemNqns", "hosts", "pool", "image", "cluster", "daosPoolLabel", "daosContainerLabel", "oclass", "subsystemsFormatted", "blockSizeFormatted", "sizeFormatted" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NVMe-oF disk in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this disk belongs to."
          },
          "bdevNames" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Map of subsystem IDs to the bdev name used for each subsystem in the NVMe-oF target services."
          },
          "namespaceNGUID" : {
            "type" : "string",
            "description" : "NVMe NGUID device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceEUI64" : {
            "type" : "string",
            "description" : "NVMe EUI-64 device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceUUID" : {
            "description" : "NVMe UUID device identifier that will be used when attaching this disk to a subsystem.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          },
          "subsystemNqns" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Subsystem NQNs that this disk is attached to."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the same subsystem as this disk."
          },
          "blockSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name in ceph (provided if this is a Ceph bdev)."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name in ceph (provided if this is a Ceph bdev)."
          },
          "cluster" : {
            "type" : "string",
            "description" : "RBD cluster configuration that this disk is configured for (provided if this is a Ceph bdev)."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosPool" : {
            "description" : "UUID of the DAOS pool where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "UUID of the DAOS container where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosPoolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosContainerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in (provided if this is a DAOS bdev)."
          },
          "oclass" : {
            "type" : "string",
            "description" : "DAOS object class (provided if this is a DAOS bdev)."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this disk is attached to."
          },
          "blockSizeFormatted" : {
            "type" : "string",
            "description" : "Block size configured for the disk."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          }
        }
      },
      "NvmeOFDiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New image size for the disk."
          }
        }
      },
      "NvmeOFDisksAttachRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the NVMe-oF disks in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFGatewayCreateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Optional name for the cluster to display to the user."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional default configurations for transports to use for NVMe-oF target services."
          },
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
            },
            "description" : "NVMe-oF target services to set up for the new cluster."
          }
        },
        "required" : [ "transportDefaults", "services" ]
      },
      "NvmeOFGatewayResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that can be used in other cluster requests."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in croit. Only used to display it to the user."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the cluster in croit. Only used to display it to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Default configurations for transports to use for NVMe-oF target services."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          }
        },
        "required" : [ "name", "description", "transportDefaults", "hints" ]
      },
      "NvmeOFGatewayUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "New description for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "forceSecure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Force secure channel for listeners. Omit if the current setting should not be changed."
          },
          "transportDefaults" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "New default configurations for transports to use for NVMe-oF target services. Overwrites all existing ones if provided."
          }
        }
      },
      "NvmeOFHostCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the host to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host. The NQN has to be unique within a cluster."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Optional shared key to use for authentication. If omitted, the host won't need to authenticate."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of IDs for subsystems that the host should be attached to."
          }
        },
        "required" : [ "nqn", "subsystems" ]
      },
      "NvmeOFHostResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the host in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key that the host will need to authenticate to NVMe-oF target services."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for subsystems that this host is attached to."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the same subsystem as this host."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this host is attached to."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          },
          "hasSharedKey" : {
            "type" : "boolean",
            "description" : "Whether the host has a shared key for authentication with NVMe-oF target services configured."
          }
        },
        "required" : [ "nqn", "subsystems", "disks", "subsystemsFormatted", "disksFormatted" ]
      },
      "NvmeOFHostUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key to use for authentication. If omitted, the host won't need to authenticate."
          }
        }
      },
      "NvmeOFHostsAttachRequest" : {
        "type" : "object",
        "required" : [ "hosts" ],
        "properties" : {
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the hosts in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFListenerConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the listener belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the listener is configured on."
          },
          "listenerId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the listener."
          },
          "type" : {
            "description" : "Transport type for this listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NIC that this listener is configured to use."
          },
          "nicName" : {
            "type" : "string",
            "description" : "Name of the NIC that this this listener is configured to use."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the VLAN that this listener is configured to use, if at all."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN that this this listener is configured to use, if at all."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port configured for the listener. If null, the cluster's default port will be used."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Secure flag. If true, the listener is configured to use TLS. The cluster's configuration may overwrite this."
          }
        },
        "required" : [ "type", "nicName" ]
      },
      "NvmeOFListenerCreateRequest" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "description" : "Type of the listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the nic that this listener is configured on."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the vlan that this listener is configured on, if at all."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port that the service should listen on."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFListenerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port that the service should listen on (required for TCP and RDMA)."
          },
          "secure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFServiceCreateRequest" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that this service is to be created on."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional transports configurations."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "Optional listeners configurations."
          }
        },
        "required" : [ "transports", "listeners" ]
      },
      "NvmeOFServiceResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the service belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit that this service is installed on."
          },
          "serverHostname" : {
            "type" : "string",
            "description" : "Hostname of the server that this service is installed on."
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages configured for the server."
          },
          "anaState" : {
            "description" : "ANA state to set for all listeners in this service.",
            "type" : "string",
            "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used as systemd name and is automatically generated. Cannot be changed."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the service in croit. Only used to display it to the user."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfigResponse"
            },
            "description" : "Transport configs specific for this service. Note that the cluster's default configs may extend these."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "Listener configs for this service."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this service, if any."
          }
        },
        "required" : [ "serverHostname", "anaState", "name", "description", "transports", "listeners", "hints" ]
      },
      "NvmeOFServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "anaState" : {
            "description" : "Optional ANA state to set for all listeners in this service.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
            }, {
              "type" : "null"
            } ]
          },
          "transports" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "List of transport configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          },
          "listeners" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "List of listeners configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          }
        }
      },
      "NvmeOFSubsystemCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the subsystem to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem. The NQN has to be unique within a cluster."
          }
        },
        "required" : [ "nqn" ]
      },
      "NvmeOFSubsystemResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the subsystem in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem."
          },
          "serialNumber" : {
            "type" : "string",
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : "string",
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Maximum number of bdevs that can be attached."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the subsystem."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the subsystem."
          },
          "hostsFormatted" : {
            "type" : "string",
            "description" : "List of hosts attached to the subsystem."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          }
        },
        "required" : [ "nqn", "serialNumber", "modelNumber", "hosts", "disks", "hostsFormatted", "disksFormatted" ]
      },
      "NvmeOFSubsystemUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "serialNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Maximum number of disks that can be attached."
          }
        }
      },
      "NvmeOFTransportConfig" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "NvmeOFTransportConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the transport config belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the transport config belongs to."
          },
          "type" : {
            "description" : "Transport type. The transport config is applied to all listeners of this type.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "I/O unit size (bytes)."
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of IO qpairs per controller."
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of in-capsule data size."
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Max I/O size (bytes)."
          }
        },
        "required" : [ "type" ]
      },
      "NvmeOFTransportType" : {
        "type" : "string",
        "enum" : [ "TCP", "RDMA" ]
      },
      "OidcClientAuth" : {
        "type" : "string",
        "enum" : [ "None", "Post", "Basic" ]
      },
      "OidcConfigCreateRequest" : {
        "type" : "object",
        "required" : [ "name", "discoveryUrl", "clientId", "groupPointer", "roleMapping", "defaultRoles", "scope" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OidcClientAuth"
            }, {
              "type" : "null"
            } ]
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "Scopes for OIDC requests, separated by spaces (default: \"openid profile\")"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          }
        }
      },
      "OidcConfigResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the OIDC config/provider in croit"
          },
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : "string",
            "$ref" : "#/components/schemas/OidcClientAuth"
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "OIDC scope to query for"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          },
          "defaultMaxExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "defaultMinExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "providerName" : {
            "type" : "string"
          },
          "roleMappingFormatted" : {
            "type" : "string"
          },
          "clientAuthLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "discoveryUrl", "clientId", "clientAuth", "groupPointer", "roleMapping", "defaultRoles", "scope", "defaultMaxExpiry", "defaultMinExpiry", "providerName", "roleMappingFormatted", "clientAuthLabel" ]
      },
      "OidcProvider" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "OktaLoginRequest" : {
        "type" : "object",
        "required" : [ "idToken" ],
        "properties" : {
          "idToken" : {
            "type" : "string"
          }
        }
      },
      "OktaOAuthConfig" : {
        "type" : "object",
        "required" : [ "baseUrl", "clientId", "issuer", "mapRoles" ],
        "properties" : {
          "baseUrl" : {
            "type" : "string"
          },
          "clientId" : {
            "type" : "string"
          },
          "issuer" : {
            "type" : "string"
          },
          "audience" : {
            "type" : [ "string", "null" ]
          },
          "mapRoles" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "OnlineStatus" : {
        "type" : "object",
        "properties" : {
          "online" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "healthy" : {
            "type" : "boolean"
          }
        }
      },
      "OptionalPaginationResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseObject"
        }, {
          "type" : "array",
          "items" : { },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseAccount" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseAccount"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/Account"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseApiTokenInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseApiTokenInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ApiTokenInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephFSSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephFSSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephPoolResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephPoolResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephPoolResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephfsClientInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephfsClientInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephfsClientInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseConfigTemplateResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseConfigTemplateResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ConfigTemplateResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCrushRuleResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCrushRuleResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CrushRuleResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseDiskResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseDiskResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/DiskResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseFreeIp" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseFreeIp"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/FreeIp"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHaGroupResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHaGroupResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HaGroupResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHookInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHookInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HookInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpGeneralInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpGeneralInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpGeneralInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpmiDevice" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpmiDevice"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpmiDevice"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMgrCrashReportEntry" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMgrCrashReportEntry"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MgrCrashReportEntry"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMultiServerServiceResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMultiServerServiceResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MultiServerServiceResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNetworkInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNetworkInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NetworkInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNicResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNicResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NicResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseOidcConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseOidcConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/OidcConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponsePoolStatsInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponsePoolStatsInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/PoolStatsInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRbdSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRbdSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RbdSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwBucketResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwBucketResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwBucketResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseScriptIdentifier" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseScriptIdentifier"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ScriptIdentifier"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseServerResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseServerResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ServerResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseSupervisorModuleJson" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseSupervisorModuleJson"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/SupervisorModuleJson"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseVlanInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseVlanInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/VlanInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OsdCreationRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OsdCreationRequestEntry"
            }
          }
        }
      },
      "OsdCreationRequestEntry" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for DB or DB/WAL (if walDisk is null)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for WAL."
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "reuseOsdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "crushDeviceClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "OsdFullRatios" : {
        "type" : "object",
        "properties" : {
          "nearfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "backfillfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "full" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "OsdStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DOWN", "DESTROYED", "UNKNOWN" ]
      },
      "OverwriteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "entries" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries to overwrite the existing ones with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "aclFile" : {
            "type" : [ "string", "null" ],
            "description" : "ACL file to overwrite the existing one with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "ownerUser" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (user), if provided. Only possible with containers."
          },
          "ownerGroup" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (group), if provided. Only possible with containers."
          }
        }
      },
      "PaginationRequest" : {
        "type" : "object",
        "description" : "Pagination request. When supplied, the result will be filtered, sorted and limited according to this request object.",
        "properties" : {
          "sortBy" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SortBy"
            },
            "description" : "Optional sorting rules for the items. Items are sorted before the limit is applied."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional maximum number of items to return. If omitted, all items are returned."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of items, defaults to 0."
          },
          "where" : {
            "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/FieldCondition"
            },
            "type" : [ "object", "null" ],
            "properties" : {
              "_and" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical AND operator. All conditions must be satisfied."
              },
              "_or" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical OR operator. At least one condition must be satisfied."
              },
              "_not" : {
                "description" : "Logical NOT operator. The condition must not be satisfied.",
                "type" : [ "object", "null", "null" ],
                "anyOf" : [ {
                  "$ref" : "#/components/schemas/WhereCondition"
                }, {
                  "type" : "null"
                } ]
              },
              "_search" : {
                "type" : [ "string", "null" ],
                "description" : "Full-text search across all searchable fields."
              }
            }
          }
        }
      },
      "PaginationResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseAccount" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Account"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseApiTokenInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiTokenInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFSSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPgStat" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPgStat"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPoolResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephfsClientInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephfsClientInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseConfigTemplateResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ConfigTemplateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCroitDependency" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitDependency"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCrushRuleResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosCertificateResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCertificateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerListResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerListResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPoolDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPosixDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPosixDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPropertyResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPropertyResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosSystemMemberResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosSystemMemberResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskPathResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseFreeIp" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FreeIp"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHaGroupResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHookInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpGeneralInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpGeneralInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpmiDevice" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpmiDevice"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayDisksResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayGroupsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayGroupsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayHostsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayHostsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMgrCrashReportEntry" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMultiServerServiceResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MultiServerServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNetworkInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NetworkInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayExportResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExportResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNicResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFCephClusterResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFGatewayResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFGatewayResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFHostResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFHostResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFListenerConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFServiceResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFSubsystemResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFSubsystemResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseObject" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseOidcConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OidcConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponsePoolStatsInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolStatsInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdImageResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdImageResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwBucketResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptIdentifier" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptIdentifier"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptInfo" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseServerResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayShareResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSupervisorModuleJson" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SupervisorModuleJson"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseTaskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TaskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseVlanInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "ParsedDaosAcl" : {
        "type" : "object",
        "required" : [ "type", "flags", "principal", "permissions", "principalType", "raw" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/DaosAclType"
          },
          "flags" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclFlag"
            }
          },
          "principal" : {
            "type" : "string"
          },
          "permissions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclPermission"
            }
          },
          "isGroup" : {
            "type" : "boolean"
          },
          "principalType" : {
            "$ref" : "#/components/schemas/DaosAclPrincipalType"
          },
          "raw" : {
            "type" : "string"
          }
        }
      },
      "PasswordChangeRequest" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "PerOsdLimit" : {
        "description" : "Limit OSD number or usage by device class, -1 means unlimited",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs."
          },
          "hdd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as HDD."
          },
          "ssd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as SSD."
          },
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as NVMe."
          },
          "unknown" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs that couldn't be identified (for net usage: also crush rules not matching a device class)."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more OSDs/storage"
          }
        }
      },
      "PingMetricsConfiguration" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean"
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PingMetricsSummary" : {
        "type" : "object",
        "properties" : {
          "fromId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "toId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "median" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "dropPercent" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "PingParameters" : {
        "type" : "object",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of ICMP echo requests sent to each host."
          },
          "period" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time between consecutive packets to a single host in milliseconds."
          },
          "fromId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Server ID of the requesting host. 0 for management host."
          },
          "toIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Server IDs of the responding hosts. 0 for management host."
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Network ID of the network within which the packets should be sent."
          }
        },
        "required" : [ "toIds" ]
      },
      "PingResult" : {
        "type" : "object",
        "properties" : {
          "xmt" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rcv" : {
            "type" : "integer",
            "format" : "int32"
          },
          "lossPercent" : {
            "type" : "number",
            "format" : "double"
          },
          "min" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "max" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "avg" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "results" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "results" ]
      },
      "PlacementGroupOverview" : {
        "type" : "object",
        "required" : [ "poolName" ],
        "properties" : {
          "poolName" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "okay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "warn" : {
            "type" : "integer",
            "format" : "int32"
          },
          "error" : {
            "type" : "integer",
            "format" : "int32"
          },
          "inactive" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "Plot" : {
        "type" : "object",
        "description" : "A single plot/line for a diagram",
        "required" : [ "datapoints", "name", "tags" ],
        "properties" : {
          "datapoints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DataPoint"
            }
          },
          "name" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Tags (e.g., server id, osd id, ...) associated with this graph"
          }
        }
      },
      "PoolCompressionAlgorithm" : {
        "type" : "string",
        "enum" : [ "LZ4", "Snappy", "Zlib", "Zstd", "None" ]
      },
      "PoolCompressionMode" : {
        "type" : "string",
        "enum" : [ "None", "Passive", "Aggressive", "Force" ]
      },
      "PoolCompressionSettings" : {
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionAlgorithm"
            }, {
              "type" : "null"
            } ]
          },
          "mode" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionMode"
            }, {
              "type" : "null"
            } ]
          },
          "requiredRatio" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "minBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PoolPermission" : {
        "type" : "object",
        "description" : "A pool-specific permission, optionally restricted to a namespace within the pool.",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, either this or wildcardPoolPermissions must be set"
          },
          "wildcardPoolPermissions" : {
            "description" : "Grant a wildcard pool permission, either this or pool must be set",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WildcardPoolPermission"
            }, {
              "type" : "null"
            } ]
          },
          "permissions" : {
            "description" : "Permissions to grant on the pool",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolPermissionType"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Only allow access to a specific namespace within this pool"
          }
        },
        "required" : [ "permissions" ]
      },
      "PoolPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE" ]
      },
      "PoolState" : {
        "type" : "string",
        "enum" : [ "Creating", "Ready", "Destroying", "Degraded", "Unknown" ]
      },
      "PoolStatsInfo" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-pool-name query parameter"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description of the pool"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the pool if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the pool if configured"
          }
        }
      },
      "PoolStatsResponse" : {
        "type" : "object",
        "properties" : {
          "bytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "readIops" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIops" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "writeBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "bytesFormatted" : {
            "type" : "string"
          },
          "readIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSecFormatted" : {
            "type" : "string"
          },
          "writeBytesPerSecFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "bytesFormatted", "readBytesPerSecFormatted", "writeBytesPerSecFormatted" ]
      },
      "QOSSettingsCommandSchema" : {
        "description" : "Ceph QOS Settings Command",
        "type" : "object",
        "required" : [ "command", "displayName", "description" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "QOSSettingsCommands" : {
        "description" : "List of ceph commands available to define QOS SETTINGS limits (nautilus and above).",
        "type" : "string",
        "enum" : [ "RBD_QOS_IOPS_LIMIT", "RBD_QOS_BPS_LIMIT", "RBD_QOS_READ_IOPS_LIMIT", "RBD_QOS_WRITE_IOPS_LIMIT", "RBD_QOS_READ_BPS_LIMIT", "RBD_QOS_WRITE_BPS_LIMIT", "RBD_QOS_BPS_BURST", "RBD_QOS_IOPS_BURST", "RBD_QOS_READ_BPS_BURST", "RBD_QOS_READ_IOPS_BURST", "RBD_QOS_WRITE_BPS_BURST", "RBD_QOS_WRITE_IOPS_BURST" ]
      },
      "QosCommandAppliedResponse" : {
        "type" : "object",
        "required" : [ "command", "errorMessage" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "success" : {
            "type" : "boolean"
          },
          "errorMessage" : {
            "type" : "string"
          }
        }
      },
      "QosCommandLimit" : {
        "description" : "The Qos command to be executed.",
        "type" : "object",
        "required" : [ "command" ],
        "properties" : {
          "command" : {
            "type" : "string",
            "description" : "The command to be executed.",
            "pattern" : "\\S"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit to be set as an unsigned integer (0 means no limit).",
            "minimum" : 0
          }
        }
      },
      "QosCommandsResponse" : {
        "description" : "The Qos setting as defined in the doc.",
        "type" : "object",
        "required" : [ "setting" ],
        "properties" : {
          "setting" : {
            "description" : "Detail of the command.",
            "type" : "object",
            "required" : [ "command", "displayName", "description" ],
            "properties" : {
              "command" : {
                "type" : "string"
              },
              "displayName" : {
                "type" : "string"
              },
              "description" : {
                "type" : "string"
              }
            }
          },
          "value" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The current limit."
          },
          "inherited" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit inherited from pool settings, if there is any."
          }
        }
      },
      "QueryOrder" : {
        "type" : "string",
        "enum" : [ "ASC", "DESC" ]
      },
      "RankReintegrateRequest" : {
        "type" : "object",
        "properties" : {
          "rank" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Rank to reintegrate. If omitted, all ranks will be attempted."
          }
        }
      },
      "RawCephPermissions" : {
        "type" : "object",
        "properties" : {
          "mon" : {
            "type" : [ "string", "null" ]
          },
          "mgr" : {
            "type" : [ "string", "null" ]
          },
          "osd" : {
            "type" : [ "string", "null" ]
          },
          "mds" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RawDaosAcl" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "type" : "string"
          }
        }
      },
      "RbdCephPermissions" : {
        "description" : "Ceph permissions for RBD clients",
        "type" : "object",
        "required" : [ "pools" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            },
            "description" : "List of pools or wildcard specs this key has access to"
          }
        }
      },
      "RbdDeleteRequest" : {
        "description" : "Details for an RBD deletion request",
        "type" : "object",
        "required" : [ "pool", "rbd" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool to operate on, repeated for safety"
          },
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD to delete, repeated for safety"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace to operate on, optional, default is the default namespace, repeated for safety"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ],
            "description" : "Must be set to \"I'm really sure that I want to delete this\""
          }
        }
      },
      "RbdFeature" : {
        "type" : "string",
        "enum" : [ "LAYERING", "EXCLUSIVE_LOCK", "OBJECT_MAP", "FAST_DIFF", "DEEP_FLATTEN", "JOURNALING" ]
      },
      "RbdImageCreationRequest" : {
        "description" : "Details of an RBD image that is to be created",
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Store actual data in a separate erasure-coded pool. The main pool will only store metadata."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace (omit/null for the default namespace)"
          }
        }
      },
      "RbdImageMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "journal", "snapshot" ]
      },
      "RbdImageMirrorState" : {
        "type" : "string",
        "enum" : [ "disabled", "primary", "mirror" ]
      },
      "RbdImageResponse" : {
        "type" : "object",
        "required" : [ "name", "pool", "features", "mirrorInfo", "hints", "sizeFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where this image resides in"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "parent" : {
            "description" : "Parent image if this is a linked clone (not for creating images, use clone endpoint)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdParentDump"
            }, {
              "type" : "null"
            } ]
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Separate erasure-coded pool in which the image data is stored. The main pool will only store metadata."
          },
          "mirrorInfo" : {
            "description" : "RBD mirror information for this RBD image.",
            "type" : "object",
            "$ref" : "#/components/schemas/RbdMirrorImageInfo"
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the pool/namespace of this image.",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "snaps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageSnapshot"
            },
            "description" : "Snapshots of this image (not for creating images), default = default Ceph features"
          },
          "withDetails" : {
            "type" : "boolean",
            "description" : "Whether or not image details are included"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to be displayed in the UI, such as errors that happened while fetching RBD details."
          },
          "sizeFormatted" : {
            "type" : "string"
          }
        }
      },
      "RbdImageSnapshot" : {
        "description" : "Details of an RBD image snapshot",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot"
          },
          "protect" : {
            "type" : "boolean",
            "description" : "True if this snapshot is protected"
          }
        },
        "required" : [ "name" ]
      },
      "RbdImageUsedSizeResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "snapshot" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the snapshot if this entry is an RBD snapshot, otherwise null"
          },
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the RBD has in total (in bytes)"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used on the RBD (in bytes)"
          }
        }
      },
      "RbdJournalingUpdateRequest" : {
        "description" : "Request to enable/disable journaling on all images",
        "type" : "object",
        "properties" : {
          "enableJournaling" : {
            "type" : "boolean",
            "description" : "Enable/Disable journaling on all images."
          }
        }
      },
      "RbdMirrorDirection" : {
        "type" : "string",
        "enum" : [ "rx_tx", "rx_only", "tx_only" ]
      },
      "RbdMirrorImageInfo" : {
        "description" : "RBD mirroring details and status of an RBD image.",
        "type" : "object",
        "required" : [ "imageMirrorMode", "mirrorState" ],
        "properties" : {
          "imageMirrorMode" : {
            "description" : "Mirror mode set for the image (disabled, journal or snapshot, snapshot is only supported in octopus or later).",
            "type" : "string",
            "examples" : [ "journal" ],
            "$ref" : "#/components/schemas/RbdImageMirrorMode"
          },
          "mirrorState" : {
            "description" : "State describing if the image is mirrored as primary, mirrored as non-primary, or has mirroring disabled.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdImageMirrorState"
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this image is primary, or null if mirroring is disabled."
          },
          "globalId" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "RBD mirroring global ID (if mirroring is enabled on this image). This ID isn't used by croit."
          },
          "state" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring state (if mirroring is enabled on this image).",
            "examples" : [ "up+replaying" ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring status description (if mirroring is enabled on this image).",
            "examples" : [ "replaying, master_position=[object_number=3, tag_tid=1, entry_tid=3], mirror_position=[object_number=3, tag_tid=1, entry_tid=3], entries_behind_master=0" ]
          },
          "lastUpdate" : {
            "type" : [ "string", "null" ],
            "description" : "Time of the latest RBD mirroring update (if mirroring is enabled on this image).",
            "examples" : [ "2020-08-06 10:32:34" ]
          },
          "daemonHost" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server on which the rbd-mirror daemon is running.",
            "examples" : [ "croit-host01" ]
          },
          "peerSites" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Peer sites which this image is mirrored from or mirrored to."
          }
        }
      },
      "RbdMirrorImageUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD image",
        "type" : "object",
        "properties" : {
          "journaling" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable/disable journaling."
          },
          "imageMirrorMode" : {
            "description" : "Mirror mode (disable, journaling or snapshot), enabling mirroring is only possible if the pool is in image mirror mode, and snapshot is only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdImageMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "Make image primary/non-primary, only possible if mirroring is enabled on the image."
          }
        }
      },
      "RbdMirrorPeer" : {
        "description" : "RBD mirroring peer details.",
        "type" : "object",
        "required" : [ "id", "siteName", "clientName" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Global ID of the peer (generated separately from the cluster IDs).",
            "examples" : [ "268847dc-e379-462b-901b-298260b7b7c6" ]
          },
          "siteName" : {
            "type" : "string",
            "description" : "Name of the peer cluster, by default its cluster ID.",
            "examples" : [ "ad5a99dd-4a08-41c3-bafa-d0ea8f5ced18" ]
          },
          "clientName" : {
            "type" : "string",
            "description" : "Name of the ceph key on the peer cluster, this ceph user is used by the rbd-mirror daemon to connect to the peer cluster. Croit uses the default from the bootstrap token (client.rbd-mirror-peer).",
            "examples" : [ "client.rbd-mirror-peer" ]
          },
          "direction" : {
            "description" : "Mirror direction, rx-tx, rx-only or tx-only. Only available with Ceph Octopus or later. Croit uses the default of the bootstrap method: rx-tx. Should this still be set to tx-only, try removing the peers from the pool on both clusters and reimport the bootstrap token.",
            "type" : [ "string", "null" ],
            "examples" : [ "client.rbd-mirror-peer" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorPeerCreateRequest" : {
        "description" : "Request to create a new peer using a bootstrap token",
        "type" : "object",
        "required" : [ "peerToken", "direction" ],
        "properties" : {
          "peerToken" : {
            "type" : "string",
            "description" : "Bootstrap token obtained from the peer cluster.",
            "examples" : [ "eyJmc2lkIjoiYmYzNTQ4MzAtZjBmZi00ZGRkLWEwNzUtMjRjNjZlNjVjODdlIiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFDdUlYTmZEeS8yS2hBQUEwMnFISm5mWDdkWSthR2l5bzRQRXc9PSIsIm1vbl9ob3N0IjoiMTcyLjMxLjExMS4xMjQ6Njc4OSwgMTcyLjMxLjExMS4xMzY6Njc4OSwgMTcyLjMxLjExMS4xMjE6Njc4OSJ9" ]
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "localSiteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of this cluster that will be displayed on the peer cluster.",
            "examples" : [ "clusterB" ]
          },
          "direction" : {
            "description" : "Direction setting for the peer, rx-tx (default), rx-only or (starting with octopus) tx-only.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdMirrorDirection"
          }
        }
      },
      "RbdMirrorPeerUpdateRequest" : {
        "description" : "Request to update mirroring settings of a mirror peer",
        "type" : "object",
        "properties" : {
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "monHosts" : {
            "type" : [ "string", "null" ],
            "description" : "Mon hosts of the peer cluster. Changing this can break the peer connection."
          },
          "direction" : {
            "description" : "New direction setting for the peer (rx-tx, rx-only or tx-only). Changing this can break the peer connection. Only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          },
          "client" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the remote client with read-access for RBD pools. Changing this can break the peer connection."
          }
        }
      },
      "RbdMirrorPoolInfo" : {
        "description" : "RBD mirroring details and status of an RBD pool+namespace.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace, will be null when referring to the pool only without namespace.",
            "examples" : [ "ns1" ]
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the RBD pool (disabled, pool or image).",
            "type" : "string",
            "examples" : [ "pool" ],
            "$ref" : "#/components/schemas/RbdPoolMirrorMode"
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Site name of the pool.",
            "examples" : [ "clusterA" ]
          },
          "peers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdMirrorPeer"
            },
            "description" : "List of peers setup for RBD mirroring, currently only one peer is supported and returned."
          },
          "statusHealth" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirror status (if mirroring is enabled on this pool).",
            "examples" : [ "OK" ]
          },
          "statusStates" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "RBD mirror status states (if mirroring is enabled on this pool).",
            "examples" : [ {
              "replaying" : 2,
              "stopped" : 1
            } ]
          }
        },
        "required" : [ "poolMirrorMode", "peers" ]
      },
      "RbdMirrorPoolUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD pool",
        "type" : "object",
        "properties" : {
          "poolMirrorMode" : {
            "description" : "Rbd mirror mode (pool, image, disabled).",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorSiteNameUpdateRequest" : {
        "description" : "Request to update the site name of a pool.",
        "type" : "object",
        "required" : [ "siteName" ],
        "properties" : {
          "siteName" : {
            "type" : "string",
            "description" : "Site name for the pool.",
            "examples" : [ "clusterA" ]
          }
        }
      },
      "RbdMirrorSnapshot" : {
        "description" : "Mirror snapshot information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot.",
            "examples" : [ 10 ]
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot.",
            "examples" : [ ".mirror.primary.4fe60c6d-bafc-4399-850f-d43783af38dc.95e9cd1b-f327-4c21-9cbe-7b2e3a575885" ]
          }
        },
        "required" : [ "name" ]
      },
      "RbdMirrorSnapshotSchedule" : {
        "description" : "Mirror snapshot schedule information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, or \"-\"/null if the schedule affects all pools.",
            "examples" : [ "poolName" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace with in the pool, or \"-\"/null if the schedule affects all namespaces.",
            "examples" : [ "-" ]
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the RBD image, or \"-\"/null if the schedule affects all images.",
            "examples" : [ "-" ]
          },
          "interval" : {
            "type" : "string",
            "description" : "Interval time of the schedule specified as time in days, hours or minutes (with suffixes d/h/m, e.g. 7d, 12h or 30m).",
            "examples" : [ "10h" ]
          },
          "startTime" : {
            "type" : [ "string", "null" ],
            "description" : "Optional start time of the schedule specified in the ISO 8601 time format.",
            "examples" : [ "14:00:00" ]
          }
        },
        "required" : [ "interval" ]
      },
      "RbdNameResponse" : {
        "description" : "An RBD name including pool and namespace.",
        "type" : "object",
        "required" : [ "rbd", "pool" ],
        "properties" : {
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD."
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where the RBD resides in."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace used for the RBD, or null for the default namespace of the pool."
          }
        }
      },
      "RbdNamespace" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "RbdParentDump" : {
        "type" : "object",
        "required" : [ "pool", "image", "snapshot" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "snapshot" : {
            "type" : "string"
          }
        }
      },
      "RbdPoolInfo" : {
        "description" : "Contains basic information on an RBD pool with namespace.",
        "type" : "object",
        "required" : [ "pool", "hints" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace or null for the default namespace."
          },
          "ec" : {
            "type" : "boolean",
            "description" : "Whether or not the pool is an erasure-coded pool."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the pool's PGs are all active or peering."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "List of hints to display in the UI, e.g. errors that happened while this pool."
          }
        }
      },
      "RbdPoolMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "pool", "image" ]
      },
      "RbdSnapshotPath" : {
        "description" : "Name of an RBD image or pool.",
        "type" : "object",
        "required" : [ "pool" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the RBD pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace."
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional RBD image, if omitted, the entire pool is used."
          }
        }
      },
      "RbdSnapshotSchedule" : {
        "description" : "Information for an RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          },
          "pathsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "failedSnapshots", "pathsFormatted" ]
      },
      "RbdSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a RBD snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot.",
            "minItems" : 1
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\""
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotUpdateRequest" : {
        "description" : "Details for an snapshot update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Rename the snapshot to this new name"
          },
          "protect" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable or disable snapshot protection"
          }
        }
      },
      "RbdUpdateRequest" : {
        "description" : "Details for a RBD update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name of the image"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New size of the image in bytes, sizes can only increase"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "New list of features to be enabled"
          }
        }
      },
      "RbdUsedSizeResponse" : {
        "type" : "object",
        "properties" : {
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the namespace (or the single RBD specified in the request) has in total in bytes"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used in the namespace (or the single RBD specified in the request) in bytes"
          },
          "rbds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageUsedSizeResponse"
            }
          }
        }
      },
      "RecommendationResponse" : {
        "type" : "object",
        "required" : [ "taskUuid", "finding", "suggestions", "links", "updatedAt" ],
        "properties" : {
          "taskUuid" : {
            "description" : "A UUID to identify this recommendation by in other requests.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "finding" : {
            "description" : "Information on this recommendation, including what should be shown in the UI.",
            "type" : "object",
            "$ref" : "#/components/schemas/Finding"
          },
          "suggestions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Suggestions that can be applied to fix or execute this advisor recommendation. Maps suggestion ID to a human-readable string."
          },
          "links" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Links to display for more info."
          },
          "hide" : {
            "type" : "boolean",
            "description" : "If true, this recommendation was muted by the user and should be hidden in the UI."
          },
          "affected" : {
            "description" : "The object affected by this recommendation. Used for linking in the UI."
          },
          "updatedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp when this recommendation was last added or updated."
          }
        }
      },
      "RecoverySpeed" : {
        "type" : "object",
        "properties" : {
          "speed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Recovery speed setting from 1 (slowest) to 10 (fastest). Set to <= 0 to restore the default configured in ceph.conf."
          }
        }
      },
      "ReplaceOsdRequest" : {
        "type" : "object",
        "properties" : {
          "osd" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "OSD ID to replace."
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to use for the replacement, meaning the OSD will be put on this disk."
          },
          "encrypted" : {
            "type" : [ "boolean", "null" ],
            "description" : "If true, the newly created OSD will be encrypted. If null, the setting of the old OSD (if available) will be used."
          },
          "keepDbWal" : {
            "type" : "boolean",
            "description" : "If true, the newly created OSD will use the same DB/WAL as the replaced disk."
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the DB partition (if at all)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the WAL partition (if at all)."
          },
          "resizeOsd" : {
            "type" : "boolean",
            "description" : "If true, the OSD will be resized to match the new disk."
          }
        }
      },
      "ReplaceOsdsRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ReplaceOsdRequest"
            }
          }
        }
      },
      "RestartPolicy" : {
        "type" : "string",
        "enum" : [ "NEVER", "ON_FAILURE", "ALWAYS" ]
      },
      "RgwBucketResponse" : {
        "type" : "object",
        "required" : [ "bucket", "placement_rule", "id", "owner", "usage", "bucket_quota", "tenant", "usageSum" ],
        "properties" : {
          "bucket" : {
            "type" : "string"
          },
          "placement_rule" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          },
          "owner" : {
            "type" : "string"
          },
          "zonegroup" : {
            "type" : [ "string", "null" ]
          },
          "mtime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "usage" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RgwBucketUsageResponse"
            },
            "description" : "Data usage by zone."
          },
          "bucket_quota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "tenant" : {
            "type" : "string"
          },
          "usageSum" : {
            "$ref" : "#/components/schemas/RgwBucketUsageResponse"
          }
        }
      },
      "RgwBucketSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwBucketUsageResponse" : {
        "type" : "object",
        "properties" : {
          "sizeKiB" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeKiBActual" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numObjects" : {
            "type" : "number",
            "format" : "double"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiB instead."
          },
          "size_kb_actual" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiBActual instead."
          },
          "num_objects" : {
            "type" : "number",
            "format" : "double",
            "description" : "Deprecated, use numObjects instead."
          }
        },
        "required" : [ "sizeFormatted" ]
      },
      "RgwDefaultPlacementRequest" : {
        "type" : "object",
        "required" : [ "placementRule" ],
        "properties" : {
          "placementRule" : {
            "type" : "string",
            "description" : "The name of the placement rule to set as default."
          },
          "storageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional storage class for the placement rule to use as default."
          }
        }
      },
      "RgwDetailedUsage" : {
        "type" : "object",
        "required" : [ "bucketName", "bucketOwner", "time" ],
        "properties" : {
          "bucketName" : {
            "type" : "string"
          },
          "bucketOwner" : {
            "type" : "string"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "bytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bytesUploaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "successfulOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "failedOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "metadataBytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwKeyRequest" : {
        "type" : "object",
        "required" : [ "user", "access_key", "secret_key" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : "string"
          },
          "secret_key" : {
            "type" : "string"
          }
        }
      },
      "RgwPlacementPolicyResponse" : {
        "type" : "object",
        "required" : [ "name", "storageClass", "dataPool", "indexPool", "dataExtraPool" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The unique name of the placement policy."
          },
          "storageClass" : {
            "type" : "string",
            "description" : "Name of the storage class used for this placement policy."
          },
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data for the placement + storage class."
          },
          "indexPool" : {
            "type" : "string",
            "description" : "The pool used to store the bucket index"
          },
          "dataExtraPool" : {
            "type" : "string",
            "description" : "The pool used to store extra metadata."
          },
          "isDefault" : {
            "type" : "boolean"
          }
        }
      },
      "RgwPlacementRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          },
          "indexPool" : {
            "type" : [ "string", "null" ],
            "description" : "The pool used as an index for buckets. Can't be erasure coded."
          },
          "dataExtraPool" : {
            "type" : [ "string", "null" ],
            "description" : "An extra data pool for metadata. Can't be erasure coded."
          }
        }
      },
      "RgwPlacementResponse" : {
        "type" : "object",
        "properties" : {
          "defaultPlacementRule" : {
            "type" : [ "string", "null" ],
            "description" : "Default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default storage class of the default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "placements" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total placements available under the requested filter. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Offset in the list of total placements that was requested. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of placements requested. Only provided when using pagination."
          }
        }
      },
      "RgwQuotaRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size. Use a negative number to disable the size quota."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects. Use a negative number to disable the objects quota."
          },
          "max_size_kb" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes). Use a negative number to disable the size quota."
          },
          "max_objects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects. Use a negative number to disable the objects quota."
          }
        }
      },
      "RgwQuotaResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size in bytes."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects."
          },
          "max_size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes)."
          },
          "max_objects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects."
          },
          "maxSizeFormatted" : {
            "type" : "string"
          },
          "maxObjectsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "maxSizeFormatted", "maxObjectsFormatted" ]
      },
      "RgwSslCertChangeRequest" : {
        "type" : "object",
        "properties" : {
          "certificate" : {
            "type" : [ "string", "null" ]
          },
          "doRollingRestart" : {
            "type" : "boolean"
          }
        }
      },
      "RgwStorageClassRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          }
        }
      },
      "RgwSubUser" : {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubUserPermission" : {
        "type" : "string",
        "enum" : [ "full-control", "read-write", "read", "write", "NONE" ]
      },
      "RgwSubuserRequest" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserResponse" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwUpdateKeysRequest" : {
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwKeyRequest"
            }
          }
        }
      },
      "RgwUpdateSubusersRequest" : {
        "type" : "object",
        "required" : [ "subusers" ],
        "properties" : {
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserRequest"
            }
          }
        }
      },
      "RgwUserKey" : {
        "type" : "object",
        "required" : [ "user" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : [ "string", "null" ]
          },
          "secret_key" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RgwUserResponse" : {
        "type" : "object",
        "required" : [ "uid", "name", "email", "subusers", "bucketQuota", "userQuota", "subusersFormatted" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "email" : {
            "type" : "string"
          },
          "suspended" : {
            "type" : "boolean"
          },
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserResponse"
            }
          },
          "bucketQuota" : {
            "description" : "This quota is applied to all buckets owned by this user.",
            "type" : "object",
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "userQuota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          },
          "subusersFormatted" : {
            "type" : "string"
          }
        }
      },
      "RgwUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "suspended" : {
            "type" : [ "boolean", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RoleEnum" : {
        "type" : "string",
        "enum" : [ "admin", "viewer", "securefolder" ]
      },
      "RunScriptRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Execute previously uploaded script by id, mutually exclusive with script"
          },
          "script" : {
            "type" : [ "string", "null" ],
            "description" : "Execute verbatim script, mutually exclusive with scriptId"
          },
          "args" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of parameters passed to the script"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of servers the script will be run on"
          }
        },
        "required" : [ "args", "servers" ]
      },
      "S3BucketName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-bucket-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the bucket if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the bucket if configured"
          }
        }
      },
      "S3BucketVersioningConfiguration" : {
        "type" : "string",
        "enum" : [ "OFF", "ENABLED", "SUSPENDED", "UNKNOWN" ]
      },
      "S3Listing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3PrefixDetail"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "S3Metadata" : {
        "type" : "object",
        "properties" : {
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "contentType" : {
            "type" : "string"
          },
          "etag" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "userMetadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "versionId" : {
            "type" : [ "string", "null" ]
          },
          "contentDisposition" : {
            "type" : [ "string", "null" ]
          },
          "cacheControl" : {
            "type" : [ "string", "null" ]
          },
          "expirationTime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "expirationTimeRuleId" : {
            "type" : [ "string", "null" ]
          },
          "contentEncoding" : {
            "type" : [ "string", "null" ]
          },
          "contentLanguage" : {
            "type" : [ "string", "null" ]
          },
          "contentMD5" : {
            "type" : [ "string", "null" ]
          },
          "httpExpiresDate" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "raw" : {
            "type" : "object",
            "additionalProperties" : { }
          }
        },
        "required" : [ "contentType", "userMetadata", "raw" ]
      },
      "S3MultipartUpload" : {
        "type" : "object",
        "required" : [ "key", "uploadId", "owner", "initiator", "storageClass", "initiated", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "uploadId" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "storageClass" : {
            "type" : "string"
          },
          "initiated" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3MultipartUploadResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3MultipartUpload"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3ObjectResponse" : {
        "type" : "object",
        "required" : [ "key", "bucketName", "owner", "eTag", "lastModified", "storageClass", "sizeFormatted", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "bucketName" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "eTag" : {
            "type" : "string"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "lastModified" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "storageClass" : {
            "type" : "string"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3ObjectsResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3ObjectResponse"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3Owner" : {
        "type" : "object",
        "required" : [ "id", "displayName" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          }
        }
      },
      "S3PrefixDetail" : {
        "type" : "object",
        "required" : [ "prefix" ],
        "properties" : {
          "prefix" : {
            "type" : "string"
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          }
        }
      },
      "S3UsageForBucketByUserResponse" : {
        "description" : "Usage data for a bucket, split by user performing the operation.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All users (unauthenticated access is mapped to \"anonymous\") accessing this bucket, entries are split into 1 hour intervals."
          }
        }
      },
      "S3UsageForUserByBucketResponse" : {
        "description" : "Usage data for a user, split by bucket.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All buckets accessed by this user, entries are split into 1 hour intervals"
          }
        }
      },
      "S3UserName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-user-name query parameter"
          }
        }
      },
      "SambaServiceDNSNameUpdateRequest" : {
        "type" : "object",
        "required" : [ "serviceDnsName" ],
        "properties" : {
          "serviceDnsName" : {
            "type" : "string",
            "description" : "The new DNS name for the SMB cluster"
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          },
          "joinServer" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Server to use when joining the new DNS name. Optional, if not supplied, the first server from the database is used."
          }
        }
      },
      "SambaServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "virtualIps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit-read read-only user."
          },
          "domainController" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "SambaShareType" : {
        "type" : "string",
        "enum" : [ "SIMPLE", "ADS" ]
      },
      "SchedulingSettings" : {
        "type" : "object",
        "required" : [ "timezone" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          }
        }
      },
      "ScriptIdentifier" : {
        "type" : "object",
        "deprecated" : true,
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "ScriptInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          },
          "hookNames" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "name" ]
      },
      "ScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SemanticVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "ServerAccessPasswords" : {
        "description" : "Passwords to access servers.",
        "type" : "object",
        "properties" : {
          "rootPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password for (physical) shell access as root user, password login for SSH is disabled."
          },
          "ipmiPassword" : {
            "type" : [ "string", "null" ],
            "description" : "IPMI password for the ADMIN user of IPMI interfaces managed by croit."
          }
        }
      },
      "ServerHealth" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double"
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean"
          }
        }
      },
      "ServerHealthResponse" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double",
            "description" : "Approximate time difference between this server and the management server, negative values indicate the server is behind."
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean",
            "description" : "True if this server was booted from disk instead of PXE."
          },
          "uptimeFormatted" : {
            "type" : "string"
          },
          "freeRamFormatted" : {
            "type" : "string"
          },
          "bootSource" : {
            "type" : "string",
            "description" : "What the server used to boot, either 'Disk' or 'PXE'"
          }
        },
        "required" : [ "uptimeFormatted", "freeRamFormatted", "bootSource" ]
      },
      "ServerInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "type" : [ "object", "null" ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "services" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "servicesRunning" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "osds" : {
            "type" : "integer",
            "format" : "int32"
          },
          "osdsRunning" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealth"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ]
          },
          "hasSambaSssd" : {
            "type" : "boolean"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "machineId" : {
            "type" : "string"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "services", "servicesRunning", "usedPorts", "ips", "health", "machineId" ]
      },
      "ServerLimit" : {
        "description" : "Limit number of servers",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of servers allowed (0 or a negative number means no limit)."
          },
          "gracePercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Grace in percent for having servers above the limit."
          },
          "graceValue" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Grace in number of servers for having servers above the limit. Overrides gracePercent when provided."
          }
        }
      },
      "ServerNameAndId" : {
        "description" : "Server id/hostname pairs for querying the stats APIs.",
        "type" : "object",
        "required" : [ "hostname" ],
        "properties" : {
          "hostname" : {
            "type" : "string",
            "description" : "The hostname"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Use this id as template parameter."
          }
        }
      },
      "ServerRebootRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ServerResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HardwareResponse"
            }, {
              "type" : "null"
            } ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ports used by this server's services."
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "IPs configured on all NICs, only these are valid for the main IP."
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealthResponse"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "hasSambaSssd" : {
            "type" : "boolean",
            "description" : "True if the server is running Samba with sssd"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this server belongs to one"
          },
          "imageDescription" : {
            "type" : "string",
            "description" : "Description for the image that is configured on the server"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) configured for the server when using it for DAOS or NVMe-oF."
          },
          "machineId" : {
            "type" : "string",
            "description" : "Machine ID"
          },
          "services" : {
            "$ref" : "#/components/schemas/ServerServicesResponse"
          },
          "ramUsageFormatted" : {
            "type" : "string"
          },
          "stateLabel" : {
            "type" : "string"
          },
          "macsFormatted" : {
            "type" : "string",
            "description" : "MAC addresses if the management interface as a comma-separated string (there are multiple if it's a bond)"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "usedPorts", "ips", "health", "imageDescription", "machineId", "services", "ramUsageFormatted", "stateLabel", "macsFormatted" ]
      },
      "ServerServicesResponse" : {
        "type" : "object",
        "required" : [ "osd", "mon", "mgr", "smb", "nfs", "mds", "iscsi", "rgw", "rbdMirror", "nvmfTgt", "daosServer", "daosAgent" ],
        "properties" : {
          "osd" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mon" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mgr" : {
            "$ref" : "#/components/schemas/Service"
          },
          "smb" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nfs" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mds" : {
            "$ref" : "#/components/schemas/Service"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rgw" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rbdMirror" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nvmfTgt" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosServer" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosAgent" : {
            "$ref" : "#/components/schemas/Service"
          }
        }
      },
      "ServerState" : {
        "type" : "string",
        "enum" : [ "booting", "running", "offline", "rebooting", "shutting_down" ]
      },
      "ServerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ]
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "image" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) to configure for services that require it."
          }
        }
      },
      "Service" : {
        "type" : "object",
        "properties" : {
          "deployed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of deployed instances of this services."
          },
          "running" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of running instances of this services."
          },
          "isDeployed" : {
            "type" : "boolean",
            "description" : "Whether an instance of this service is deployed."
          },
          "isRunning" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether an instance of this service is running."
          }
        }
      },
      "ServiceControlRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The service ID, or in case of an OSD the daemon ID."
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Required for multi-server services"
          },
          "isOsd" : {
            "type" : "boolean",
            "description" : "If this service is an OSD."
          }
        }
      },
      "ServiceHealthResponse" : {
        "description" : "Health information about a running service",
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Uptime in seconds"
          },
          "memory" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Memory usage (RSS) in GiB"
          },
          "uptimeFormatted" : {
            "type" : "string",
            "description" : "Uptime in seconds"
          },
          "memoryFormatted" : {
            "type" : "string",
            "description" : "Memory usage (RSS) in GiB"
          }
        },
        "required" : [ "uptimeFormatted", "memoryFormatted" ]
      },
      "ServiceNvmeofAnaState" : {
        "type" : "string",
        "enum" : [ "optimized", "non_optimized", "inaccessible" ]
      },
      "ServiceState" : {
        "type" : "string",
        "enum" : [ "creating", "enabled", "disabled", "creation_failed" ]
      },
      "ServiceSubState" : {
        "type" : "string",
        "enum" : [ "ACTIVE", "STANDBY" ]
      },
      "ServiceTypePath" : {
        "type" : "string",
        "enum" : [ "osds", "mons", "radosgws", "mds", "mgrs", "nfs_gateways", "iscsis", "smbs", "rbd_mirrors", "daos_server", "daos_agent", "nvmf_tgts" ]
      },
      "ServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port for the service. Only relevant for RGW."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "SSL/TLS port for the service. Only relevant for RGW."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW DNS name to use for this service. Only relevant for RGW."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW zone to use for this service. Only relevant for RGW."
          }
        }
      },
      "SetDaosAclRequest" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "description" : "ACL entry to update. If it doesn't exist, it will be created.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosAclEntry"
          }
        }
      },
      "SetDaosContainerOwnerRequest" : {
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "The new owner."
          },
          "isGroup" : {
            "type" : "boolean",
            "description" : "Whether the owner is a group instead of a user."
          }
        }
      },
      "SetDaosPropertyRequest" : {
        "type" : "object",
        "required" : [ "name", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property to set."
          },
          "value" : {
            "type" : "string",
            "description" : "Value that the property should be set to."
          }
        }
      },
      "Severity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARNING", "CRITICAL" ]
      },
      "SignedLicenseData" : {
        "description" : "Signed license information as received from https://api.croit.io.",
        "type" : "object",
        "required" : [ "nextRefresh", "features", "osds", "rawCapacityGb", "usedCapacityGb", "netCapacityGb", "storage", "servers", "croitVersions" ],
        "properties" : {
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "License server needs to be contacted by this time."
          },
          "cephUuid" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Ceph FSID"
          },
          "gracePeriodDays" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace period when the license or nextRefresh was exceeded."
          },
          "features" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "boolean"
            },
            "description" : "Limit features explicitly, setting a feature to false here disables it explicitly. Features missing here use the default setting."
          },
          "osds" : {
            "description" : "Limit the number of OSDs that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Limit the raw available capacity of the cluster.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Limit the used capacity of the cluster (incl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "netCapacityGb" : {
            "description" : "Limit the net data stored by this cluster (excl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "storage" : {
            "description" : "Limit the available hardware storage.",
            "type" : "object",
            "$ref" : "#/components/schemas/StorageLimit"
          },
          "servers" : {
            "description" : "Limit the number of nodes that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "croitVersions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "Set of croit versions this license is valid for. Empty set means all versions."
          },
          "offline" : {
            "type" : "boolean",
            "description" : "License is applicable to offline croit instances."
          },
          "free" : {
            "type" : "boolean",
            "description" : "License is a free license (not paid for, but community edition or trial)"
          }
        }
      },
      "SimpleDaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "clusterName", "name", "description" ]
      },
      "SimpleHookInfo" : {
        "type" : "object",
        "required" : [ "event" ],
        "properties" : {
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "SimpleRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "startBucket", "independent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "startBucket" : {
            "type" : "string"
          },
          "independent" : {
            "type" : "string"
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "SmbAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SmbGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean"
          }
        },
        "required" : [ "description", "type", "virtualIps" ]
      },
      "SmbGatewayServerRequest" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          }
        }
      },
      "SmbGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "hostname", "virtualIps" ]
      },
      "SmbGatewayServerResponse1" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "virtualIps" ]
      },
      "SmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "adminPassword", "readonlyPassword", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : "string",
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : "string",
            "description" : "Password of the croit-read read-only user."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewSimpleSmbGatewayShare"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SmbGatewayServiceResponse" : {
        "type" : "object",
        "required" : [ "type", "servers", "virtualIps", "shares" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse1"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "minItems" : 1
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Joined with adcli+sssd."
          }
        }
      },
      "SmbGatewayShareResponse" : {
        "type" : "object",
        "required" : [ "type", "share", "path" ],
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Type of the SMB cluster that this share belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the SMB cluster that this share belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of this share."
          },
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the croit-ro user."
          },
          "roUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          },
          "roUsersFormatted" : {
            "type" : [ "string", "null" ]
          },
          "rwUsersFormatted" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SortBy" : {
        "type" : "object",
        "required" : [ "column", "order" ],
        "properties" : {
          "column" : {
            "type" : "string",
            "description" : "Which column to sort by."
          },
          "order" : {
            "description" : "Whether to sort ascending or descending.",
            "type" : "string",
            "$ref" : "#/components/schemas/QueryOrder"
          }
        }
      },
      "SsdPrimaryRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "ssdStartBucket", "ssdIndependent", "hddStartBucket", "hddIndependent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ssdStartBucket" : {
            "type" : "string"
          },
          "ssdIndependent" : {
            "type" : "string"
          },
          "ssdDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "hddStartBucket" : {
            "type" : "string"
          },
          "hddIndependent" : {
            "type" : "string"
          },
          "hddDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "ssdCopies" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "StandbyReplaySetting" : {
        "type" : "object",
        "properties" : {
          "allowStandbyReplay" : {
            "type" : "boolean"
          },
          "cephFsName" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "StatsUnit" : {
        "type" : "string",
        "enum" : [ "IOPS", "BYTES_PER_SECOND", "BITS_PER_SECOND", "OBJECTS_PER_SECOND", "OBJECTS", "BYTES", "SECONDS", "MILLISECONDS", "MICROSECONDS", "PERCENT", "COUNT", "NONE" ]
      },
      "StorageLimit" : {
        "type" : "object",
        "description" : "Limit available hardware storage",
        "properties" : {
          "osds" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, excluding DB/WAL (negative number means no limit)."
          },
          "osdsWithJournal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL (negative number means no limit)."
          },
          "osdsTotal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL and not yet used disks."
          },
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for all disks."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more storage"
          }
        }
      },
      "SupervisorModuleJson" : {
        "type" : "object",
        "required" : [ "name", "command", "restartPolicy" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "healthy" : {
            "type" : "boolean"
          },
          "disabled" : {
            "type" : "boolean"
          },
          "command" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "restartPolicy" : {
            "$ref" : "#/components/schemas/RestartPolicy"
          },
          "running" : {
            "type" : "boolean"
          },
          "pid" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "SurveyCeph" : {
        "type" : "object",
        "properties" : {
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "rawCapacityGB" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "fullPercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolSurvey"
            }
          },
          "rgwBuckets" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketSurvey"
            }
          },
          "cephFsStats" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephfsSurvey"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "pools", "rgwBuckets" ]
      },
      "SurveyConfigResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          }
        }
      },
      "SurveyDisk" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "sizeGB" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "type" : {
            "$ref" : "#/components/schemas/DiskType"
          },
          "numPaths" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "role", "name", "deviceClass", "smart", "type" ]
      },
      "SurveyNic" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/NicType"
          },
          "bondSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numVlans" : {
            "type" : "integer",
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "SurveyReport" : {
        "type" : "object",
        "required" : [ "services", "disks", "servers", "nics" ],
        "properties" : {
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyService"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyDisk"
            }
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyServer"
            }
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyNic"
            }
          },
          "ceph" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SurveyCeph"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "SurveyServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "totalCores" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "virtualCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "physicalCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "SurveyService" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SurveyUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "TaskAdvisorUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hide" : {
            "type" : "boolean"
          }
        }
      },
      "TaskProgressResponse" : {
        "type" : "object",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "TaskQuestion" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "defaultResponse" : {
            "type" : "string"
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "priority" : {
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "timeout" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
          },
          "response" : {
            "type" : "string",
            "writeOnly" : true
          },
          "timeLeft" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "TaskQuestionAnswer" : {
        "type" : "object",
        "required" : [ "token", "response" ],
        "properties" : {
          "token" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "response" : {
            "type" : "string"
          }
        }
      },
      "TaskQuestionPriority" : {
        "type" : "string",
        "enum" : [ "Standard", "Urgent" ]
      },
      "TaskQuestionResponse" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string",
            "description" : "Task question message to display to the user."
          },
          "defaultResponse" : {
            "type" : "string",
            "description" : "Default response if user doesn't answer in time."
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Response options to offer to the user."
          },
          "priority" : {
            "description" : "Priority for this question.",
            "type" : "string",
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Token used for the reply request."
          },
          "timeout" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total time to respond to the question (in milliseconds)."
          },
          "timeLeft" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Time left to respond to the question (in milliseconds)."
          }
        }
      },
      "TaskResponse" : {
        "description" : "A long running tasks.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "description" : "Progress indication of a background task.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskProgressResponse"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          },
          "cancelled" : {
            "type" : "boolean"
          },
          "question" : {
            "description" : "Question that a task might prompt for.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestionResponse"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "TemplateObject" : {
        "type" : "object",
        "required" : [ "content", "type" ],
        "properties" : {
          "content" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/TemplateVariable"
            }
          },
          "nullable" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          }
        }
      },
      "TemplateVariable" : {
        "type" : "object",
        "properties" : {
          "nullable" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      },
      "TerminalConnection" : {
        "type" : "object",
        "required" : [ "path", "authToken", "validUntil" ],
        "properties" : {
          "path" : {
            "type" : "string",
            "description" : "Connect here."
          },
          "tlsPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for TLS."
          },
          "plaintextPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for an unencrypted connection."
          },
          "authToken" : {
            "description" : "Pass as Authorization header.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "URL is valid until this time, existing connections stay connected afterwards."
          },
          "iscsi" : {
            "type" : "boolean",
            "description" : "Whether this is a connection to an iSCSI gateway."
          }
        }
      },
      "TimezoneSettings" : {
        "type" : "object",
        "required" : [ "timezone", "options" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          },
          "options" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "Token" : {
        "description" : "Token Response",
        "type" : "object",
        "required" : [ "access_token", "token_type", "roles" ],
        "properties" : {
          "access_token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Access token, should be handled as an opaque value as the format may change in the future."
          },
          "token_type" : {
            "type" : "string",
            "description" : "OAuth2 token type, always \"bearer\"."
          },
          "expires_in" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Remaining validity."
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "All roles of the user the token is associated with."
          },
          "userId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Internal id of the user this token is associated with."
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean",
            "description" : "Set if the user never changed their password."
          }
        }
      },
      "TokenInfoReply" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "oidcId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcSubject" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "UUID" : {
        "type" : "string",
        "format" : "uuid",
        "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
      },
      "UnencryptedBackupRequest" : {
        "type" : "object",
        "required" : [ "file" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          }
        }
      },
      "UpdateGrubRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "UploadS3ObjectRequest" : {
        "type" : "object",
        "required" : [ "key", "file" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "UserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "VPNConfigRequest" : {
        "description" : "Croit VPN configuartion request to https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "croitVersionString" : {
            "type" : [ "string", "null" ],
            "description" : "Croit version as a string (omitted if unknown)."
          },
          "croitVersion" : {
            "description" : "Croit version (omitted if unknown).",
            "type" : "object",
            "anyOf" : [ {
              "$ref" : "#/components/schemas/VPNCroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname to use for the croit VPN."
          },
          "extraArgs" : {
            "type" : [ "string", "null" ],
            "description" : "Extra arguments to pass to the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        },
        "required" : [ "hostname" ]
      },
      "VPNConfigResponse" : {
        "description" : "Croit VPN configuartion as received from https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID for the vpn configuration."
          },
          "envs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Environment variables to set for the croit VPN container."
          },
          "image" : {
            "description" : "Image to use for the croit VPN container.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNCroitDockerImage"
          },
          "stateDir" : {
            "type" : "string",
            "description" : "Directory to use for the croit VPN configuration. Should be mounted from a docker volume."
          },
          "resetState" : {
            "type" : "boolean",
            "description" : "If true, the croit client requesting the VPN config needs to reset the VPN state directory."
          },
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          }
        },
        "required" : [ "envs", "image", "stateDir", "reqId" ]
      },
      "VPNConnectInfo" : {
        "description" : "Croit VPN connection confirmation and information on the client.",
        "type" : "object",
        "required" : [ "reqId", "hostname", "fqdn", "ip", "errorMessage", "vpnLogs" ],
        "properties" : {
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          },
          "connected" : {
            "type" : "boolean",
            "description" : "Whether or not connection was successful."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname assigned by the croit VPN."
          },
          "fqdn" : {
            "type" : "string",
            "description" : "FQDN assigned by the croit VPN."
          },
          "ip" : {
            "type" : "string",
            "description" : "IP assigned by the croit VPN."
          },
          "errorMessage" : {
            "type" : "string",
            "description" : "Error message if VPN failed to connect."
          },
          "vpnLogs" : {
            "type" : "string",
            "description" : "VPN logs if VPN failed to connect."
          }
        }
      },
      "VPNConnectionInfo" : {
        "type" : "object",
        "required" : [ "status", "suggestedHostname" ],
        "properties" : {
          "status" : {
            "description" : "Croit VPN connection status.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNConnectionStatus"
          },
          "configuredHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to be used in the croit VPN as configured by the user."
          },
          "suggestedHostname" : {
            "type" : "string",
            "description" : "Hostname to be used in the croit VPN as suggested by croit."
          }
        }
      },
      "VPNConnectionRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to use for the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        }
      },
      "VPNConnectionStatus" : {
        "type" : "object",
        "properties" : {
          "containerRunning" : {
            "type" : "boolean",
            "description" : "True if croit VPN container is running."
          },
          "connected" : {
            "type" : "boolean",
            "description" : "True if connected to the croit VPN."
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Version of the tailscale client."
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname in the croit VPN."
          },
          "fqdn" : {
            "type" : [ "string", "null" ],
            "description" : "FQDN in the croit VPN."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Tailscale ID in the croit VPN"
          },
          "userId" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "User ID in the croit VPN"
          },
          "ips" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of IPs of this host in the croit VPN."
          },
          "reason" : {
            "type" : "string",
            "description" : "If disconnected, the reason why croit assumes that the VPN is not connected."
          }
        },
        "required" : [ "reason" ]
      },
      "VPNCroitDockerImage" : {
        "type" : "object",
        "description" : "Docker image specification.",
        "properties" : {
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "Registry to use. If omitted, the default registry (docker hub) is used."
          },
          "login" : {
            "type" : [ "object", "null" ],
            "description" : "Login to use. If omitted, no login data is provided to the registry (the image needs to be public)."
          },
          "name" : {
            "type" : "string",
            "description" : "Image name."
          },
          "tag" : {
            "type" : "string",
            "description" : "Image tag."
          }
        },
        "required" : [ "name", "tag" ]
      },
      "VPNCroitVersion" : {
        "type" : "object",
        "description" : "Croit version.",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Major croit release version (e.g. 2303)."
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Minor croit release version (e.g. 1)."
          },
          "patch" : {
            "type" : "string",
            "description" : "Patch version (only relevant for nightly or dev builds)."
          },
          "cephRelease" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph release (e.g. quincy)."
          }
        },
        "required" : [ "patch" ]
      },
      "VlanAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlanId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "VlanInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "VlanUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "WhereCondition" : {
        "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
        "additionalProperties" : {
          "$ref" : "#/components/schemas/FieldCondition"
        },
        "type" : [ "object", "null" ],
        "properties" : {
          "_and" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical AND operator. All conditions must be satisfied."
          },
          "_or" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical OR operator. At least one condition must be satisfied."
          },
          "_not" : {
            "description" : "Logical NOT operator. The condition must not be satisfied.",
            "type" : [ "object", "null", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WhereCondition"
            }, {
              "type" : "null"
            } ]
          },
          "_search" : {
            "type" : [ "string", "null" ],
            "description" : "Full-text search across all searchable fields."
          }
        }
      },
      "WildcardPoolPermission" : {
        "type" : "string",
        "enum" : [ "ALL_POOLS", "ALL_CEPHFS_POOLS" ]
      }
    }
  },
  "tags" : [ {
    "name" : "api-tokens",
    "description" : "Manage croit API tokens."
  }, {
    "name" : "audit",
    "description" : "Query croit audit logs."
  }, {
    "name" : "authentication",
    "description" : "OAuth2 authentication."
  }, {
    "name" : "ceph-keys",
    "description" : "Manage Ceph access keys."
  }, {
    "name" : "ceph-pools",
    "description" : "Manage ceph pools."
  }, {
    "name" : "cephfs",
    "description" : "CephFS file management."
  }, {
    "name" : "change-requests"
  }, {
    "name" : "cluster"
  }, {
    "name" : "config",
    "description" : "Configure settings for croit and ceph."
  }, {
    "name" : "config-templates",
    "description" : "Manage templates for config files."
  }, {
    "name" : "croit",
    "description" : "Information about the croit application."
  }, {
    "name" : "crush",
    "description" : "CRUSH map and rule management."
  }, {
    "name" : "daos",
    "description" : "Configure and manage DAOS."
  }, {
    "name" : "disks",
    "description" : "Manage server disks."
  }, {
    "name" : "extra-files",
    "description" : "Static web server for files located in /config/extra-files (or in /config/extra-files-secure, requiring authentication), to be downloaded by hook scripts on the servers."
  }, {
    "name" : "ha-groups",
    "description" : "Manage high availability groups and floating IPs."
  }, {
    "name" : "hooks",
    "description" : "Hook scripts for specific events."
  }, {
    "name" : "images",
    "description" : "Manage OS images."
  }, {
    "name" : "ipmi",
    "description" : "Manage IPMI interfaces."
  }, {
    "name" : "license",
    "description" : "croit license information."
  }, {
    "name" : "logs",
    "description" : "Log file API."
  }, {
    "name" : "maintenance",
    "description" : "Cluster maintenance and recovery APIs."
  }, {
    "name" : "networks",
    "description" : "Manage networks."
  }, {
    "name" : "placement-groups",
    "description" : "Manage placement groups."
  }, {
    "name" : "qos-settings",
    "description" : "QOS Settings."
  }, {
    "name" : "rbd-mirror",
    "description" : "Manage RBD mirroring for RBD pools. To configure RBD mirroring, first start an RBD mirror service on the cluster that data should be mirrored to. Then use this API to enable mirroring on pools with the same name on both clusters. To connect the two clusters, generate a bootstrap token on one of the pools, and import the token on the same pool on the other cluster."
  }, {
    "name" : "rbds",
    "description" : "Manage RBD images in pools."
  }, {
    "name" : "s3",
    "description" : "Manage S3 access."
  }, {
    "name" : "servers",
    "description" : "Manage server hardware, configuration, and services."
  }, {
    "name" : "services",
    "description" : "Manage services, this includes both Ceph services and croit-specific services running on both the ceph servers and management node."
  }, {
    "name" : "setup",
    "description" : "Initial setup of croit."
  }, {
    "name" : "snapshot-schedule",
    "description" : "Schedule automatic snapshots for CephFS and RBD."
  }, {
    "name" : "stats",
    "description" : "Get statistics of the cluster and servers."
  }, {
    "name" : "status",
    "description" : "Backend status."
  }, {
    "name" : "supervisor",
    "description" : "Manage supervisor operations."
  }, {
    "name" : "support",
    "description" : "Connect to croit support."
  }, {
    "name" : "survey",
    "description" : "Manage participation in the croit hardware survey."
  }, {
    "name" : "task-advisor",
    "description" : "Admin task advisor."
  }, {
    "name" : "tasks",
    "description" : "Status and overview of long running background tasks."
  }, {
    "name" : "users",
    "description" : "Manage croit users."
  } ],
  "paths" : {
    "/api-tokens" : {
      "get" : {
        "summary" : "List all configured api tokens.",
        "operationId" : "ApiTokenResource_getApiTokens",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseApiTokenInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a new API token. Returns the secret token (which should only be shown once to the user).",
        "operationId" : "ApiTokenResource_createApiToken",
        "tags" : [ "api-tokens" ],
        "requestBody" : {
          "description" : "API token creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/api-tokens/{id}" : {
      "patch" : {
        "summary" : "Update an API token.",
        "operationId" : "ApiTokenResource_updateApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "API token update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an API token.",
        "operationId" : "ApiTokenResource_deleteApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit" : {
      "get" : {
        "summary" : "Get audit logs.",
        "operationId" : "AuditResource_getAuditLogs",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "description" : "Limit number of results returned, max = 100, default = 50.",
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 1
          }
        }, {
          "description" : "Offset for pagination, default = 0.",
          "name" : "offset",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 0
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AuditInfo"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-ad-logs" : {
      "post" : {
        "summary" : "Fix Samba AD audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaADLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-simple-logs" : {
      "post" : {
        "summary" : "Fix Samba simple audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaSimpleLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/{id}" : {
      "get" : {
        "summary" : "Get specific audit log by ID.",
        "operationId" : "AuditResource_getAuditLog",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AuditInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/login" : {
      "post" : {
        "summary" : "OAuth 2 authentication via HTTP basic authentication, see Section 4.4 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginBasic",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        }
      }
    },
    "/auth/login-form" : {
      "post" : {
        "summary" : "OAuth 2 authentication with all parameters as url-encoded form, see Section 4.3 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginForm",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type", "username", "password" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  },
                  "username" : {
                    "type" : "string"
                  },
                  "password" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        }
      }
    },
    "/auth/logout" : {
      "post" : {
        "summary" : "Log out the current user session",
        "operationId" : "AuthResource_logout",
        "tags" : [ "authentication" ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/auth/oidc" : {
      "get" : {
        "summary" : "List of all OIDC configs.",
        "operationId" : "AuthResource_getOidcConfigs",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseOidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed configuration for every registered OIDC provider.",
          "usage" : [ "Open the identity provider administration view", "Review provider settings before editing or deleting entries" ],
          "response_shape" : "OptionalPaginationResponse<OidcConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit, sort or filter provider records.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"providerName\":{\"_ilike\":\"%prod%\"}}]}"
          } ],
          "failure_modes" : [ "403 if called with an API token session", "200 [] when no providers are configured" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Require an interactive admin session before exposing provider settings."
          }, {
            "code" : "200",
            "action" : "Present an empty state encouraging the creation of a provider."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "OIDC admin view"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc/{id}", "/auth/oidc/providers" ],
          "postprocessing_hint" : "Mask client secrets when rendering and avoid persisting them client-side.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create new OIDC configuration",
        "operationId" : "AuthResource_createOidcConfig",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "OIDC configuration creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/callback" : {
      "post" : {
        "summary" : "Handle OIDC callback",
        "operationId" : "AuthResource_oidcCallback",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "code",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "error",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "state",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        }
      }
    },
    "/auth/oidc/providers" : {
      "get" : {
        "summary" : "Get list of OIDC provider options",
        "operationId" : "AuthResource_getOidcProviders",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/OidcProvider"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured OIDC providers for login selection screens.",
          "usage" : [ "Call on the login page to show available identity providers", "Cache provider names between sessions unless configuration changes" ],
          "response_shape" : "array<OidcProvider>",
          "failure_modes" : [ "200 [] when no OIDC providers are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display a message indicating that no external providers are available."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/oidc/{id}/login", "/auth/oidc" ],
          "postprocessing_hint" : "Sort providers alphabetically before rendering the list.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/oidc/{id}" : {
      "put" : {
        "summary" : "Update OIDC configuration",
        "operationId" : "AuthResource_updateOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC configuration update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get specific OIDC configuration",
        "operationId" : "AuthResource_getOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch a single OIDC provider configuration for editing.",
          "usage" : [ "Load details when the admin selects a provider from the list", "Validate configuration values before saving changes" ],
          "response_shape" : "OidcConfigResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "403 if called with an API token session", "404 if the provider does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Require a human admin session before exposing provider secrets."
          }, {
            "code" : "404",
            "action" : "Display a toast that the provider was removed and refresh the list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-provider detail fetch"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Do not log clientSecret fields; redact before telemetry.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete OIDC configuration",
        "operationId" : "AuthResource_deleteOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/invalidate" : {
      "post" : {
        "summary" : "Invalidate all OIDC user sessions",
        "operationId" : "AuthResource_invalidateOidcSessions",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/login" : {
      "get" : {
        "summary" : "Initiate OIDC login flow",
        "operationId" : "AuthResource_oidcLogin",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off the browser-based OIDC authorization flow and obtain a redirect response.",
          "usage" : [ "Invoke when the user selects an external provider on the login screen", "Immediately follow the redirect location to continue the OIDC handshake" ],
          "response_shape" : "HTTP 302 redirect",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier returned by GET /auth/oidc/providers",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the provider is unknown", "500 if the OIDC discovery or redirect construction fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Show an error and refresh the provider list before retrying."
          }, {
            "code" : "500",
            "action" : "Log details, alert the user, and offer fallback credentials if available."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "User login attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/providers", "/auth/oidc/callback", "/auth/token-info" ],
          "postprocessing_hint" : "Persist the generated state token client-side (e.g. in session storage) before following the redirect.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/okta/login" : {
      "post" : {
        "summary" : "Login with Okta ID token",
        "operationId" : "AuthResource_loginWithOktaIdToken",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "Okta login request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OktaLoginRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        }
      }
    },
    "/auth/okta/signInConfig" : {
      "get" : {
        "summary" : "Get Okta OAuth configuration",
        "operationId" : "AuthResource_getOktaCfg",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OktaOAuthConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve Okta OAuth metadata required to render the Okta login widget.",
          "usage" : [ "Call once when loading the Okta-based login page", "Refresh only if the frontend detects configuration changes" ],
          "response_shape" : "OktaOAuthConfig",
          "failure_modes" : [ "500 if Okta integration is not configured" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show a maintenance message and fall back to standard credentials."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/okta/login", "/auth/token-info" ],
          "postprocessing_hint" : "Persist issuer and audience client-side for token verification before invoking /auth/okta/login.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/token-info" : {
      "get" : {
        "summary" : "Get auth info for the request bearer token.",
        "operationId" : "AuthResource_tokenInfo",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TokenInfoReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the current bearer token to derive username, roles and expiry.",
          "usage" : [ "Call immediately after successful login to cache session metadata", "Re-run when showing account settings to refresh expiry information" ],
          "response_shape" : "TokenInfoReply",
          "failure_modes" : [ "401 if the bearer token is missing or invalid" ],
          "error_handling" : [ {
            "code" : "401",
            "action" : "Trigger a re-login flow and clear stale session cookies."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Session inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/logout", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Persist expiry and provider IDs locally so subsequent calls are avoided.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients" : {
      "get" : {
        "summary" : "List all currently connected CephFS clients.",
        "operationId" : "CephFsListingResource_listCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephfsClientInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the active CephFS clients reported by the MDS.",
          "usage" : [ "Show currently connected clients in admin dashboards", "Refresh on demand when diagnosing stuck sessions" ],
          "response_shape" : "OptionalPaginationResponse<CephfsClientInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or sort client entries.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "400 if ceph status cannot be fetched" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Display an error banner and recommend checking Ceph health."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Client inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/clients/evict", "/stats" ],
          "postprocessing_hint" : "Highlight clients with stale sessions (zero age) before allowing eviction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients/evict" : {
      "post" : {
        "summary" : "Evict (kick) a connected client, the client can reconnect but must do so explicitly.",
        "operationId" : "CephFsListingResource_evictCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "description" : "ID of the client to evict",
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int64"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/copy" : {
      "put" : {
        "summary" : "Copy a file or directory recursively.",
        "operationId" : "CephFsListingResource_copyCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/create-directory" : {
      "post" : {
        "summary" : "Create a new directory recursively.",
        "operationId" : "CephFsListingResource_createCephFsDirectory",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsNewDirectoryRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/delete" : {
      "delete" : {
        "summary" : "Delete files or directories recursively.",
        "operationId" : "CephFsListingResource_deleteCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "deleteSnapshots",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/download" : {
      "get" : {
        "summary" : "Download a file.",
        "operationId" : "CephFsListingResource_downloadCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate a download token for a CephFS file and stream its content.",
          "usage" : [ "Invoke when the user requests to download a file", "Do not poll; each request creates a fresh download token" ],
          "response_shape" : "DownloadableObject",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "Absolute CephFS file path to download.",
            "required" : true,
            "example" : "/data/archive.log"
          } ],
          "failure_modes" : [ "400 if the path is not a file", "403 for protected .croit folders", "400 if CephFS is not configured" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Show an error toast and prevent download for directories."
          }, {
            "code" : "403",
            "action" : "Request admin credentials before exposing protected files."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/upload" ],
          "postprocessing_hint" : "Immediately follow the returned download URL; token lifetimes are short.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files" : {
      "patch" : {
        "summary" : "Update or rename a file/directory.",
        "operationId" : "CephFsListingResource_patchCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsFileUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List files in a directory.",
        "operationId" : "CephFsListingResource_listCephFsFiles",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntries"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List directory entries (names only) along with directory metadata.",
          "usage" : [ "Load before rendering a CephFS directory tree", "Refresh after uploads or deletions to update the listing" ],
          "response_shape" : "CephFsDirectoryEntries",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Absolute CephFS path to list (e.g. /, /data/projects).",
            "required" : true,
            "example" : "/"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the dir parameter does not point to a directory", "403 if accessing protected .croit folders as non-admin" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Surface the error and prompt the user to select a valid directory."
          }, {
            "code" : "403",
            "action" : "Inform the user that .croit folders require admin privileges."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files-with-stats", "/cephfs/files-paginated", "/cephfs/download" ],
          "postprocessing_hint" : "Sort entries client-side and merge with stats if needed from /files-with-stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-paginated" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesPaginated",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephFsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate CephFS directory entries with full stats to avoid huge payloads.",
          "usage" : [ "Use in UIs with infinite scroll for large directories", "Request subsequent pages by adjusting pagination.after" ],
          "response_shape" : "PaginationResponse<CephFsResponse>",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Directory path to list.",
            "required" : true,
            "example" : "/data/projects"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset and filters.",
            "required" : true,
            "example" : "{\"limit\":200,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Keep limits <= 500 to avoid timeouts."
          },
          "failure_modes" : [ "400 if CephFS is not configured", "400 if dir is not a directory", "403 for protected .croit folders" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fallback to /files when pagination is not required."
          }, {
            "code" : "403",
            "action" : "Show an authorization error and disable listing."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Paginated directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-with-stats" ],
          "postprocessing_hint" : "Use pagination.after from response to fetch the next chunk.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-with-stats" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesWithStats",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntriesWithStats"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return directory entries together with full CephFS statistics for each item.",
          "usage" : [ "Use when a UI needs size, permissions or type information per entry", "Prefer /files-paginated for very large directories to avoid heavy payloads" ],
          "response_shape" : "CephFsDirectoryEntriesWithStats",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Absolute CephFS path to inspect.",
            "required" : true,
            "example" : "/data"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the target is not a directory", "403 for protected .croit folders" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Suggest fallback to root or a smaller directory."
          }, {
            "code" : "403",
            "action" : "Prompt for admin privileges when accessing .croit paths."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Heavy directory stats"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-paginated" ],
          "postprocessing_hint" : "Gracefully handle entries disappearing during traversal (nulls are skipped).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout" : {
      "put" : {
        "summary" : "Change the pool a file or directory is stored in.",
        "description" : "Files can only be changed if they are empty. Changing a directory only affects new files and subdirectories.",
        "operationId" : "CephFsListingResource_setCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS layout configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsLayout"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the pool a file or directory is stored in.",
        "operationId" : "CephFsListingResource_getCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsLayout"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the pool and namespace layout attributes for a file or directory.",
          "usage" : [ "Call before modifying layout to display current targets", "Use during troubleshooting to confirm where data is stored" ],
          "response_shape" : "CephFsLayout",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "File or directory path to inspect.",
            "required" : true,
            "example" : "/data/logs"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the path is a symbolic link" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Inform the user that symbolic links are not supported and select the target directory instead."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Layout inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cephfs/layout/pools", "/cephfs/layout" ],
          "postprocessing_hint" : "Display null pools as 'default' in UI for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout/pools" : {
      "get" : {
        "summary" : "Get pools that are eligible as data storage location in the layout API.",
        "operationId" : "CephFsListingResource_getPoolsForCephfsLayout",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CephFS data pools that can be assigned via the layout API.",
          "usage" : [ "Populate pool dropdowns when editing directory layouts", "Refresh when filesystem topology changes" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "200 [] when CephFS has no data pools or filesystem not found" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Notify that no data pools are available and CephFS may not be configured."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Layout configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cephfs/layout", "/pools" ],
          "postprocessing_hint" : "Display pool names with human-friendly descriptions from /pools if needed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/move" : {
      "put" : {
        "summary" : "Rename a file or directory.",
        "operationId" : "CephFsListingResource_moveCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/quota" : {
      "put" : {
        "summary" : "Set the quota of a directory.",
        "operationId" : "CephFsListingResource_setCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsQuota"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the quota of a directory.",
        "operationId" : "CephFsListingResource_getCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsQuota"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch byte and file quotas applied to a CephFS directory.",
          "usage" : [ "Display current quota before allowing edits", "Check quota status while troubleshooting capacity issues" ],
          "response_shape" : "CephFsQuota",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Directory path to inspect.",
            "required" : true,
            "example" : "/home/project"
          } ],
          "failure_modes" : [ "400 if the target is not a directory", "400 if CephFS is not configured" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Suggest selecting a directory (not the filesystem root when forbidden)."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Quota inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/quota", "/cephfs/files" ],
          "postprocessing_hint" : "Display null values as 'unlimited'.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/stats" : {
      "post" : {
        "summary" : "Get stats for a list of files.",
        "operationId" : "CephFsListingResource_listCephfsFiles",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "description" : "Absolute paths of the requested files.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/upload" : {
      "put" : {
        "summary" : "Upload a file.",
        "operationId" : "CephFsListingResource_uploadCephFsFile",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsUploadRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests" : {
      "get" : {
        "summary" : "Get all pending change requests.",
        "operationId" : "ChangeRequestResource_getPendingChangeRequests",
        "tags" : [ "change-requests" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ChangeRequest"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/change-requests/{id}/approve" : {
      "post" : {
        "summary" : "Approve a pending change request.",
        "operationId" : "ChangeRequestResource_approveChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests/{id}/reject" : {
      "post" : {
        "summary" : "Reject a pending change request.",
        "operationId" : "ChangeRequestResource_rejectChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_createCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bootstrap a brand-new Ceph cluster using the selected MON disk and IP address.",
          "usage" : [ "Invoke immediately after fetching candidates from GET /cluster/create/mons.", "Monitor the returned ManagedTask via /tasks/{id} until the bootstrap completes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "diskId",
            "in" : "body",
            "description" : "Identifier of the MON-formatted disk (from GET /cluster/create/mons)",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "body",
            "description" : "Server hosting the MON disk",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Management IP address to bind the initial MON",
            "required" : true,
            "example" : "10.0.0.12"
          }, {
            "name" : "ipv6",
            "in" : "body",
            "description" : "Set true when the provided IP is IPv6",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the cluster is already configured", "400 if the selected disk is missing or not MON-capable", "400 if the IP does not match the ipv6 flag" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate disk/server eligibility via GET /cluster/create/mons and ensure the IP belongs to the server before retrying."
          }, {
            "code" : "409",
            "action" : "If concurrent bootstrap is in progress, wait for the existing ManagedTask to finish."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Cluster bootstrap is a one-time operation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/maintenance/migrations" ],
          "postprocessing_hint" : "Persist the returned task id and stream updates from /tasks/{id} until state=FINISHED.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bootstrapping the cluster is destructive if a cluster already exists."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/create/mons" : {
      "get" : {
        "summary" : "List all servers that have a MON disk.",
        "operationId" : "ClusterResource_getMonCandidates",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/InitialMonServer"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List servers eligible to host the initial Ceph MON during cluster bootstrap.",
          "usage" : [ "Call prior to POST /cluster to populate the MON selection UI.", "Refresh after wiping disks or changing roles to see newly eligible servers." ],
          "response_shape" : "array<InitialMonServer>",
          "failure_modes" : [ "200 [] when no disks with role=mon are detected" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Advise the operator to provision mon-formatted disks or rerun disk discovery."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Cluster bootstrap planning"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster", "/disks/create-osds" ],
          "postprocessing_hint" : "Sort by hostname and display both IPv4/IPv6 entries so the installer can choose the correct address.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/deploy" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_deployCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterDeployRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy the initial Ceph monitors using multiple preselected MON disks.",
          "usage" : [ "Call once during bootstrap after validating candidates from GET /cluster/create/mons.", "Track the returned ManagedTask via /tasks/{id} to follow wiping and MON provisioning progress." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "mons[].diskId",
            "in" : "body",
            "description" : "Disk identifier for each MON you want to create.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "mons[].serverId",
            "in" : "body",
            "description" : "Server hosting the disk.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "mons[].ip",
            "in" : "body",
            "description" : "IP address for the MON daemon on that server.",
            "required" : true,
            "example" : "10.0.0.15"
          }, {
            "name" : "mons[].ipv6",
            "in" : "body",
            "description" : "Set true when ip is IPv6.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the cluster is already configured", "400 if no monitors are supplied", "400 if validation detects disks that cannot host a MON" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Re-run GET /cluster/create/mons and adjust the selection; wipe flagged disks when prompted."
          }, {
            "code" : "409",
            "action" : "If another deployment is running, monitor the existing ManagedTask instead of retrying immediately."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Initial deployment should run once"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Store the returned task id and display wiping/installation progress until done.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deploying multiple monitors may wipe disks that contain existing data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/releases" : {
      "get" : {
        "summary" : "Get running Ceph releases",
        "operationId" : "ClusterResource_clusterReleases",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephReleases"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the Ceph release distribution currently running across cluster daemons.",
          "usage" : [ "Call before triggering upgrades to confirm the cluster is homogeneous.", "Poll during migrations to track remaining hosts still on older releases." ],
          "response_shape" : "CephReleases",
          "failure_modes" : [ "500 if Ceph rejected the versions request or returned malformed data" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking Ceph mgr health; include ceph versions stderr in diagnostics if the error persists."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Upgrade monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status", "/maintenance/migrations" ],
          "postprocessing_hint" : "Highlight releases other than the target to communicate remaining upgrade tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status" : {
      "get" : {
        "summary" : "Get croit cluster status",
        "operationId" : "ClusterResource_clusterStatus",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph and croit service health snapshot.",
          "usage" : [ "Call before running Ceph-altering workflows to ensure the cluster is healthy", "Refresh every 10 seconds when rendering live dashboards" ],
          "response_shape" : "ClusterStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure Ceph is configured; if not, expect cephStatus to be null.",
            "post_action" : "Surface warnings or degraded services in the UI."
          },
          "failure_modes" : [ "503 if the croit backend cache is unavailable", "200 with cephStatus=null when Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry with exponential backoff (up to 30s) before alerting operations."
          }, {
            "code" : "200",
            "action" : "Display maintenance banner if cephStatus is null."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared across dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status/detail", "/status" ],
          "postprocessing_hint" : "Cache the response for <=5s client-side to avoid excess load.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/detail" : {
      "get" : {
        "summary" : "Get Ceph health detail.",
        "operationId" : "ClusterResource_clusterHealthDetail",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephStatusHealth"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect detailed Ceph health checks including summaries and explanations.",
          "usage" : [ "Call after detecting warnings in GET /cluster/status", "Use sparingly for drill-down views to reduce payload size" ],
          "response_shape" : "CephHealthDetail",
          "failure_modes" : [ "503 if the Ceph manager is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry up to 3 times with 5 second backoff; inform the user if still unavailable."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Detail view heavy payload"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/mute/{check}" ],
          "postprocessing_hint" : "Limit the number of displayed checks and truncate long detail strings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history" : {
      "get" : {
        "summary" : "List available past cluster state timestamps.",
        "operationId" : "ClusterResource_clusterStatusHistoryEntries",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int64"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available historical snapshots for later retrieval.",
          "usage" : [ "Fetch once to populate a history selector", "Choose the latest timestamp to investigate recent incidents" ],
          "response_shape" : "array<long>",
          "failure_modes" : [ "200 [] when historical cache is empty" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show message that no history is available yet."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Used sparingly when opening timelines"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history/{timestamp}" ],
          "postprocessing_hint" : "Sort timestamps descending before presenting to users.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history/{timestamp}" : {
      "get" : {
        "summary" : "Get cluster state as close as possible to a specific timestamp.",
        "operationId" : "ClusterResource_getClusterPastState",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "description" : "Timestamp as returned by /cluster/status/history",
          "name" : "timestamp",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a cached cluster status snapshot close to the requested time.",
          "usage" : [ "Call after selecting a timestamp from GET /cluster/status/history", "Prefer timestamps not older than 15 minutes for accurate diagnostics" ],
          "response_shape" : "ClusterStatus",
          "path_parameters" : [ {
            "name" : "timestamp",
            "in" : "path",
            "description" : "Epoch seconds returned by GET /cluster/status/history",
            "required" : true,
            "example" : "1700000000"
          } ],
          "failure_modes" : [ "404 if no cached status exists for the requested timestamp", "200 with cephStatus=null when Ceph was unreachable at that time" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fallback to the closest earlier timestamp or notify the user."
          }, {
            "code" : "200",
            "action" : "Warn the user that Ceph data was unavailable at that time."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Timeline exploration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history", "/cluster/status/detail" ],
          "postprocessing_hint" : "Indicate the actual snapshot timestamp compared to the requested value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/mute/{check}" : {
      "post" : {
        "summary" : "Mute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckMute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HealthCheckMuteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Temporarily mute a specific Ceph health check to suppress alerts.",
          "usage" : [ "Call immediately before acknowledging a known issue to keep dashboards quiet.", "Specify ttl when scheduling an automatic unmute; otherwise rely on a manual POST /cluster/status/unmute/{check}." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ttl",
            "in" : "body",
            "description" : "Seconds until the mute automatically expires (0 keeps default behaviour).",
            "required" : false,
            "example" : "3600"
          }, {
            "name" : "sticky",
            "in" : "body",
            "description" : "true to leave the check muted even after Ceph reports it resolved.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check identifier (e.g. OSD_DOWN).",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "400 if ttl is negative", "404 if the health check name is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Clamp ttl to a positive value or set it to 0 to rely on Ceph defaults."
          }, {
            "code" : "404",
            "action" : "List active checks from GET /cluster/status to validate the identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Alert suppression"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/unmute/{check}" ],
          "postprocessing_hint" : "Immediately refresh GET /cluster/status to reflect the muted check.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/status/nagios" : {
      "get" : {
        "summary" : "Get overall Ceph health status formatted for Nagios.",
        "operationId" : "ClusterResource_clusterHealthSummaryForNagios",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose Ceph health in a Nagios-compatible single line format.",
          "usage" : [ "Integrate with external Nagios/icinga style monitors", "Use when plain text status codes are required" ],
          "response_shape" : "text/plain",
          "failure_modes" : [ "200 CEPH CRITICAL - failed to get cluster status when cache missing" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat message containing 'failed to get cluster status' as CRITICAL in the monitoring system."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "External monitoring poll"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios/{check}" ],
          "postprocessing_hint" : "Use first token to determine Nagios state before logging.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/nagios/{check}" : {
      "get" : {
        "summary" : "Get a specific Ceph health check in Nagios text format.",
        "operationId" : "ClusterResource_clusterHealthForNagios",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a Nagios-compatible status line for a specific Ceph health check code.",
          "usage" : [ "Configure Nagios/Icinga service checks for individual Ceph alerts", "Provide targeted status for dashboards that focus on specific health codes" ],
          "response_shape" : "text/plain",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check code, e.g. SLOW_OPS",
            "required" : true,
            "example" : "SLOW_OPS"
          } ],
          "failure_modes" : [ "200 <code> UNKNOWN - cannot get ceph status when cache missing" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Interpret UNKNOWN as CRITICAL in monitoring and retry after 30s."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Per-check polling"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios" ],
          "postprocessing_hint" : "Split first word to extract Nagios state before piping to external tools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/unmute/{check}" : {
      "post" : {
        "summary" : "Unmute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckUnmute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Re-enable a previously muted Ceph health check.",
          "usage" : [ "Call after resolving the underlying issue so alerts resume.", "Use to cancel a sticky mute created via POST /cluster/status/mute/{check}." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Health check identifier to unmute.",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "404 if the check is not known" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the check is currently muted by inspecting GET /cluster/status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Alert management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status/mute/{check}", "/cluster/status" ],
          "postprocessing_hint" : "Trigger a status refresh to confirm the check is now active.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config" : {
      "put" : {
        "summary" : "Set Ceph configuration option",
        "operationId" : "CephConfigResource_setCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all ceph configs.",
        "operationId" : "CephConfigResource_getCephConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete Ceph configuration option",
        "operationId" : "CephConfigResource_deleteCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates" : {
      "get" : {
        "summary" : "List of all templates.",
        "operationId" : "TemplateResource_getTemplates",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseConfigTemplateResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/helpers" : {
      "get" : {
        "summary" : "Get template helpers",
        "operationId" : "TemplateResource_getHelpers",
        "tags" : [ "config-templates" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/templates/{template}" : {
      "put" : {
        "summary" : "Set configuration template",
        "operationId" : "TemplateResource_setTemplate",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Template configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ConfigTemplateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates/templates/{template}/variables" : {
      "get" : {
        "summary" : "Get template variables",
        "operationId" : "TemplateResource_getVariables",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TemplateObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/available" : {
      "get" : {
        "summary" : "Get available Ceph configuration options",
        "operationId" : "CephConfigResource_getAvailableOptions",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/CephConfigResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/availableAsList" : {
      "get" : {
        "summary" : "List available ceph configs.",
        "operationId" : "CephConfigResource_getAvailableOptionsAsList",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/client" : {
      "get" : {
        "summary" : "Download client Ceph configuration file",
        "operationId" : "CephConfigResource_getConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/full" : {
      "get" : {
        "summary" : "Download full Ceph configuration file",
        "operationId" : "CephConfigResource_getFullConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/modified" : {
      "get" : {
        "summary" : "List modified ceph configs.",
        "operationId" : "CephConfigResource_getCephOrCroitConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/rgw-ssl-cert" : {
      "put" : {
        "summary" : "Set RGW SSL certificate",
        "operationId" : "CephConfigResource_setRgwSslCert",
        "tags" : [ "config" ],
        "requestBody" : {
          "description" : "RGW SSL certificate configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSslCertChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW SSL certificate",
        "operationId" : "CephConfigResource_getRgwSslCert",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies" : {
      "get" : {
        "summary" : "List croit app dependencies.",
        "operationId" : "CroitAppResource_getAllDependencies",
        "tags" : [ "croit" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCroitDependency"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies/cyclonedx" : {
      "get" : {
        "summary" : "Download croit app dependencies as CycloneDX SBOM.",
        "operationId" : "CroitAppResource_cyclonedx",
        "tags" : [ "croit" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush" : {
      "post" : {
        "summary" : "Update the current CRUSH map.",
        "operationId" : "CrushResource_setCrushMap",
        "tags" : [ "crush" ],
        "requestBody" : {
          "description" : "CRUSH map update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CrushTree"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ChangeRequest"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current CRUSH map.",
        "operationId" : "CrushResource_getCrushMap",
        "tags" : [ "crush" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CrushTree"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the full CRUSH tree including buckets, hosts, and OSD assignments.",
          "usage" : [ "Call before planning placement rule changes or visualising data distribution.", "Refresh after running ceph osd crush set commands to verify topology updates." ],
          "response_shape" : "CrushTree",
          "failure_modes" : [ "500 if the Ceph cluster rejects the osd tree command" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking manager health; include Ceph stderr in troubleshooting notes."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "CRUSH inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush/rules", "/disks/create-osds", "/pools" ],
          "postprocessing_hint" : "Summarize weight totals per bucket and highlight destroyed OSDs for operators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/destroyed-osd-ids" : {
      "get" : {
        "summary" : "Get list of destroyed OSD IDs",
        "operationId" : "CrushResource_getDestroyedOsdIds",
        "tags" : [ "crush" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DestroyedOsdIds"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/ec-profiles" : {
      "get" : {
        "summary" : "Get all EC profiles.",
        "operationId" : "CrushResource_getEcProfiles",
        "tags" : [ "crush" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/ErasureCodeProfileDump"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/osd/{osdId}/metadata" : {
      "get" : {
        "summary" : "Retrieve OSD metadata, resulting JSON contains runtime information about the OSD and varies by Ceph version.",
        "operationId" : "CrushResource_getOsdMetaData",
        "tags" : [ "crush" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch Ceph-reported metadata for a specific OSD (host, bucket, state, etc.).",
          "usage" : [ "Inspect placement and attributes before migrating or removing an OSD.", "Verify metadata differences after ceph osd metadata commands or crush map edits." ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if the OSD id is unknown", "500 if Ceph rejects the metadata command" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /crush to confirm active OSD ids before retrying."
          }, {
            "code" : "500",
            "action" : "Retry after verifying mgr/osd availability; include command stderr for troubleshooting."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Metadata inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/disks", "/maintenance/osd-full-ratios" ],
          "postprocessing_hint" : "Present key-value pairs grouped by section (e.g., device, network) to improve readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules" : {
      "get" : {
        "summary" : "List CRUSH rules.",
        "operationId" : "CrushResource_getCrushRules",
        "tags" : [ "crush" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCrushRuleResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CRUSH rules with their steps to analyze data placement policies.",
          "usage" : [ "Fetch before assigning rules to pools or creating new ones.", "Compare rules after modifications to ensure parameters match expectations." ],
          "response_shape" : "OptionalPaginationResponse<CrushRuleResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON allowing filtering and sorting by rule name or type.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"type\":{\"_eq\":\"replicated\"}}]}"
          } ],
          "failure_modes" : [ "500 if the Ceph manager rejects the crush rule query" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying Ceph mgr health; include ceph osd crush rule dump output when escalating."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Rule inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/pools", "/crush/rules/simple" ],
          "postprocessing_hint" : "Group replicated vs erasure rules and display chooseleaf steps prominently for operators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/classes" : {
      "get" : {
        "summary" : "List CRUSH device classes.",
        "operationId" : "CrushResource_getCrushRuleClasses",
        "tags" : [ "crush" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/simple" : {
      "post" : {
        "summary" : "Create a simple CRUSH rule.",
        "operationId" : "CrushResource_newSimpleCrushRule",
        "tags" : [ "crush" ],
        "requestBody" : {
          "description" : "Simple CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimpleRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a basic replicated or erasure-coded CRUSH rule targeting a specific bucket/device class.",
          "usage" : [ "Use when onboarding new pools requiring dedicated placement rules.", "Provide deviceClass to avoid mixing drive types in future expansions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "CRUSH rule name to create.",
            "required" : true,
            "example" : "replicated-ssd"
          }, {
            "name" : "startBucket",
            "in" : "body",
            "description" : "Starting bucket (e.g., default root).",
            "required" : true,
            "example" : "default"
          }, {
            "name" : "deviceClass",
            "in" : "body",
            "description" : "Optional target device class such as ssd or hdd.",
            "required" : false,
            "example" : "ssd"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "true to create an EC rule (requires parity/data parameters).",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if device class is blank", "409 if a rule with the same name already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide a non-empty device class or remove the field entirely."
          }, {
            "code" : "409",
            "action" : "Choose a unique rule name or delete the conflicting rule first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule authoring"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/crush" ],
          "postprocessing_hint" : "After creation, associate the rule with a pool and run ceph osd map to verify placement.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating CRUSH rules affects placement decisions for subsequent pools."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/ssdPrimary" : {
      "post" : {
        "summary" : "Create SSD primary CRUSH rule",
        "operationId" : "CrushResource_newSsdPrimaryCrushRule",
        "tags" : [ "crush" ],
        "requestBody" : {
          "description" : "SSD primary CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SsdPrimaryRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/{name}" : {
      "delete" : {
        "summary" : "Delete specified CRUSH rule.",
        "operationId" : "CrushResource_deleteCrushRule",
        "tags" : [ "crush" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an existing CRUSH rule from the cluster.",
          "usage" : [ "Ensure no pools reference the rule before calling this endpoint.", "Perform after migrating pools to alternate rules to keep the CRUSH map tidy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "CRUSH rule name to delete.",
            "required" : true,
            "example" : "replicated-ssd"
          } ],
          "failure_modes" : [ "404 if the rule name does not exist", "409 if Ceph refuses to remove the rule because it is still referenced" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /crush/rules to verify the list before retrying."
          }, {
            "code" : "409",
            "action" : "Reassign any dependent pools to other rules and retry the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/pools" ],
          "postprocessing_hint" : "Dump the CRUSH map to confirm the rule is gone and no orphaned references remain.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing rules impacting pool placement may lead to data movement if referenced inadvertently."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos" : {
      "get" : {
        "summary" : "Retrieve all DAOS configs.",
        "operationId" : "DaosClusterResource_getDaosClusters",
        "tags" : [ "daos" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/SimpleDaosConfig"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS cluster.",
        "operationId" : "DaosClusterResource_createDaosCluster",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/verify" : {
      "post" : {
        "summary" : "Verify if the servers can be used to set up DAOS.",
        "operationId" : "DaosClusterResource_verifyDaosSetup",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation request for verification",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosVerificationResult"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}" : {
      "get" : {
        "summary" : "Retrieve a DAOS cluster by ID.",
        "operationId" : "DaosClusterResource_getDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosConfig"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS cluster.",
        "operationId" : "DaosClusterResource_deleteDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs" : {
      "get" : {
        "summary" : "Retrieve a list of certificates for the DAOS cluster.",
        "operationId" : "DaosCertificateResource_getDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosCertificateResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new client certificate to the DAOS cluster.",
        "operationId" : "DaosCertificateResource_createDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/reparse-expiries" : {
      "post" : {
        "summary" : "Reparse all expiries from the CRT files.",
        "operationId" : "DaosCertificateResource_reparseDaosCertsExpiries",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}" : {
      "patch" : {
        "summary" : "Update a client certificate's name or description.",
        "operationId" : "DaosCertificateResource_updateDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a client certificate from the DAOS cluster. The admin/agent/server and CA certificates cannot be deleted.",
        "operationId" : "DaosCertificateResource_deleteDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/crtFile" : {
      "get" : {
        "summary" : "Download the crt file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCrtFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/daos-configs.{type}" : {
      "get" : {
        "summary" : "Download a tar package containing all necessary files to connect to DAOS with the chosen certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCertPackage",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Download as tar or as zip file.",
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : "zip|tar"
          }
        }, {
          "description" : "Include admin config and certificate files.",
          "name" : "withAdmin",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        }
      }
    },
    "/daos/{daosId}/certs/{certId}/keyFile" : {
      "get" : {
        "summary" : "Download the key file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosKeyFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/container-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available container properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosContainerProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/containers" : {
      "get" : {
        "summary" : "Retrieve all DAOS containers in the cluster.",
        "operationId" : "DaosClusterResource_getAllDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/disks" : {
      "get" : {
        "summary" : "Retrieve all DAOS disks.",
        "operationId" : "DaosDiskResource_getDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPosixDiskResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new DAOS disk.",
        "operationId" : "DaosDiskResource_createDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS disk creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosDiskCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/disks/{daosDiskId}" : {
      "delete" : {
        "summary" : "Remove a DAOS disk.",
        "operationId" : "DaosDiskResource_removeDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosDiskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/members" : {
      "get" : {
        "summary" : "Retrieve member states of the DAOS cluster.",
        "operationId" : "DaosClusterResource_getDaosState",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosSystemMemberResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pool-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available pool properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosPoolProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools" : {
      "get" : {
        "summary" : "List all DAOS pools.",
        "operationId" : "DaosPoolResource_getDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPoolDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS pool.",
        "operationId" : "DaosPoolResource_createDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosPoolRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/simple" : {
      "get" : {
        "summary" : "List all DAOS pools without any query information.",
        "operationId" : "DaosPoolResource_getSimpleDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosPoolResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}" : {
      "get" : {
        "summary" : "Get detailed info on a single pool.",
        "operationId" : "DaosPoolResource_getDaosPoolInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosPoolDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS pool.",
        "operationId" : "DaosPoolResource_deleteDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a DAOS pool from the specified cluster and remove cached metadata.",
          "usage" : [ "Clean up pools that are no longer required before reclaiming storage.", "Recreate pools with different properties after explicitly removing the old instance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID to delete.",
            "required" : true,
            "example" : "8601f8c6-..."
          } ],
          "failure_modes" : [ "404 if the pool cannot be resolved for the given cluster", "500 if the DAOS remove operation fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh DAOS pool listings and retry with a valid identifier."
          }, {
            "code" : "500",
            "action" : "Inspect DAOS server logs; ensure the pool is disconnected from clients before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "DAOS pool deletion"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/reintegrate" ],
          "postprocessing_hint" : "Trigger a DAOS pool cache refresh to update UI listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl" : {
      "post" : {
        "summary" : "Update or add a pool ACL entry.",
        "operationId" : "DaosPoolResource_updatePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the pool ACL.",
        "operationId" : "DaosPoolResource_overwritePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a pool ACL entry.",
        "operationId" : "DaosPoolResource_deletePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl-structured" : {
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/aclFile" : {
      "get" : {
        "summary" : "Get pool ACL file.",
        "operationId" : "DaosPoolResource_getPoolACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers" : {
      "get" : {
        "summary" : "List all DAOS containers with details in a pool.",
        "operationId" : "DaosContainerResource_getDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS container.",
        "operationId" : "DaosContainerResource_createDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS container creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosContainerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/list" : {
      "get" : {
        "summary" : "List all DAOS containers in a pool.",
        "operationId" : "DaosContainerResource_listDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerListResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}" : {
      "get" : {
        "summary" : "Get detailed info on a single container.",
        "operationId" : "DaosContainerResource_getDaosContainerInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS container.",
        "operationId" : "DaosContainerResource_deleteDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Force delete the container.",
          "name" : "force",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl" : {
      "post" : {
        "summary" : "Update or add a container ACL entry.",
        "operationId" : "DaosContainerResource_updateContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the container ACL.",
        "operationId" : "DaosContainerResource_overwriteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a container ACL entry.",
        "operationId" : "DaosContainerResource_deleteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" : {
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" : {
      "get" : {
        "summary" : "Get container ACL file.",
        "operationId" : "DaosContainerResource_getContainerACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/owner" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerOwner",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS container owner request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosContainerOwnerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/props" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container properties.",
        "operationId" : "DaosContainerResource_getContainerProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/props" : {
      "put" : {
        "summary" : "Set a pool property.",
        "operationId" : "DaosPoolResource_setPoolProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool properties.",
        "operationId" : "DaosPoolResource_getPoolProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/reintegrate" : {
      "post" : {
        "summary" : "Reintegrate a DAOS rank, or all ranks available, for a pool.",
        "operationId" : "DaosPoolResource_reintegrateDaosRank",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Rank reintegrate request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RankReintegrateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers" : {
      "post" : {
        "summary" : "Add a server as client to DAOS.",
        "operationId" : "DaosClusterResource_addDaosServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server configuration for DAOS client",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosClientCreationServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from a DAOS cluster.",
        "operationId" : "DaosClusterResource_removeServerFromDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure and restart DAOS on the server.",
        "operationId" : "DaosClusterResource_restartDaosOnServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "DaosClusterResource_testSshConnectionDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/start-ranks" : {
      "post" : {
        "summary" : "Start a list of ranks.",
        "operationId" : "DaosClusterResource_startDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to start",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/stop-ranks" : {
      "post" : {
        "summary" : "Stop a list of ranks.",
        "operationId" : "DaosClusterResource_stopDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to stop",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks" : {
      "get" : {
        "summary" : "List of all disks across all servers.",
        "operationId" : "DiskResource_getAllDisks",
        "tags" : [ "disks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate every discovered disk with hardware, health and role metadata across the fleet.",
          "usage" : [ "Build storage inventory dashboards before drilling into per-server views", "Refresh after provisioning or wiping disks to confirm state changes" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"role\":{\"_in\":[\"osd\",\"journal\"]}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Restrict large clusters to manageable chunks.",
            "pagination.where" : "Filter by role, health or hostname before exporting."
          },
          "failure_modes" : [ "200 [] when no disks match the applied filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an empty state and prompt hardware rescan if disks are expected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Fleet-wide disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/paths" ],
          "postprocessing_hint" : "Highlight disks with missing stats and merge in SMART data where available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/create-osds" : {
      "post" : {
        "summary" : "Create multiple OSDs",
        "operationId" : "DiskResource_createMultipleOsds",
        "tags" : [ "disks" ],
        "requestBody" : {
          "description" : "OSD creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ManagedTask"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision one or more OSD daemons on the specified servers and disks.",
          "usage" : [ "Call after planning OSD placement; chunk large batches per server to keep tasks manageable.", "Monitor each returned ManagedTask to verify disk wiping, ceph-volume, and CRUSH integration steps." ],
          "response_shape" : "array<ManagedTask>",
          "request_parameters" : [ {
            "name" : "osds[].serverId",
            "in" : "body",
            "description" : "Server that will host the new OSD.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "osds[].diskId",
            "in" : "body",
            "description" : "Disk identifier selected for OSD creation.",
            "required" : true,
            "example" : "345"
          }, {
            "name" : "osds[].encrypted",
            "in" : "body",
            "description" : "true to enable dm-crypt for the OSD.",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "osds[].reuseOsdId",
            "in" : "body",
            "description" : "Optional existing OSD id to reuse when replacing disks.",
            "required" : false,
            "example" : "112"
          } ],
          "failure_modes" : [ "400 if crushDeviceClass contains whitespace", "400 if validation of journaling or encryption prerequisites fails", "500 if ceph-volume or hardware detection encounters fatal errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize request payload (e.g. remove spaces from device classes) and retry."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs for failing disks; rerun create-osds only for failed entries after remediation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Resource-intensive provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/replace-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Display one task per server; surface WARN logs for disks requiring manual cleanup.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating OSDs wipes disks and alters CRUSH topology."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/install-croit" : {
      "post" : {
        "summary" : "Install croit to disks.",
        "operationId" : "DiskResource_installCroitToDisk",
        "tags" : [ "disks" ],
        "requestBody" : {
          "description" : "Disk installation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/InstallCroitRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Install the croit management image onto selected boot disks across one or more servers.",
          "usage" : [ "Deploy croit onto fresh hardware before adding the servers to the cluster.", "Reinstall the management stack after wiping or replacing boot drives." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "disks[].server",
            "in" : "body",
            "description" : "Server ID hosting the disk.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "disks[].disk",
            "in" : "body",
            "description" : "Disk ID to receive the croit installation.",
            "required" : true,
            "example" : "145"
          }, {
            "name" : "disks[].serial",
            "in" : "body",
            "description" : "Disk serial for confirmation.",
            "required" : true,
            "example" : "S3X4ABCD"
          }, {
            "name" : "disks[].destroy",
            "in" : "body",
            "description" : "true to destroy existing OSD metadata when reusing disks.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the request is empty, contains duplicates, or disks are too small/in use", "400 if container switching is required but not allowed in offline mode", "200 ManagedTask(status=FAILED) if installation steps fail on a subset of disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure disks are unassigned, online, and meet size requirements; wipe them if necessary."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to identify failed hosts and rerun only for those disks."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Boot disk installation"
          },
          "related_endpoints" : [ "/disks/wipe", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "After the task succeeds, reboot the servers from the freshly installed disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/paths" : {
      "get" : {
        "summary" : "List of all known multipath disk paths across all servers.",
        "operationId" : "DiskResource_getAllDiskPaths",
        "tags" : [ "disks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDiskPathResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect multipath device paths and their states across all servers.",
          "usage" : [ "Check path health when diagnosing disk or fabric issues", "Filter by inactive paths before dispatching remediation tasks" ],
          "response_shape" : "PaginationResponse<DiskPathResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sorting and filters.",
            "required" : false,
            "example" : "{\"where\":[{\"active\":{\"_eq\":false}}]}"
          } ],
          "failure_modes" : [ "200 [] when no multipath devices exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an informational banner that no multipath data is available."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipath inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/disks", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Group entries by diskId and surface inactive paths prominently.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/replace-osds" : {
      "post" : {
        "summary" : "Replace an OSDs by creating one on another disk.",
        "operationId" : "DiskResource_replaceOsds",
        "tags" : [ "disks" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReplaceOsdsRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace existing OSDs by provisioning new instances on different disks, carrying over metadata where possible.",
          "usage" : [ "Run when disks fail and need to be replaced with new hardware.", "Use resizeOsd=true to reweigh the OSD after moving it to a larger disk." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "osds[].osd",
            "in" : "body",
            "description" : "ID of the OSD being replaced.",
            "required" : true,
            "example" : "112"
          }, {
            "name" : "osds[].disk",
            "in" : "body",
            "description" : "Disk ID that will host the new OSD.",
            "required" : true,
            "example" : "456"
          }, {
            "name" : "osds[].keepDbWal",
            "in" : "body",
            "description" : "true to reuse existing DB/WAL devices; set false and provide dbDisk/walDisk to move journals.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "osds[].resizeOsd",
            "in" : "body",
            "description" : "Reweigh the OSD according to the new disk size.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if OSDs or disks appear multiple times in the request", "400 if the prior DB/WAL configuration cannot be determined when keepDbWal=true", "500 if ceph-volume creation fails on the new disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Deduplicate the request payload and explicitly provide DB/WAL disks when required."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask logs for failing steps; rerun only for the OSDs that did not complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Disk replacement workload"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/create-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Review warnings emitted in the ManagedTask to address multi-disk or journal ambiguities.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Replacing OSDs wipes disks and reconfigures CRUSH mappings."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/wipe" : {
      "delete" : {
        "summary" : "Wipe disks on servers.",
        "operationId" : "DiskResource_wipeDisksRequest",
        "tags" : [ "disks" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskDeleteRequestWrapper"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Securely wipe one or more disks, optionally destroying associated OSDs in the cluster map.",
          "usage" : [ "Prepare disks for reuse after removing OSDs or other data.", "Clean drives prior to decommissioning hardware from the cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "disks[].server",
            "in" : "body",
            "description" : "Server ID hosting the disk.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "disks[].disk",
            "in" : "body",
            "description" : "Disk ID to wipe.",
            "required" : true,
            "example" : "145"
          }, {
            "name" : "disks[].serial",
            "in" : "body",
            "description" : "Serial confirmation string to avoid wiping the wrong disk.",
            "required" : true,
            "example" : "S3X4ABCD"
          }, {
            "name" : "disks[].destroy",
            "in" : "body",
            "description" : "true to remove the OSD from the CRUSH map after wiping.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the request is empty, contains duplicates, or serial numbers do not match", "400 if any disk is boot media or in use by DAOS", "200 ManagedTask(status=FAILED) if wiping fails on a subset of disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate disk ownership, serial numbers, and DAOS usage before retrying."
          }, {
            "code" : "200",
            "action" : "Inspect task logs to identify disks that failed and rerun the wipe for those drives only."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 3600,
            "note" : "Disk wiping"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/create-osds", "/tasks" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion and run hardware detection to confirm disks are blank.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}" : {
      "delete" : {
        "summary" : "Delete disk",
        "operationId" : "DiskResource_deleteDiskWithoutServerId",
        "tags" : [ "disks" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk entry from the inventory, typically after permanent removal or decommissioning.",
          "usage" : [ "Call after detaching hardware or replacing a disk so it no longer appears in inventory.", "Use only when the disk is not referenced by DAOS or active OSDs." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "Identifier of the disk from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "400 if the disk is still referenced by DAOS", "404 if the disk id is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Detach the disk from DAOS engines or update DAOS mappings before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh disk lists to confirm the identifier and retry if necessary."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Inventory cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks", "/disks/create-osds", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Refresh GET /disks or /servers/{id}/disks to confirm the entry is gone.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}/benchmark/basic" : {
      "post" : {
        "summary" : "Benchmark disk performance",
        "operationId" : "DiskResource_benchmarkDisk",
        "tags" : [ "disks" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a basic synchronous write benchmark on an unassigned disk to measure worst-case journal throughput.",
          "usage" : [ "Evaluate new disks before assigning them to critical roles (journals/DB).", "Collect performance metrics for hardware surveys or troubleshooting." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "404 if the disk or server no longer exists", "400 if the disk is assigned or has partitions/mountpoints", "200 ManagedTask(status=FAILED) if fio or SSH commands fail during the benchmark" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the disk is unassigned, unmounted, and wiped before benchmarking."
          }, {
            "code" : "200",
            "action" : "Review task logs for fio/SSH failures, correct the issue, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Disk benchmarking"
          },
          "related_endpoints" : [ "/disks", "/servers/{id}/disks", "/disks/install-croit" ],
          "postprocessing_hint" : "Capture the ManagedTask output for archival or hardware survey submissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/download/{token}/{fileName}" : {
      "get" : {
        "summary" : "Download file by token",
        "operationId" : "DownloadResource_download",
        "parameters" : [ {
          "name" : "fileName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "token",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/events/hook-scripts" : {
      "get" : {
        "summary" : "List all script files with their linked hooks.",
        "operationId" : "EventResource_getScriptsWithHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseScriptInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file and link hooks.",
        "operationId" : "EventResource_createScriptAndLinkHooks",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hook-scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file and linked hooks.",
        "operationId" : "EventResource_replaceScriptAndHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks" : {
      "get" : {
        "summary" : "List of all installed hook scripts.",
        "deprecated" : true,
        "operationId" : "EventResource_getHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHookInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_createHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks/hook-points" : {
      "get" : {
        "summary" : "List of all available hook points.",
        "operationId" : "EventResource_getHookPoints",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/HookPointInfo"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/events/hooks/{id}" : {
      "patch" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_updateHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a hook event.",
        "deprecated" : true,
        "operationId" : "EventResource_deleteHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts" : {
      "get" : {
        "summary" : "List all script files.",
        "deprecated" : true,
        "operationId" : "EventResource_getScripts",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseScriptIdentifier"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_createScript",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/execute" : {
      "post" : {
        "summary" : "Run a script immediately.",
        "operationId" : "EventResource_runHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script execution configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RunScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_replaceScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the script file contents.",
        "operationId" : "EventResource_getScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a script file.",
        "operationId" : "EventResource_deleteScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/extra-files-secure/{path}" : {
      "get" : {
        "summary" : "Authenticated static file server for files stored in /config/extra-files-secure, requires a croit account with the SECURE_FOLDER role.",
        "operationId" : "ExtraFileSecureResource_downloadSecureExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/extra-files/{path}" : {
      "get" : {
        "summary" : "Publicly accessible static file server for files stored in /config/extra-files.",
        "operationId" : "ExtraFileResource_downloadExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/gateways/iscsi" : {
      "get" : {
        "summary" : "List all iSCSI gateways.",
        "operationId" : "IscsiGatewayResource_getIscsiGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured iSCSI gateway clusters and descriptive metadata.",
          "usage" : [ "Call when rendering the iSCSI gateway overview page.", "Refresh after edits to confirm descriptions and service IDs." ],
          "response_shape" : "PaginationResponse<IscsiGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":25,\"where\":[{\"description\":{\"_ilike\":\"%prod%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":25,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.order.description" : "Sort stable lists of gateways for operators."
          },
          "failure_modes" : [ "200 data=[] when no iSCSI gateways exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Guide users to create an iSCSI gateway via POST /gateways/iscsi."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/servers", "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Render serviceId prominently so follow-up calls can reference it.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/disks" : {
      "get" : {
        "summary" : "List all iSCSI disks.",
        "operationId" : "IscsiGatewayResource_getIscsiDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayDisksResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the list of iSCSI-exposed RBD LUNs with group/host usage details.",
          "usage" : [ "Call when showing which RBD images are exported over iSCSI.", "Refresh after mapping or unmapping LUNs to confirm group/host assignments." ],
          "response_shape" : "PaginationResponse<IscsiGatewayDisksResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"image\":{\"_ilike\":\"%db%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no LUNs are mapped" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying iSCSI gateway pods and Ceph manager logs."
          }, {
            "code" : "200",
            "action" : "Explain that no iSCSI disks are currently exported."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Highlight disks with empty groups to spot unused exports quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/groups" : {
      "get" : {
        "summary" : "List all iSCSI groups.",
        "operationId" : "IscsiGatewayResource_getIscsiGroups",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayGroupsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve iSCSI initiator groups with their members and mapped LUNs.",
          "usage" : [ "Load before editing group memberships or presenting access summaries.", "Refresh after changes to the iSCSI gateway config to confirm group composition." ],
          "response_shape" : "PaginationResponse<IscsiGatewayGroupsResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"group\":{\"_ilike\":\"%db%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no groups are defined" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry with exponential backoff and inspect Ceph iSCSI gateway logs."
          }, {
            "code" : "200",
            "action" : "Indicate that no initiator groups are present currently."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI config snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/hosts", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Group response entries by serviceId and surface luns list so UI can expand per group.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/hosts" : {
      "get" : {
        "summary" : "List all iSCSI hosts.",
        "operationId" : "IscsiGatewayResource_getIscsiHosts",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayHostsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate iSCSI hosts, their credentials, group membership, and attached LUNs.",
          "usage" : [ "Fetch when displaying host access configuration or auditing CHAP credentials.", "Refresh after modifying hosts/groups to verify the resulting mappings." ],
          "response_shape" : "PaginationResponse<IscsiGatewayHostsResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"group\":{\"_eq\":\"production\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no hosts are configured" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking iSCSI gateway daemons; include stderr in support logs."
          }, {
            "code" : "200",
            "action" : "Explain that no hosts have been created yet."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI host snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Mask passwords when presenting to users lacking admin privileges; rely on username and luns for detail.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/servers" : {
      "get" : {
        "summary" : "List all iSCSI servers.",
        "operationId" : "IscsiGatewayResource_getIscsiServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Show iSCSI target services mapped to servers including health state and addresses.",
          "usage" : [ "Fetch when presenting the iSCSI server list so operators can verify IP and health.", "Re-query after modifying gateway services or Ceph config to validate deployment." ],
          "response_shape" : "PaginationResponse<IscsiGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter down to unhealthy targets for remediation.",
            "pagination.order.hostname" : "Keep server ordering predictable across refreshes."
          },
          "failure_modes" : [ "500 if fetching iSCSI configuration from Ceph fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking Ceph manager health; fall back to service logs for details."
          }, {
            "code" : "200",
            "action" : "If the list is empty, confirm that gateway services are deployed."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "iSCSI server status polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi", "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Cross-reference config.gateways from Ceph to highlight servers known to Ceph but missing in croit.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs" : {
      "get" : {
        "summary" : "List all nfs clusters.",
        "operationId" : "NfsGatewayResource_getNfsGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate configured NFS gateway clusters and their base configuration.",
          "usage" : [ "Call to populate the NFS gateway overview before drilling into servers or exports.", "Refresh after creating or editing a gateway to verify forceSecure and transport defaults." ],
          "response_shape" : "PaginationResponse<NfsGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":25,\"where\":[{\"forceSecure\":{\"_eq\":true}}]}).",
            "required" : false,
            "example" : "{\"limit\":25,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS before attaching hosts.",
            "pagination.order.description" : "Sort consistently for large environments."
          },
          "failure_modes" : [ "200 data=[] when no NFS gateways are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display guidance on how to create an NFS gateway cluster."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs/servers", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Surface entries with non-empty hints first so admins notice configuration issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/exports" : {
      "get" : {
        "summary" : "List all nfs exports.",
        "operationId" : "NfsGatewayResource_getNfsExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayExportResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NFS exports, paths, and client permissions for all clusters.",
          "usage" : [ "Call before presenting export configuration so ACLs and protocols are visible.", "Refresh after creating, patching, or deleting exports to confirm the resulting state." ],
          "response_shape" : "PaginationResponse<NfsGatewayExportResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"serviceId\":{\"_eq\":1}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.serviceId" : "Limit exports to a single gateway before editing.",
            "pagination.where.path" : "Search for exports pointing at specific CephFS directories."
          },
          "failure_modes" : [ "200 data=[] when no exports exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a prompt describing how to create exports via POST /gateways/nfs/exports."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS export inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/servers" ],
          "postprocessing_hint" : "Group results by serviceId and display accessJoined for quick ACL review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/servers" : {
      "get" : {
        "summary" : "List all nfs servers.",
        "operationId" : "NfsGatewayResource_getNfsServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NFS gateway services per server including health information.",
          "usage" : [ "Fetch when rendering the NFS server table to expose hostnames, IPs and health.", "Re-query after restarting services or adjusting HA settings to confirm status changes." ],
          "response_shape" : "PaginationResponse<NfsGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy entries for alerting.",
            "pagination.order.hostname" : "Keep server order stable across refreshes."
          },
          "failure_modes" : [ "200 data=[] when no NFS gateway services are registered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no servers are mapped to the selected gateway yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS server status refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Highlight servers with healthy=false or missing IPs so admins can remediate quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof" : {
      "get" : {
        "summary" : "List all NVMe-oF clusters.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFGatewayResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF gateway clusters including transport defaults and configuration hints.",
          "usage" : [ "Call before displaying the NVMe-oF overview dashboard.", "Refresh after task-based changes (e.g. add/delete gateway) to confirm state and surface hints." ],
          "response_shape" : "PaginationResponse<NvmeOFGatewayResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":20,\"where\":[{\"forceSecure\":{\"_eq\":true}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS.",
            "pagination.order.name" : "Keep cluster ordering stable for operators."
          },
          "failure_modes" : [ "500 if NVMe-oF service status refresh fails", "200 data=[] when no NVMe-oF clusters exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting nvmeof-target tasks; include configurator logs for support."
          }, {
            "code" : "200",
            "action" : "Explain that no NVMe-oF clusters are configured yet and reference POST /gateways/nvmeof."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF gateway inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Flag gateways with non-empty hints to prompt admins to run remediation tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters" : {
      "post" : {
        "summary" : "Add a new NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_setNvmeOFCephCluster",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all NVMe-oF ceph cluster configurations.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFCephClusters",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFCephClusterResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters/{name}" : {
      "delete" : {
        "summary" : "Remove a NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFCephCluster",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks" : {
      "get" : {
        "summary" : "List all NVMe-oF disks.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF disks (Ceph RBD or DAOS) with identifiers, size, hints, and subsystem memberships.",
          "usage" : [ "Fetch before attaching disks to subsystems or auditing exported storage.", "Refresh after provisioning tasks to confirm image size lookups and DAOS metadata resolved without errors." ],
          "response_shape" : "PaginationResponse<NvmeOFDiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":2}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter to CEPH or DAOS disks depending on workflow.",
            "pagination.where.subsystems" : "Identify disks already attached to specific subsystems."
          },
          "failure_modes" : [ "500 if Ceph/DAOS metadata queries fail", "200 data=[] when no NVMe-oF disks are defined" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after confirming Ceph/DAOS connectivity; inspect hints array for partial failures."
          }, {
            "code" : "200",
            "action" : "Inform the user that no disks are exported yet."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Draw attention to entries with non-empty hints to highlight disks that need remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_addNvmeOFBdev",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NVMe-oF disk backed by either a Ceph RBD image or a DAOS object.",
          "usage" : [ "Expose a freshly created RBD image to NVMe-oF hosts via selected subsystems.", "Attach an existing DAOS disk to NVMe-oF after validating cluster prerequisites." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "type",
            "in" : "body",
            "description" : "NVMe-oF backend type: CEPH or DAOS.",
            "required" : true,
            "example" : "CEPH"
          }, {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "Gateway cluster ID hosting the disk.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subsystems[]",
            "in" : "body",
            "description" : "Subsystem IDs to attach immediately.",
            "required" : true,
            "example" : "[12]"
          }, {
            "name" : "pool/image",
            "in" : "body",
            "description" : "Ceph pool and RBD image (required for CEPH type).",
            "required" : false,
            "example" : "pool=nvme,image=lun01"
          }, {
            "name" : "daosDisk/daosId",
            "in" : "body",
            "description" : "Either reference an existing DAOS disk or provide DAOS cluster + pool/container info.",
            "required" : false,
            "example" : "daosDisk=42"
          }, {
            "name" : "blockSize",
            "in" : "body",
            "description" : "Block size in bytes (required for DAOS and optional override for CEPH).",
            "required" : false,
            "example" : "4096"
          } ],
          "failure_modes" : [ "400 if namespaces are supplied, required fields are missing, or validation checks fail (e.g. DAOS disk attached to multiple subsystems)", "404 if the gateway, subsystem, DAOS disk, or NIC references do not exist", "200 ManagedThreadTask(status=FAILED) if nvmeof-target reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the payload (remove namespace, supply mandatory fields, ensure blockSize is 512-aligned) and retry."
          }, {
            "code" : "404",
            "action" : "Refresh NVMe-oF inventories to pick valid IDs before resubmitting."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedThreadTask log and NVMe-oF configurator output, fix host issues, then rerun the task."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk provisioning"
          },
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/disks to confirm the disk appears with the expected subsystem bindings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_updateNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an NVMe-oF disk and propagate changes to the backing storage (Ceph RBD or DAOS).",
          "usage" : [ "Expand a Ceph-backed NVMe-oF LUN after increasing the application quota.", "Grow DAOS-backed exports once additional capacity has been provisioned." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "New size in bytes; omit to leave the disk unchanged.",
            "required" : false,
            "example" : "549755813888"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "200 null when no size is provided (no-op)", "400 if attempting to shrink a DAOS-backed disk", "500 if underlying Ceph/DAOS resize commands fail" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Provide a new size to trigger a resize."
          }, {
            "code" : "400",
            "action" : "Detach the disk from NVMe-oF and adjust it within DAOS before attempting to shrink."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedThreadTask log and storage backends; fix the issue then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk resize"
          },
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/disks/{diskId}", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDiskRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an NVMe-oF disk from the gateway, optionally deleting the backing RBD image.",
          "usage" : [ "Retire LUNs no longer needed by clients.", "Remove test disks while optionally cleaning up Ceph data." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "Set true to delete the underlying RBD image.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if the disk ID does not exist", "500 if gateway reconfiguration or Ceph deletion fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List NVMe-oF disks to verify the ID before retrying."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target and Ceph logs; clean up partially removed resources before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services/{serviceId}/transports/{type}", "/gateways/nvmeof/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts" : {
      "get" : {
        "summary" : "List all NVMe-oF hosts.",
        "operationId" : "NvmeOFHostResource_getNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFHostResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF hosts (NQNs) with shared key status, subsystem memberships, and attached disks.",
          "usage" : [ "Fetch when auditing NVMe-oF access or before attaching hosts to subsystems.", "Refresh after task-managed host changes to confirm shared key masking and assignments." ],
          "response_shape" : "PaginationResponse<NvmeOFHostResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":3}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.hasSharedKey" : "Identify hosts that require TLS PSK enrollment.",
            "pagination.where.subsystems" : "Filter hosts attached to specific subsystems before detaching."
          },
          "failure_modes" : [ "500 if host data cannot be retrieved", "200 data=[] when no NVMe-oF hosts exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting nvmeof-target logs; ensure configurator finished running."
          }, {
            "code" : "200",
            "action" : "Inform the user that no hosts are registered with the gateway yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF host inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Mask sharedKey unless the actor has admin privileges; rely on hasSharedKey for UX cues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_addNvmeOFHost",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts/{hostId}" : {
      "put" : {
        "summary" : "Update an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_updateNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF host update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_removeNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/listeners" : {
      "get" : {
        "summary" : "List all NVMe-oF listeners.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFListeners",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFListenerConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate NVMe-oF listeners across services including NIC, VLAN, port and TLS settings.",
          "usage" : [ "Call when displaying listener configuration to operators or ahead of network audits.", "Refresh after adding/removing listeners to confirm the configurator committed changes." ],
          "response_shape" : "PaginationResponse<NvmeOFListenerConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"type\":{\"_eq\":\"TCP\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.gatewayId" : "Filter listeners to a specific cluster before editing.",
            "pagination.where.secure" : "Identify listeners that already enforce TLS."
          },
          "failure_modes" : [ "500 if the DAO cannot retrieve listeners", "200 data=[] when no listeners are present" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking nvmeof-target tasks; resync the gateway if errors persist."
          }, {
            "code" : "200",
            "action" : "Inform the user that no listeners are defined yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof" ],
          "postprocessing_hint" : "Display nicName and vlan to align network automation with listener placement.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/services" : {
      "get" : {
        "summary" : "List all NVMe-oF services.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF target services per server with hugepage config, NIC bindings, and errors.",
          "usage" : [ "Fetch when reviewing NVMe-oF deployment health to inspect service-level hints.", "Poll after task-managed changes (add/remove service, update listeners) to confirm the configurator applied updates." ],
          "response_shape" : "PaginationResponse<NvmeOFServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"gatewayId\":{\"_eq\":5}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.error" : "Filter services with outstanding configurator hints.",
            "pagination.order.serverHostname" : "Maintain ordering by host for easier comparisons."
          },
          "failure_modes" : [ "500 if NVMe-oF configurator fails to refresh service status", "200 data=[] when no services exist for the selected gateways" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking nvmeof-target logs; do not proceed with automation until status refresh succeeds."
          }, {
            "code" : "200",
            "action" : "Warn that no services are currently configured for these gateways."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF service health"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Highlight entries with non-null error or mismatched nrHugepages to prompt corrective actions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/subsystems" : {
      "get" : {
        "summary" : "List all NVMe-oF subsystems.",
        "operationId" : "NvmeOFSubsystemResource_getNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFSubsystemResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF subsystems with host and disk membership metadata.",
          "usage" : [ "Fetch before presenting subsystem details or attaching hosts/disks.", "Refresh after task operations (attach/detach) to validate membership state." ],
          "response_shape" : "PaginationResponse<NvmeOFSubsystemResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":4}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.hosts" : "Filter subsystems that already expose to specific hosts.",
            "pagination.where.disks" : "Identify subsystems using a particular disk ID."
          },
          "failure_modes" : [ "500 if subsystem data cannot be retrieved", "200 data=[] when no subsystems exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after ensuring nvmeof-target configuration succeeded; review configurator logs."
          }, {
            "code" : "200",
            "action" : "Communicate that no subsystems are defined yet and point to POST /gateways/nvmeof/subsystems."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF subsystem inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Expose hostsFormatted and disksFormatted so UIs can show readable membership chips.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_addNvmeOFSubsystem",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_updateNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Subsystem update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_removeNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" : {
      "post" : {
        "summary" : "Attach disks to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Disk attachment configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-hosts" : {
      "post" : {
        "summary" : "Attach hosts to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-disks" : {
      "post" : {
        "summary" : "Detach disks from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-hosts" : {
      "post" : {
        "summary" : "Detach hosts from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}" : {
      "patch" : {
        "summary" : "Update name or description of an NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an NVMe-oF cluster. This also deletes all services and configuration associated with the cluster.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF service configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure the NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_reconfigureNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "fromScratch",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NVMe-oF service metadata, ANA state, transports, listeners, or hugepage settings.",
          "usage" : [ "Modify service parameters after hardware or configuration changes.", "Adjust ANA state or listener definitions as part of maintenance." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional user-facing description for the service.",
            "required" : false,
            "example" : "NVMe-oF target on node12"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "Desired hugepage allocation for the server.",
            "required" : false,
            "example" : "4096"
          }, {
            "name" : "anaState",
            "in" : "body",
            "description" : "ANA state to apply to all listeners.",
            "required" : false,
            "example" : "optimized"
          }, {
            "name" : "transports",
            "in" : "body",
            "description" : "Full list of transport configs to replace existing ones.",
            "required" : false,
            "example" : "[{\"type\":\"TCP\",\"maxIoSize\":1048576}]"
          }, {
            "name" : "listeners",
            "in" : "body",
            "description" : "Listener definitions to overwrite current configuration.",
            "required" : false,
            "example" : "[{\"type\":\"TCP\",\"nicId\":101,\"port\":4420}]"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if requested ANA state is invalid or listeners reference unsupported NICs", "404 if the gateway or service ID is unknown", "500 if nvmeof-target reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate requested parameters against cluster policy (forceSecure, NIC availability)."
          }, {
            "code" : "404",
            "action" : "Refresh the service list and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve errors, then resubmit the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF service reconfiguration"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to ensure updated settings are reflected before proceeding.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/errors" : {
      "delete" : {
        "summary" : "Forget any config errors associated with this service.",
        "operationId" : "NvmeOFGatewayResource_forgetNvmeOFConfigErrors",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clear cached NVMe-oF service configuration errors after they have been addressed.",
          "usage" : [ "Call once operators have fixed the reported misconfiguration and want the dashboard to reset.", "Use to acknowledge resolved errors before triggering a fresh service rescan." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID whose error cache should be cleared.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the service record no longer exists" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service list; recreate the service if it was deleted."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF error acknowledgements"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/services to confirm the error array is empty.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" : {
      "post" : {
        "summary" : "Add a new listener to an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NVMe-oF listener bound to a specific NIC/VLAN for a target service.",
          "usage" : [ "Call when onboarding new fabrics or scaling out access points for an NVMe-oF service.", "Use right after provisioning additional NICs to expose the service on the new network segment." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "body.type",
            "in" : "body",
            "description" : "Transport type (TCP, RDMA, etc.).",
            "required" : true,
            "example" : "TCP"
          }, {
            "name" : "body.nicId",
            "in" : "body",
            "description" : "NIC ID to bind the listener to.",
            "required" : true,
            "example" : "101"
          }, {
            "name" : "body.vlanId",
            "in" : "body",
            "description" : "Optional VLAN ID for tagged listeners.",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "body.port",
            "in" : "body",
            "description" : "Override port; null falls back to cluster default.",
            "required" : false,
            "example" : "4420"
          }, {
            "name" : "body.secure",
            "in" : "body",
            "description" : "Set true to request TLS, subject to cluster policy.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if NIC validation fails or the request would break security policy", "404 if the gateway or service ID is invalid", "500 if nvmeof-target configuration fails during apply" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify the NIC belongs to the service server and adjust VLAN/security settings."
          }, {
            "code" : "404",
            "action" : "Refresh services/listeners lists and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target logs on the host, resolve errors, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 600,
            "note" : "NVMe-oF listener creation"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/listeners to verify the listener appears with the expected NIC/VLAN.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF listener's configuration.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust port or TLS settings for an existing NVMe-oF listener.",
          "usage" : [ "Modify listener ports during maintenance without recreating the listener.", "Enable or disable TLS when policy changes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "port",
            "in" : "body",
            "description" : "Optional port override; null keeps the existing value.",
            "required" : false,
            "example" : "4420"
          }, {
            "name" : "secure",
            "in" : "body",
            "description" : "Optional TLS flag.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID owning the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier to update.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if enabling TLS violates cluster security restrictions", "404 if the gateway/service/listener combination is invalid", "500 if nvmeof-target fails to reconfigure the listener" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Respect forceSecure policy and ensure TLS prerequisites are met."
          }, {
            "code" : "404",
            "action" : "Refresh listener inventory and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve errors, then rerun the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF listener updates"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/listeners to confirm new port/TLS state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a listener from an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NVMe-oF listener so the service stops exposing that network endpoint.",
          "usage" : [ "Call during listener maintenance (e.g. decommissioning a NIC or VLAN).", "Use ahead of recreating the listener with new parameters to avoid duplicate bindings." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Target service that owns the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier as returned by the listeners API.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the gateway, service, or listener cannot be found", "500 if nvmeof-target fails to reconfigure after removal" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh listeners for the service to obtain current IDs, then retry."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target tasks on the server and rerun once they finish successfully."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Refresh GET /gateways/nvmeof/listeners to ensure the listener ID disappears.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports/{type}" : {
      "delete" : {
        "summary" : "Delete a transport configuration.",
        "operationId" : "NvmeOFGatewayResource_deleteTransportConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a custom NVMe-oF transport configuration so the service falls back to cluster defaults.",
          "usage" : [ "Call after reverting transport tuning or decommissioning a transport type from the service.", "Use before recreating the transport with new parameters to avoid conflicting overrides." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "Numeric identifier of the NVMe-oF gateway cluster.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Internal service ID within the gateway.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Transport to remove (TCP, RDMA, etc.).",
            "required" : true,
            "example" : "TCP"
          } ],
          "failure_modes" : [ "404 if the gateway or service ID is invalid", "500 if the gateway fails to reconfigure after deleting the transport" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the NVMe-oF service list and verify you are using current IDs before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve deployment issues, then rerun the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF transport removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to confirm the service no longer lists the transport override.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/smb" : {
      "get" : {
        "summary" : "List all SMB clusters with their config.",
        "operationId" : "SmbGatewayResource_getSmbGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured SMB gateway clusters with Active Directory and VIP metadata.",
          "usage" : [ "Query before rendering the SMB configuration overview.", "Refresh after editing domain settings or virtual IP pools to confirm changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":20,\"where\":[{\"type\":{\"_eq\":\"ACTIVE_DIRECTORY\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter clusters by Samba share type before managing shares.",
            "pagination.order.description" : "Maintain deterministic ordering across refreshes."
          },
          "failure_modes" : [ "200 data=[] when no SMB clusters are defined" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain how to create an SMB gateway via POST /gateways/smb."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Expose joinWithSssd and domain details so administrators can confirm integration status quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/servers" : {
      "get" : {
        "summary" : "List all SMB servers.",
        "operationId" : "SmbGatewayResource_getSmbServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List SMB gateway servers with their NIC bindings, VLANs, and CTDB health.",
          "usage" : [ "Fetch when presenting the SMB server grid to monitor HA status and virtual IP placement.", "Re-query after rebalancing CTDB or adjusting NIC assignments to confirm effective changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy nodes for quick remediation.",
            "pagination.order.hostname" : "Keep server lists stable between refreshes."
          },
          "failure_modes" : [ "200 data=[] when no SMB servers are associated with the cluster" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no servers are currently mapped to this SMB service."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB server health refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Highlight servers without virtual IPs or with unhealthy=false to draw operator focus.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/shares" : {
      "get" : {
        "summary" : "List all SMB shares.",
        "operationId" : "SmbGatewayResource_getSmbShares",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayShareResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return SMB shares, underlying paths, and access control definitions.",
          "usage" : [ "Fetch prior to editing share permissions or exposing share listings to operators.", "Refresh after share mutations to confirm guest/rw/ro settings and AD mappings." ],
          "response_shape" : "PaginationResponse<SmbGatewayShareResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"serviceId\":{\"_eq\":2}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.share" : "Search for a particular share name quickly.",
            "pagination.where.type" : "Filter to simple vs Active Directory shares when auditing access."
          },
          "failure_modes" : [ "200 data=[] when no SMB shares exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain that no shares are configured yet and point to POST /gateways/smb/shares."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB share inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/servers" ],
          "postprocessing_hint" : "Surface rwUsersFormatted/roUsersFormatted alongside share names for quick permission audits.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images" : {
      "get" : {
        "summary" : "List available images",
        "operationId" : "ImageResource_listImages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available croit node images with metadata and default selections.",
          "usage" : [ "Call to populate the image catalog UI before allowing selection or download.", "Refresh after invoking POST /images/refresh or /images/default to ensure state is current." ],
          "response_shape" : "ImageListReply",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON supporting filters (e.g. {\"limit\":20,\"where\":[{\"cpuArchitecture\":{\"_eq\":\"x86_64\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where" : "Filter by cpuArchitecture, isDefault or isNightly before presenting to users.",
            "pagination.order" : "Sort by timestamp desc to show latest images first."
          },
          "failure_modes" : [ "200 with images/data empty when no images have been synchronized yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state prompt to refresh images or contact support."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Catalog refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/images/refresh", "/images/{image}", "/images/archs" ],
          "postprocessing_hint" : "When pagination is absent use the `images` array; otherwise combine `data` and `total` for pagination UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/archs" : {
      "put" : {
        "summary" : "Set enabled architectures",
        "operationId" : "ImageResource_setEnabledArch",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Architecture configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ArchConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get enabled architectures",
        "operationId" : "ImageResource_getEnabledArch",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ArchConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report which CPU architectures are currently enabled for croit images.",
          "usage" : [ "Read before displaying architecture toggles in the UI.", "Confirm the enabled state after PUT /images/archs or POST /images/default." ],
          "response_shape" : "ArchConfig",
          "failure_modes" : [ "200 with a flag set to false when that architecture has been explicitly disabled" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Communicate that no images will boot for disabled architectures until re-enabled."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Architecture toggle refresh"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images/archs (PUT)", "/images/default" ],
          "postprocessing_hint" : "Disable UI flows that assume images exist when an architecture flag is false.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/default" : {
      "post" : {
        "summary" : "Set default image",
        "operationId" : "ImageResource_setDefaultImage",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Default image request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/DefaultImageRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get default image for architecture",
        "operationId" : "ImageResource_getDefaultImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "arch",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DefaultImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the default boot image UUID for a requested CPU architecture.",
          "usage" : [ "Call durant automated installs to learn which image croit nodes should boot by default.", "Verify that a default image is configured before prompting users to enable an architecture." ],
          "response_shape" : "DefaultImageResponse",
          "request_parameters" : [ {
            "name" : "arch",
            "in" : "query",
            "description" : "Architecture identifier (x86_64/amd64 or arm64/aarch64).",
            "required" : true,
            "example" : "x86_64"
          } ],
          "failure_modes" : [ "400 if the architecture string is not recognized", "404 if no default image is configured for the requested architecture" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize the architecture value to x86_64/amd64 or arm64/aarch64 and retry."
          }, {
            "code" : "404",
            "action" : "Prompt the administrator to set a default image via POST /images/default or enable the architecture."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/archs", "/images/default (POST)" ],
          "postprocessing_hint" : "Treat the returned UUID as authoritative until the image catalog refreshes.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/images/packages/{image}" : {
      "get" : {
        "summary" : "Get packages installed in an image",
        "operationId" : "ImageResource_getImagePackages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ImagePackage"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List OS packages baked into a specific croit image for compliance or troubleshooting.",
          "usage" : [ "Fetch when an operator inspects package versions before rolling out the image.", "Compare package sets between images to validate upgrade impact." ],
          "response_shape" : "array<ImagePackage>",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "UUID from GET /images representing the image to inspect.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if the image UUID is unknown" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the image list and pick a currently available image before retrying."
          } ],
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "Package audit"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Sort packages alphabetically and surface notable version differences to the user.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/refresh" : {
      "post" : {
        "summary" : "Refresh available images",
        "operationId" : "ImageResource_refreshImages",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/unused" : {
      "delete" : {
        "summary" : "Delete all unused images from disk. This includes all images that are not the default image and are not used by any server.",
        "operationId" : "ImageResource_deleteUnused",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}" : {
      "get" : {
        "summary" : "Get image information",
        "operationId" : "ImageResource_getImageInfo",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageInfoResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a concise description for a specific image (used by automated installers).",
          "usage" : [ "Call from provisioning workflows that need a human-readable label for the selected image.", "Validate that an image UUID obtained earlier still resolves before starting downloads." ],
          "response_shape" : "ImageInfoResponse",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "Image UUID returned by GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if the image metadata is no longer present" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-sync images via POST /images/refresh or choose another UUID."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer metadata lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}/{file}", "/images/default" ],
          "postprocessing_hint" : "Display the description verbatim; it already includes timestamp and UUID.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      },
      "delete" : {
        "summary" : "Delete a downloaded image from disk",
        "operationId" : "ImageResource_deleteImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/startDownload" : {
      "post" : {
        "summary" : "Start downloading an image",
        "operationId" : "ImageResource_startImageDownload",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/{file}" : {
      "get" : {
        "summary" : "Download an image file",
        "operationId" : "ImageResource_downloadImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "file",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download a raw croit OS image artifact for offline storage or provisioning.",
          "usage" : [ "Call when an administrator explicitly requests the binary image payload.", "Use ahead of manual provisioning workflows that need the kernel/initrd bundle on disk." ],
          "response_shape" : "application/octet-stream",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "Image identifier from GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          }, {
            "name" : "file",
            "in" : "path",
            "description" : "Filename within the image directory (e.g. rootfs.img, initrd).",
            "required" : true,
            "example" : "rootfs.img"
          } ],
          "failure_modes" : [ "404 if the requested image or file does not exist on disk" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the image catalog, confirm the file name, and retry the download."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Large image download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}", "/images/refresh" ],
          "postprocessing_hint" : "Stream the response directly to persistent storage and avoid logging binary data.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/install" : {
      "get" : {
        "summary" : "Get croit installation script",
        "operationId" : "InstallResource_getInstallScript",
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        }
      }
    },
    "/ipmi" : {
      "get" : {
        "summary" : "Show all IPMI devices",
        "operationId" : "IpmiResource_getIpmiDevices",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpmiDevice"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/add" : {
      "post" : {
        "summary" : "Add an IPMI device that is not managed by croit's DHCP server",
        "operationId" : "IpmiResource_addIpmiServer",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI device information",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiDeviceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/config" : {
      "patch" : {
        "summary" : "Set the global IPMI configuration",
        "operationId" : "IpmiResource_setIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the global IPMI configuration",
        "operationId" : "IpmiResource_getIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpmiConfig"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/poll-state" : {
      "get" : {
        "summary" : "Poll the state of the given IPMI devices.",
        "operationId" : "IpmiResource_pollIpmiState",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/IpmiDeviceStateWrapper"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}" : {
      "delete" : {
        "summary" : "Remove an IPMI device, it will be re-detected if it still exists",
        "operationId" : "IpmiResource_deleteIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/identify" : {
      "post" : {
        "summary" : "Turns on the identify LED for 5 minutes.",
        "operationId" : "IpmiResource_identifyIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}/initialize" : {
      "post" : {
        "summary" : "Initialize an IPMI device to be used with croit.",
        "description" : "Sets boot device to PXE, and turns on power and optionally configures the ADMIN password to the default croit password.",
        "operationId" : "IpmiResource_initializeIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Optional information for accessing the IPMI device if it uses a non-default password.",
          "required" : false,
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiAccess"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/ipmi-controller-reset" : {
      "post" : {
        "summary" : "Reboots the IPMI management controller itself.",
        "operationId" : "IpmiResource_rebootIpmiController",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-cycle" : {
      "post" : {
        "summary" : "Reboots a server.",
        "operationId" : "IpmiResource_rebootIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-off" : {
      "post" : {
        "summary" : "Shutdown a server.",
        "operationId" : "IpmiResource_powerOffIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-on" : {
      "post" : {
        "summary" : "Boots a server.",
        "operationId" : "IpmiResource_powerOnIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/reboot-to-bios" : {
      "post" : {
        "summary" : "Reboots a server and opens the BIOS setup menu.",
        "operationId" : "IpmiResource_rebootToBiosIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys" : {
      "get" : {
        "summary" : "List all Ceph users/keys.",
        "operationId" : "KeyResource_getCephKeys",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "description" : "Include Ceph and croit service keys (default: false)",
          "name" : "includeSystemKeys",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephUserResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new Ceph user/key, the specified user must not exist yet",
        "operationId" : "KeyResource_addCephKey",
        "tags" : [ "ceph-keys" ],
        "requestBody" : {
          "description" : "Ceph user/key configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd" : {
      "get" : {
        "summary" : "Deploy the Ceph Container Storage Interface (CSI) driver for RBD",
        "operationId" : "KeyResource_downloadKubernetesCsiRbdConf",
        "tags" : [ "ceph-keys" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd/config/{user}/{pool}" : {
      "get" : {
        "summary" : "Generate the ConfigMap, StorageClass, and Secret objects needed by ceph-csi to provision a RBD backed PersistentVolume",
        "operationId" : "KeyResource_downloadKubernetesCsiCroitConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes/{user}/{pool}" : {
      "get" : {
        "summary" : "Download Kubernetes configuration",
        "operationId" : "KeyResource_downloadKubernetesConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}" : {
      "patch" : {
        "summary" : "Update an existing Ceph user",
        "operationId" : "KeyResource_updateCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Ceph user/key update configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserUpdate"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a Ceph user",
        "operationId" : "KeyResource_deleteCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}/download" : {
      "get" : {
        "summary" : "Download a ceph.client.XYZ.keyring file",
        "operationId" : "KeyResource_downloadCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/license" : {
      "patch" : {
        "summary" : "Update license info.",
        "operationId" : "LicenseResource_patchLicenseInfo",
        "tags" : [ "license" ],
        "requestBody" : {
          "description" : "License update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/LicensePatchRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get license info.",
        "operationId" : "LicenseResource_licenseInfo",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/license/refresh" : {
      "post" : {
        "summary" : "Refresh license info.",
        "operationId" : "LicenseResource_refreshLicense",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/logs/export" : {
      "get" : {
        "summary" : "Export Logs",
        "operationId" : "VictoriaLogsResource_exportLogs",
        "tags" : [ "logs" ],
        "parameters" : [ {
          "description" : "The optional output format. `json` is the default VictoriaLogs output format, while the others represent `journalctl -o output` formats.",
          "name" : "format",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/ExportFormats"
          },
          "required" : true
        }, {
          "name" : "query",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/LogsQLRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Export VictoriaLogs data based on a LogsQL query for offline analysis.",
          "usage" : [ "Build a LogsQLRequest with desired filters and optional time range", "Call this endpoint on-demand when a user requests a zipped log export" ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Validate that the query JSON is well-formed and that requested servers exist.",
            "post_action" : "Store the returned download token and present a download link to the user."
          },
          "request_parameters" : [ {
            "name" : "query",
            "in" : "query",
            "description" : "Serialized LogsQLRequest JSON controlling filters, time range and pagination.",
            "required" : false,
            "example" : "{\"type\":\"query\",\"start\":1699999999,\"end\":1700003599}"
          }, {
            "name" : "format",
            "in" : "query",
            "description" : "Optional output format: raw|cat|short|with-unit.",
            "required" : false,
            "default" : "raw",
            "example" : "with-unit"
          } ],
          "common_parameters" : {
            "query.limit" : "Limit response size to avoid enormous exports.",
            "query.where" : "Apply filters to shrink the dataset before export."
          },
          "default_values" : {
            "format" : "raw"
          },
          "failure_modes" : [ "502 if VictoriaLogs backend is unreachable", "204 when the export contains no matching entries" ],
          "error_handling" : [ {
            "code" : "502",
            "action" : "Show an error and retry after verifying VictoriaLogs availability."
          }, {
            "code" : "204",
            "action" : "Inform the user that the query returned no data."
          } ],
          "retry_strategy" : "retry_on_502",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Expensive log export"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "WS /logs", "/cluster/status" ],
          "postprocessing_hint" : "The response is a streaming ZIP; pipe it to disk before presenting to users.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Exports may contain sensitive audit data"
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/allow-standby-replay" : {
      "put" : {
        "summary" : "Enable or disable standby replay.",
        "operationId" : "MaintenanceResource_setAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Standby replay configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/StandbyReplaySetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the standby-replay setting (false if there is no cephfs)",
        "operationId" : "MaintenanceResource_getAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/StandbyReplaySetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose whether CephFS standby replay is enabled for the default filesystem.",
          "usage" : [ "Fetch when displaying the standby replay toggle in the CephFS settings.", "Re-query after PATCH /maintenance/allow-standby-replay to confirm the applied state." ],
          "response_shape" : "StandbyReplaySetting",
          "failure_modes" : [ "200 allowStandbyReplay=false when CephFS is not configured", "500 if the Ceph CLI command fails or Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain that CephFS is not yet configured; standby replay defaults to false."
          }, {
            "code" : "500",
            "action" : "Retry after checking CephFS health; the CLI response contains more detail."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS flag read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/allow-standby-replay (PATCH)", "/maintenance/max-mds" ],
          "postprocessing_hint" : "If cephFsName is null, display the cluster default CephFS name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/backup" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFile",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup archive for offline storage.",
          "usage" : [ "Invoke when an administrator requests a manual backup download from the UI.", "Use before major maintenance to archive the current configuration." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "500 if the backup cannot be generated due to non-default database credentials", "500 if backup creation fails for another reason" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show the backend error; if it references database configuration, revert to default credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/backup/basic-auth" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFileBasicAuth",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitUser"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup using Basic Auth credentials.",
          "usage" : [ "Trigger from automation scripts relying on Basic Auth to fetch configuration backups.", "Invoke before maintenance when API clients cannot supply bearer tokens." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "500 if the backup cannot be generated due to non-default database credentials", "500 if backup creation fails for another reason" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show the backend error; if it references database configuration, revert to default credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/backup", "/maintenance/config-backups" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups" : {
      "patch" : {
        "summary" : "Configure cloud configuration backups.",
        "operationId" : "MaintenanceResource_setBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Backup configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloudConfigBackupConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable automatic offsite configuration backups.",
          "usage" : [ "Toggle cloud backups from the maintenance settings view.", "Disable backups temporarily before entering offline maintenance mode." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "true to turn on cloud backups, false to disable them.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if enabling backups while the appliance runs in offline mode" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Switch the system back to online mode or keep backups disabled."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Configuration toggles"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "After turning backups on, prompt the administrator to immediately generate and store the encryption key.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if cloud configuration backups are enabled and working.",
        "operationId" : "MaintenanceResource_getBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CloudConfigBackupStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Describe whether cloud configuration backups are enabled and the metadata of the last successful run.",
          "usage" : [ "Fetch when opening the backup settings page to show current status.", "Refresh after enabling, disabling, or running a backup to display the latest timestamp and checksum." ],
          "response_shape" : "CloudConfigBackupStatus",
          "failure_modes" : [ "200 with lastBackupTimestamp=null when no backup has been executed yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inform the user that no backup exists yet and suggest triggering one."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/config-backups (PATCH)", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Mask the backupEncryptionKey when presenting the data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/create" : {
      "post" : {
        "summary" : "Perform a cloud backup now.",
        "operationId" : "MaintenanceResource_runBackup",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an immediate cloud backup using the current encryption key.",
          "usage" : [ "Run after large configuration changes to capture the new state.", "Use when the UI indicates the last automatic backup failed." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if cloud backups are disabled in offline mode", "200 ManagedTask(status=FAILED) if the backup job encounters errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Switch the appliance back to online mode or keep backups disabled."
          }, {
            "code" : "200",
            "action" : "Inspect the managed task log; resolve the underlying issue before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "On-demand backup"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Stream task progress to the UI and surface the resulting timestamp and checksum once finished.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/generate-new-key" : {
      "post" : {
        "summary" : "Generates a new crypto key used for all future backups.",
        "operationId" : "MaintenanceResource_regenerateKey",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate the encryption key used for cloud configuration backups.",
          "usage" : [ "Run after a key compromise to generate a fresh encryption key.", "Rotate keys during scheduled security maintenance before triggering new backups." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "200 ManagedTask(status=SUCCEEDED) always returns with the new key ID" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Read task messages to retrieve and securely store the new key identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Key rotation"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Display the new key UUID and instruct operators to download the key material immediately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/croit-auto-update" : {
      "get" : {
        "summary" : "Get croit auto-update parameters.",
        "operationId" : "MaintenanceResource_getCroitAutoUpdateConfig",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the configured croit auto-update schedule and registry overrides.",
          "usage" : [ "Fetch to pre-fill the auto-update configuration form.", "Re-query after PUT /maintenance/croit-auto-update or /maintenance/update-now to ensure settings persisted." ],
          "response_shape" : "CroitAutoUpdateConfigRequest",
          "failure_modes" : [ "200 with enabled=false when automatic updates are disabled", "500 if the scheduler state cannot be loaded" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that auto updates are disabled and hide schedule-only controls."
          }, {
            "code" : "500",
            "action" : "Surface the backend error and suggest reviewing the job scheduler logs."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update (PUT)", "/maintenance/update-now" ],
          "postprocessing_hint" : "Redact registry credentials before logging or persisting the response.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "put" : {
        "summary" : "Change croit auto-update parameters.",
        "operationId" : "MaintenanceResource_configureCroitAutoUpdate",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Croit auto-update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/disable-cpu-idle-states" : {
      "put" : {
        "summary" : "Disable CPU idle states above set limit.",
        "operationId" : "MaintenanceResource_toggleHighPerformanceCPUMode",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "CPU idle state limit",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : [ "integer", "null" ],
                "format" : "int32"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if CPU idle states are disabled.",
        "operationId" : "MaintenanceResource_getIdleStates",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "integer",
                  "format" : "int32"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the configured CPU idle state limit for high performance mode.",
          "usage" : [ "Call when rendering the performance tuning page.", "Fetch again after PUT /maintenance/disable-cpu-idle-states to show the applied threshold." ],
          "response_shape" : "integer|null",
          "failure_modes" : [ "200 null when no idle state restriction is active" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat null as disabled and communicate that high performance mode is off."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Lightweight configuration read"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/maintenance/disable-cpu-idle-states (PUT)" ],
          "postprocessing_hint" : "Display non-null values as the maximum allowed C-state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags" : {
      "get" : {
        "summary" : "Ceph cluster flag overview.",
        "operationId" : "MaintenanceResource_getClusterFlags",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFlagReponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate Ceph cluster flags alongside recommended and current states.",
          "usage" : [ "Call when rendering the Ceph flag management screen.", "Refresh after toggling a flag to confirm the updated cluster state." ],
          "response_shape" : "array<CephFlagReponse>",
          "failure_modes" : [ "200 [] when the Ceph health cache has not populated flag data yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an informational banner that flag details are currently unavailable; Ceph may still be initialising."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "UI refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/flags/{flag}/set", "/maintenance/flags/{flag}/unset" ],
          "postprocessing_hint" : "Highlight entries where currentState differs from recommendedState.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags/{flag}/set" : {
      "put" : {
        "summary" : "Set a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_setClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/flags/{flag}/unset" : {
      "put" : {
        "summary" : "Unset a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_unsetClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/max-mds" : {
      "put" : {
        "summary" : "Set the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_setMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Maximum MDS configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MaxMdsSetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_getMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaxMdsSetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report the configured CephFS max_mds value (active MDS count).",
          "usage" : [ "Fetch when rendering the CephFS scaling settings.", "Refresh after PUT /maintenance/max-mds to ensure the new limit is in effect." ],
          "response_shape" : "MaxMdsSetting",
          "failure_modes" : [ "500 if CephFS is not configured or the Ceph CLI call fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Inform the operator that CephFS must exist and Ceph must be reachable before retrying."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/max-mds (PUT)", "/maintenance/allow-standby-replay" ],
          "postprocessing_hint" : "Validate UI input to stay within the available MDS server count.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations" : {
      "get" : {
        "summary" : "Check which Ceph upgrades or container switches can be performed.",
        "operationId" : "MaintenanceResource_availableMigrations",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AvailableMigrationTasks"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Summarise which Ceph major upgrades or container switches are still available.",
          "usage" : [ "Fetch before presenting the upgrade wizard so only valid actions are shown.", "Re-query after completing an upgrade or container switch to refresh the UI state." ],
          "response_shape" : "AvailableMigrationTasks",
          "failure_modes" : [ "200 with all flags false when no further upgrades are pending" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that the cluster is already on the latest supported release."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/migrations/{release}", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Use `switchTarget` to highlight the recommended container tag.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations/switch-container" : {
      "post" : {
        "summary" : "Switch to the correct croit container.",
        "operationId" : "MaintenanceResource_switchContainer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Switch the running croit container to the image required by the target Ceph release.",
          "usage" : [ "Invoke when GET /maintenance/migrations indicates a container switch is required before continuing upgrades.", "Use to realign container versions after manual changes." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if running offline or already on the correct container", "400 if the target release is below the minimum supported", "500 if the switch process fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Follow the guidance in the error message (disable offline mode or upgrade Ceph first)."
          }, {
            "code" : "500",
            "action" : "Review task logs to address failures before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Container switch"
          },
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/{release}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/migrations/{release}" : {
      "post" : {
        "summary" : "Perform a Ceph major version upgrade.",
        "operationId" : "MaintenanceResource_upgrade",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "release",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off a Ceph major upgrade to the specified release.",
          "usage" : [ "Upgrade Ceph to a newer supported release following the guided migration flow.", "Resume an interrupted upgrade by reissuing the same release once prerequisites are satisfied." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "release",
            "in" : "path",
            "description" : "Target Ceph release (e.g. quincy, reef).",
            "required" : true,
            "example" : "reef"
          } ],
          "failure_modes" : [ "400 if the release is unsupported or prerequisites are not met", "500 if upgrade steps fail midway" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use GET /maintenance/migrations to verify available upgrades and resolve prerequisites."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, address reported issues, then rerun the upgrade."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Ceph major upgrade"
          },
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Monitor the ManagedTask and validate cluster health after completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/min-compat-client" : {
      "put" : {
        "summary" : "Set the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_setMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Minimum compatible client version",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MinCompatClientVersion"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_getMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephRelease"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the enforced minimum Ceph client release (min-compat-client).",
          "usage" : [ "Fetch when displaying the client compatibility settings.", "Refresh after PUT /maintenance/min-compat-client to verify the cluster accepted the change." ],
          "response_shape" : "CephRelease|null",
          "failure_modes" : [ "200 null when no explicit minimum has been set", "500 if the Ceph CLI command fails or Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that the cluster uses the Ceph default and prompt admins to set one if needed."
          }, {
            "code" : "500",
            "action" : "Retry after checking Ceph health; the CLI stderr contains the root cause."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/min-compat-client (PUT)" ],
          "postprocessing_hint" : "Render releases using standard Ceph codenames.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd-full-ratios" : {
      "patch" : {
        "summary" : "Update OSD full ratios.",
        "operationId" : "MaintenanceResource_setOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "OSD full ratios update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdFullRatios"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get OSD full ratios.",
        "operationId" : "MaintenanceResource_getOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OsdFullRatios"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph OSD fullness thresholds (nearfull/backfillfull/full).",
          "usage" : [ "Call when rendering the OSD fullness configuration panel before allowing edits.", "Refresh immediately after PATCH /maintenance/osd-full-ratios to confirm the applied values." ],
          "response_shape" : "OsdFullRatios",
          "failure_modes" : [ "504 if the Ceph CLI does not respond in time", "500 if the Ceph CLI returns an error or malformed JSON" ],
          "error_handling" : [ {
            "code" : "504",
            "action" : "Retry after 15 seconds and alert operators if timeouts persist."
          }, {
            "code" : "500",
            "action" : "Surface the backend error and request operators to check Ceph health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/osd-full-ratios (PATCH)" ],
          "postprocessing_hint" : "Convert decimals to percentages with two decimals before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd/{osdId}/deep-scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to deep-scrub all its PGs.",
        "operationId" : "MaintenanceResource_deepScrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request a deep scrub (byte-for-byte verification) for all PGs on a specific OSD.",
          "usage" : [ "Run after hardware incidents to validate data integrity.", "Supplement automatic deep scrubs for clusters with extended intervals." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the OSD ID is unknown", "500 if Ceph refuses the deep scrub (cluster busy or unhealthy)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the OSD still exists before retrying."
          }, {
            "code" : "500",
            "action" : "Wait until cluster load decreases and deep-scrub throttles permit execution."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Manual deep scrubs"
          },
          "related_endpoints" : [ "/maintenance/osd/{osdId}/scrub", "/pools/{name}/deep-scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/osd/{osdId}/scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to scrub all its PGs.",
        "operationId" : "MaintenanceResource_scrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request an immediate scrub for all placement groups hosted by a specific OSD.",
          "usage" : [ "Invoke after resolving data inconsistencies or performing disk maintenance.", "Trigger periodic manual scrubs for critical OSDs outside automatic scheduling." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the OSD ID is unknown", "500 if Ceph rejects the scrub request" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh OSD inventories before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph health detail and active scrubs; retry once the cluster is ready."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual OSD scrubs"
          },
          "related_endpoints" : [ "/maintenance/osd/{osdId}/deep-scrub", "/pools/{name}/scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/reboot-all-servers" : {
      "post" : {
        "summary" : "Reboot all servers not running their configured image.",
        "operationId" : "MaintenanceResource_rebootServersToUpdateImage",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot every server that is not running its configured croit image to apply pending updates.",
          "usage" : [ "Execute after updating the default image to ensure all nodes boot the latest version.", "Use when maintenance tasks require a coordinated restart across the fleet." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "200 ManagedTask(status=FAILED) if some servers fail to reboot" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to identify hosts that did not reboot and handle them manually before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Fleet-wide reboot"
          },
          "related_endpoints" : [ "/servers/reboot", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "Monitor host status and service health once the task completes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/recovery-speed" : {
      "put" : {
        "summary" : "Set the recovery speed.",
        "description" : "This can be used to fine-tune the balance between client IOPS and data rebalancing.",
        "operationId" : "MaintenanceResource_setRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Recovery speed configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RecoverySpeed"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the recovery speed.",
        "operationId" : "MaintenanceResource_getRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RecoverySpeed"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the effective Ceph recovery throttle speed normalised to the 1-10 slider.",
          "usage" : [ "Fetch when rendering the recovery speed configuration form.", "Re-query after updating the throttle to confirm the active value." ],
          "response_shape" : "RecoverySpeed",
          "failure_modes" : [ "500 if Ceph configuration values are unavailable or invalid" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Display the backend message and prompt operators to inspect ceph.conf and cluster health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Admin-only configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/recovery-speed (PUT)" ],
          "postprocessing_hint" : "Map `speed` to the UI slider; 10 represents the default fastest behaviour.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/restart-croit" : {
      "post" : {
        "summary" : "Restart the croit container. Will only work if the restart policy in docker has been configured correctly.",
        "operationId" : "MaintenanceResource_restartCroit",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger a restart of the croit management container.",
          "usage" : [ "Call after applying configuration updates that require a management restart.", "Monitor the returned ManagedTask to ensure the restart completes before issuing further API calls." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if a Ceph upgrade is currently in progress", "500 if the container restart fails due to Docker policy" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Wait for the ongoing Ceph upgrade task to finish before retrying."
          }, {
            "code" : "500",
            "action" : "Check Docker restart policies and host logs; rerun once the failure is corrected."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Management restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/update-now", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Use the ManagedTask id to poll /tasks/{id} and wait for completion before calling other management APIs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Restarting the management container interrupts active sessions and background jobs."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/schedulingTimezone" : {
      "patch" : {
        "summary" : "Update the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_patchSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Scheduling timezone update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SchedulingSettings"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_getSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TimezoneSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide the timezone used for scheduled jobs along with available options.",
          "usage" : [ "Call to populate the scheduling timezone dropdown.", "Re-query after PATCH /maintenance/schedulingTimezone to confirm the new selection." ],
          "response_shape" : "TimezoneSettings",
          "failure_modes" : [ "200 timezone=\"UTC\" when no explicit timezone has been configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inform the user that UTC is used until a different timezone is selected."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Rare settings read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/schedulingTimezone (PATCH)" ],
          "postprocessing_hint" : "Use the `options` list to render a dropdown of valid timezones.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/update-now" : {
      "post" : {
        "summary" : "Check for updates now.",
        "operationId" : "MaintenanceResource_updateNow",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Immediately check for and apply available croit container updates.",
          "usage" : [ "Run after adjusting auto-update settings to validate connectivity and registry credentials.", "Trigger a one-off update outside the scheduled window." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if the system is configured for offline mode", "500 if the update process fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Disable offline mode or mirror the container image locally before retrying."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log for pull/authentication errors and retry once resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Manual update trigger"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules" : {
      "get" : {
        "summary" : "List ceph mgr modules.",
        "operationId" : "MgrModuleResource_listModules",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephModuleStatus"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/balancer/disable" : {
      "put" : {
        "summary" : "Toggle balancer module off.",
        "operationId" : "MgrModuleResource_disableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/balancer/enable" : {
      "put" : {
        "summary" : "Toggle balancer module on.",
        "operationId" : "MgrModuleResource_enableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "operationId" : "MgrModuleResource_listCrashes",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "description" : "Include archived and old crashes (older than 2 weeks with default config)",
          "name" : "show-all",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMgrCrashReportEntry"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/archive-all" : {
      "post" : {
        "summary" : "Archive all recent crash reports, clearing all warnings.",
        "operationId" : "MgrModuleResource_archiveAllCrashReports",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes/{crashId}" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "description" : "The return value is the raw json as reported by Ceph and may change with minor Ceph releases.",
        "operationId" : "MgrModuleResource_getCrashDetails",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/{crashId}/archive" : {
      "post" : {
        "summary" : "Archive a crash report, clearing the Ceph health warning related to it.",
        "operationId" : "MgrModuleResource_archiveCrashReport",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/disable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module off.",
        "operationId" : "MgrModuleResource_disableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/enable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module on.",
        "operationId" : "MgrModuleResource_enableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/roles" : {
      "get" : {
        "summary" : "List ceph mgr dashboard roles.",
        "operationId" : "MgrModuleResource_listDashboardRoles",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardRole"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/roles/{rolename}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_updateDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_deleteDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_addDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/users" : {
      "get" : {
        "summary" : "List ceph mgr dashboard users.",
        "operationId" : "MgrModuleResource_listDashboardUsers",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardUser"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/users/{username}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_updateDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_deleteDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_addDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/services" : {
      "get" : {
        "summary" : "List live ceph mgr module services.",
        "operationId" : "MgrModuleResource_listServices",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the live Ceph manager service endpoints (dashboard, REST API, etc.).",
          "usage" : [ "Display URLs for active mgr modules in the UI.", "Verify that mgr-managed services are reachable before automation proceeds." ],
          "response_shape" : "map<string,string>",
          "failure_modes" : [ "500 if the ceph command to list services fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph mgr logs and ensure the mgr daemons are healthy, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Mgr service discovery"
          },
          "related_endpoints" : [ "/modules", "/modules/balancer" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics" : {
      "put" : {
        "summary" : "Configure ping metrics.",
        "operationId" : "PingResource_updateMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping metrics configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingMetricsConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get ping metrics configuration.",
        "operationId" : "PingResource_getMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PingMetricsConfiguration"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics/summary" : {
      "get" : {
        "summary" : "Get ping metrics summary.",
        "operationId" : "PingResource_getMetricsSummary",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/PingMetricsSummary"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/ping" : {
      "post" : {
        "summary" : "Ping hosts.",
        "operationId" : "PingResource_ping",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping parameters",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingParameters"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/PingResult"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/networks" : {
      "get" : {
        "summary" : "List all configured networks.",
        "operationId" : "NetworkResource_getNetworks",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNetworkInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new network",
        "operationId" : "NetworkResource_addNetwork",
        "tags" : [ "networks" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NetworkInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/networks/{id}" : {
      "put" : {
        "summary" : "Replace a network, must provide the full network config",
        "operationId" : "NetworkResource_replaceNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a network by its ID",
        "operationId" : "NetworkResource_deleteNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs" : {
      "get" : {
        "summary" : "List all PGs in a pool.",
        "operationId" : "PlacementGroupResource_getPgDetails",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephPgStat"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/backfill" : {
      "post" : {
        "summary" : "Force backfill of a placement group",
        "operationId" : "PlacementGroupResource_forceBackfill",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/deep-scrub" : {
      "post" : {
        "summary" : "Start deep scrubbing a placement group",
        "operationId" : "PlacementGroupResource_deepScrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/details" : {
      "get" : {
        "summary" : "Get detailed information about a placement group",
        "operationId" : "PlacementGroupResource_queryPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/recover" : {
      "post" : {
        "summary" : "Force recovery of a placement group",
        "operationId" : "PlacementGroupResource_forceRecovery",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/repair" : {
      "post" : {
        "summary" : "Repair a placement group",
        "operationId" : "PlacementGroupResource_repairPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/scrub" : {
      "post" : {
        "summary" : "Start scrubbing a placement group",
        "operationId" : "PlacementGroupResource_scrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools" : {
      "get" : {
        "summary" : "List all pools.",
        "operationId" : "PoolResource_getPools",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephPoolResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph storage pools with capacity, protection and usage stats.",
          "usage" : [ "Populate the pool overview grid before drilling into details", "Refresh periodically when monitoring utilization or pool flags" ],
          "response_shape" : "OptionalPaginationResponse<CephPoolResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to filter/sort pools (by name, application, deleteProtected, etc.).",
            "required" : false,
            "example" : "{\"limit\":25,\"where\":[{\"application\":{\"_eq\":\"rbd\"}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Limit results on large clusters to keep responses manageable.",
            "pagination.where" : "Filter by deleteProtected or application before executing actions."
          },
          "failure_modes" : [ "200 [] when no pools are discovered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state encouraging pool creation or hardware discovery."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{name}/details", "/pools/{name}/compression", "/stats/pool-names" ],
          "postprocessing_hint" : "Derive warning badges for pools with erasureCodingOverwriteSupportMissing or nearing quotas.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a pool.",
        "operationId" : "PoolResource_createPool",
        "tags" : [ "ceph-pools" ],
        "requestBody" : {
          "description" : "Pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new Ceph pool with optional erasure coding, quotas, and CRUSH rule adjustments.",
          "usage" : [ "Call when onboarding new application workloads requiring dedicated pools.", "Follow up with GET /pools to confirm quotas, size, and application flags." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Pool name without whitespace.",
            "required" : true,
            "example" : "rbd-app"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "true to create an erasure-coded pool (requires dataChunks/parityChunks).",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "Desired pg_num; defaults to 128 if omitted.",
            "required" : false,
            "example" : "256"
          }, {
            "name" : "crushRule",
            "in" : "body",
            "description" : "Optional CRUSH rule id to assign immediately after creation.",
            "required" : false,
            "example" : "2"
          } ],
          "failure_modes" : [ "400 if the name is missing or contains whitespace", "400 if mutual parameters (e.g. erasure coding chunks) are inconsistent", "409 if a pool with the same name already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Sanitize the request payload (name formatting, EC parameters) and retry."
          }, {
            "code" : "409",
            "action" : "Skip creation or choose a different name; GET /pools to confirm existing entries."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Pool provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}", "/crush" ],
          "postprocessing_hint" : "If creating an EC pool, verify allow_ec_overwrites succeeded in the ManagedTask logs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating pools impacts cluster placement groups and storage utilization."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/all-infos" : {
      "get" : {
        "summary" : "Get mirror infos on all pools.",
        "operationId" : "RbdMirrorResource_getAllPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/schedules" : {
      "get" : {
        "summary" : "Get mirror snapshot schedules of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getSnapshotSchedules",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a schedule for RBD mirror snapshots. Call this endpoint with the same request body as when adding a schedule (via POST). The task returned by this endpoint will not provide information on whether or not a schedule was removed. To check if deletion was successful, request the list of schedules and check for any changes.",
        "operationId" : "RbdMirrorResource_deleteSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new schedule for rbd mirror snapshots.",
        "operationId" : "RbdMirrorResource_createSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "description" : "Snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}" : {
      "patch" : {
        "summary" : "Update pool flags.",
        "operationId" : "PoolResource_updatePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update pool metadata, quotas, or replication settings without recreating the pool.",
          "usage" : [ "Adjust pg_num, quotas, or CRUSH rules during capacity planning.", "Rename pools or toggle delete protection after confirming migration plans." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Optional new pool name (no commas allowed).",
            "required" : false,
            "example" : "rbd-prod"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "Target pg_num/pgp_num; triggers ceph osd pool set commands.",
            "required" : false,
            "example" : "256"
          }, {
            "name" : "quotaMaxBytes",
            "in" : "body",
            "description" : "Pool byte quota; 0 disables the limit.",
            "required" : false,
            "example" : "1099511627776"
          }, {
            "name" : "unprotect",
            "in" : "body",
            "description" : "true to clear the delete protection flag for 15 minutes.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "compression",
            "in" : "body",
            "description" : "Compression mode and algorithm overrides.",
            "required" : false,
            "example" : "{\"mode\":\"aggressive\",\"algorithm\":\"zstd\"}"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Current pool name.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if the payload is invalid (e.g. new name contains commas)", "404 if the pool cannot be found", "500 if Ceph rejects configuration changes (quota, pg updates, CRUSH adjustments)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fix the offending field (rename formatting, conflicting flags) and resubmit."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list to select an existing pool."
          }, {
            "code" : "500",
            "action" : "Review Ceph command output, ensure the cluster is healthy, then retry in smaller increments if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Pool configuration changes"
          },
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Monitor ceph health for remapping/backfill and refresh GET /pools to confirm updated stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete pool.",
        "operationId" : "PoolResource_deletePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph pool after confirming it no longer holds important data.",
          "usage" : [ "Call once all data is migrated away and the pool is unprotected (include the confirmation token).", "Monitor ceph health after deletion to ensure PGs return to active/clean state." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "poolId",
            "in" : "body",
            "description" : "Expected pool id as safety check.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Must equal the confirmation string 'I know this will delete data'.",
            "required" : true,
            "example" : "I know this will delete data"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name to remove.",
            "required" : true,
            "example" : "rbd-old"
          } ],
          "failure_modes" : [ "400 if confirmation text or poolId mismatches", "400 if the pool is still protected", "409 if the pool is in use by RGW or other services" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the confirmation string and identifiers match the target pool before retrying."
          }, {
            "code" : "409",
            "action" : "Check RGW placement targets or dependent services and detach them first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Pool deletion risk"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/s3/buckets" ],
          "postprocessing_hint" : "Watch ceph health and PG states for the affected pool until no longer listed.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting a pool irreversibly removes data and affects the CRUSH map."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/compression" : {
      "get" : {
        "summary" : "Get pool compression info.",
        "operationId" : "PoolResource_getCompressionSettings",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PoolCompressionSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve compression settings for a specific pool to validate configuration.",
          "usage" : [ "Open the compression settings dialog before editing", "Check current values after updating compression policies" ],
          "response_shape" : "PoolCompressionSettings",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if compression info cannot be parsed (ENOENT)", "404 if the pool does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Show a toast that compression is not configured and allow setting defaults."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list and inform the user the pool was removed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool configuration viewing"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{name}", "/pools" ],
          "postprocessing_hint" : "Display human-readable algorithm labels using PoolCompressionAlgorithm.cephName.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/deep-scrub" : {
      "post" : {
        "summary" : "Add pool to deep scrub queue.",
        "operationId" : "PoolResource_deepScrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a deep scrub for the pool to read and verify all data blocks.",
          "usage" : [ "Trigger after hardware issues or inconsistent PGs to perform a thorough validation.", "Schedule less frequent deep scrubs on mission-critical pools between maintenance windows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for deep scrub.",
            "required" : true,
            "example" : "ec-archive"
          } ],
          "failure_modes" : [ "500 if Ceph refuses the deep scrub (pool missing, deep scrub throttled, or cluster unhealthy)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Ensure the cluster is healthy and deep-scrub is permitted, then resubmit when load is low."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Deep scrub scheduling"
          },
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Watch ceph health detail for deep-scrub progress and follow up on any reported inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/details" : {
      "get" : {
        "summary" : "Get pool details.",
        "operationId" : "PoolResource_getPoolDetails",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose raw Ceph pool detail JSON for diagnostics and advanced tooling.",
          "usage" : [ "Fetch when the admin opens the pool detail drawer", "Use in support bundles or advanced troubleshooting" ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool is absent" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Inform the user that the pool no longer exists and reload the pool list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Detailed pool inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Render only relevant fields and hide sensitive Ceph internals in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/enable-ec-overwrites" : {
      "post" : {
        "summary" : "Enable the ec_overwrites flag for the pool.",
        "description" : "croit tries to enable this when creating the pool, however, this may fail if there are non-Bluestore OSDs. Pools that should have this flag but don't can be identified by the field 'erasureCodingOverwriteSupportMissing'.",
        "operationId" : "PoolResource_enableEcOverwrites",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable Ceph erasure-coded overwrites so the pool can host RBD or CephFS workloads.",
          "usage" : [ "Run after upgrading legacy OSDs when the UI shows erasureCodingOverwriteSupportMissing=true.", "Execute immediately after creating an EC pool if the automatic flag enable failed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools.",
            "required" : true,
            "example" : "ec-data"
          } ],
          "failure_modes" : [ "404 if the pool cannot be found", "500 if Ceph rejects the command (e.g. OSDs not BlueStore or cluster unavailable)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the pool list and retry with an existing pool name."
          }, {
            "code" : "500",
            "action" : "Inspect ceph osd logs, ensure all target OSDs are BlueStore, then rerun the request."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "EC overwrite toggles"
          },
          "related_endpoints" : [ "/pools/{name}", "/pools/{name}/details" ],
          "postprocessing_hint" : "Refresh GET /pools/{name} to confirm erasureCodingOverwriteSupportMissing cleared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/scrub" : {
      "post" : {
        "summary" : "Add pool to scrub queue.",
        "operationId" : "PoolResource_scrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a standard scrub for the pool to validate replica consistency.",
          "usage" : [ "Run after resolving object errors to force Ceph to rescan the pool.", "Schedule periodic health checks for critical pools outside the automatic window." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for scrubbing.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "500 if Ceph refuses the scrub (pool missing, command throttled, or mon connection failed)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check ceph health detail for active scrubs or errors, wait for the cluster to stabilize, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Manual pool scrubs"
          },
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Monitor ceph health detail until the scrub completes without new inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a pool and optional namespace.",
        "operationId" : "PoolRbdResource_forceCacheUpdate",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for a specific namespace within the pool.",
          "usage" : [ "Refresh cached metadata after editing images in a single tenant namespace.", "Call after restoring from backup scripts that bypass croit caching." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Namespace to clear; omit for default namespace.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the namespace.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "200 even if the namespace cache is already empty" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No follow-up required; next read repopulates the cache."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 3600,
            "note" : "Namespace cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbd-namespaces" ],
          "postprocessing_hint" : "Issue a GET with details=true to rebuild cache entries on demand.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update-all" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for pool including all namespaces.",
        "operationId" : "PoolRbdResource_forceCacheUpdateAll",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on (including all of its namespaces)",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for all namespaces in the pool.",
          "usage" : [ "Force croit to refresh image metadata after bulk CLI changes.", "Clear stale size/feature information before audits." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose cache should be flushed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "200 even if no cache entries existed" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No action needed; subsequent GET calls repopulate the cache."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "postprocessing_hint" : "Follow with GET requests to rebuild the cache for affected workloads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/qos" : {
      "post" : {
        "summary" : "Set qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_setPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_listPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_deletePoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update a pool's mirroring settings.",
        "operationId" : "RbdMirrorResource_updatePoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to update.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Pool mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a pool's mirroring settings for all namespaces.",
        "operationId" : "RbdMirrorResource_getPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to get mirror settings of.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional RBD namespace, or the default namespace if null.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/journaling" : {
      "post" : {
        "summary" : "Enable/Disable journaling for all images not in snapshot mode in the pool.",
        "operationId" : "RbdMirrorResource_updatePoolJournalingSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool with the images.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional).",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Journaling update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdJournalingUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers" : {
      "post" : {
        "summary" : "Add a pool peer using the bootstrap token from a remote cluster.",
        "operationId" : "RbdMirrorResource_addPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers/{id}" : {
      "patch" : {
        "summary" : "Change pool peer settings. These changes only take effect after restarting the rbd-mirror daemon service.",
        "operationId" : "RbdMirrorResource_updatePoolPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a specific peer mirroring cluster from a pool.",
        "operationId" : "RbdMirrorResource_deletePoolMirrorPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool containing the peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/token" : {
      "patch" : {
        "summary" : "Change the site name of the pool.",
        "operationId" : "RbdMirrorResource_updatePoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to set the site name.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Site name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSiteNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the bootstrap token to set up a peer for the pool. This token can be imported on a peer cluster to automatically set up a connection between the two clusters to mirror the pool. Note that the token contains sensitive information about your cluster!\n\nWill return null if anything fails while trying to create the token (e.g. mirroring is not enabled on the pool).",
        "operationId" : "RbdMirrorResource_getPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to generate a token for.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-namespaces" : {
      "get" : {
        "summary" : "List all existing RBD namespaces",
        "operationId" : "RbdNamespaceResource_listRbdNamespaces",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNamespace"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List namespaces available within an RBD pool.",
          "usage" : [ "Discover namespaces before provisioning images for a tenant.", "Refresh after creating or deleting namespaces to update UI selections." ],
          "response_shape" : "array<RbdNamespace>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose namespaces should be listed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool is unknown", "200 [] when the pool has no namespaces" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state encouraging namespace creation."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list and retry with a valid name."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Namespace discovery"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces/{namespace}", "/pools/{pool}/rbds" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{pool}/rbd-namespaces/{namespace}" : {
      "delete" : {
        "summary" : "Delete a RBD namespace",
        "operationId" : "RbdNamespaceResource_deleteRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an empty RBD namespace from the pool.",
          "usage" : [ "Clean up deprecated namespaces after migrating images to a new structure.", "Delete temporary namespaces once automation has drained them." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to remove.",
            "required" : true,
            "example" : "vm"
          } ],
          "failure_modes" : [ "400 if the namespace still contains images", "500 if Ceph rejects the deletion (namespace missing or command failed)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List images in the namespace, delete them first, then retry."
          }, {
            "code" : "500",
            "action" : "Verify the namespace still exists via rbd namespace list and reissue the request once the cluster is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Namespace cleanup"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbd-namespaces to confirm the namespace disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new RBD namespace",
        "operationId" : "RbdNamespaceResource_createRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a dedicated namespace within a pool to group related RBD images.",
          "usage" : [ "Call during tenant onboarding to isolate their images.", "Create staging namespaces before cloning golden images for tests." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool that will contain the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to create.",
            "required" : true,
            "example" : "tenant-a"
          } ],
          "failure_modes" : [ "409 if the namespace already exists", "500 if Ceph rejects the command (pool missing or insufficient permissions)" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Skip creation and reuse the existing namespace."
          }, {
            "code" : "500",
            "action" : "Verify the pool name and Ceph health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Namespace creation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Immediately refresh the namespace list or create initial images within the new namespace.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds" : {
      "get" : {
        "summary" : "List all RBDs including their details in a pool",
        "operationId" : "PoolRbdResource_listRbdImages",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images in a pool (optionally including details) for inventory or UI browsing.",
          "usage" : [ "Populate pool detail views before selecting an image to manage.", "Page through RBDs when auditing capacity or identifying stale images." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters, sort order, and limits.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"namespace\":{\"_is_null\":true}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Name of the pool containing the images.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool does not exist", "200 data=[] when the pool has no images" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the pool list and retry with a valid name."
          }, {
            "code" : "200",
            "action" : "Display an empty state encouraging image creation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "RBD inventory"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new RBD",
        "operationId" : "PoolRbdResource_createRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdImageCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new RBD image within the selected pool (optionally creating the namespace).",
          "usage" : [ "Provision a backing volume for a VM or application before mapping it to clients.", "Bootstrap automation that prepares RBDs for NVMe-oF or iSCSI exports." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Image size in bytes (must be >0).",
            "required" : true,
            "example" : "268435456000"
          }, {
            "name" : "features[]",
            "in" : "body",
            "description" : "Optional RBD feature list (e.g. layering, exclusive-lock).",
            "required" : false,
            "example" : "[\"exclusive-lock\",\"object-map\"]"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Optional namespace; created on the fly if missing.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "erasureCodedPool",
            "in" : "body",
            "description" : "Optional metadata-only pool when using EC data pool offload.",
            "required" : false,
            "example" : "ec-data"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Target pool for the image.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "409 if an image with the same name already exists", "500 if Ceph refuses creation (e.g. invalid namespace or pool)" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Choose a unique image name or delete the existing one."
          }, {
            "code" : "500",
            "action" : "Validate pool/namespace existence and review Ceph logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD provisioning"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "Trigger GET /pools/{pool}/rbds with details=true to confirm the image appears with correct features.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}" : {
      "patch" : {
        "summary" : "Change properties of an existing RBD image.",
        "operationId" : "PoolRbdResource_updateRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Details to be changed",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust metadata of an existing RBD image (rename, grow, or toggle features).",
          "usage" : [ "Increase image size after storage expansion.", "Rename an image before migrating clients to a new naming scheme.", "Enable features such as object-map or fast-diff after ensuring client compatibility." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the image.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New image name; triggers ceph rename when provided.",
            "required" : false,
            "example" : "vm-001-renamed"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "New size in bytes (must be >= current size).",
            "required" : false,
            "example" : "322122547200"
          }, {
            "name" : "features[]",
            "in" : "body",
            "description" : "Replace enabled features list.",
            "required" : false,
            "example" : "[\"exclusive-lock\",\"object-map\"]"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Current image name.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if the image belongs to a different pool/namespace or if a shrink is attempted", "400 if the image is still in use by Ceph iSCSI (warning escalated via ignorable warnings)", "500 if Ceph resize or rename commands fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify payload consistency and ensure the target size is >= current size before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs for failures, resolve the issue, then reissue the update."
          }, {
            "code" : "200",
            "action" : "If you receive an ignorable warning about iSCSI usage, coordinate downtime before retrying disruptive changes."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "RBD metadata updates"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Force an RBD cache refresh for the image and notify dependent services of name changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get details of a specific RBD image (not cached)",
        "operationId" : "PoolRbdResource_rbdDetails",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve up-to-date details for a specific RBD image, bypassing caches when necessary.",
          "usage" : [ "Inspect features, mirroring status, and snapshots before performing maintenance.", "Verify image metadata immediately after updates to confirm changes took effect." ],
          "response_shape" : "RbdImageResponse",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace if the image is not in the default namespace.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to retrieve.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if the image cannot be found", "500 if Ceph fails to return image details" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the image list and retry with the current name."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and retry once connectivity is restored."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Image detail lookup"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an existing RBD image",
        "operationId" : "PoolRbdResource_rbdDelete",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the RBD to delete",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD deletion request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RBD image after validating confirmations and dependencies.",
          "usage" : [ "Remove retired images once snapshots are purged and consumers are detached.", "Automate cleanup workflows after migrating workloads to a new pool." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace; omit for default.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Repeat the pool name for confirmation.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Repeat the image name for confirmation.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Must equal the confirmation phrase to proceed.",
            "required" : true,
            "example" : "I'm really sure that I want to delete this"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name to delete.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if confirmation fields or namespace do not match the request path", "400 if the image still has snapshots", "500 if Ceph rejects the deletion (image already gone or cluster unhealthy)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fix the confirmation payload, remove snapshots, and reissue the deletion."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log and Ceph health; retry after resolving cluster errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RBD deletions"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Stream the ManagedTask output to the UI and refresh GET /pools/{pool}/rbds once it finishes.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting an RBD image permanently removes all data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a single RBD image.",
        "operationId" : "PoolRbdResource_forceCacheUpdateRbd",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate cached metadata for a single RBD image.",
          "usage" : [ "Clear stale size or feature info after manual rbd CLI operations.", "Use during troubleshooting when the UI shows outdated data for one image." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace for the image.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name being refreshed.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "200 even if no cache entry existed" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No additional handling required; trigger a GET to repopulate metadata."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 3600,
            "note" : "Image cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Next GET request will reconstruct the cache entry; avoid back-to-back invalidations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/flatten" : {
      "post" : {
        "summary" : "Flatten a clone, making it independent of its parent. Flattening happens in the background and may take hours to complete.",
        "operationId" : "PoolRbdResource_flattenRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a background flattening job to detach a clone from its parent snapshot.",
          "usage" : [ "Run before deleting or expiring the parent snapshot chain.", "Reduce read amplification on steady-state clones kept long term." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the clone.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the clone.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Clone image name to flatten.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "200 ManagedTask(status=FAILED) if flattening encounters errors or the clone disappears" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Monitor the ManagedTask log; resolve underlying Ceph issues and rerun if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Clone flatten operations"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Wait for the ManagedTask to complete and then verify the parent snapshot can be safely removed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/qos" : {
      "post" : {
        "summary" : "Set qos limits of an image.",
        "operationId" : "QosRbdSettingResources_setRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of an image.",
        "operationId" : "QosRbdSettingResources_listRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limit of an image.",
        "operationId" : "QosRbdSettingResources_deleteRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update RBD mirroring settings for the image.",
        "operationId" : "RbdMirrorResource_updateImageMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to update.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Image mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorImageUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/resync" : {
      "post" : {
        "summary" : "Force a RBD mirroring resync on the image. Note that this only flags the image, it's up to the rbd-mirror daemon to execute the resync.",
        "operationId" : "RbdMirrorResource_resyncImage",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to resync.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots" : {
      "get" : {
        "summary" : "Get mirror snapshots of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getImageSnapshots",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshot"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a mirror snapshot of the image",
        "operationId" : "RbdMirrorResource_createImageSnapshot",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}" : {
      "patch" : {
        "summary" : "Update an existing snapshot of an image.",
        "operationId" : "PoolRbdResource_updateRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to update",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to update",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rename or change protection status for an existing RBD snapshot.",
          "usage" : [ "Protect snapshots before exposing clones to prevent accidental deletion.", "Rename snapshots to follow retention policies after automation triggers." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace for the snapshot.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New snapshot name.",
            "required" : false,
            "example" : "pre-upgrade-2024-04"
          }, {
            "name" : "protect",
            "in" : "body",
            "description" : "true to protect, false to unprotect.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Current snapshot name.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "404 if the snapshot cannot be found", "500 if Ceph rejects the rename/protect command or dependencies exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the snapshot list to confirm its presence before retrying."
          }, {
            "code" : "500",
            "action" : "Ensure dependent clones are detached and Ceph is healthy, then retry the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot metadata updates"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Re-fetch snapshot details to confirm the new name or protection status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a snapshot of an image.",
        "operationId" : "PoolRbdResource_deleteRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to delete",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RBD snapshot to free storage or allow subsequent image deletion.",
          "usage" : [ "Clean up snapshots after confirming they are no longer needed for rollback.", "Run before deleting the parent image, because deletions require all snapshots to be gone." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace if the image is not in the default.",
            "required" : false,
            "example" : "prod"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to delete.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "500 if Ceph refuses to delete the snapshot (still protected or clones depend on it)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Unprotect the snapshot and detach dependent clones before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Snapshot deletions"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbds/{rbd} to verify the snapshot list updated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new snapshot of an image.",
        "operationId" : "PoolRbdResource_createRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to snapshot",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the new snapshot",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a point-in-time snapshot for an RBD image.",
          "usage" : [ "Take an application-consistent snapshot prior to maintenance or upgrade steps.", "Capture a base image before cloning it to new environments." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace containing the image.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the source image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to snapshot.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to create.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "409 if a snapshot with the same name already exists", "500 if Ceph refuses to create the snapshot" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Choose a unique snapshot name or delete the existing one."
          }, {
            "code" : "500",
            "action" : "Verify image accessibility and Ceph health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot creation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "List snapshots to confirm creation and consider protecting it if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" : {
      "post" : {
        "summary" : "Create a clone of a snapshot on an existing image.",
        "operationId" : "PoolRbdResource_createRbdClone",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to clone",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot to clone",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Clone creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloneRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clone an RBD snapshot into a writable image, optionally in another pool or namespace.",
          "usage" : [ "Provision a new VM from a golden snapshot without copying data.", "Create point-in-time test environments while keeping linkage to the parent image." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the source snapshot.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Destination pool for the clone.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New clone name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Destination namespace (requires Mimic+ clients for cross-namespace clones).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Source pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Source image name.",
            "required" : true,
            "example" : "golden-template"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to clone.",
            "required" : true,
            "example" : "2024-01-01"
          } ],
          "failure_modes" : [ "400 if clone v2 is required but min-compat-client is too low", "500 if Ceph refuses the clone (snapshot missing, insufficient permissions)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Upgrade clients or run 'ceph osd set-require-min-compat-client mimic' before retrying."
          }, {
            "code" : "500",
            "action" : "Verify the snapshot exists and is protected when required, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD clone operations"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "List the destination pool to confirm the clone appears and schedule flattening if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/rbds" : {
      "get" : {
        "summary" : "List all RBD details in all pools",
        "operationId" : "RbdResource_listAllRbds",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images with size, mirroring, and feature details across all pools/namespaces.",
          "usage" : [ "Call to populate RBD inventory tables in the UI.", "Refresh after provisioning or deleting RBDs to ensure cached details are current." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sorting, and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"pool\":{\"_eq\":\"rbd\"}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Set limit <=100 to avoid large ceph-volume dumps.",
            "pagination.where.namespace" : "Filter by namespace when browsing multi-tenant pools."
          },
          "failure_modes" : [ "500 if Ceph queries fail or the RBD cache is unavailable" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking Ceph mgr health; show the underlying exception to operators."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "RBD inventory refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds/rbd-names", "/rbds/rbd-infos", "/rbds/rbd-pools" ],
          "postprocessing_hint" : "If withDetails=false, schedule detail fetches for visible rows before rendering.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-infos" : {
      "get" : {
        "summary" : "Get RBD details (size, features, parent, data-pool) for a list of images.",
        "operationId" : "RbdResource_rbdDetailsMultiple",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "Images to query, syntax is pool/image or pool/namespace/image.",
          "name" : "image",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/RbdImageResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch detailed metadata for specific RBD images in bulk.",
          "usage" : [ "Call when an operator selects multiple images to inspect mirroring, parent, or feature flags.", "Use after provisioning to confirm images picked up expected settings." ],
          "response_shape" : "map<string,RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "image",
            "in" : "query",
            "description" : "Repeatable query parameter in the form pool/image or pool/namespace/image.",
            "required" : true,
            "example" : "rbd/my-image"
          } ],
          "failure_modes" : [ "400 if an image identifier is malformed", "500 if RBD detail retrieval fails for all requested images" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize image identifiers to pool[/namespace]/image before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect logs for ceph/rbd errors; reissue the request for affected images only."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "Detailed RBD metadata"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "Warn users when map entries are null (images unavailable) and suggest refreshing the cache.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-names" : {
      "get" : {
        "summary" : "List all RBD names in all pools",
        "operationId" : "RbdResource_listAllRbdNames",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNameResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return lightweight RBD identifiers (pool/namespace/name) for quick selection lists.",
          "usage" : [ "Populate dropdowns when prompting the user to select an image.", "Call before issuing detailed queries to avoid loading full image metadata." ],
          "response_shape" : "array<RbdNameResponse>",
          "failure_modes" : [ "500 if Ceph rbd list commands fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Log the exception and retry once Ceph connectivity is restored."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD name lookup"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-pools" ],
          "postprocessing_hint" : "Sort results alphabetically and group by pool for UI widgets.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-pools" : {
      "get" : {
        "summary" : "List all RBD pools and namespaces",
        "operationId" : "RbdResource_listAllRbdPools",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List pools and namespaces that contain RBD images.",
          "usage" : [ "Call prior to presenting pool/namespace selectors in the UI.", "Use to validate that a target pool is active before provisioning RBDs." ],
          "response_shape" : "array<RbdPoolInfo>",
          "failure_modes" : [ "500 if Ceph reports errors while enumerating pools" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting Ceph manager logs; inactive pools may need activation."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD pool listing"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "Highlight pools with active=false to signal decommissioned namespaces.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/used-size" : {
      "get" : {
        "summary" : "Returns RBD pool/namespace/image used size",
        "operationId" : "RbdResource_rbdUsedSize",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The namespace to query. If omitted or set to null, the default namespace will be used.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "description" : "The pool to query (required).",
          "name" : "pool",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "The rbd to query. If omitted or set to null,the size of the entire namespace will be returned, otherwise only the size of this rbd.",
          "name" : "rbd",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdUsedSizeResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate provisioned and used size for a pool, namespace, or specific RBD image.",
          "usage" : [ "Display usage data before reclaiming space or deleting snapshots.", "Assess capacity distribution across namespaces for reporting." ],
          "response_shape" : "RbdUsedSizeResponse",
          "request_parameters" : [ {
            "name" : "pool",
            "in" : "query",
            "description" : "Pool name to query (required).",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace to scope usage calculations.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "rbd",
            "in" : "query",
            "description" : "Optional image name to return a single-image result.",
            "required" : false,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if the pool cannot be found", "500 if Ceph usage queries fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the pool exists before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and rerun once the cluster responds to usage queries."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Usage reporting"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets" : {
      "get" : {
        "summary" : "List of all buckets.",
        "operationId" : "RgwResource_getRgwBuckets",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with usage, owner and placement details.",
          "usage" : [ "Render the bucket inventory view", "Filter via pagination when exporting bucket data" ],
          "response_shape" : "OptionalPaginationResponse<RgwBucketResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for large bucket sets.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"owner\":{\"_eq\":\"alice\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no buckets exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show onboarding guidance to create buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/policy" ],
          "postprocessing_hint" : "Aggregate usageSum across zones for dashboard totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}" : {
      "patch" : {
        "summary" : "Update RGW bucket",
        "operationId" : "RgwResource_updateRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW bucket details",
        "operationId" : "RgwResource_getRgwBucketDetails",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BucketDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return ACL, CORS and versioning information for a bucket via RGW.",
          "usage" : [ "Open before editing bucket access settings", "Refresh after applying policy or versioning changes to confirm state" ],
          "response_shape" : "BucketDetails",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID to disambiguate tenants when looking up the bucket.",
            "required" : false,
            "example" : "tenant1:alice"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (with tenant prefix if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found", "400 if the provided owner does not match" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt the operator to refresh the bucket inventory or verify ownership."
          }, {
            "code" : "400",
            "action" : "Validate owner input and retry without an owner if unsure."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket detail inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/buckets/{bucketName}/policy", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Mask sensitive ACL entries when presenting to non-admin viewers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete RGW bucket",
        "operationId" : "RgwResource_deleteRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketDeletionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RGW bucket, optionally purging all objects first.",
          "usage" : [ "Call with deleteData=true to purge objects for large cleanup operations (returns a ManagedTask).", "Use deleteData=false to remove an empty bucket immediately." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "true to delete all objects before dropping the bucket.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Confirmation string required when deleteData=true (I know this will delete data).",
            "required" : false,
            "example" : "I know this will delete data"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (without tenant prefix).",
            "required" : true,
            "example" : "logs-prod"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist or the name mismatch", "400 if deleteData=true without confirmation string" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /s3/buckets to confirm the bucket still exists before retrying."
          }, {
            "code" : "400",
            "action" : "Provide the exact confirmation text when deleting data."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Bucket lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects", "/tasks/{id}" ],
          "postprocessing_hint" : "If a ManagedTask is returned, monitor it for WARN logs when objects fail to delete.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting buckets (especially with deleteData=true) permanently removes stored objects."
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new S3 bucket.",
        "operationId" : "RgwResource_createBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/download" : {
      "get" : {
        "summary" : "Download an object.",
        "operationId" : "RgwResource_downloadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stream a single S3 object through croit with presigned token handling.",
          "usage" : [ "Allow administrators to download objects directly from the UI", "Use for one-off retrievals; do not poll" ],
          "response_shape" : "DownloadableObject",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenant resolution.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to download.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object is missing", "403 if the caller lacks permission" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Warn the administrator and suggest refreshing the object list."
          }, {
            "code" : "403",
            "action" : "Require admin credentials and ensure ACLs allow access."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Object downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Trigger the download immediately; do not attempt resumable transfers via this endpoint.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. API params are identical to object listing.",
        "operationId" : "RgwResource_listMultipartUploads",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MultipartUploadListing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect ongoing multipart uploads for a bucket using native S3 markers.",
          "usage" : [ "Display uploads that may require cleanup", "Use before deciding to abort stalled uploads" ],
          "response_shape" : "MultipartUploadListing",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "max",
            "in" : "query",
            "description" : "Maximum uploads to return (default 50).",
            "required" : false,
            "example" : "100"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Filter uploads by key prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "continuationToken",
            "in" : "query",
            "description" : "Continue listing from previous response.",
            "required" : false,
            "example" : "CgAJAA..."
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to list without delimiter.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to list.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the bucket inventory before retrying."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads-paginated", "/s3/buckets/{bucketName}/multipart-uploads" ],
          "postprocessing_hint" : "Sort by initiated time to highlight oldest uploads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Cancel an active or abandoned multi-part upload.",
        "operationId" : "RgwResource_cancelMultipartUpload",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "uploadId",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads-paginated" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. Uses croit's pagination.",
        "operationId" : "RgwResource_listMultipartUploadsPaginated",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3MultipartUploadResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate multipart uploads with server-side filtering and caching of continuation tokens.",
          "usage" : [ "Use in admin UIs where consistent paging is required", "Prefer when sorting/filtering uploads by metadata" ],
          "response_shape" : "S3MultipartUploadResponse",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for the bucket.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Filter uploads by prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter grouping.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          }, {
            "name" : "maxQueried",
            "in" : "query",
            "description" : "Cap on how many uploads to scan server-side per request (default 10000).",
            "required" : false,
            "example" : "5000"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to page through.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the bucket name/owner before retrying."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads", "/s3/buckets/{bucketName}/objects-paginated" ],
          "postprocessing_hint" : "Reuse the pagination.after and returned next markers to continue the listing without re-querying earlier data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects" : {
      "get" : {
        "summary" : "List objects in a bucket. Refer to S3 documentation for listing details",
        "operationId" : "RgwResource_listBucketObjects",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Listing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform an S3 object listing with optional prefix and pagination markers.",
          "usage" : [ "Use for browsing objects in classic delimiter-based mode", "When more control is needed, prefer the paginated variant" ],
          "response_shape" : "S3Listing",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "max",
            "in" : "query",
            "description" : "Maximum keys per response (defaults to 50).",
            "required" : false,
            "example" : "100"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Restrict listing to keys with this prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "continuationToken",
            "in" : "query",
            "description" : "Opaque marker to continue a previous listing.",
            "required" : false,
            "example" : "CgABAA..."
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter-based folder emulation.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to list objects from.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist", "400 if listing parameters are invalid" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the bucket list and confirm the owner parameter."
          }, {
            "code" : "400",
            "action" : "Validate prefix and continuation token before retrying."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Interactive bucket browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects-paginated", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Combine prefixes and objects to render directory-style listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an object by name.",
        "operationId" : "RgwResource_deleteS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects-paginated" : {
      "get" : {
        "summary" : "List objects and prefixes in a bucket. Uses croit's pagination.",
        "operationId" : "RgwResource_listBucketObjectsAndPrefixes",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "description" : "Maximum number of S3 objects queried for filtering.",
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3ObjectsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide consistent server-side pagination over bucket contents with filtering and sorting support.",
          "usage" : [ "Use in UI tables that need deterministic paging and sorting", "Cache continuation tokens returned via pagination.after for subsequent calls" ],
          "response_shape" : "S3ObjectsResponse",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenant-aware lookups.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Restrict listing to objects with this prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter-based grouping.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          }, {
            "name" : "maxQueried",
            "in" : "query",
            "description" : "Upper bound for objects scanned per request (default 10000).",
            "required" : false,
            "example" : "5000"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to enumerate.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found", "400 if filters are invalid" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket ownership or refresh the inventory."
          }, {
            "code" : "400",
            "action" : "Adjust pagination filters or reduce maxQueried when timeouts occur."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Paginated object browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Merge prefixes with objects when presenting a tree view; use nextMarker caching to avoid re-querying prior pages.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/acl" : {
      "put" : {
        "summary" : "Override an object's ACL.",
        "operationId" : "RgwResource_setObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Object ACL",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/AclEntry"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current ACL of an object.",
        "operationId" : "RgwResource_getObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the ACL grants for a specific object.",
          "usage" : [ "Display permissions before editing", "Audit who has access to sensitive objects" ],
          "response_shape" : "array<AclEntry>",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key whose ACL to load.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object or bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the object key is correct and the user has permission to read it."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object ACL inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Highlight grants that provide public access or wildcard permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/copy" : {
      "put" : {
        "summary" : "Copy an object.",
        "operationId" : "RgwResource_copyS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/metadata" : {
      "put" : {
        "summary" : "Override object metadata.",
        "operationId" : "RgwResource_putS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "S3 metadata",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/S3Metadata"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get metadata of an object.",
        "operationId" : "RgwResource_getS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Metadata"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch S3 object metadata (size, content type, custom headers) without downloading the object.",
          "usage" : [ "Inspect metadata prior to downloads", "Verify custom metadata set by clients" ],
          "response_shape" : "S3Metadata",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to inspect.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object or bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Recheck the key (case sensitive) and ensure the bucket is selected correctly."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object metadata inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Expose both standard headers and user metadata distinctly in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/move" : {
      "put" : {
        "summary" : "Move an object.",
        "operationId" : "RgwResource_moveS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/policy" : {
      "post" : {
        "summary" : "Create or update a bucket policy. See the ceph documentation for the list of currently supported actions.",
        "operationId" : "RgwResource_setPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Bucket policy in JSON format",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a bucket policy.",
        "operationId" : "RgwResource_getPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the JSON policy attached to an S3 bucket.",
          "usage" : [ "Display the existing policy before editing", "Export policies for compliance reviews" ],
          "response_shape" : "BucketPolicy",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional bucket owner to resolve tenancy.",
            "required" : false,
            "example" : "tenant1:alice"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (may include tenant prefix).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket has no policy or does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Inform the user that no policy is set and offer to create one."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Policy inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Pretty-print the JSON before displaying to administrators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a bucket policy.",
        "operationId" : "RgwResource_deletePolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/quota" : {
      "put" : {
        "summary" : "Set a quota for this bucket.",
        "operationId" : "RgwResource_setBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/upload" : {
      "put" : {
        "summary" : "Upload an object.",
        "operationId" : "RgwResource_uploadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UploadS3ObjectRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/default-placement" : {
      "put" : {
        "summary" : "Set the default placement rule. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setDefaultPlacement",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "Default placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwDefaultPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements" : {
      "get" : {
        "summary" : "List all available placement policies in all zones.",
        "operationId" : "RgwResource_getPlacements",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwPlacementResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose RGW placement policies and the default placement for configuration UIs.",
          "usage" : [ "Load when editing bucket placement settings", "Refresh after creating or deleting placements" ],
          "response_shape" : "RgwPlacementResponse",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON. When omitted, placements array is returned; with pagination, data/total/after/limit are provided.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          } ],
          "failure_modes" : [ "200 with empty placements when no policies exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Prompt admins to create a placement before assigning buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Placement configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/buckets", "/s3/default-placement" ],
          "postprocessing_hint" : "Prefer the field data when pagination is used; fallback to placements otherwise.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/placements/{name}" : {
      "put" : {
        "summary" : "Create a new placement policy in the default zonegroup in the default zone. This API does not support multi-site setups.",
        "operationId" : "RgwResource_addPlacement",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name for the policy, each zone within a zonegroup must have a policy with the same name.",
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements/{placementRule}/storage-classes/{storageClass}" : {
      "put" : {
        "summary" : "Set storage classes on placement rules. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to add or edit.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Storage class configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwStorageClassRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a storage class on a placement rule. Deletes the entire placement rule when specifying the STANDARD storage class. This API does not support multi-site setups.",
        "operationId" : "RgwResource_deleteStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to remove, or STANDARD to remove the entire placement rule.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/usage/by-bucket/{bucketName}" : {
      "get" : {
        "summary" : "Retrieve latest usage statistics for a given S3 bucket.",
        "description" : "Return results aggregated into 1 hour intervals for all users that accessed the bucket.\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForBucketByUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Aggregate hourly RGW usage for a bucket across all users.",
          "usage" : [ "Feed billing reports or compliance exports", "Schedule periodic runs; avoid interactive polling" ],
          "response_shape" : "S3UsageForBucketByUserResponse",
          "request_parameters" : [ {
            "name" : "hours",
            "in" : "query",
            "description" : "Number of prior hours to include.",
            "required" : true,
            "example" : "24"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to analyze (with tenant if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket has no usage records" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Confirm usage logging is enabled and the bucket has recent activity."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-user/{uid}", "/stats" ],
          "postprocessing_hint" : "Group the returned per-user lists before persisting to accounting systems; trimming is triggered automatically.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/usage/by-user/{uid}" : {
      "get" : {
        "summary" : "Retrieve usage statistics for a given S3 user.",
        "description" : "Return results aggregated into 1 hour intervals for all buckets the user accessed. Caution: this cannot be used for the anonymous user\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForUserByBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Collect hourly RGW usage metrics for a specific user to feed billing or analytics.",
          "usage" : [ "Trigger on-demand reports and persist results externally", "Avoid frequent polling; schedule periodic exports instead" ],
          "response_shape" : "S3UsageForUserByBucketResponse",
          "request_parameters" : [ {
            "name" : "hours",
            "in" : "query",
            "description" : "Number of hours to include (integer).",
            "required" : true,
            "example" : "24"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to report on.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if usage data is unavailable or logging disabled" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify RGW usage logging is enabled and the user has activity within the requested window."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-bucket/{bucketName}", "/stats" ],
          "postprocessing_hint" : "Aggregate returned hourly buckets before billing; consider trimming data once exported.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/user-names" : {
      "get" : {
        "summary" : "Get list of RGW user names",
        "operationId" : "RgwResource_getRgwUsers",
        "tags" : [ "s3" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide a lightweight list of RGW user IDs for selectors or autocomplete.",
          "usage" : [ "Populate dropdowns when selecting a user", "Refresh occasionally to pick up new accounts" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "200 [] when RGW is not configured or no users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Fallback to an empty state and allow user creation."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Sort user IDs alphabetically before display.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users" : {
      "get" : {
        "summary" : "List of S3 users.",
        "operationId" : "RgwResource_getRgwUserInfo",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "uid",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW users with metadata for management or dashboards.",
          "usage" : [ "Render the S3 user inventory table", "Filter by uid to fetch specific users before editing" ],
          "response_shape" : "OptionalPaginationResponse<RgwUserResponse>",
          "request_parameters" : [ {
            "name" : "uid",
            "in" : "query",
            "description" : "Optional list of user IDs to fetch; when provided results are unpaginated.",
            "required" : false,
            "example" : "[\"user1\",\"user2\"]"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for general listing.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          } ],
          "failure_modes" : [ "200 [] when RGW is configured but no users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show onboarding guidance to create S3 users."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "User inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/user-names", "/s3/users/{uid}/keys" ],
          "postprocessing_hint" : "Merge cached data to avoid hitting RGW for every refresh.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create RGW user",
        "operationId" : "RgwResource_createRgwUser",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "New RGW user creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new RGW user account for S3 access.",
          "usage" : [ "Call before generating access keys via /s3/users/{uid}/keys.", "Provide tenant when working in multi-tenant deployments to segregate users." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "uid",
            "in" : "body",
            "description" : "Unique RGW user id.",
            "required" : true,
            "example" : "app-backups"
          }, {
            "name" : "tenant",
            "in" : "body",
            "description" : "Optional tenant identifier for multi-tenant setups.",
            "required" : false,
            "example" : "customer-a"
          }, {
            "name" : "defaultPlacement",
            "in" : "body",
            "description" : "Placement target for new buckets (optional).",
            "required" : false,
            "example" : "default-placement"
          } ],
          "failure_modes" : [ "400 if the user already exists", "400 if placement or storage class names are invalid", "503 if RGW is unavailable" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the uid or tenant and retry."
          }, {
            "code" : "503",
            "action" : "Wait for RGW availability; check cluster health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "RGW user provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/keys", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Immediately request credentials via /s3/users/{uid}/keys to complete onboarding.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}" : {
      "patch" : {
        "summary" : "Update RGW user",
        "operationId" : "RgwResource_updateRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW user",
        "operationId" : "RgwResource_deleteRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RGW user account and invalidate its credentials cache.",
          "usage" : [ "Call after migrating data away from the user or revoking access.", "Remove all keys and subusers beforehand to avoid orphaned credentials." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user id to remove.",
            "required" : true,
            "example" : "app-backups"
          } ],
          "failure_modes" : [ "404 if the user does not exist", "409 if the user still owns buckets or subusers" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /s3/users to confirm the uid before retrying."
          }, {
            "code" : "409",
            "action" : "Delete existing buckets or subusers tied to the user first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User deprovisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Invalidate any UI caches and update IAM dashboards to reflect the removal.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create RGW subuser",
        "operationId" : "RgwResource_createRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/bucket-quota" : {
      "put" : {
        "summary" : "Set a quota for all buckets owned by this user.",
        "operationId" : "RgwResource_setUserBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User bucket quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/buckets" : {
      "get" : {
        "summary" : "List all buckets owner by the user.",
        "operationId" : "RgwResource_getRgwBucketsForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwBucketResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List buckets owned by a specific RGW user, including usage and quotas.",
          "usage" : [ "Display per-user bucket inventory", "Validate bucket ownership before applying user-level policies" ],
          "response_shape" : "array<RgwBucketResponse>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID whose buckets to list.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt the operator to refresh or recreate the user before viewing buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory by user"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/users" ],
          "postprocessing_hint" : "Sum usage across buckets to show per-user totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file",
        "operationId" : "RgwResource_getS3CfgFile",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file containing credentials and endpoint info for an RGW user.",
          "usage" : [ "Offer the config download after creating or rotating credentials", "Avoid repeated downloads; regenerate when IPs or keys change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user or subuser ID (user or user:subuser).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist", "400 if no RGW gateway servers are available" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt admins to refresh the user list."
          }, {
            "code" : "400",
            "action" : "Ensure an RGW gateway is running before allowing downloads."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" ],
          "postprocessing_hint" : "Serve the download immediately; tokens are short-lived.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/key" : {
      "get" : {
        "summary" : "Get RGW user key",
        "operationId" : "RgwResource_getRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwUserKey"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the credentials for a specific S3 subuser or main user.",
          "usage" : [ "Display access/secret keys when downloading configuration files", "Call after key rotation to show the new credentials" ],
          "response_shape" : "RgwUserKey",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (format user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the key is not found", "403 if RGW is not configured" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt to create the key via PUT /users/{uid}/keys/{accessKey}."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users" ],
          "postprocessing_hint" : "Redact secretKey in logs and restrict exposure to admins.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys" : {
      "put" : {
        "summary" : "Update RGW keys",
        "operationId" : "RgwResource_updateRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW keys update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateKeysRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW user keys",
        "operationId" : "RgwResource_getRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all access keys belonging to a user or subuser.",
          "usage" : [ "Show existing keys before rotating or deleting", "Audit which subusers have credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Offer to create the user or refresh the list of S3 users."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/key" ],
          "postprocessing_hint" : "Mask secretKey values unless explicitly requested by an admin.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW user key",
        "operationId" : "RgwResource_removeRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW user key",
        "operationId" : "RgwResource_createRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/quota" : {
      "put" : {
        "summary" : "Set a quota for this user.",
        "operationId" : "RgwResource_setUserQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers" : {
      "put" : {
        "summary" : "Update RGW subusers",
        "operationId" : "RgwResource_updateRgwSubusers",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subusers update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateSubusersRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW subusers for user",
        "operationId" : "RgwResource_getRgwSubusersForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwSubUser"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List subusers belonging to an RGW account, including their permissions.",
          "usage" : [ "Load subusers before editing their keys or ACLs", "Display subuser information in account dashboards" ],
          "response_shape" : "array<RgwSubUser>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt creation of the user or refresh the users list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subuser inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/subusers/{subuser}/keys" ],
          "postprocessing_hint" : "Group results by permissions to highlight read-only subusers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}" : {
      "patch" : {
        "summary" : "Update RGW subuser",
        "operationId" : "RgwResource_updateRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW subuser",
        "operationId" : "RgwResource_deleteRgwSubser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file for subuser",
        "operationId" : "RgwResource_getS3CfgFileForsubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file scoped to a specific subuser.",
          "usage" : [ "Offer immediately after creating a subuser", "Reuse only until credentials or endpoints change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "backup"
          } ],
          "failure_modes" : [ "404 if user or subuser is unknown" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload subusers for the account and retry."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/cfg-file/download", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Download immediately; tokens expire quickly.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys" : {
      "get" : {
        "summary" : "Get RGW keys for subuser",
        "operationId" : "RgwResource_getRgwKeysForSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List credentials for a specific RGW subuser.",
          "usage" : [ "Review keys before regenerating or deleting", "Audit which subusers have active credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "alice:tenant"
          } ],
          "failure_modes" : [ "404 if user or subuser is missing" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Suggest reloading subusers or creating the subuser first."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" ],
          "postprocessing_hint" : "Mask secret keys in UI unless explicitly requested.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW key for subuser",
        "operationId" : "RgwResource_removeSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW key for subuser",
        "operationId" : "RgwResource_createSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/server-access/host-keys" : {
      "get" : {
        "summary" : "Get the SSH host keys configured on the servers as pairs of key type, public key.",
        "operationId" : "SshKeyResource_getHostKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/keys" : {
      "put" : {
        "summary" : "Replace all SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_replaceSshKeys",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/KeyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_getSshKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/passwords" : {
      "patch" : {
        "summary" : "Set server passwords",
        "operationId" : "SshKeyResource_setServerPasswords",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerAccessPasswords"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get server passwords.",
        "operationId" : "SshKeyResource_getServerPasswords",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ServerAccessPasswords"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers" : {
      "get" : {
        "summary" : "List all servers.",
        "operationId" : "ServerResource_getServers",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all managed servers including hardware, health and service metadata.",
          "usage" : [ "Populate inventory or overview tables before drilling into per-server details", "Refresh every 30 seconds at most when tracking cluster health in dashboards" ],
          "response_shape" : "OptionalPaginationResponse<ServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional JSON string (PaginationRequest) controlling sort, filters, offset and limit.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0,\"sortBy\":[[\"hostname\",\"ASC\"]]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Cap list size to avoid fetching every server on large clusters.",
            "pagination.where" : "Filter by hostname, roles or states before requesting details."
          },
          "failure_modes" : [ "200 [] when no servers match the applied filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat empty data as 'no servers discovered' and prompt setup if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared viewer polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/services", "/servers/ips" ],
          "postprocessing_hint" : "Derive UI aggregates (e.g. running service counts) from the response before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIps",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a simple list of free IP addresses within a subnet for quick selection.",
          "usage" : [ "Use in auto-complete inputs when assigning new IPs", "Run immediately before reserving an address to avoid stale results" ],
          "response_shape" : "array<string>",
          "request_parameters" : [ {
            "name" : "subnet",
            "in" : "query",
            "description" : "CIDR representing the pool to search (e.g. 10.0.0.0/24).",
            "required" : true,
            "example" : "10.0.0.0/24"
          }, {
            "name" : "limit",
            "in" : "query",
            "description" : "Maximum number of addresses to return.",
            "required" : true,
            "example" : "8"
          } ],
          "failure_modes" : [ "400 if subnet is invalid", "200 [] when no free IPs are found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate the subnet locally and show friendly feedback on formatting errors."
          }, {
            "code" : "200",
            "action" : "Fallback to a manual entry flow when no addresses are returned."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips-obj", "/servers/ips" ],
          "postprocessing_hint" : "Display the results in ascending order and avoid caching them beyond the current form interaction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips-obj" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIpsObjects",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseFreeIp"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate a list of free IP addresses within a subnet, returning structured records.",
          "usage" : [ "Call before provisioning new services to reserve free management IPs", "Use in UI workflows that require both IP and subnet context" ],
          "response_shape" : "OptionalPaginationResponse<FreeIp>",
          "request_parameters" : [ {
            "name" : "subnet",
            "in" : "query",
            "description" : "CIDR describing the pool to scan for free addresses (e.g. 10.0.0.0/24).",
            "required" : true,
            "example" : "10.0.0.0/24"
          }, {
            "name" : "limit",
            "in" : "query",
            "description" : "Maximum number of free addresses to return.",
            "required" : true,
            "example" : "16"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON if additional client-side paging is desired.",
            "required" : false,
            "example" : "{\"after\":0,\"limit\":10}"
          } ],
          "failure_modes" : [ "400 if the subnet parameter is not valid CIDR", "200 [] when no free addresses are available" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate CIDR formatting client-side and prompt the user to correct it."
          }, {
            "code" : "200",
            "action" : "Inform the user that no free IPs remain in the subnet."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips", "/servers/ips", "/servers/ips-with-subnet" ],
          "postprocessing_hint" : "Hold the response only transiently; recalculate before committing allocations to avoid races.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ha-groups" : {
      "get" : {
        "summary" : "List of all configured HA groups.",
        "operationId" : "HaGroupResource_getHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHaGroupResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create HA group",
        "operationId" : "HaGroupResource_createHagroup",
        "tags" : [ "ha-groups" ],
        "requestBody" : {
          "description" : "HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ha-groups/{id}" : {
      "put" : {
        "summary" : "Update HA group",
        "operationId" : "HaGroupResource_updateHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete HA group",
        "operationId" : "HaGroupResource_deleteHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ips" : {
      "get" : {
        "summary" : "List all IP addresses in use.",
        "operationId" : "ServerResource_listIps",
        "tags" : [ "servers" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpAddressInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return all IP addresses in use across NICs, VLANs, HA groups and SMB services.",
          "usage" : [ "Generate concise IP usage summaries before assigning new addresses", "Cross-check address ownership during troubleshooting sessions" ],
          "response_shape" : "IpAddressInfo",
          "failure_modes" : [ "200 with empty lists when no IP data has been discovered yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a guidance message to trigger hardware discovery if lists are empty."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "IP usage overview requests"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips-with-subnet", "/servers/free-ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Deduplicate IPv4/IPv6 entries before presenting, since some addresses appear in multiple categories.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ips-with-subnet" : {
      "get" : {
        "summary" : "List all used IP addresses with their subnet.",
        "operationId" : "ServerResource_listIpsWithSubnet",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpGeneralInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate IP addresses with subnet metadata for capacity analysis.",
          "usage" : [ "Run before allocating new addresses to ensure subnet availability", "Filter by subnet to produce reports for network teams" ],
          "response_shape" : "OptionalPaginationResponse<IpGeneralInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters (e.g. by subnet) and limits.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"subnetShort\":{\"_eq\":\"10.0.0.0/24\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no IPs match the requested filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Return an empty table and recommend verifying discovery if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subnet utilisation lookups"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Group results by subnetShort to highlight utilisation hotspots.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/nics" : {
      "get" : {
        "summary" : "List all nics.",
        "operationId" : "ServerResource_getAllNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NICs across all servers with bond and VLAN metadata.",
          "usage" : [ "Build global network inventory views or export NIC data", "Filter for unused interfaces before provisioning new services" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters, sorting and limits.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"bond\":{\"_is_null\":true}}]}"
          } ],
          "failure_modes" : [ "200 [] when no NICs exist in the cluster" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Present a zero-state hinting that hardware discovery has not completed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Cluster-wide NIC inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Aggregate by bond or NUMA node if needed in dashboards.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/reboot" : {
      "post" : {
        "summary" : "Reboot multiple servers",
        "operationId" : "ServerResource_rebootServers",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerRebootRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule reboots for multiple servers in one request.",
          "usage" : [ "Roll dozens of hosts after applying kernel or firmware patches.", "Automate controlled restarts during maintenance windows." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Set of server IDs to reboot.",
            "required" : true,
            "example" : "[21,22,23]"
          } ],
          "failure_modes" : [ "400 if the server list is empty or contains duplicates", "404 if any referenced server IDs are invalid", "200 ManagedTask(status=FAILED) if some nodes fail to reboot" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide at least one unique server ID."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and remove missing entries."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to determine which servers failed and retry individually."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Bulk reboot scheduling"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/shutdown", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/update-grub" : {
      "post" : {
        "summary" : "Update GRUB on all boot disks of the given servers.",
        "operationId" : "ServerResource_updateGrub",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateGrubRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Regenerate GRUB configurations on the selected servers' boot disks.",
          "usage" : [ "Run after modifying kernel parameters or reinstalling bootloaders.", "Execute during recovery workflows to ensure the correct boot image is selected." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "List of server IDs whose boot disks should be updated.",
            "required" : true,
            "example" : "[12,14]"
          } ],
          "failure_modes" : [ "400 if the server list is empty", "200 ManagedTask(status=FAILED) if bootloader updates fail on one or more hosts" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Specify at least one server ID before retrying."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask logs to resolve host-specific issues, then rerun for failed servers only."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Bootloader maintenance"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}" : {
      "patch" : {
        "summary" : "Update server",
        "operationId" : "ServerResource_updateServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update server metadata and optionally queue background tasks for image changes or hugepage reconfiguration.",
          "usage" : [ "Rename a server or adjust its management IP after hardware changes.", "Switch the boot image or adjust hugepage reservations prior to deploying NVMe-oF/DAOS services." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "hostname",
            "in" : "body",
            "description" : "Optional new hostname.",
            "required" : false,
            "example" : "ceph-node-3"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional management IPv4 address.",
            "required" : false,
            "example" : "192.168.10.23"
          }, {
            "name" : "image",
            "in" : "body",
            "description" : "Image UUID or 'default' to restore defaults.",
            "required" : false,
            "example" : "default"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes displayed in the UI.",
            "required" : false,
            "example" : "Reserved for DR testing"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "Number of 2MiB hugepages to configure.",
            "required" : false,
            "example" : "2048"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found", "400 if image validation fails or incompatible services are detected", "500 if background ManagedTask steps fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review validation errors (boot disks, compatibility warnings) and adjust the payload."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, resolve issues (e.g. image download failures), then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server configuration updates"
          },
          "related_endpoints" : [ "/servers/{id}", "/servers/{id}/reboot", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask and reboot the server if the image was changed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete server",
        "operationId" : "ServerResource_deleteServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a server from croit inventory after services and dependencies are cleared.",
          "usage" : [ "Retire hardware that has been physically removed from the cluster.", "Clean up failed installations before re-registering the host." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server is already gone", "400 if the server hosts DAOS resources", "400 if a monitor service is still assigned to the server" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the server list to confirm removal and skip further action."
          }, {
            "code" : "400",
            "action" : "Detach DAOS assignments or remove Ceph monitor services before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Server deletions"
          },
          "related_endpoints" : [ "/servers/{id}/services", "/servers/{id}/disks", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Update external inventory systems and reread GET /servers to ensure the host disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks" : {
      "get" : {
        "summary" : "List disks on the server.",
        "operationId" : "ServerResource_getDisks",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List disks attached to a specific server with live utilization details.",
          "usage" : [ "Inspect storage layout before scheduling OSD or service changes", "Refresh after maintenance to verify disk states and statistics" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling sorting, limit and filters.",
            "required" : false,
            "example" : "{\"limit\":25,\"where\":[{\"role\":{\"_eq\":\"osd\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric server identifier returned by GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server has no disks or the identifier is unknown" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Surface an empty-state message and prompt a rescan if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Heavy data payload per server"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers", "/disks", "/servers/{id}/services" ],
          "postprocessing_hint" : "Highlight disks with missing stats and merge with smart metrics if available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update disk",
        "operationId" : "ServerResource_updateDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update per-disk metadata, assign roles, or toggle identify LEDs for maintenance workflows.",
          "usage" : [ "Promote an unassigned disk to journal/DB/WAL after validation.", "Locate a disk in the chassis by enabling the identify LED." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "role",
            "in" : "body",
            "description" : "New disk role (e.g. journal).",
            "required" : false,
            "example" : "journal"
          }, {
            "name" : "partitions",
            "in" : "body",
            "description" : "Partition count when preparing journal disks.",
            "required" : false,
            "example" : "4"
          }, {
            "name" : "identifyLed",
            "in" : "body",
            "description" : "true to enable the LED, false to disable.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes stored with the disk.",
            "required" : false,
            "example" : "Installed in bay 4"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the disk is not associated with the specified server", "400 if the disk is missing, already assigned, or the role change is not supported", "500 if LED commands or journal preparation fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the disk inventory and retry with correct IDs."
          }, {
            "code" : "400",
            "action" : "Ensure the disk is unassigned/online and that requested roles match cluster state."
          }, {
            "code" : "500",
            "action" : "Check daemon logs for LED or journal preparation failures before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Disk metadata updates"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/wipe" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete disk",
        "operationId" : "ServerResource_deleteDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk record from a server after hardware replacement or removal.",
          "usage" : [ "Clear stale entries when a disk was taken out but the hardware scan has not run yet.", "Reset the inventory before reimporting a disk with a new role." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the disk ID is not associated with the server", "400 if DAOS currently uses the disk" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-run hardware detection or list disks to confirm valid IDs."
          }, {
            "code" : "400",
            "action" : "Detach the disk from DAOS engines before retrying the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Disk inventory cleanup"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}/smart" ],
          "postprocessing_hint" : "Run hardware re-detect or import to refresh disk listings after removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks/{diskId}/smart" : {
      "post" : {
        "summary" : "Update disk SMART details",
        "operationId" : "ServerResource_updateDiskSmartDetails",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DiskSmartStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an on-demand SMART data refresh for a specific disk.",
          "usage" : [ "Pull the latest health metrics before deciding to replace a disk.", "Validate alerts from monitoring systems with real-time SMART data." ],
          "response_shape" : "DiskSmartStatus",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the server or disk cannot be resolved", "500 if the SMART refresh task fails or times out" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh server/disk inventories and retry with correct IDs."
          }, {
            "code" : "500",
            "action" : "Inspect daemon task logs; ensure SMART tooling is healthy before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "SMART refresh"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics" : {
      "get" : {
        "summary" : "List nics on the server.",
        "operationId" : "ServerResource_getNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NIC inventory and link status for a specific server.",
          "usage" : [ "Load before rendering network configuration dialogs", "Re-query after applying NIC or VLAN changes to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or filter returned NICs.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"type\":{\"_neq\":\"virtual\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server has no NICs or the id is unknown" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state and suggest refreshing hardware data if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server NIC inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/nics", "/servers" ],
          "postprocessing_hint" : "Group bonded members and flag stale lastSeen values for manual review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/nics/bonds" : {
      "post" : {
        "summary" : "Create network bond",
        "operationId" : "ServerResource_createBond",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Bond creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BondRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an LACP or active/passive bond on a server and migrate existing IP configuration.",
          "usage" : [ "Call during network onboarding to aggregate multiple NICs under a single bond interface.", "Rebuild bonds after replacing physical adapters while preserving IP assignments." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Bond interface name (15 characters).",
            "required" : true,
            "example" : "bond0"
          }, {
            "name" : "nics[]",
            "in" : "body",
            "description" : "List of NIC IDs that form the bond (minimum two).",
            "required" : true,
            "example" : "[101,102]"
          }, {
            "name" : "activePassive",
            "in" : "body",
            "description" : "true for active/passive (mode 1), false for LACP.",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "primary",
            "in" : "body",
            "description" : "Primary NIC ID when activePassive=true.",
            "required" : false,
            "example" : "101"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if constraints are violated (duplicate name, <2 NICs, mixed NIC types, conflicting primary)", "404 if the server or one of the NIC IDs does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the payload to satisfy bond rulesensure NICs belong to the server and match the selected mode."
          }, {
            "code" : "404",
            "action" : "Refresh the server/NIC inventory and retry with valid identifiers."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Bond configuration"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Re-run hardware detection or networking checks to verify the bond state on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}" : {
      "patch" : {
        "summary" : "Update network interface",
        "operationId" : "ServerResource_updateNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NIC update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NicUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NIC addressing, notes, MAC address, or adjust bonded NIC membership on a server.",
          "usage" : [ "Reconfigure IPs after a network change.", "Replace a failed NIC while keeping MAC reservations up to date." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address (CIDR).",
            "required" : false,
            "example" : "192.168.120.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address (CIDR).",
            "required" : false,
            "example" : "fd00:120::5/64"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes stored with the NIC.",
            "required" : false,
            "example" : "Connected to TOR A"
          }, {
            "name" : "mac",
            "in" : "body",
            "description" : "Override MAC when replacing hardware (server must be offline).",
            "required" : false,
            "example" : "02:00:5e:10:00:00"
          }, {
            "name" : "bond.activePassive",
            "in" : "body",
            "description" : "Switch bond mode between active/passive and LACP.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "bond.primary",
            "in" : "body",
            "description" : "Primary NIC ID when active/passive mode is selected.",
            "required" : false,
            "example" : "101"
          }, {
            "name" : "bond.nics[]",
            "in" : "body",
            "description" : "New list of slave NIC IDs for the bond.",
            "required" : false,
            "example" : "[101,102]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier from GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "404 if the NIC does not belong to the server", "400 for invalid IP formats, unsupported MAC replacements, or incompatible bond settings", "500 if bonding operations fail while updating slave membership" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh NIC inventory before retrying."
          }, {
            "code" : "400",
            "action" : "Ensure the server is offline for MAC changes and that bond requests follow hardware constraints."
          }, {
            "code" : "500",
            "action" : "Inspect server logs for bonding errors; apply changes incrementally if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "NIC configuration changes"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/bonds", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Restart DHCP updates and verify network reachability after changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete network interface",
        "operationId" : "ServerResource_deleteNic",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a network interface record from the server inventory (and tear down virtual links).",
          "usage" : [ "Clean up NIC entries after replacing hardware or undoing temporary bonding.", "Delete misconfigured virtual interfaces before reapplying network settings." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "Identifier of the NIC to remove.",
            "required" : true,
            "example" : "58"
          } ],
          "failure_modes" : [ "404 if the NIC is not attached to the server", "400 if DAOS still references the NIC", "200 with warning when the NIC IP is used by a monitor service (requires manual acknowledgement)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the NIC list and choose a valid identifier."
          }, {
            "code" : "400",
            "action" : "Detach the NIC from DAOS engines before retrying."
          }, {
            "code" : "200",
            "action" : "If an ignorable warning cites a Ceph monitor IP, remove the monitor or change its address first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NIC deletions"
          },
          "postprocessing_hint" : "Trigger DHCP regeneration and re-run hardware detection to refresh NIC state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans" : {
      "get" : {
        "summary" : "List vlans configured on the nic.",
        "operationId" : "ServerResource_getVlans",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseVlanInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List VLAN interfaces configured on a specific NIC.",
          "usage" : [ "Inspect VLAN assignments before modifying network topology", "Verify applied VLAN changes after POST/PATCH operations" ],
          "response_shape" : "OptionalPaginationResponse<VlanInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or filter VLAN entries.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"vlan\":{\"_gte\":100}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "200 [] when the NIC has no VLANs or identifiers are invalid" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an empty list and prompt the user to add VLANs if needed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-NIC VLAN inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/nics" ],
          "postprocessing_hint" : "Present both IPv4 and IPv6 columns and indicate overlapping DHCP pools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add VLAN",
        "operationId" : "ServerResource_addVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewVlanRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Attach a tagged VLAN interface to a specific server NIC, including optional IPv4/IPv6 addresses.",
          "usage" : [ "Provision tenant networks on dedicated NICs.", "Restore VLAN configuration after replacing network hardware." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "vlan",
            "in" : "body",
            "description" : "VLAN tag to assign.",
            "required" : true,
            "example" : "110"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address for the VLAN.",
            "required" : false,
            "example" : "10.0.110.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address for the VLAN.",
            "required" : false,
            "example" : "fd00:110::5/64"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "400 if the IP conflicts with another interface on the server", "404 if the NIC does not belong to the server" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique IP assignments or clear conflicting addresses first."
          }, {
            "code" : "404",
            "action" : "Refresh NIC inventory and retry with the correct NIC ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN provisioning"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}/vlans/{vlanId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans/{vlanId}" : {
      "patch" : {
        "summary" : "Update VLAN",
        "operationId" : "ServerResource_updateVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VlanUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update VLAN tag or IP configuration for an existing VLAN interface on a NIC.",
          "usage" : [ "Change addressing after moving the VLAN to a new subnet.", "Adjust tagging when consolidating VLAN numbering." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "vlan",
            "in" : "body",
            "description" : "Optional new VLAN tag.",
            "required" : false,
            "example" : "120"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address (CIDR).",
            "required" : false,
            "example" : "10.0.120.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address (CIDR).",
            "required" : false,
            "example" : "fd00:120::5/64"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier hosting the VLAN.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "404 if the VLAN or NIC cannot be found", "400 if new IP assignments conflict with existing interfaces" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh VLAN listings before retrying."
          }, {
            "code" : "400",
            "action" : "Resolve IP conflicts or choose a unique VLAN tag before reissuing the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN updates"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Validate routing and DHCP settings after modifying VLAN parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete VLAN",
        "operationId" : "ServerResource_deleteVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a VLAN interface from a server NIC and clean up the underlying host link if possible.",
          "usage" : [ "Call after migrating VLAN traffic away from the interface.", "Undo temporary VLAN assignments made for maintenance tasks." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier within the server.",
            "required" : true,
            "example" : "58"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "404 if the NIC/VLAN combination does not exist", "200 with warning if the VLAN IP is still used by a monitor service", "500 if SSH cleanup fails; VLAN entry is still removed from the database" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the VLAN list for the NIC before retrying."
          }, {
            "code" : "200",
            "action" : "Acknowledge the ignorable warning and remove dependent monitor services before reassigning the IP."
          }, {
            "code" : "500",
            "action" : "Manually delete the VLAN on the host (ip link del) and retry hardware detection if required."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "VLAN removal"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Run hardware re-detect or reapply network configuration to confirm the VLAN disappeared on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/reboot" : {
      "post" : {
        "summary" : "Reboot server",
        "operationId" : "ServerResource_rebootServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule an immediate reboot of the specified server via the croit agent.",
          "usage" : [ "Restart a node after applying configuration changes.", "Recover a machine that requires a manual reboot outside of rolling operations." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server list and retry with a valid ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server reboot"
          },
          "related_endpoints" : [ "/servers/{id}/shutdown", "/servers/reboot" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/redetect" : {
      "post" : {
        "summary" : "Redetect hardware",
        "operationId" : "ServerResource_redetectHardware",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger the agent to rescan hardware (NICs, disks, etc.) for the specified server.",
          "usage" : [ "Refresh inventory after physically swapping components.", "Revalidate hardware information when monitoring detects discrepancies." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server inventory before retrying."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "Hardware re-detect"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services" : {
      "get" : {
        "summary" : "List services on the server.",
        "operationId" : "ServerResource_getServices",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph and gateway services running on a specific server.",
          "usage" : [ "Audit service placement before scheduling migrations", "Refresh after service start/stop actions to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<ServiceResource.MultiServerServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset and filters (e.g. by service type).",
            "required" : false,
            "example" : "{\"where\":[{\"type\":{\"_eq\":\"mon\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server runs no services" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state card noting that no services are scheduled on the host."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server service inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/servers/{id}/disks", "/servers" ],
          "postprocessing_hint" : "Highlight services with WARN/ERROR health before showing to the operator.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services/{serviceId}" : {
      "delete" : {
        "summary" : "Delete service",
        "operationId" : "ServerResource_deleteService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach a service instance from a specific server, optionally triggering managed removal tasks.",
          "usage" : [ "Remove a service from a node prior to decommissioning the server.", "Force-stop a misbehaving service by removing it from the host." ],
          "response_shape" : "ManagedTask?",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID assigned to the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if either the server or service mapping is unknown", "409 if the service manager refuses the removal because another operation holds the lock" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /servers/{id}/services to confirm the mapping before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other service control tasks to finish, then reissue the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server service removal"
          },
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/start", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/shutdown" : {
      "post" : {
        "summary" : "Shutdown server",
        "operationId" : "ServerResource_shutdownServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Gracefully shut down a server through the croit agent and mark it as shutting down.",
          "usage" : [ "Power off a node before hardware maintenance.", "Prepare servers for planned outages after migrating workloads." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server inventory and retry with a valid ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server shutdown"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/reboot" ],
          "postprocessing_hint" : "Update runbooks to reflect that the server is offline and monitor for daemon task completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the server via SSH.",
        "operationId" : "TerminalResource_connectToTerminalProxy",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mds" : {
      "post" : {
        "summary" : "Add MDS service",
        "operationId" : "ServerResource_addMdsService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a CephFS metadata server (MDS) on the specified host.",
          "usage" : [ "Scale CephFS metadata capacity by adding another MDS daemon.", "Recreate an MDS after host replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run the MDS daemon.",
            "required" : true,
            "example" : "25"
          } ],
          "failure_modes" : [ "400 if an MDS already runs on the server or CephFS setup blocks provisioning", "404 if the server ID cannot be found", "500 if key creation or daemon start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the server is not already hosting an MDS and CephFS pools are ready."
          }, {
            "code" : "404",
            "action" : "Refresh the server list before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs and fix host issues prior to reattempting."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "MDS provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mon" : {
      "post" : {
        "summary" : "Add monitor service",
        "operationId" : "ServerResource_addMonService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Monitor service creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MonServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a Ceph monitor on the specified server, provisioning keys and optional disk wiping.",
          "usage" : [ "Scale out the monitor quorum when adding new nodes.", "Redeploy a monitor after replacing hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "IPv4 address for the monitor to bind to.",
            "required" : true,
            "example" : "192.168.10.11"
          }, {
            "name" : "diskId",
            "in" : "body",
            "description" : "Disk ID used for the monitor store; will be wiped if necessary.",
            "required" : true,
            "example" : "104"
          } ],
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that should host the monitor.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if Ceph is not yet configured or a duplicate monitor exists", "404 if the server or disk ID is invalid", "500 if key creation or service start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Deploy the initial monitor first or remove existing monitor instances."
          }, {
            "code" : "404",
            "action" : "Refresh server/disk inventories before retrying."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log, resolve host issues, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Monitor provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rbd-mirror" : {
      "post" : {
        "summary" : "Start a rbd mirror daemon on the server. Only one rbd mirror daemon is allowed to run on each server.",
        "operationId" : "ServerResource_addRbdMirrorService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an rbd-mirror daemon on the specified server, including keyring creation.",
          "usage" : [ "Provision replication capacity between clusters by adding mirror daemons.", "Recreate a mirror daemon after node recovery." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run rbd-mirror.",
            "required" : true,
            "example" : "31"
          } ],
          "failure_modes" : [ "400 if a mirror daemon already exists on the server or required packages are missing", "404 if the server ID cannot be resolved", "500 if key creation or daemon start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure rbd-mirror is installed and no other mirror service exists on the host."
          }, {
            "code" : "404",
            "action" : "Refresh the server list and retry."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to resolve host issues before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "rbd-mirror provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rgw" : {
      "post" : {
        "summary" : "Add RGW service",
        "operationId" : "ServerResource_addRgwService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a RADOS Gateway (RGW) instance on the specified server.",
          "usage" : [ "Scale RGW capacity by adding additional gateways.", "Recreate an RGW daemon after server replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will host the RGW service.",
            "required" : true,
            "example" : "28"
          } ],
          "failure_modes" : [ "400 if an RGW already runs on the server", "404 if the server ID cannot be found", "500 if key creation, Ceph configuration, or daemon startup fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure multi-RGW per server is enabled or remove the existing RGW first."
          }, {
            "code" : "404",
            "action" : "Refresh GET /servers and retry with a valid ID."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs, resolve host issues, and rerun the deployment."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RGW provisioning"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/servers/{serverId}/services/{serviceId}/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServerResource_restartServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a service instance on a specific server.",
          "usage" : [ "Bounce a daemon after applying configuration changes on a single node.", "Recover a service exhibiting issues without affecting other replicas." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not bound to the server", "409 if another control task conflicts", "500 if the restart fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server's service list before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other actions to complete."
          }, {
            "code" : "500",
            "action" : "Review server logs to resolve issues and retry once healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service restart"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServerResource_startServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service instance on a particular server.",
          "usage" : [ "Bring a daemon online on a chosen node without affecting other replicas.", "Recover a service after host maintenance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to start on the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not associated with the server", "409 if another control action is in progress", "500 if the daemon fails to start" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List services for the server and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to complete before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect logs on the server to fix underlying issues prior to reissuing the command."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service start"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/stop", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServerResource_stopServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance running on a specific server.",
          "usage" : [ "Drain a daemon prior to host maintenance.", "Temporarily disable a problematic service on one server." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not linked to the server", "409 if other control operations are pending", "500 if the daemon fails to stop" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List server services to confirm mapping before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for existing tasks to finish."
          }, {
            "code" : "500",
            "action" : "Investigate logs on the server and retry once issues are resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service stop"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServerResource_restartServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "description" : "",
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Bounce a daemon after applying configuration updates.", "Recover an OSD exhibiting issues on a particular node." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "404 if the mapping is invalid", "409 if a conflicting task is already queued", "500 if the restart fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the mapping via GET /servers/{serverId}/services before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to finish."
          }, {
            "code" : "500",
            "action" : "Inspect logs on the server; resolve issues before running again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD restart"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServerResource_startServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service or OSD on a given server, disambiguating by type.",
          "usage" : [ "Start an OSD process on its host after maintenance.", "Bring a specific service replica online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "404 if the specified ID is not associated with the server", "409 if another control action conflicts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch the server's service/OSD list and retry with a valid ID."
          }, {
            "code" : "409",
            "action" : "Retry after existing operations complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD start"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/stop", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServerResource_stopServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Drain an OSD or service prior to maintenance.", "Temporarily disable a daemon causing issues." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service or OSD ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the mapping is invalid", "409 if another control task is in progress" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server's service list and retry."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to complete before reissuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD stop"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "ServerResource_testSshConnection",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Use SSH with retries.",
          "name" : "retry",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Run a simple SSH connectivity test against the specified server (optionally with retries).",
          "usage" : [ "Diagnose SSH access issues before scheduling tasks that require remote commands.", "Measure whether retry logic is needed for unstable connections." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "sleep",
            "in" : "query",
            "description" : "Sleep duration (seconds) per iteration to simulate work.",
            "required" : false,
            "example" : "1"
          }, {
            "name" : "retry",
            "in" : "query",
            "description" : "true to use the retry-enabled SSH client.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found", "500 if SSH connection attempts fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Review server reachability, credentials, and logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "SSH diagnostics"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/redetect" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services" : {
      "get" : {
        "summary" : "List of all services across all servers.",
        "operationId" : "ServiceResource_getAllServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph and croit services with health, state, and placement details.",
          "usage" : [ "Call to render the service inventory dashboard with pagination support.", "Refresh after starting/stopping services or during maintenance to monitor state transitions." ],
          "response_shape" : "OptionalPaginationResponse<MultiServerServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"type\":{\"_eq\":\"osd\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":50,\"order\":[{\"state\":\"asc\"}]}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter to service types like mon/mds/nfs before bulk actions.",
            "pagination.where.running" : "Focus on stopped services when triaging issues."
          },
          "failure_modes" : [ "200 data=[],total=0 when no services match the filter" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Relax filters or confirm that services have been provisioned before retrying."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Service monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/{serviceId}", "/services/restart" ],
          "postprocessing_hint" : "Group services by type and highlight entries with health.uptime=null to indicate unseen daemons.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi" : {
      "post" : {
        "summary" : "Create a new iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addIscsiGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "iSCSI gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision the single supported iSCSI gateway cluster and deploy ceph-iscsi gateways on selected servers.",
          "usage" : [ "Call during initial setup to instantiate the iSCSI control plane.", "Use after wiping an old deployment (servers rebooted) to recreate the gateway." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[].serverId",
            "in" : "body",
            "description" : "Server ID to host the gateway instance.",
            "required" : true,
            "example" : "101"
          }, {
            "name" : "servers[].ip",
            "in" : "body",
            "description" : "Client-facing IP already configured on the server.",
            "required" : true,
            "example" : "192.168.10.50"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional display name for the gateway.",
            "required" : false,
            "example" : "Primary iSCSI cluster"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or a second gateway is attempted", "404 if any referenced server ID does not exist", "409 if another creation task is currently running", "500 if Ceph pool or ceph-iscsi provisioning fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Configure CephFS and ensure only one gateway is defined before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and submit only managed server IDs."
          }, {
            "code" : "409",
            "action" : "Wait for the existing creation task to finish; retry if it failed."
          }, {
            "code" : "500",
            "action" : "Inspect task logs, reboot gateway servers if necessary, then re-run the creation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "iSCSI cluster provisioning"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "Monitor the ManagedTask output; once complete, verify gateway health via GET /services/iscsi.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}" : {
      "patch" : {
        "summary" : "Update an iSCSI gateway.",
        "operationId" : "IscsiServiceResource_updateIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable metadata on the iSCSI gateway service (currently the description).",
          "usage" : [ "Rename the gateway in the UI after reassigning responsibilities.", "Clarify the service description following infrastructure changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional new description shown to operators.",
            "required" : false,
            "example" : "Production iSCSI service"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID to update.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service ID cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi to confirm the service still exists before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI metadata update"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Inspect the ceph-iscsi gateway configuration.",
        "operationId" : "IscsiServiceResource_getIscsiGatewayConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiGatewayConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the ceph-iscsi configuration snapshot for the selected gateway.",
          "usage" : [ "Load the gateway detail view before presenting targets and clients.", "Refresh after finishing gateway maintenance or changing the active target." ],
          "response_shape" : "IscsiGatewayConfig",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "200 with empty clients/disks lists when no exports are configured", "500 if reading gateway.conf from the Ceph iSCSI config pool fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state and guide the user to add disks or clients."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and ensure the iSCSI config pool exists before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Gateway configuration refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI service.",
        "operationId" : "IscsiServiceResource_deleteIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down the iSCSI gateway service and purge its Ceph-side configuration.",
          "usage" : [ "Invoke when decommissioning the iSCSI deployment or migrating to new hardware.", "Use before recreating the gateway to ensure no residual configuration remains." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier as returned by GET /services/iscsi.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service ID no longer exists", "500 if another operation currently modifies the gateway or Ceph config cleanup fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the iSCSI service list and retry only if the gateway still exists."
          }, {
            "code" : "500",
            "action" : "Wait for concurrent tasks to finish, inspect server logs, then retry the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway removal"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Inform operators that affected servers must be rebooted before provisioning a new gateway.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a server to an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addServerToIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayServer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale out the iSCSI gateway by adding another server with its client-facing IP.",
          "usage" : [ "Use when onboarding a new gateway node to increase throughput.", "Call after replacing hardware to reinstate the node into the gateway cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "serverId",
            "in" : "body",
            "description" : "Server ID being added to the gateway.",
            "required" : true,
            "example" : "102"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Client-facing IP already configured on the server.",
            "required" : true,
            "example" : "192.168.10.51"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Existing iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service or server ID is unknown", "409 if ceph-iscsi reports the gateway is already defined on the host", "500 if starting the gateway daemon or reconfiguring peers fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch the current gateway and server list, then retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Ensure the server was rebooted after previous deletions and retry once the daemon is stopped."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log for details; address host issues before re-running."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway scaling"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "After success, run GET /services/iscsi/{serviceId} to confirm the new server appears and is healthy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}" : {
      "delete" : {
        "summary" : "Delete an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an iSCSI client definition and revoke its access credentials.",
          "usage" : [ "Call when retiring a host that should no longer access exported LUNs.", "Use before recreating the client with new CHAP secrets to avoid duplicates." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN as shown in the gateway configuration.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the service or client name cannot be found", "500 if the gateway rejects the deletion request" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} to confirm current clients before retrying."
          }, {
            "code" : "500",
            "action" : "Verify gateway connectivity and logs, then retry once the control plane is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI client removal"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Re-run GET /services/iscsi/{serviceId} to confirm the client entry is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Configure a new iSCSI client",
        "operationId" : "IscsiServiceResource_createIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI client entry (CHAP credentials plus optional host group assignment).",
          "usage" : [ "Add a new initiator to access exported LUNs.", "Recreate a client with fresh credentials during onboarding." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "CHAP username (8-64 chars).",
            "required" : true,
            "example" : "client-user"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "CHAP secret (12-16 chars).",
            "required" : true,
            "example" : "Sup3rS3cret123"
          }, {
            "name" : "group",
            "in" : "body",
            "description" : "Optional host group to auto-assign.",
            "required" : false,
            "example" : "prod-nodes"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Desired client name or IQN.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newhost"
          } ],
          "failure_modes" : [ "400 if the credentials fail validation or host group assignment is invalid", "404 if the service ID is unknown", "500 if the gateway cannot create the client" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure username/password meet length requirements and host group exists."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi to confirm the service ID."
          }, {
            "code" : "500",
            "action" : "Check iscsi-gateway logs; delete any partial client and retry once healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI client creation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "patch" : {
        "summary" : "Change a client's username/password",
        "operationId" : "IscsiServiceResource_changeIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate CHAP credentials for an existing iSCSI client.",
          "usage" : [ "Update secrets after a credential leak or scheduled rotation.", "Rename the client user while preserving existing LUN mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "Optional new CHAP username (8-64 chars).",
            "required" : false,
            "example" : "client-rotated"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Optional new CHAP secret (12-16 chars).",
            "required" : false,
            "example" : "N3wSecret123456"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Existing client name/IQN to update.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the client cannot be found", "500 if the gateway rejects the update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the client list to verify the name before retrying."
          }, {
            "code" : "500",
            "action" : "Check gateway logs; if the update partially applied, reapply with consistent credentials."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI credential rotation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}/disks" : {
      "delete" : {
        "summary" : "Unmap a disk from an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteLunFromIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an exported RBD image (LUN) from an iSCSI client without deleting the data.",
          "usage" : [ "Invoke when revoking a client's access to a specific disk before remapping it elsewhere.", "Use during maintenance to unmap volumes ahead of storage reconfiguration." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body.pool",
            "in" : "body",
            "description" : "RBD pool that hosts the disk to unmap.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.name",
            "in" : "body",
            "description" : "RBD image name to remove from the client mapping.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN whose mapping should be removed.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the LUN is not mapped to the client", "500 if the gateway connection fails or rejects the update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId}/clients/{name}/disks to confirm active mappings before retrying."
          }, {
            "code" : "500",
            "action" : "Check gateway logs/connectivity, then rerun once the management plane is responsive."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI LUN detach"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "postprocessing_hint" : "After success, refresh the client's disk list to verify the mapping is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add new disk(s) to an iSCSI client",
        "operationId" : "IscsiServiceResource_addLunToIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image will be created if it doesn't exist yet",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map existing or newly created RBD images to an iSCSI client.",
          "usage" : [ "Provision LUNs for a host by creating and exporting images in one call.", "Re-attach disks to a client after recreating credentials." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].pool",
            "in" : "body",
            "description" : "RBD pool for the disk.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "[].name",
            "in" : "body",
            "description" : "RBD image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "[].size",
            "in" : "body",
            "description" : "Size in MB for new images (null to use existing).",
            "required" : false,
            "example" : "102400"
          }, {
            "name" : "[].backstore",
            "in" : "body",
            "description" : "Backstore type (USER/USERBLOCK/...) when supported.",
            "required" : false,
            "example" : "USER"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN receiving the disks.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "400 if backstore changes are attempted on unsupported servers or the LUN already exists", "404 if the service or client is unknown", "500 if Ceph or the gateway fails during mapping" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure backstore options match server OS and avoid duplicate mappings."
          }, {
            "code" : "404",
            "action" : "Confirm the service/client exists via GET /services/iscsi/{serviceId}."
          }, {
            "code" : "500",
            "action" : "Check gateway logs; remove partially created disks before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk mapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/disks" : {
      "get" : {
        "summary" : "List iSCSI RBD exports for a gateway.",
        "operationId" : "IscsiServiceResource_getImages",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Include image details",
          "name" : "details",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiImagesResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images exported by the iSCSI gateway, optionally with metadata.",
          "usage" : [ "Populate the disks tab for an iSCSI gateway detail view.", "Refresh after adding, deleting or resizing LUNs." ],
          "response_shape" : "IscsiImagesResponse",
          "request_parameters" : [ {
            "name" : "details",
            "in" : "query",
            "description" : "true to include per-disk metadata (pool, WWN, controls).",
            "required" : false,
            "default" : "false",
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "200 with disks=[] when no exports exist", "404 if the gateway has no active servers to answer API requests", "500 if the ceph-iscsi API call fails or gateway.conf cannot be read" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Render an empty state and prompt creation of new exports."
          }, {
            "code" : "404",
            "action" : "Refresh the gateway list and ensure at least one server is assigned and online."
          }, {
            "code" : "500",
            "action" : "Inspect ceph-iscsi logs and verify API credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi/{serviceId}/disks/{wwn}" : {
      "patch" : {
        "summary" : "Update parameters for an exported RBD image.",
        "operationId" : "IscsiServiceResource_updateDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Image change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiImageChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an exported iSCSI disk without removing it from clients.",
          "usage" : [ "Grow a LUN after expanding underlying storage.", "Adjust disk size during maintenance while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "New disk size in MB.",
            "required" : true,
            "example" : "102400"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID owning the disk.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "Disk WWN identifier as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "404 if the disk cannot be found by WWN", "500 if Ceph rejects the resize or the gateway API fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the disk list and retry with the current WWN."
          }, {
            "code" : "500",
            "action" : "Inspect gateway/Ceph logs; ensure the new size is valid before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI disk resize"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI-managed disk",
        "operationId" : "IscsiServiceResource_deleteIscsiImage",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an exported iSCSI disk and optionally remove the backing RBD image.",
          "usage" : [ "Call when retiring a LUN after data migration.", "Use to free capacity once a client no longer needs the associated disk." ],
          "response_shape" : "ManagedTask?",
          "request_parameters" : [ {
            "name" : "body.deleteData",
            "in" : "body",
            "description" : "Set true to delete the RBD data, false to only remove the export.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "body.pool",
            "in" : "body",
            "description" : "Pool that stores the image; must match gateway metadata.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.image",
            "in" : "body",
            "description" : "RBD image name to confirm for deletion.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "World Wide Name of the disk as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "404 if the WWN is unknown to the gateway", "500 if the pool/image confirmation does not match gateway metadata or Ceph rejects disk deletion" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the iSCSI disk list to obtain the current WWN before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect gateway and Ceph logs; correct mismatched parameters or retry once the storage backend is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI disk deletion"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "If deleteData=true, wait for the ManagedTask to finish before reusing the pool/image name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}" : {
      "delete" : {
        "summary" : "Delete a host group.",
        "operationId" : "IscsiServiceResource_deleteHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an iSCSI host group after unmapping its members.",
          "usage" : [ "Call once all hosts and disks have been reassigned and the group is no longer needed.", "Use prior to recreating the group with a different membership or policy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name as displayed by the gateway.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the group does not exist", "500 if the gateway refuses to remove the group while hosts or disks remain mapped" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} to confirm current groups before retrying."
          }, {
            "code" : "500",
            "action" : "Remove remaining host/disk mappings, acknowledge the warning, then delete again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group updates"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "postprocessing_hint" : "Warn operators that mapped images stay attached until explicitly unmapped.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new host group.",
        "operationId" : "IscsiServiceResource_createHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI host group to manage access for multiple clients.",
          "usage" : [ "Organize initiators before mapping disks in bulk.", "Prepare a group for automated provisioning workflows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Name of the host group to create.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the service ID is invalid", "500 if the gateway refuses to create the host group" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi and retry with a valid service ID."
          }, {
            "code" : "500",
            "action" : "Inspect gateway logs; ensure the group name is unique before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group creation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/disks" : {
      "delete" : {
        "summary" : "Remove a disk from a host group.",
        "operationId" : "IscsiServiceResource_deleteDiskFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach RBD disks from an iSCSI host group without deleting the images.",
          "usage" : [ "Trim group access before assigning disks to a different client or group.", "Use as part of group decommissioning to clear remaining disk mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body.pool",
            "in" : "body",
            "description" : "Pool containing the disk to remove from the group.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.name",
            "in" : "body",
            "description" : "RBD image name to unmap from the group.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the disk mapping is unknown to the group", "500 if the gateway API fails while updating masks" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh group disk listings and retry with a current pool/image pair."
          }, {
            "code" : "500",
            "action" : "Check ceph-iscsi logs; retry once connectivity is restored."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk unmapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Verify the host groups access list in GET /services/iscsi/{serviceId} to confirm removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add disks to a host group.",
        "operationId" : "IscsiServiceResource_addDiskToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of disks to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map one or more RBD images to every client in a host group.",
          "usage" : [ "Grant a fleet of initiators access to new storage in a single call.", "Pre-provision LUNs before adding hosts to the group." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].pool",
            "in" : "body",
            "description" : "RBD pool for each disk.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "[].name",
            "in" : "body",
            "description" : "RBD image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "[].size",
            "in" : "body",
            "description" : "Optional size in MB for images that should be created if missing.",
            "required" : false,
            "example" : "102400"
          }, {
            "name" : "[].backstore",
            "in" : "body",
            "description" : "Backstore type (defaults to USER).",
            "required" : false,
            "example" : "USER"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Target host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "400 if changing backstore is unsupported or images already exist in the group", "404 if the service or group is unknown", "500 if gateway operations fail while adding mappings" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm backstore compatibility and avoid duplicate mappings."
          }, {
            "code" : "404",
            "action" : "List host groups to verify the name before retrying."
          }, {
            "code" : "500",
            "action" : "Check iscsi-gateway logs; remove partially added disks before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group disk mapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts" : {
      "delete" : {
        "summary" : "Remove hosts from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostsFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove multiple hosts from an iSCSI host group in a single call.",
          "usage" : [ "Call when bulk decommissioning initiators or moving them to another group.", "Use before deleting the host group to ensure no members remain." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body[]",
            "in" : "body",
            "description" : "Array of host identifiers (IQNs) to remove.",
            "required" : true,
            "example" : "[\"iqn.1993-08.org.debian:01:node01\", \"iqn.1993-08.org.debian:01:node02\"]"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if any supplied host is not associated with the group", "500 if the gateway API fails mid-update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-read group membership and retry with only existing hosts."
          }, {
            "code" : "500",
            "action" : "Check ceph-iscsi logs and retry once the control plane is responsive."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk iSCSI host unassign"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "postprocessing_hint" : "Confirm that remaining hosts are correct before assigning new disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add hosts to a host group.",
        "operationId" : "IscsiServiceResource_addHostsToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of hosts to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bulk add multiple initiator IQNs to an iSCSI host group.",
          "usage" : [ "Onboard a batch of servers that should share the same LUN set.", "Restore group membership after recreating host entries." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body[]",
            "in" : "body",
            "description" : "Array of host IQNs to add to the group.",
            "required" : true,
            "example" : "[\"iqn.1993-08.org.debian:01:node01\",\"iqn.1993-08.org.debian:01:node02\"]"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the service or group does not exist", "500 if any host fails to join" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the group exists via GET /services/iscsi/{serviceId} before retrying."
          }, {
            "code" : "500",
            "action" : "Review gateway logs and retry with hosts that succeeded removed from the list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk host enrollment"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" : {
      "delete" : {
        "summary" : "Remove a host from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single host from an iSCSI host group while leaving its disk mappings intact.",
          "usage" : [ "Call when revoking a specific initiators access to the group.", "Use ahead of moving the host into a different group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to remove.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:node01"
          } ],
          "failure_modes" : [ "404 if the host is not currently part of the group", "500 if the gateway rejects the membership update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List group hosts and retry with a valid identifier."
          }, {
            "code" : "500",
            "action" : "Inspect ceph-iscsi logs, resolve connectivity issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host unassign"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add a host to a host group.",
        "operationId" : "IscsiServiceResource_addHostToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add a single initiator IQN to an existing iSCSI host group.",
          "usage" : [ "Grant an additional server access to the group's mapped LUNs.", "Re-enroll a host that was previously removed from the group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to add.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newnode"
          } ],
          "failure_modes" : [ "404 if the service or group does not exist", "500 if the gateway fails to add the host" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List host groups to verify the group name and ensure the service ID is valid."
          }, {
            "code" : "500",
            "action" : "Inspect gateway logs; confirm the host IQN is formatted correctly before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host enrollment"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/servers/{hostname}" : {
      "delete" : {
        "summary" : "Remove a server from an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_removeServerFromIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostname",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach one gateway server from the iSCSI cluster, stopping its service and cleaning ceph-iscsi config entries.",
          "usage" : [ "Call during node maintenance or decommission to drain a specific server from the gateway.", "Use before deleting the entire gateway to remove surplus servers cleanly." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier (see GET /services/iscsi).",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "hostname",
            "in" : "path",
            "description" : "Server hostname/FQDN exactly as registered with the gateway.",
            "required" : true,
            "example" : "gw1.example.com"
          } ],
          "failure_modes" : [ "400 if attempting to remove the final server from the gateway", "404 if the service or hostname cannot be mapped to the gateway", "500 if another management action currently locks the service" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use DELETE /services/iscsi/{serviceId} to remove the last server instead."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} and retry with a current hostname."
          }, {
            "code" : "500",
            "action" : "Wait for concurrent tasks to finish, then rerun the removal."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway node removal"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion before reusing the server for other roles.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/target" : {
      "put" : {
        "summary" : "Set iSCSI target to be used in other endpoints",
        "operationId" : "IscsiServiceResource_setIscsiTarget",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Target IQN string",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "string"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set or override the global target IQN used for a specific iSCSI service.",
          "usage" : [ "Adjust target IQN after importing an existing configuration.", "Correct the target identifier when recovering from configuration drift." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body",
            "in" : "body",
            "description" : "Target IQN string.",
            "required" : true,
            "example" : "iqn.2003-01.com.example:iscsi-gw"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if the provided IQN is not present in the ceph-iscsi configuration", "404 if the service ID cannot be found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review the warning emitted by ignorableWarnings and confirm if overriding is intended."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi and retry with a valid service ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI target IQN update"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the ceph-iscsi config shell",
        "operationId" : "IscsiServiceResource_connectToIscsiTerminal",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Open an authenticated shell session on the active iSCSI gateway server for manual iscsi-config commands.",
          "usage" : [ "Use for troubleshooting ceph-iscsi configuration without SSHing manually.", "Call to automate scripted adjustments via the exposed terminal stream." ],
          "response_shape" : "TerminalConnection",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID whose active node should be targeted.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service or active server cannot be determined", "500 if the shell session fails to initialize" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the gateway is running and retry once an active server is available."
          }, {
            "code" : "500",
            "action" : "Check terminal service logs; attempt a new connection after resolving host issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "iSCSI management shell"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Close the terminal when finished; state changes may require subsequent API calls to refresh cached data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways" : {
      "post" : {
        "summary" : "Create a new NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "NFS gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NFS cluster backed by CephFS across the selected servers.",
          "usage" : [ "Run during initial setup to expose CephFS over NFS.", "Recreate the cluster after a teardown to restore service." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "List of server IDs that will host the ganesha daemons.",
            "required" : true,
            "example" : "[12,13,14]"
          }, {
            "name" : "exports[]",
            "in" : "body",
            "description" : "Optional exports to seed during creation.",
            "required" : false,
            "example" : "[{\"nfsPath\":\"/exports/data\",\"backendPath\":\"/cephfs/data\"}]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional human-readable description shown in the UI.",
            "required" : false,
            "example" : "Production NFS"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or a server already participates in another NFS cluster", "404 if any referenced server ID does not exist", "500 if ganesha provisioning fails on a target host" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Configure CephFS and ensure each server belongs to at most one NFS cluster."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and resubmit valid IDs."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log; resolve host issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "NFS cluster provisioning"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "postprocessing_hint" : "Monitor the task until completion and confirm cluster health via GET /services/nfs-gateways/{serviceId}.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}" : {
      "patch" : {
        "summary" : "Update an NFS cluster.",
        "operationId" : "NfsServiceResource_patchNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NfsGatewayServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NFS cluster metadata and server membership.",
          "usage" : [ "Adjust the cluster description or server list after hardware changes.", "Swap out nodes while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Optional new server list replacing the existing membership.",
            "required" : false,
            "example" : "[12,15,16]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional updated description shown in the UI.",
            "required" : false,
            "example" : "NFS cluster for analytics"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if a server is already part of another NFS cluster", "404 if the service ID or referenced servers are unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure servers belong to only one NFS cluster before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh service/server inventories and resubmit with valid IDs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS cluster updates"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Retrieve the NFS cluster configuration snapshot.",
        "operationId" : "NfsServiceResource_getNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayService"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve servers and exports configured for the NFS gateway cluster.",
          "usage" : [ "Load the NFS cluster detail view for administrators.", "Refresh after modifying servers or exports to confirm the applied state." ],
          "response_shape" : "NfsGatewayService",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 with exports=[] and servers=[] when no configuration exists yet" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service inventory and retry with an existing cluster ID."
          }, {
            "code" : "400",
            "action" : "Ensure the selected service is of type nfs_gateway before proceeding."
          }, {
            "code" : "200",
            "action" : "Display an empty state explaining that no servers or exports are assigned yet."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS cluster detail refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports" : {
      "get" : {
        "summary" : "List exports belonging to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/NfsGatewayExport"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List exports defined for the NFS gateway cluster.",
          "usage" : [ "Populate the exports tab in the NFS cluster view.", "Refresh after creating, updating or deleting an export." ],
          "response_shape" : "array<NfsGatewayExport>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 [] when the cluster currently has no exports" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the cluster still exists and retry."
          }, {
            "code" : "400",
            "action" : "Ensure only NFS gateway IDs are used for this call."
          }, {
            "code" : "200",
            "action" : "Show an empty state inviting the user to create exports."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS export list polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add an export to the NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayExport"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NFS export and trigger the ganesha daemons to apply it.",
          "usage" : [ "Expose new CephFS directories over NFS.", "Call after preparing data that should be served to clients." ],
          "response_shape" : "NfsGatewayExport",
          "request_parameters" : [ {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "Export path visible to clients.",
            "required" : true,
            "example" : "/exports/data"
          }, {
            "name" : "backendPath",
            "in" : "body",
            "description" : "CephFS path backing the export.",
            "required" : true,
            "example" : "/cephfs/data"
          }, {
            "name" : "squash",
            "in" : "body",
            "description" : "Optional squash policy (e.g. root_squash).",
            "required" : false,
            "example" : "root_squash"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if an export with the same nfsPath already exists", "404 if the service ID is invalid", "500 if ganesha fails to reload the configuration" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List existing exports and choose a unique nfsPath."
          }, {
            "code" : "404",
            "action" : "Ensure the cluster still exists before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ganesha logs on member servers; resolve issues then resubmit."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export creation"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports/{exportId}", "/services/nfs-gateways/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports/{exportId}" : {
      "put" : {
        "summary" : "Replace an export entry on the NFS cluster.",
        "operationId" : "NfsServiceResource_replaceNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing NFS export definition with new parameters.",
          "usage" : [ "Adjust export paths or permissions after reorganizing data.", "Update squash or client access settings without recreating the export." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "New export path presented to clients.",
            "required" : true,
            "example" : "/exports/data"
          }, {
            "name" : "backendPath",
            "in" : "body",
            "description" : "CephFS path backing the export.",
            "required" : true,
            "example" : "/cephfs/data"
          }, {
            "name" : "squash",
            "in" : "body",
            "description" : "Squash mode (e.g. root_squash).",
            "required" : false,
            "example" : "root_squash"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Existing export identifier.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the export ID or service ID is unknown", "500 if ganesha reload fails or servers reject the new configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the export list before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ganesha logs; correct configuration issues then resubmit."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export updates"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an export entry from the NFS cluster.",
        "operationId" : "NfsServiceResource_deleteNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NFS export from the gateway and propagate the deletion to all servers.",
          "usage" : [ "Invoke after decommissioning a dataset so clients lose access.", "Use prior to redefining the export with new parameters to avoid duplicate entries." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS gateway service ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Numeric export identifier from GET /services/nfs-gateways/{serviceId}/exports.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the service or export ID is unknown", "500 if server-side export deletion fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the export list; retry with a current ID."
          }, {
            "code" : "500",
            "action" : "Inspect Ganesha logs and rerun once the management task succeeds."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS export removal"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/servers" : {
      "get" : {
        "summary" : "List server IDs assigned to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int32"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server IDs participating in the NFS gateway cluster.",
          "usage" : [ "Populate the servers tab in the NFS cluster detail view.", "Refresh after adding or removing nodes from the cluster." ],
          "response_shape" : "array<int>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 [] when the cluster has no active servers" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the cluster list and retry with a current ID."
          }, {
            "code" : "400",
            "action" : "Select a service of type nfs_gateway before calling this endpoint."
          }, {
            "code" : "200",
            "action" : "Show an empty state indicating that no servers are assigned yet."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS server membership polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/restart" : {
      "post" : {
        "summary" : "Restart services or OSDs.",
        "operationId" : "ServiceResource_restartMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart multiple services or OSDs immediately without waiting for long-running tasks.",
          "usage" : [ "Batch restart selected daemons after applying configuration changes.", "Prefer POST /services/rolling-restart for critical services that require sequential safety." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "true if the entry refers to an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "404 if any referenced service or server is unknown", "409 if the service manager rejects concurrent restarts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch current assignments via GET /services before resubmitting."
          }, {
            "code" : "409",
            "action" : "Defer the restart or switch to /services/rolling-restart to queue safely."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered restarts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/rolling-restart", "/tasks" ],
          "postprocessing_hint" : "Refresh GET /services to confirm the new state; consider monitoring /tasks if follow-up jobs were triggered.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/rolling-restart" : {
      "post" : {
        "summary" : "Performs a rolling restart on the provided services or OSDs.",
        "description" : "Each service is restarted one after another. Should one of the services fail to restart, the rolling restart will be stopped.\nOnly one rolling restart will run at a time, i.e.multiple calls to this endpoint won't run in parallel.",
        "operationId" : "ServiceResource_restartMultipleServicesRolling",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a sequential restart of multiple services/OSDs, enforcing cluster health checks between steps.",
          "usage" : [ "Use for critical daemons where concurrency would cause downtime (monitors, managers, SMB servers, etc.).", "Trigger after rolling out configuration or package updates when a safe restart cadence is required." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "Set true when the entry refers to an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if any referenced service/OSD is unknown", "409 if another rolling restart is already in progress", "500 if a step fails to restart within safety thresholds" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Refresh GET /services to fetch current IDs before resubmitting."
          }, {
            "code" : "409",
            "action" : "Wait for the currently running rolling restart task to finish before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to identify the failing service, resolve its issue, then rerun with the remaining entries."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Rolling restart orchestration"
          },
          "related_endpoints" : [ "/services/restart", "/tasks" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask; if it stops on a failure, address the reported service before retrying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb" : {
      "post" : {
        "summary" : "Create a new simple SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a simple SMB cluster backed by CephFS across the specified servers.",
          "usage" : [ "Call during initial SMB setup once CephFS and required networks are configured.", "Recreate the cluster after teardown when migrating to new hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Array of server/NIC/VLAN tuples that will host CTDB nodes.",
            "required" : true,
            "example" : "[{\"server\":21,\"nic\":7,\"vlan\":null}]"
          }, {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Floating IPs that will be distributed across nodes.",
            "required" : true,
            "example" : "[\"192.168.20.100\",\"192.168.20.101\"]"
          }, {
            "name" : "shares[]",
            "in" : "body",
            "description" : "Optional share definitions to seed during creation.",
            "required" : false,
            "example" : "[{\"name\":\"data\",\"path\":\"/cephfs/data\"}]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional display name for the SMB cluster.",
            "required" : false,
            "example" : "Production SMB"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured, no servers are provided, or virtual IP validation fails", "404 if any referenced server ID does not exist", "409 if network/IP conflicts require operator acknowledgement", "500 if CTDB or samba provisioning fails on a host" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure at least one server is specified and CephFS is configured before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh the server list and resubmit valid IDs."
          }, {
            "code" : "409",
            "action" : "Review the warning presented via ignorableWarnings and confirm the IP layout before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log for the failing node; fix the issue then re-run the creation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB cluster provisioning"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Wait for the ManagedTask to finish, then verify CTDB health and share accessibility.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/active-directory-authentication" : {
      "post" : {
        "summary" : "Create a new SMB cluster using Active Directory for authentication.",
        "operationId" : "SmbServiceResource_addActiveDirectorySmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Active Directory SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ActiveDirectorySmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an Active Directory-integrated SMB cluster with CTDB high availability.",
          "usage" : [ "Use when administrators need domain-joined SMB access to CephFS shares.", "Recreate the cluster on new hardware while keeping AD as the identity provider." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Server/NIC/VLAN tuples including AD credentials for each node.",
            "required" : true,
            "example" : "[{\"server\":21,\"nic\":7,\"vlan\":null,\"domainAdminUser\":\"Administrator\"}]"
          }, {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Shared DNS name for the cluster; may be blank for per-host joins.",
            "required" : true,
            "example" : "smb.prod.example.com"
          }, {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Floating IPs managed by CTDB.",
            "required" : true,
            "example" : "[\"192.168.30.50\",\"192.168.30.51\"]"
          }, {
            "name" : "joinWithSssd",
            "in" : "body",
            "description" : "Join the domain via sssd (alternative to adcli).",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "shares[]",
            "in" : "body",
            "description" : "Optional shares to create immediately.",
            "required" : false,
            "example" : "[{\"name\":\"home\",\"path\":\"/cephfs/home\"}]"
          } ],
          "failure_modes" : [ "400 if CephFS is missing, servers are omitted, or AD credentials are incomplete", "404 if any server ID is invalid", "409 if network/DNS validation raises ignorable warnings", "500 if AD join or CTDB provisioning fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure CephFS is configured and supply credentials for every server."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Review the warning surfaced via ignorableWarnings and acknowledge before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to address AD or CTDB failures prior to re-running."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB+AD cluster provisioning"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Once the task completes, verify CTDB health and domain membership before exposing shares.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}" : {
      "patch" : {
        "summary" : "Update an SMB cluster.",
        "operationId" : "SmbServiceResource_updateSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update SMB cluster metadata, virtual IPs, or credentials.",
          "usage" : [ "Adjust virtual IP assignments after changing network topology.", "Rotate admin/readonly passwords following security policies." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Optional new set of CTDB floating IPs.",
            "required" : false,
            "example" : "[\"192.168.20.100\",\"192.168.20.101\"]"
          }, {
            "name" : "adminPassword",
            "in" : "body",
            "description" : "Optional new croit admin password for SMB shares.",
            "required" : false,
            "example" : ""
          }, {
            "name" : "readonlyPassword",
            "in" : "body",
            "description" : "Optional new readonly password.",
            "required" : false,
            "example" : ""
          }, {
            "name" : "domainController",
            "in" : "body",
            "description" : "Optional AD domain controller hostname.",
            "required" : false,
            "example" : "dc01"
          }, {
            "name" : "dnsServers[]",
            "in" : "body",
            "description" : "Optional DNS servers for SMB nodes.",
            "required" : false,
            "example" : "[\"192.168.20.10\",\"192.168.20.11\"]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional UI description for the cluster.",
            "required" : false,
            "example" : "Production SMB cluster"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if virtual IP validation fails or required passwords are missing for updates", "404 if the cluster ID cannot be found", "500 if Samba/CTDB reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review ignorableWarnings for IP conflicts and provide all required credentials."
          }, {
            "code" : "404",
            "action" : "Refresh the SMB service list before retrying."
          }, {
            "code" : "500",
            "action" : "Check task logs and underlying nodes; rerun after issues are resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "SMB cluster updates"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name" ],
          "postprocessing_hint" : "Monitor the ManagedThreadTask until completion and verify CTDB status afterward.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get SMB cluster config and state.",
        "operationId" : "SmbServiceResource_getSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SmbGatewayServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve full configuration and runtime state for a specific SMB gateway cluster.",
          "usage" : [ "Call when opening the SMB cluster detail view to display servers, shares, and AD metadata.", "Re-query after updating share configuration or joining/leaving AD to verify the applied settings." ],
          "response_shape" : "SmbGatewayServiceResponse",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Identifier of the SMB service returned by GET /services.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the SMB cluster does not exist", "503 if CTDB health data is currently unavailable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm the serviceId before retrying."
          }, {
            "code" : "503",
            "action" : "Retry after CTDB stabilises; consider checking server_state cache for broader issues."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB cluster detail"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Surface healthy=false servers and missing virtual IPs prominently to prompt operator remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down an SMB cluster, removing all servers and shares managed by croit.",
          "usage" : [ "Call when decommissioning the SMB service or migrating to a fresh deployment.", "Use after draining shares and clients to ensure the cluster is fully removed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the SMB cluster no longer exists", "500 if another management action currently locks the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the SMB service inventory; only retry when the cluster is still listed."
          }, {
            "code" : "500",
            "action" : "Wait for outstanding tasks to finish, then delete again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "SMB cluster removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers" : {
      "post" : {
        "summary" : "Add a server to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale an SMB cluster by onboarding a new node with Samba and CTDB services.",
          "usage" : [ "Add capacity after provisioning additional servers.", "Re-add a node following maintenance once it is ready to rejoin the cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "body",
            "description" : "Server ID to add.",
            "required" : true,
            "example" : "24"
          }, {
            "name" : "nic",
            "in" : "body",
            "description" : "NIC ID for CTDB/public traffic.",
            "required" : true,
            "example" : "9"
          }, {
            "name" : "vlan",
            "in" : "body",
            "description" : "Optional VLAN ID for the CTDB interface.",
            "required" : false,
            "example" : "30"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "Domain admin account (required for AD clusters).",
            "required" : false,
            "example" : "Administrator"
          }, {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "Password for the domain admin account.",
            "required" : false,
            "example" : ""
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if validation fails (missing credentials, unhealthy cluster state)", "404 if the server or cluster ID is invalid", "409 if IP validation surfaces conflicts", "500 if CTDB or AD join fails on the new server" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure all existing nodes are healthy and provide required credentials."
          }, {
            "code" : "404",
            "action" : "Refresh the cluster/server lists and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Review ignorableWarnings and acknowledge conflicts before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, resolve host issues, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node onboarding"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/service-dns-name" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single server from the SMB cluster while keeping the cluster online.",
          "usage" : [ "Call before draining a node for maintenance or replacement.", "Use to rebalance the cluster after reducing capacity requirements." ],
          "response_shape" : "ManagedThreadTask?",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID as returned by GET /services/smb/{serviceId}.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if attempting to remove the final server (operation disallowed)", "404 if the server is not associated with the cluster", "500 if another cluster task is running" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use DELETE /services/smb/{serviceId} to dismantle the remaining cluster."
          }, {
            "code" : "404",
            "action" : "Refresh the server list to locate a valid ID before retrying."
          }, {
            "code" : "500",
            "action" : "Allow in-flight tasks to complete and run the removal again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/service-dns-name" : {
      "post" : {
        "summary" : "Change the service DNS name of an SMB cluster.",
        "operationId" : "SmbServiceResource_changeServiceDnsName",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DNS name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceDNSNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update the shared DNS name under which an AD-integrated SMB cluster registers.",
          "usage" : [ "Call after receiving a new service DNS entry or correcting a previous configuration.", "Rejoin the cluster to AD with a fresh name following recovery exercises." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Target DNS name for the cluster (non-empty unless sssd mode allows otherwise).",
            "required" : true,
            "example" : "smb.prod.example.com"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "Domain admin account used to perform the join.",
            "required" : true,
            "example" : "Administrator"
          }, {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "Password for the domain admin account.",
            "required" : true,
            "example" : ""
          }, {
            "name" : "joinServer",
            "in" : "body",
            "description" : "Optional server ID to execute the AD join from.",
            "required" : false,
            "example" : "21"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if the cluster is not AD-enabled, credentials are missing, or removing the DNS name is unsupported", "404 if joinServer is provided but not part of the cluster", "500 if Active Directory join operations fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm the cluster uses AD and provide the required domain credentials."
          }, {
            "code" : "404",
            "action" : "List cluster servers and retry with a valid joinServer."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log for AD errors; fix and rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB DNS updates"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/active-directory-authentication" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares" : {
      "post" : {
        "summary" : "Add a share to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Samba share backed by CephFS within the cluster.",
          "usage" : [ "Expose additional datasets to SMB clients without restarting services.", "Provision temporary maintenance shares for support operations." ],
          "response_shape" : "GeneratedId",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Share name presented to clients.",
            "required" : true,
            "example" : "projects"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "CephFS path exported by the share.",
            "required" : true,
            "example" : "/cephfs/projects"
          }, {
            "name" : "readOnly",
            "in" : "body",
            "description" : "Optional read-only setting.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the cluster ID does not exist", "409 if a share with the same name already exists", "500 if Samba fails to reload the configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the cluster list and retry with a valid ID."
          }, {
            "code" : "409",
            "action" : "Rename or remove the conflicting share before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Samba/CTDB logs and re-run after resolving errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "SMB share creation"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares/{shareId}", "/services/smb/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares/{shareId}" : {
      "put" : {
        "summary" : "Replace a share on an SMB cluster.",
        "operationId" : "SmbServiceResource_replaceSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing SMB share definition with new parameters.",
          "usage" : [ "Update share paths or permissions without deleting and recreating the share.", "Align share configuration with policy changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New share name (overwrites existing).",
            "required" : true,
            "example" : "projects"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "CephFS path exported by the share.",
            "required" : true,
            "example" : "/cephfs/projects"
          }, {
            "name" : "readOnly",
            "in" : "body",
            "description" : "Optional read-only flag.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share identifier to replace.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the share ID does not exist", "500 if Samba fails to apply the new configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List shares to confirm the ID before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Samba logs and re-run after correcting configuration errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share update"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a share from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an SMB share definition from the cluster configuration.",
          "usage" : [ "Call when retiring a dataset or before recreating the share with new settings.", "Use to revoke access quickly while leaving the cluster online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share ID from GET /services/smb/{serviceId}/shares.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the share ID does not exist on the cluster" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the share list and retry with a current identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/start" : {
      "post" : {
        "summary" : "Start services or OSDs.",
        "operationId" : "ServiceResource_startMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start multiple services or OSD daemons in parallel via the service manager.",
          "usage" : [ "Bring a set of daemons online after maintenance windows.", "Automate recovery workflows that re-enable services across nodes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to start.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "Set true when the entry represents an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "404 if any service/server mapping is invalid", "409 if the service manager rejects concurrent starts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service list via GET /services before resubmitting."
          }, {
            "code" : "409",
            "action" : "Wait for other control tasks to complete or split the batch."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service starts"
          },
          "related_endpoints" : [ "/services/stop", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Poll GET /services to confirm each entry reports a running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/stop" : {
      "post" : {
        "summary" : "Stop services or OSDs.",
        "operationId" : "ServiceResource_stopMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop multiple services or OSD daemons in one request.",
          "usage" : [ "Gracefully shut down daemons prior to maintenance windows.", "Evacuate services from a node before hardware work." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to stop.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services/OSDs.",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "True when the entry represents an OSD daemon.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "404 if any referenced service/server combination is unknown", "409 if the service manager prevents concurrent stops" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm current IDs before retrying."
          }, {
            "code" : "409",
            "action" : "Sequence the stops or wait for other control operations to complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stops"
          },
          "related_endpoints" : [ "/services/start", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services to ensure the daemons report a stopped state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServiceResource_restartService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service instance, optionally targeting a specific server.",
          "usage" : [ "Apply configuration changes that require a daemon restart.", "Recover a misbehaving service without touching others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/server combination is unknown", "409 if another control action is already queued for the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List current services via GET /services and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for ongoing operations to finish before rerunning the restart."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services/rolling-restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServiceResource_startService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service on its assigned server (or a specific server for multi-instance services).",
          "usage" : [ "Bring a daemon back online after targeted maintenance.", "Recover a service that was previously stopped by operators." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to start.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service or server pairing is invalid", "409 if another control task already manipulates the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Retrieve the current service inventory and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other service control operations to complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service start"
          },
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/restart", "/services/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServiceResource_stopService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance on demand.",
          "usage" : [ "Quiesce a daemon before performing host maintenance.", "Temporarily disable a service causing issues without touching others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/server pairing cannot be found", "409 if another control task is already acting on the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services and retry with up-to-date IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to finish before issuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stop"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/services/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a service.",
        "operationId" : "ServiceResource_updateService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable properties of a service (description, ports, DNS, etc.).",
          "usage" : [ "Adjust RGW service ports or DNS after network changes.", "Revise the display description for operators." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description shown in the UI.",
            "required" : false,
            "example" : "RGW on node12"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "Optional plain HTTP port (RGW only).",
            "required" : false,
            "example" : "8080"
          }, {
            "name" : "sslPort",
            "in" : "body",
            "description" : "Optional HTTPS port (RGW only).",
            "required" : false,
            "example" : "8443"
          }, {
            "name" : "rgwDnsName",
            "in" : "body",
            "description" : "Optional DNS name for RGW services.",
            "required" : false,
            "example" : "rgw.example.com"
          }, {
            "name" : "rgwZone",
            "in" : "body",
            "description" : "Optional RGW zone to assign.",
            "required" : false,
            "example" : "us-east"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to update.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "409 if concurrent operations hold the service lock", "500 if backend updates fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the service list before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other control operations to finish before resubmitting."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log; correct configuration issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Service metadata update"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a service.",
        "operationId" : "ServiceResource_deleteServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a service (or remove a server from a multi-server service).",
          "usage" : [ "Invoke when decomissioning daemons or shrinking multi-server services.", "If the service spans multiple servers, provide the server query parameter to detach only that node." ],
          "response_shape" : "ManagedTask?",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services; omit to delete the entire service.",
            "required" : false,
            "example" : "7"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier from GET /services.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the service does not exist", "409 if the daemon refuses to delete the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm the id and retry."
          }, {
            "code" : "409",
            "action" : "Inspect daemon logs; ensure the service is stopped before deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Service lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/{id}/stop", "/services/restart" ],
          "postprocessing_hint" : "If a ManagedTask is returned, stream /tasks/{id} until completion.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServiceResource_restartServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service or OSD daemon, optionally targeting a specific server instance.",
          "usage" : [ "Bounce an unhealthy daemon without impacting peers.", "Restart an OSD after storage maintenance." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain of the target (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/OSD (or specified server) cannot be found", "409 if another control task prevents the restart" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service inventory and retry with valid identifiers."
          }, {
            "code" : "409",
            "action" : "Wait for other operations to complete before reissuing the restart."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "related_endpoints" : [ "/services/start", "/services/stop", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services/{type}/{id} or monitor tasks to confirm the daemon returns to running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServiceResource_startServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service or OSD daemon, specifying whether the ID refers to a service or an OSD.",
          "usage" : [ "Bring an individual daemon online after maintenance.", "Start an OSD process once its device is available." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the target ID or server reference is invalid", "409 if a conflicting control task is in progress" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify IDs via GET /services or GET /osds before retrying."
          }, {
            "code" : "409",
            "action" : "Retry once other control tasks complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD start"
          },
          "related_endpoints" : [ "/services/{type}/{id}/stop", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServiceResource_stopServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service or OSD daemon designated by type and ID.",
          "usage" : [ "Suspend a daemon before performing maintenance on its host or storage.", "Temporarily disable an OSD without affecting others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the identifier or server mapping does not exist", "409 if another control task is already operating on the daemon" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service/OSD inventory prior to retrying."
          }, {
            "code" : "409",
            "action" : "Wait for concurrent operations to finish before issuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD stop"
          },
          "related_endpoints" : [ "/services/{type}/{id}/start", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/available-ceph-versions" : {
      "get" : {
        "summary" : "Get a list of supported Ceph releases.",
        "operationId" : "SetupResource_getAvailableCephVersions",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephRelease"
                  }
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/ceph-default" : {
      "get" : {
        "summary" : "Get the default ceph release for this container as a lowercase string.",
        "operationId" : "SetupResource_getCephDefaultRelease",
        "tags" : [ "setup" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        }
      }
    },
    "/setup/ceph-version" : {
      "post" : {
        "summary" : "Set the Ceph version for a fresh deployment or import.",
        "operationId" : "SetupResource_setCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Ceph version configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephVersionConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the currently configured Ceph version.",
        "operationId" : "SetupResource_getCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephVersionConfiguration"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/import-cluster" : {
      "post" : {
        "summary" : "Imports an existing Ceph cluster.",
        "operationId" : "SetupResource_importCluster",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Cluster import request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterImportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/list-interfaces" : {
      "get" : {
        "summary" : "List all interfaces on the management node.",
        "operationId" : "SetupResource_getManagementInterfaceCandidates",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/InterfaceResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/main-ip" : {
      "post" : {
        "summary" : "Set's the interface used for PXE booting.",
        "operationId" : "SetupResource_setMainIp",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Main IP configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MainIpRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-backup" : {
      "post" : {
        "summary" : "Restore from an encrypted cloud backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Backup restore request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BackupRestoreRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-unencrypted-backup" : {
      "post" : {
        "summary" : "Restore from an unencrypted backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromUnencryptedBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UnencryptedBackupRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs" : {
      "get" : {
        "summary" : "Get all CephFS snapshot jobs.",
        "operationId" : "CephFsSnapshotResource_getCephFsSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephFSSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List scheduled CephFS snapshot jobs and their status for monitoring or editing.",
          "usage" : [ "Render the snapshot schedule table in the UI", "Refresh after creating or updating snapshot jobs" ],
          "response_shape" : "OptionalPaginationResponse<CephFSSnapshotSchedule>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or sort snapshot schedules.",
            "required" : false,
            "example" : "{\"limit\":20}"
          } ],
          "failure_modes" : [ "200 [] when no snapshot jobs are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show guidance that snapshots can be scheduled via POST /snapshot-schedule/cephfs."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Snapshot schedule polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs/{id}", "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Display failedSnapshots prominently if present for active schedules.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_addCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_updateCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_removeCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd" : {
      "get" : {
        "summary" : "Get all RBD snapshot jobs.",
        "operationId" : "RbdSnapshotResource_getRbdSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRbdSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_addRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "RBD snapshot schedule creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_updateRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot schedule update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_removeRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats" : {
      "get" : {
        "summary" : "Get a graph by name.",
        "description" : "\n\t\t\tSee resources/statistics/graphite-queries.yml for available graphs.\n\n\t\t\tSome queries like server-specific stats expect template parameter which are passed with\n\t\t\t<code>template-{name}</code> query parameters. Example:\n\n\t\t\t<code>/stats?graph=server-disk-load&startTime=-600&maxDataPoints=50&template-server-id=1</code>\n\n\t\t\tstartTime and endTime should be in the same format, i.e., either both > 0 or both <= 0\n\t\t\t",
        "operationId" : "StatsResource_getStatsAuthed",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "description" : "End time of the graph, default = 0. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "The graph to query.",
          "name" : "graph",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "Maximum number of data points to return to thin out graphs over long time ranges. Default = 500",
          "name" : "maxDataPoints",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "Start time of the graph. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GraphResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve time-series metrics for dashboards using predefined graphite graph IDs.",
          "usage" : [ "Call when rendering monitoring charts; reuse cached data between dashboards if time range unchanged", "Limit polling to no more than once per refresh interval configured for the graph" ],
          "response_shape" : "GraphResponse",
          "request_parameters" : [ {
            "name" : "graph",
            "in" : "query",
            "description" : "Graph identifier defined in resources/statistics/graphite-queries.yml.",
            "required" : true,
            "example" : "server-disk-load"
          }, {
            "name" : "startTime",
            "in" : "query",
            "description" : "Unix timestamp (seconds) or negative offset indicating the start of the time window.",
            "required" : true,
            "example" : "-600"
          }, {
            "name" : "endTime",
            "in" : "query",
            "description" : "Unix timestamp (seconds) or negative offset for the end of the window (default 0).",
            "required" : false,
            "default" : "0"
          }, {
            "name" : "maxDataPoints",
            "in" : "query",
            "description" : "Maximum data points to return; higher values increase payload size (default 500).",
            "required" : false,
            "default" : "500"
          } ],
          "common_parameters" : {
            "template-*" : "Supply graph-specific template variables like template-server-id=1."
          },
          "failure_modes" : [ "400 if template parameters are missing or invalid", "404 if the graph identifier is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate parameters client-side and provide friendly error messaging."
          }, {
            "code" : "404",
            "action" : "Fallback to a default graph list and prompt selection again."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/stats/server-names", "/stats/pool-names", "/stats/s3-user-names" ],
          "postprocessing_hint" : "Downsample or merge series client-side if visualization cannot display all datapoints.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/cephfs-monitored-dirs" : {
      "put" : {
        "summary" : "Set the CephFS directories that are monitored for statistics.",
        "description" : "Replaces the currently configured set of directories.",
        "operationId" : "StatsResource_updateCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "CephFS directories to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get CephFS directories that are monitored for statistics.",
        "operationId" : "StatsResource_getCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsMonitoredDir"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose the list of CephFS directories currently tracked by utilization metrics.",
          "usage" : [ "Show monitored directories in the CephFS stats configuration UI", "Verify directory watch list after administrators update it" ],
          "response_shape" : "array<CephFsMonitoredDir>",
          "failure_modes" : [ "200 [] when no directories are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display guidance for adding directories via PUT /stats/cephfs-monitored-dirs."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Sort directories alphabetically and ensure '/' appears first.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/monitored-rbds" : {
      "put" : {
        "summary" : "Set the Rbd images that are monitored for statistics.",
        "description" : "Replaces the currently configured set of Rbd images.",
        "operationId" : "StatsResource_updateRbdMonitoredImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the Rbd images that are monitored for statistics.",
        "operationId" : "StatsResource_getMonitoredRbds",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/MonitoredRbd"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images currently tracked for RBD I/O statistics.",
          "usage" : [ "Display the monitored RBD list in the stats configuration UI", "Confirm that requested images are being collected" ],
          "response_shape" : "array<String>",
          "failure_modes" : [ "200 [] when no images are being monitored" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain how to add images via POST /stats/monitored-rbds."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats", "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Display items sorted and grouped by pool for readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Remove images from the set of monitored Rbds.",
        "operationId" : "StatsResource_deleteMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add images to the set of monitored Rbds.",
        "operationId" : "StatsResource_addMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Additional Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats/pool-names" : {
      "get" : {
        "summary" : "Get available Ceph pools for statistics.",
        "operationId" : "StatsResource_getPoolNames",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponsePoolStatsInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide pool identifiers and metadata for stats template selection.",
          "usage" : [ "Populate pool selection widgets before querying pool graphs", "Use quota fields to pre-select pools nearing limits" ],
          "response_shape" : "OptionalPaginationResponse<PoolStatsInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for sorting/filtering pools.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"displayName\":{\"_ilike\":\"%rbd%\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no pools are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Notify the user that no pools exist and provide a link to pool management."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/pools", "/stats" ],
          "postprocessing_hint" : "Map queryName to `template-pool-name` parameter values in stats calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-bucket-names" : {
      "get" : {
        "summary" : "Get available S3 buckets for statistics.",
        "operationId" : "StatsResource_getS3BucketNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3BucketName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with quotas for use as template parameters in S3 graphs.",
          "usage" : [ "Populate S3 bucket selectors before requesting usage charts", "Refresh after new buckets are created or quotas change" ],
          "response_shape" : "array<S3BucketName>",
          "failure_modes" : [ "200 [] when RGW is configured but no buckets exist", "200 [] when RGW is not configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a hint that no buckets are available and allow creation in RGW UI."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "S3 selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-user-names", "/stats" ],
          "postprocessing_hint" : "Use queryName when calling /stats?graph=... with template-s3-bucket-name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-user-names" : {
      "get" : {
        "summary" : "Get available S3 users for statistics.",
        "description" : "This API is somewhat expensive if there are a lot of S3 users, don't call this too often.",
        "operationId" : "StatsResource_getS3UserNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3UserName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return RGW user identifiers for stats templates (e.g. bandwidth per user).",
          "usage" : [ "Populate user pickers in S3 usage dashboards", "Request sparingly on large clusters due to cost" ],
          "response_shape" : "array<S3UserName>",
          "failure_modes" : [ "200 [] when no RGW users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no users are available and suggest user creation if required."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Expensive RGW user listing"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-bucket-names", "/stats" ],
          "postprocessing_hint" : "Normalize queryName by substituting '.' and '@' when building template parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/server-names" : {
      "get" : {
        "summary" : "Get available server names for statistics.",
        "operationId" : "StatsResource_getServerNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ServerNameAndId"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server identifiers used as template parameters for stats queries.",
          "usage" : [ "Populate server selectors before fetching graphs", "Refresh when the hardware inventory changes" ],
          "response_shape" : "array<ServerNameAndId>",
          "failure_modes" : [ "200 [] when no servers are registered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state noting that no servers are yet detected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/servers", "/stats" ],
          "postprocessing_hint" : "Sort by hostname before presenting in dropdowns.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/status" : {
      "get" : {
        "summary" : "Backend status and health check.",
        "description" : "Returns aggregated health data that indicates whether the croit backend is operational.",
        "operationId" : "BackendStatusResource_getBackendStatus",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BackendStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Check whether the croit backend is healthy before executing workflows.",
          "usage" : [ "Call before write operations or when rendering global status widgets", "Treat non-OK health results as degraded service" ],
          "response_shape" : "BackendStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure caller is authenticated with at least viewer privileges.",
            "post_action" : "Escalate alerts to the UI if status.health != 'OK'."
          },
          "failure_modes" : [ "503 if the backend is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry with exponential backoff (max 3 attempts) then alert operations."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Shared global polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status" ],
          "postprocessing_hint" : "Highlight health warnings prominently; avoid storing raw payload in logs.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/status/croit-version" : {
      "get" : {
        "summary" : "Get croit version.",
        "description" : "Retrieves the currently running croit software version as a semantic version string.",
        "operationId" : "BackendStatusResource_getCroitVersionParsed",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Determine the running croit software version for diagnostics and support.",
          "usage" : [ "Fetch once when composing system diagnostics or about dialogs", "Attach version metadata to support bundles" ],
          "response_shape" : "string",
          "workflow_guidance" : {
            "pre_check" : "Ensure viewer-level access.",
            "post_action" : "Cache version in session or telemetry payload."
          },
          "failure_modes" : [ "503 if backend temporarily unavailable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry after 10 seconds or fall back to cached value."
          } ],
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Version rarely changes"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/status" ],
          "postprocessing_hint" : "Store value client-side to avoid repeated calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/supervisor" : {
      "get" : {
        "summary" : "Inspect supervised services status.",
        "operationId" : "SupervisorResource_listProcesses",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseSupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}" : {
      "get" : {
        "summary" : "Get details of a specific supervised service.",
        "operationId" : "SupervisorResource_getProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}/restart" : {
      "post" : {
        "summary" : "Restart a specific supervised service.",
        "operationId" : "SupervisorResource_restartProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/start" : {
      "post" : {
        "summary" : "Start a supervised service.",
        "operationId" : "SupervisorResource_startProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/stop" : {
      "post" : {
        "summary" : "Stop a supervised service.",
        "operationId" : "SupervisorResource_stopProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/info" : {
      "get" : {
        "summary" : "Collect some support info for debugging purposes.",
        "operationId" : "SupportResource_getSupportInfo",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn" : {
      "get" : {
        "summary" : "Check if connected to croit VPN.",
        "operationId" : "SupportResource_getVPNConnection",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/VPNConnectionInfo"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/support/vpn/connect" : {
      "post" : {
        "summary" : "Connect to the croit VPN.",
        "operationId" : "SupportResource_connectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VPNConnectionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn/disconnect" : {
      "post" : {
        "summary" : "Disconnect to the croit VPN.",
        "operationId" : "SupportResource_disconnectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/survey" : {
      "patch" : {
        "summary" : "Enable or disable the croit hardware survey.",
        "operationId" : "SurveyResource_updateSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Survey configuration update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SurveyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get survey configuration",
        "operationId" : "SurveyResource_getSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyConfigResponse"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/feedback" : {
      "post" : {
        "summary" : "Report feedback to croit.io.",
        "operationId" : "SurveyResource_postFeedback",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Feedback data",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/preview" : {
      "get" : {
        "summary" : "Preview what is sent to croit.io if survey is enabled.",
        "operationId" : "SurveyResource_previewSurveyData",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyReport"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor" : {
      "post" : {
        "summary" : "Force a refresh of the recommendation list",
        "operationId" : "TaskAdvisorResource_refreshTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "get" : {
        "summary" : "Get a list of all recommendation tasks",
        "operationId" : "TaskAdvisorResource_getTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RecommendationResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current task-advisor recommendations for administrators.",
          "usage" : [ "Call to populate the task-advisor dashboard when the page loads.", "Poll periodically (e.g. every 60s) to surface new findings or auto-mitigations." ],
          "response_shape" : "array<RecommendationResponse>",
          "failure_modes" : [ "200 [] when no recommendations are currently available" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state card explaining that no actions are required."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Advisor dashboard refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/task-advisor", "/task-advisor/suggestions/{suggestionId}", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Sort recommendations by updatedAt descending and badge muted entries so operators can restore them.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor/retry-backup" : {
      "post" : {
        "summary" : "Retry the backup on mon disks.",
        "operationId" : "TaskAdvisorResource_retryBackupOnMonDisk",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/suggestions/{suggestionId}" : {
      "post" : {
        "summary" : "Apply a suggestion from an advisor recommendation",
        "operationId" : "TaskAdvisorResource_applySuggestion",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "suggestionId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/{taskUuid}" : {
      "patch" : {
        "summary" : "Hide a task from the recommendation list",
        "operationId" : "TaskAdvisorResource_patchTask",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskAdvisorUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a task identified by UUID",
        "operationId" : "TaskAdvisorResource_deleteTaskByUuid",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks" : {
      "get" : {
        "summary" : "Fetch a list of tasks.",
        "operationId" : "TaskResource_getAllTasks",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseTaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate through historical and active tasks with optional filtering and sorting.",
          "usage" : [ "Load the task history view with pagination controls.", "Filter tasks by state or name when auditing recent maintenance operations." ],
          "response_shape" : "PaginationResponse<TaskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON supporting where/order/limit clauses (e.g. {\"limit\":50,\"where\":[{\"state\":{\"_eq\":\"FAILED\"}}]}).",
            "required" : true,
            "example" : "{\"limit\":25,\"order\":[{\"startedAt\":\"desc\"}]}"
          } ],
          "common_parameters" : {
            "pagination.where.state" : "Filter to RUNNING/FAILED to focus on tasks needing action.",
            "pagination.order.startedAt" : "Sort descending to view the newest tasks first."
          },
          "failure_modes" : [ "200 with data=[] when no tasks match the filter" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Relax filters or expand the time range before retrying."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Task history pagination"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Use `total` and `limit` to drive pagination UI; hide sensitive task names from non-admin users as returned.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/active" : {
      "get" : {
        "summary" : "Get all currently active tasks (running or waiting).",
        "operationId" : "TaskResource_getAllActiveTasks",
        "tags" : [ "tasks" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all tasks that are currently RUNNING or WAITING.",
          "usage" : [ "Drive dashboards that show live operational activity.", "Poll after submitting work to present users with any tasks that still require monitoring or interaction." ],
          "response_shape" : "array<TaskResponse>",
          "failure_modes" : [ "200 [] when there are no active tasks" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a no-active-tasks message and stop polling until new tasks are created."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Active task overview"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 5,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks", "/tasks/status", "/tasks/{id}" ],
          "postprocessing_hint" : "Sort by startedAt descending and flag WAITING tasks that might require manual approval (question != null).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/status" : {
      "get" : {
        "summary" : "Get tasks with status.",
        "operationId" : "TaskResource_getTaskStatuses",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch status snapshots for multiple tasks in one request.",
          "usage" : [ "Poll in bulk when coordinating several concurrent background jobs.", "Use after starting a batch of tasks to detect which ones still require attention." ],
          "response_shape" : "array<TaskResponse>",
          "request_parameters" : [ {
            "name" : "id",
            "in" : "query",
            "description" : "Repeatable query parameter listing task ids to inspect (e.g. id=12&id=34).",
            "required" : true,
            "example" : "id=101&id=202"
          } ],
          "failure_modes" : [ "200 [] when none of the supplied task ids are active or visible" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "If expected tasks are missing, query GET /tasks/{id} individually or reload the task history."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Batch status polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Map responses by id; treat missing entries as completed, purged, or permission filtered tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}" : {
      "get" : {
        "summary" : "Get task.",
        "operationId" : "TaskResource_getTaskStatus",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the latest status snapshot for a single long-running task.",
          "usage" : [ "Call immediately after an endpoint returns a ManagedTask to track its execution until completion.", "Use while showing a task detail drawer to stream progress, log output, and pending questions." ],
          "response_shape" : "TaskResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier returned when the task was started.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "404 if the task id is unknown or filtered (e.g. non-admins requesting sensitive tasks)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Confirm the id, ensure sufficient permissions, then fall back to GET /tasks/status for batch checks."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Task detail polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/status", "/tasks/{id}/cancel", "/tasks/{id}/answer" ],
          "postprocessing_hint" : "Stop polling once done=true; treat statusCode 0 as success, -256 as user cancel, others as failure, and surface question tokens when present.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}/answer" : {
      "post" : {
        "summary" : "Answer task question.",
        "operationId" : "TaskResource_answerQuestion",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Task question answer",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskQuestionAnswer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks/{id}/cancel" : {
      "post" : {
        "summary" : "Cancel task.",
        "operationId" : "TaskResource_cancelTask",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users" : {
      "get" : {
        "summary" : "List all known users (local, LDAP and OIDC included).",
        "operationId" : "UserResource_getUsers",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseAccount"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new croit user. Returns the ID of the new user.",
        "operationId" : "UserResource_createUser",
        "tags" : [ "users" ],
        "requestBody" : {
          "description" : "User creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/AccountRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/oidc/{id}/users/{subject}" : {
      "patch" : {
        "summary" : "Update roles of an OIDC user.",
        "operationId" : "UserResource_updateOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an OIDC user.",
        "operationId" : "UserResource_deleteOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}" : {
      "patch" : {
        "summary" : "Update a local croit user.",
        "operationId" : "UserResource_updateUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "User update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a local croit user account.",
        "operationId" : "UserResource_deleteUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}/password" : {
      "put" : {
        "summary" : "Change the password of a local croit user.",
        "operationId" : "UserResource_setPassword",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Password change request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PasswordChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-required-permissions" : [ "viewer" ]
      }
    }
  },
  "info" : {
    "title" : "Croit platform API",
    "version" : "1.0",
    "description" : "API documentation for the croit platform."
  }
}