{
  "openapi" : "3.1.0",
  "components" : {
    "schemas" : {
      "Account" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "authScheme" : {
            "$ref" : "#/components/schemas/AccountAuthScheme"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "managedByLdap" : {
            "type" : "boolean"
          },
          "fullName" : {
            "type" : [ "string", "null" ],
            "description" : "Full name of LDAP/OIDC users"
          },
          "distinguishedName" : {
            "type" : [ "string", "null" ],
            "description" : "Distinguished name (DN) of LDAP users"
          },
          "managedByOidcProvider" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/AccountOidcInfo"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "username", "roles", "authScheme" ]
      },
      "AccountAuthScheme" : {
        "type" : "string",
        "enum" : [ "password", "ldap", "oidc", "api_token" ]
      },
      "AccountOidcInfo" : {
        "type" : "object",
        "properties" : {
          "oidcRefreshTokenPresent" : {
            "type" : "boolean"
          },
          "oidcRefreshExpiry" : {
            "type" : [ "string", "null" ]
          },
          "oidcUpdateExpiry" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AccountRequest" : {
        "description" : "Request to create a new croit user.",
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Login name of the user."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "AclEntry" : {
        "type" : "object",
        "description" : "An ACL entry for a bucket, see S3 documentation for details.",
        "required" : [ "grantee", "permission" ],
        "properties" : {
          "grantee" : {
            "$ref" : "#/components/schemas/AclEntryGrantee"
          },
          "userId" : {
            "type" : [ "string", "null" ],
            "description" : "Only meaningful if grantee == SINGLE_USER."
          },
          "displayName" : {
            "type" : [ "string", "null" ],
            "description" : "Informational. Not used when setting ACLs."
          },
          "permission" : {
            "type" : "object"
          }
        }
      },
      "AclEntryGrantee" : {
        "type" : "string",
        "enum" : [ "ALL_USERS", "AUTHENTICATED_USERS", "SINGLE_USER", "LOG_DELIVERY" ]
      },
      "ActiveDirectorySmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "domain", "netbiosDomainName", "serviceDnsName", "domainController", "dnsServers", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : "string",
            "description" : "Active Directory domain/realm, e.g., MY-ORG.LOCAL"
          },
          "netbiosDomainName" : {
            "type" : "string",
            "description" : "NetBIOS domain name, e.g., MY-ORG"
          },
          "serviceDnsName" : {
            "type" : "string",
            "description" : "Service DNS name which will be used as NetBIOS name by which an SMB server is known."
          },
          "domainController" : {
            "type" : "string",
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Try to join with adcli+sssd. The image running on the server needs to support this."
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AdminCephPermissions" : {
        "type" : "object"
      },
      "ApiTokenInfo" : {
        "description" : "Information about an API token.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Account ID of the API token."
          },
          "name" : {
            "type" : "string",
            "description" : "Descriptive name of the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Roles for the API token."
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry time of the API token (optional, if omitted, the token doesn't expire)."
          }
        },
        "required" : [ "name", "roles" ]
      },
      "ApiTokenRequest" : {
        "description" : "Request to create a new API token.",
        "type" : "object",
        "required" : [ "name", "roles" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Descriptive name for the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Time when api token is supposed to expire (optional)."
          }
        }
      },
      "ApiTokenUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin role also needs viewer role."
          }
        }
      },
      "ApiWarning" : {
        "type" : "object",
        "required" : [ "id", "message" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "message" : {
            "type" : "string"
          }
        }
      },
      "ArchConfig" : {
        "type" : "object",
        "properties" : {
          "x86_64" : {
            "type" : "boolean",
            "description" : "Whether x86_64 images are enabled."
          },
          "arm64" : {
            "type" : "boolean",
            "description" : "Whether arm64 images are enabled."
          }
        }
      },
      "AuditInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "category" : {
            "type" : "string"
          },
          "operation" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "method" : {
            "$ref" : "#/components/schemas/AuditLogMethod"
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "endpoint" : {
            "type" : "string"
          },
          "queryParams" : {
            "type" : "string"
          },
          "body" : {
            "type" : "string"
          }
        },
        "required" : [ "time", "category", "operation", "username", "ip", "method", "endpoint", "queryParams", "body" ]
      },
      "AuditLogMethod" : {
        "type" : "string",
        "enum" : [ "POST", "GET", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS" ]
      },
      "AvailableConfigTemplate" : {
        "type" : "object",
        "required" : [ "name", "template" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "template" : {
            "type" : "string"
          }
        }
      },
      "AvailableMigrationTasks" : {
        "type" : "object",
        "properties" : {
          "mimic" : {
            "type" : "boolean"
          },
          "nautilus" : {
            "type" : "boolean"
          },
          "octopus" : {
            "type" : "boolean"
          },
          "pacific" : {
            "type" : "boolean"
          },
          "quincy" : {
            "type" : "boolean"
          },
          "reef" : {
            "type" : "boolean"
          },
          "switchTarget" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BackendStatus" : {
        "description" : "Status overview of the croit backend. Does not contain Ceph information.",
        "type" : "object",
        "properties" : {
          "doSetup" : {
            "type" : "boolean",
            "description" : "Cluster setup required"
          },
          "cephConfigured" : {
            "type" : "boolean",
            "description" : "True if Ceph is configured and ceph status can be queried"
          },
          "daosConfigured" : {
            "type" : "boolean",
            "description" : "True if DAOS is configured"
          },
          "status" : {
            "description" : "Croit health check",
            "type" : "string",
            "$ref" : "#/components/schemas/CroitHealthStatus"
          },
          "oktaOAuth" : {
            "type" : "boolean",
            "description" : "Auth via Okta available"
          },
          "versions" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitApiVersion"
            },
            "description" : "Available croit versions"
          },
          "currentVersion" : {
            "type" : "string",
            "description" : "Running croit version"
          },
          "currentVersionParsed" : {
            "description" : "Running croit version (parsed)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "useCustomLogo" : {
            "type" : "boolean",
            "description" : "Custom logo available at /api/extra-files/logo[-small].svg"
          },
          "backends" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CroitBackendConfiguration"
            },
            "description" : "Manage multiple croit clusters that share a centralized login system. This list may or may not contain the current cluster"
          },
          "multiMdsEnabled" : {
            "type" : "boolean",
            "description" : "Multi MDS is enabled"
          },
          "multiRgwEnabled" : {
            "type" : "boolean",
            "description" : "Multi RGW is enabled"
          },
          "error" : {
            "type" : [ "string", "null" ],
            "description" : "Error message to display in case there are critical errors in croit."
          },
          "errorLong" : {
            "type" : [ "string", "null" ],
            "description" : "Longer error message to display in case there are critical errors in croit."
          }
        },
        "required" : [ "status", "versions", "currentVersion" ]
      },
      "BackupRestoreRequest" : {
        "type" : "object",
        "required" : [ "encryptionKey", "croitApiToken", "backupUuid" ],
        "properties" : {
          "encryptionKey" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "croitApiToken" : {
            "type" : "string"
          },
          "backupUuid" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "BondRequest" : {
        "type" : "object",
        "required" : [ "name", "nics" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "activePassive" : {
            "type" : "boolean"
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BondUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "activePassive" : {
            "type" : [ "boolean", "null" ]
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BootDiskRequest" : {
        "type" : "object",
        "properties" : {
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to install croit on."
          },
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that the disk is on. Used as a sanity check that the correct disk is selected."
          }
        }
      },
      "BucketCreationRequest" : {
        "description" : "Create an S3 bucket.",
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "User id of the owner"
          },
          "placement" : {
            "type" : [ "string", "null" ],
            "description" : "Name of a placement policy as returned by /placements"
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "expectedNumberOfObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Expected number of objects to pre-shard the bucket. If in doubt: don't set this as setting a too large value will degrade performance."
          },
          "endpoint" : {
            "type" : [ "string", "null" ],
            "description" : "The S3 endpoint (full URL) used to create this bucket, this effectively controls the zonegroup in which the bucket is created."
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "BucketDeletionRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "deleteData" : {
            "type" : [ "boolean", "null" ]
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BucketDetails" : {
        "type" : "object",
        "required" : [ "cors", "acl", "versioning" ],
        "properties" : {
          "cors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CORSRuleResponse"
            }
          },
          "acl" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
          }
        }
      },
      "BucketUpdateRequest" : {
        "description" : "Update an S3 bucket.",
        "type" : "object",
        "properties" : {
          "owner" : {
            "type" : [ "string", "null" ],
            "description" : "Change owner to this uid."
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CORSRuleResponse" : {
        "description" : "S3 CORS rule",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "string", "null" ],
            "description" : "Unique identifier for the rule"
          },
          "allowedMethods" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed HTTP methods"
          },
          "allowedOrigins" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed origins"
          },
          "allowedHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed headers"
          },
          "exposeHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Exposed headers"
          },
          "maxAgeSeconds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max age in seconds for preflight requests"
          }
        },
        "required" : [ "allowedMethods", "allowedOrigins", "allowedHeaders", "exposeHeaders" ]
      },
      "Category" : {
        "type" : "string",
        "enum" : [ "CEPH", "BACKUP", "CRUSH", "MON", "MGR", "OSD", "PG", "RGW", "NFS", "ISCSI", "SMB", "OS", "CROIT", "RBD_MIRROR", "MDS", "NVMEOF" ]
      },
      "CephConfChangeRequest" : {
        "type" : "object",
        "properties" : {
          "value" : { },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CephConfDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "CephConfigDumpLevel" : {
        "type" : "string",
        "enum" : [ "BASIC", "ADVANCED", "DEV", "UNKNOWN" ]
      },
      "CephConfigResponse" : {
        "type" : "object",
        "required" : [ "name", "value", "description", "default", "level", "seeAlso" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "value" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "description" : {
            "type" : "string"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephConfigUnit"
            }, {
              "type" : "null"
            } ]
          },
          "default" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "level" : {
            "$ref" : "#/components/schemas/CephConfigDumpLevel"
          },
          "seeAlso" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "canUpdateAtRuntime" : {
            "type" : [ "boolean", "null" ]
          },
          "currentValue" : { },
          "currentValueFormatted" : { },
          "defaultValue" : { },
          "defaultValueFormatted" : { }
        }
      },
      "CephConfigType" : {
        "type" : "string",
        "enum" : [ "STRING", "INT", "DOUBLE", "BOOL", "TEXT_FILE" ]
      },
      "CephConfigUnit" : {
        "type" : "string",
        "enum" : [ "BYTES", "SECONDS" ]
      },
      "CephConfigValueReply" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CephConfigType"
          },
          "value" : { }
        }
      },
      "CephDashboardRole" : {
        "type" : "object",
        "required" : [ "scopes_permissions", "name" ],
        "properties" : {
          "scopes_permissions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephDashboardUser" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "integer",
            "format" : "int64"
          },
          "name" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "croitImport" : {
            "type" : "boolean"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFSSnapshotSchedule" : {
        "description" : "Object containing all information for an CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a millisecond-precision timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "Comma-separated string of CephFS directories to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "pathsFormatted", "failedSnapshots" ]
      },
      "CephFlagReponse" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "recommendedState" : {
            "type" : "boolean"
          },
          "currentState" : {
            "type" : "boolean"
          }
        }
      },
      "CephFsDirectoryEntries" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFsDirectoryEntriesWithStats" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            }
          }
        }
      },
      "CephFsFileType" : {
        "type" : "string",
        "enum" : [ "FILE", "DIR", "SYMLINK", "UNKNOWN" ]
      },
      "CephFsFileUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "absolutePath" : {
            "type" : [ "string", "null" ],
            "description" : "New absolute path of the file to rename or move the file."
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Permissions in Unix notation."
          }
        }
      },
      "CephFsLayout" : {
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsMonitoredDir" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-cephfs-dir-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of bytes. Deprecated, use value returned by /stats API."
          },
          "quotaFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of files. Deprecated, use value returned by /stats API"
          }
        }
      },
      "CephFsNewDirectoryRequest" : {
        "type" : "object",
        "required" : [ "dir" ],
        "properties" : {
          "dir" : {
            "type" : "string"
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "null to use the default pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsPathPermission" : {
        "type" : "object",
        "required" : [ "path", "permissions" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephfsPathPermissionType"
          }
        }
      },
      "CephFsQuota" : {
        "type" : "object",
        "properties" : {
          "maxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephFsResponse" : {
        "type" : "object",
        "required" : [ "path", "sizeFormatted", "dirFilesFormatted", "modeFormatted", "quotaMaxBytesFormatted" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "fullPath" : {
            "type" : [ "string", "null" ]
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephFsFileType"
            }, {
              "type" : "null"
            } ]
          },
          "dirBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirSubdirs" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "symlinkPath" : {
            "type" : [ "string", "null" ]
          },
          "isDir" : {
            "type" : [ "boolean", "null" ]
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "dirFilesFormatted" : {
            "type" : "string"
          },
          "modeFormatted" : {
            "type" : "string"
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string"
          }
        }
      },
      "CephFsSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a CephFS snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\".",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot.",
            "minItems" : 1
          }
        }
      },
      "CephFsSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          }
        }
      },
      "CephFsUploadRequest" : {
        "type" : "object",
        "required" : [ "file", "path" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "path" : {
            "type" : "string"
          }
        }
      },
      "CephHealth" : {
        "type" : "string",
        "enum" : [ "HEALTH_OK", "HEALTH_WARN", "HEALTH_ERR", "HEALTH_UNKNOWN" ]
      },
      "CephHealthCheckDetailMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          }
        }
      },
      "CephHealthCheckSummaryMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephModule" : {
        "type" : "object",
        "required" : [ "name", "error_string", "module_options" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "can_run" : {
            "type" : "boolean"
          },
          "error_string" : {
            "type" : "string"
          },
          "module_options" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephModuleOption"
            }
          }
        }
      },
      "CephModuleOption" : {
        "type" : "object",
        "required" : [ "name", "type", "level", "default_value", "min", "max", "enum_allowed", "desc", "long_desc", "tags", "see_also" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string"
          },
          "level" : {
            "type" : "string"
          },
          "flags" : {
            "type" : "integer",
            "format" : "int32"
          },
          "default_value" : {
            "type" : "string"
          },
          "min" : {
            "type" : "string"
          },
          "max" : {
            "type" : "string"
          },
          "enum_allowed" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "desc" : {
            "type" : "string"
          },
          "long_desc" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "see_also" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephModuleStatus" : {
        "type" : "object",
        "required" : [ "enabled_modules", "disabled_modules" ],
        "properties" : {
          "enabled_modules" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "disabled_modules" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephModule"
            }
          }
        }
      },
      "CephMutedStatusCheck" : {
        "type" : "object",
        "required" : [ "code", "summary" ],
        "properties" : {
          "code" : {
            "type" : "string",
            "description" : "Name of the muted status check.",
            "examples" : [ "SLOW_OPS" ]
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Indicates whether this check will stay muted once it's resolved."
          },
          "summary" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPermissions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "raw" : "#/components/schemas/RawCephPermissions",
            "admin" : "#/components/schemas/AdminCephPermissions",
            "rbd" : "#/components/schemas/RbdCephPermissions",
            "cephfs" : "#/components/schemas/CephfsCephPermissions"
          }
        },
        "type" : "object"
      },
      "CephPgStat" : {
        "type" : "object",
        "required" : [ "pgid", "state", "acting", "up" ],
        "properties" : {
          "pgid" : {
            "type" : "string"
          },
          "state" : {
            "type" : "string"
          },
          "last_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "last_deep_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "acting" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "acting_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPoolDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "stats", "hints", "redundancy", "unprotectedUntilFormatted", "quotaMaxBytesFormatted", "quotaMaxObjectsFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgpNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "crushRule" : {
            "type" : "integer",
            "format" : "int32"
          },
          "stats" : {
            "$ref" : "#/components/schemas/PoolStatsResponse"
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "erasureCodingOverwriteSupportMissing" : {
            "type" : "boolean",
            "description" : "Indicates whether this pool is missing the ec_overwrites flag."
          },
          "fastRead" : {
            "type" : "boolean",
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "unprotectedUntil" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Time until the no_delete flag on the pool will be set again if it was temporarily disabled. null if pool is currently protected."
          },
          "deleteProtected" : {
            "type" : "boolean",
            "description" : "True if pool is currently protected from deletion."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to display in the UI."
          },
          "redundancy" : {
            "type" : "string"
          },
          "unprotectedUntilFormatted" : {
            "type" : "string",
            "description" : "Like unprotectedUntil, but formatted into a human-readable string."
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxBytes formatted to be human-readable and to show usage percentage"
          },
          "quotaMaxObjectsFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxObjects formatted to be more easily readable and to show usage percentage"
          }
        }
      },
      "CephPoolSurvey" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "application" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "pgNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "crushRule" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "unprotect" : {
            "type" : [ "boolean", "null" ]
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "fastRead" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "compression" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionSettings"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephRelease" : {
        "type" : "string",
        "enum" : [ "luminous", "mimic", "nautilus", "octopus", "pacific", "quincy", "reef" ]
      },
      "CephReleaseCount" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "$ref" : "#/components/schemas/CephRelease"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephReleases" : {
        "type" : "object",
        "required" : [ "mon", "mgr", "osd", "mds", "overall", "other" ],
        "properties" : {
          "mon" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mgr" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "osd" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "overall" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "other" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/CephReleaseCount"
              }
            }
          }
        }
      },
      "CephStatus" : {
        "type" : "object",
        "required" : [ "fsid", "health" ],
        "properties" : {
          "fsid" : {
            "type" : "string"
          },
          "quorumNamesCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "health" : {
            "$ref" : "#/components/schemas/CephStatusHealth"
          },
          "osdMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusOsdmap"
            }, {
              "type" : "null"
            } ]
          },
          "mgrMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusMgrMap"
            }, {
              "type" : "null"
            } ]
          },
          "pgMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusPgMap"
            }, {
              "type" : "null"
            } ]
          },
          "numOfMons" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusCheck" : {
        "type" : "object",
        "required" : [ "severity", "summary" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "summary" : {
            "$ref" : "#/components/schemas/CephHealthCheckSummaryMessage"
          },
          "detail" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephHealthCheckDetailMessage"
            }
          },
          "muted" : {
            "type" : "boolean",
            "description" : "Indicates whether this check is muted."
          }
        }
      },
      "CephStatusHealth" : {
        "type" : "object",
        "required" : [ "status", "checks" ],
        "properties" : {
          "status" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "checks" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephStatusCheck"
            }
          },
          "mutes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephMutedStatusCheck"
            },
            "description" : "List of muted status checks. null indicates that the current ceph version doesn't support muting status checks."
          }
        }
      },
      "CephStatusMgrMap" : {
        "type" : "object",
        "properties" : {
          "available" : {
            "type" : [ "boolean", "null" ]
          },
          "standbysCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusOsdmap" : {
        "type" : "object",
        "properties" : {
          "numUpOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusPgMap" : {
        "type" : "object",
        "properties" : {
          "bytesUsed" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "bytesTotal" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringBytesPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringObjectsPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dataBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephUserRequest" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions" ],
        "properties" : {
          "user" : {
            "type" : "string",
            "description" : "A fully qualified Ceph user name, i.e., usually client.XYZ"
          },
          "comment" : {
            "type" : "string",
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "Permissions for this keyring",
            "type" : "object",
            "$ref" : "#/components/schemas/CephPermissions"
          }
        }
      },
      "CephUserResponse" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions", "rawPermissions" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "comment" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephPermissions"
          },
          "rawPermissions" : {
            "$ref" : "#/components/schemas/RawCephPermissions"
          }
        }
      },
      "CephUserUpdate" : {
        "type" : "object",
        "properties" : {
          "comment" : {
            "type" : [ "string", "null" ],
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "New permissions for this keyring",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephPermissions"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephVersionConfiguration" : {
        "type" : "object",
        "required" : [ "cephVersion" ],
        "properties" : {
          "cephVersion" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "CephfsCephPermissions" : {
        "type" : "object",
        "required" : [ "pools", "paths" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            }
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsPathPermission"
            }
          }
        }
      },
      "CephfsClientInfo" : {
        "description" : "A Ceph client connected to CephFS, can be either a Kernel or libcephfs client.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numLeases" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of open files"
          },
          "numCaps" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of CephFS caps"
          },
          "state" : {
            "type" : "string",
            "description" : "Connection state"
          },
          "requestLoadAverage" : {
            "type" : "number",
            "format" : "double",
            "description" : "Load caused by this client's requests"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP the client is connecting from"
          },
          "cephUser" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph user name used by this client"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname reported by the client"
          },
          "mountpoint" : {
            "type" : [ "string", "null" ],
            "description" : "Subtree mounted by the client"
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Client Ceph or kernel version"
          }
        },
        "required" : [ "state", "ip" ]
      },
      "CephfsPathPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE", "READ_WRITE_PLACEMENT", "READ_WRITE_SNAPSHOT", "READ_WRITE_PLACEMENT_SNAPSHOT" ]
      },
      "CephfsSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "files" : {
            "type" : "integer",
            "format" : "int64"
          },
          "dirs" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "ChangeRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "createdBy" : {
            "$ref" : "#/components/schemas/ChangeRequestUser"
          },
          "affectedObject" : {
            "type" : "string"
          },
          "changes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ChangeRequestItem"
            }
          },
          "state" : {
            "$ref" : "#/components/schemas/ChangeRequestStatus"
          }
        },
        "required" : [ "description", "createdBy", "affectedObject", "changes", "state" ]
      },
      "ChangeRequestItem" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "type" : "string"
          }
        }
      },
      "ChangeRequestStatus" : {
        "type" : "string",
        "enum" : [ "PENDING", "APPROVED", "REJECTED" ]
      },
      "ChangeRequestUser" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CloneRequest" : {
        "description" : "Details for a clone creation request",
        "type" : "object",
        "required" : [ "pool", "name" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool in which to store the clone (can be different from the parent image)"
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the new clone"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace for the new clone. Requires v2 cloning, i.e., all clients must be at least Mimic or kernel 4.19"
          }
        }
      },
      "CloudConfigBackupConfig" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "CloudConfigBackupStatus" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "lastBackupTimestamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp of the last backup, null if never backed up."
          },
          "lastBackupSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the last backup in byte, null if never backed up."
          },
          "lastBackupChecksum" : {
            "type" : [ "string", "null" ],
            "description" : "SHA256 checksum of the encrypted data of the last backup, null if never backed up."
          },
          "clusterId" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "backupEncryptionKey" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "cephFsid" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "ClusterCreationRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "ClusterDeployRequest" : {
        "type" : "object",
        "required" : [ "mons" ],
        "properties" : {
          "mons" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MonitorRequest"
            }
          }
        }
      },
      "ClusterImportRequest" : {
        "type" : "object",
        "required" : [ "adminKey", "mons" ],
        "properties" : {
          "adminKey" : {
            "type" : "string"
          },
          "mons" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "minItems" : 1
          }
        }
      },
      "ClusterStatus" : {
        "description" : "A croit cluster status report consisting of two parts: information about croit-related services and general Ceph services. Both states are gathered independently so you still get information about croit services if your Ceph cluster is down.",
        "type" : "object",
        "required" : [ "timestamp", "cephLastUpdated", "placementGroups", "servers", "mds", "utilizationByDeviceClass", "radosgws", "iscsi", "nfsGateways", "smbGateways", "nvmeofGateways", "licenseValidUntil", "croitUptime" ],
        "properties" : {
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "The timestamp at which this status report was created. Note that the Ceph state can be up to 30 seconds older if Ceph is slow to respond."
          },
          "cephLastUpdated" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Age of the Ceph status in seconds (relative to `timestamp`). Note that this can be negative, i.e., fresher than the other data."
          },
          "cephStatus" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "healthDetails" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusHealth"
            }, {
              "type" : "null"
            } ]
          },
          "placementGroups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PlacementGroupOverview"
            }
          },
          "recoveryTimeRemaining" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "servers" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "mds" : {
            "$ref" : "#/components/schemas/MdsOnlineStatus"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/DeviceClassUtilization"
            }
          },
          "radosgws" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nfsGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "smbGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nvmeofGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "licenseActive" : {
            "type" : "boolean"
          },
          "licenseValidUntil" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "croitUptime" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "ConfigTemplateRequest" : {
        "type" : "object",
        "properties" : {
          "predefinedTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Use a pre-defined template. Either this or customTemplate must be set."
          },
          "customTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Set a completely custom template. Either this or customTemplate must be set."
          }
        }
      },
      "ConfigTemplateResponse" : {
        "type" : "object",
        "required" : [ "id", "description", "currentTemplateName", "currentTemplate", "availableTemplates" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "currentTemplateName" : {
            "type" : "string"
          },
          "currentTemplate" : {
            "type" : "string"
          },
          "availableTemplates" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AvailableConfigTemplate"
            }
          }
        }
      },
      "CpuArchitecture" : {
        "type" : "string",
        "enum" : [ "AMD64", "ARM64" ]
      },
      "CreateDaosContainerRequest" : {
        "type" : "object",
        "required" : [ "name", "type", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the container. Allowed are alphanumeric characters (a-z, A-Z, 0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "type" : {
            "description" : "Type of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Chunk size for the container."
          },
          "objectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default object class for the container."
          },
          "directoryObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default directory object class for the container."
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default file object class for the container."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on container creation. Some properties can only be set when creating a container."
          }
        }
      },
      "CreateDaosPoolRequest" : {
        "type" : "object",
        "required" : [ "name", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the pool. Allowed are alphanumeric characters (a-zA-Z0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the pool in bytes."
          },
          "scmPerc" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Percentage of SCM as percent points. NVMes will thereby get 100 minus this value as percentage."
          },
          "nranks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of ranks to use (which are then chosen automatically). Cannot be used together with ranks."
          },
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ranks to use. Cannot be used together with nranks."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on pool creation. Some properties can only be set when creating a pool."
          }
        }
      },
      "CroitApiVersion" : {
        "type" : "object",
        "required" : [ "version", "releaseDate", "infoUrl" ],
        "properties" : {
          "version" : {
            "type" : "string"
          },
          "releaseDate" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "infoUrl" : {
            "type" : "string"
          }
        }
      },
      "CroitAutoUpdateConfigRequest" : {
        "description" : "Schedule the automatic update of the croit docker image.",
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "custom" : {
            "type" : "boolean",
            "description" : "If true, customized docker registry and docker image settings are used, otherwise the croit defaults."
          },
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryUsername" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry username. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryPassword" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry password. Ignored for PUT requests if \"custom\" is set to true."
          },
          "imageName" : {
            "type" : "string",
            "description" : "The name of the docker image. Ignored for PUT requests if \"custom\" is set to true."
          },
          "croitTag" : {
            "type" : "string",
            "description" : "The docker image tag. Ignored for PUT requests if \"custom\" is set to true."
          }
        },
        "required" : [ "imageName", "croitTag" ]
      },
      "CroitBackendConfiguration" : {
        "description" : "A croit backend configured in the config file.",
        "type" : "object",
        "required" : [ "name", "url" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Display name of the croit cluster"
          },
          "url" : {
            "type" : "string",
            "description" : "API endpoint"
          }
        }
      },
      "CroitDependency" : {
        "type" : "object",
        "required" : [ "id", "dependency", "link", "license", "text" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "dependency" : {
            "type" : "string"
          },
          "link" : {
            "type" : "string"
          },
          "license" : {
            "type" : "string"
          },
          "text" : {
            "type" : "string"
          }
        }
      },
      "CroitHealthStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DB_ERROR", "INTERNAL_ERROR" ]
      },
      "CroitServiceType" : {
        "type" : "string",
        "enum" : [ "osd", "mon", "mgr", "radosgw", "mds", "nfs_gateway", "iscsi", "smb", "rbd_mirror", "daos_server", "daos_agent", "nvmf_tgt", "unknown" ]
      },
      "CroitUser" : {
        "type" : "object",
        "required" : [ "userName", "roles", "providerName", "idString", "name" ],
        "properties" : {
          "userName" : {
            "type" : "string"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean"
          },
          "isApiToken" : {
            "type" : "boolean"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "providerName" : {
            "type" : "string"
          },
          "idString" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          }
        }
      },
      "CroitVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "patch" : {
            "type" : "string"
          },
          "cephRelease" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephRelease"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "patch" ]
      },
      "CrushBucketType" : {
        "type" : "string",
        "enum" : [ "OSD", "HOST", "CHASSIS", "RACK", "ROW", "PDU", "POD", "ROOM", "DATACENTER", "ZONE", "REGION", "ROOT", "UNKNOWN" ]
      },
      "CrushNode" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OsdStatus"
            }, {
              "type" : "null"
            } ]
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushBucketType"
          },
          "children" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "used" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "reweight" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "diskId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalGuid" : {
            "type" : [ "string", "null" ]
          },
          "pgs" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "CrushRuleOp" : {
        "type" : "string",
        "enum" : [ "TAKE", "CHOOSE", "CHOOSE_INDEP", "CHOOSELEAF", "CHOOSELEAF_INDEP", "EMIT", "NOOP", "UNKNOWN", "TUNING" ]
      },
      "CrushRuleResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushRuleType"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "steps" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleStep"
            }
          },
          "typeLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "type", "steps", "typeLabel" ]
      },
      "CrushRuleStep" : {
        "type" : "object",
        "required" : [ "op", "crushMapTextFormat" ],
        "properties" : {
          "op" : {
            "$ref" : "#/components/schemas/CrushRuleOp"
          },
          "crushMapTextFormat" : {
            "type" : "string"
          }
        }
      },
      "CrushRuleType" : {
        "type" : "string",
        "enum" : [ "REPLICATED", "ERASURE" ]
      },
      "CrushTree" : {
        "type" : "object",
        "required" : [ "nodes", "stray" ],
        "properties" : {
          "nodes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          },
          "stray" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          }
        }
      },
      "DaosAclEntry" : {
        "discriminator" : {
          "propertyName" : "kind",
          "mapping" : {
            "raw" : "#/components/schemas/RawDaosAcl",
            "parsed" : "#/components/schemas/ParsedDaosAcl"
          }
        },
        "type" : "object"
      },
      "DaosAclFlag" : {
        "type" : "string",
        "enum" : [ "G" ]
      },
      "DaosAclPermission" : {
        "type" : "string",
        "enum" : [ "r", "w", "c", "d", "t", "T", "a", "A", "o" ]
      },
      "DaosAclPrincipalType" : {
        "type" : "string",
        "enum" : [ "PosixUser", "PosixGroup", "PosixOther", "User", "Group" ]
      },
      "DaosAclResponse" : {
        "type" : "object",
        "required" : [ "entries", "entriesRaw", "ownerUser", "ownerGroup" ],
        "properties" : {
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries parsed into structured JSON. If the ACL failed to be parsed, it's mapped into an entry of kind \"RawDaosAcl\"."
          },
          "entriesRaw" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "ACL entries how they are reported by DAOS, without any parsing done to them."
          },
          "ownerUser" : {
            "type" : "string",
            "description" : "User that owns the pool."
          },
          "ownerGroup" : {
            "type" : "string",
            "description" : "Group that owns the pool."
          }
        }
      },
      "DaosAclType" : {
        "type" : "string",
        "enum" : [ "A" ]
      },
      "DaosCapacity" : {
        "type" : "object",
        "properties" : {
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total NVMe capacity in GB."
          },
          "scm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total SCM capacity in GB."
          }
        }
      },
      "DaosCertificateCreationRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosCertificateResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the certificate, or -1 if it's a DAOS system certificate."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the certificate."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the certificate."
          },
          "expiry" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry of the certificate. If possible, check the CRT file instead."
          },
          "type" : {
            "description" : "Type of certificate.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosCertificateType"
          }
        },
        "required" : [ "name", "description", "expiry", "type" ]
      },
      "DaosCertificateType" : {
        "type" : "string",
        "enum" : [ "CA", "SERVER", "ADMIN", "AGENT", "CLIENT" ]
      },
      "DaosCertificateUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosClientCreationServerRequest" : {
        "description" : "Server to add as a client to a DAOS cluster.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. Can be left empty for clients."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of targets. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of threads. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "version" : {
            "$ref" : "#/components/schemas/DaosVersion"
          },
          "upgradeVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "provider" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32"
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosServerConfig"
            }
          }
        },
        "required" : [ "clusterName", "name", "description", "version", "provider", "servers" ]
      },
      "DaosContainerDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          },
          "pool" : {
            "description" : "UUID of the pool the container resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "type" : {
            "description" : "Container type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "typeRaw" : {
            "type" : "string",
            "description" : "Container type, as reported by DAOS directly."
          },
          "latestSnapshot" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "redundancyFactor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Redundancy factor of the container."
          },
          "numHandles" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "openTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "closeModifyTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "objectClass" : {
            "type" : [ "string", "null" ]
          },
          "dirObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "hints" : {
            "type" : [ "string", "null" ]
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        },
        "required" : [ "name", "pool", "uuid", "type", "typeRaw" ]
      },
      "DaosContainerListResponse" : {
        "type" : "object",
        "required" : [ "uuid", "name" ],
        "properties" : {
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          }
        }
      },
      "DaosContainerType" : {
        "type" : "string",
        "enum" : [ "POSIX", "HDF5", "PYTHON", "SPARK", "DATABASE", "ROOT", "SEISMIC", "METEO", "UNKNOWN" ]
      },
      "DaosCreationRequest" : {
        "description" : "Request to create a new DAOS cluster.",
        "type" : "object",
        "required" : [ "clusterName", "name", "description", "provider", "servers" ],
        "properties" : {
          "clusterName" : {
            "type" : "string",
            "description" : "Name of the DAOS cluster."
          },
          "name" : {
            "type" : "string",
            "description" : "Optional human-readable name for the cluster."
          },
          "description" : {
            "type" : "string",
            "description" : "Optional description for the cluster."
          },
          "provider" : {
            "type" : "string",
            "description" : "Interface provider."
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of targets for this engine."
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of threads (typically targets divided by 4)"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCreationServerRequest"
            },
            "description" : "List of servers to use for DAOS."
          }
        }
      },
      "DaosCreationServerRequest" : {
        "type" : "object",
        "description" : "Server to add as part of the new DAOS cluster",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "isAccessPoint" : {
            "type" : "boolean",
            "description" : "Whether this is an access point."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. If empty, 1 nics per NUMA node will be automatically selected."
          },
          "scms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of SCMs/PMEMs to use. If not provided, all available will be used."
          },
          "nvmes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of NVMe to use. If not provided, all available will be used."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of targets. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of threads. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosDiskCreationRequest" : {
        "type" : "object",
        "required" : [ "name", "pool", "container" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the new DAOS disk in croit."
          },
          "pool" : {
            "description" : "UUID of the DAOS pool that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes for the disk."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DAOS object class to use for the disk."
          }
        }
      },
      "DaosDiskInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "path" : {
            "type" : "string"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "path" ]
      },
      "DaosEngineConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "numaNode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nic" : {
            "$ref" : "#/components/schemas/DaosNic"
          },
          "scms" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          },
          "nvmes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          }
        },
        "required" : [ "nic", "scms", "nvmes" ]
      },
      "DaosMemberState" : {
        "type" : "string",
        "enum" : [ "AwaitFormat", "Starting", "Ready", "Joined", "Stopping", "Stopped", "Excluded", "AdminExcluded", "Errored", "Unresponsive", "Unknown" ]
      },
      "DaosNic" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "mac" ]
      },
      "DaosPoolDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "state" : {
            "description" : "Pool state parsed as an enum. Unrecognized values are mapped to \"Unknown\"",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "Pool state, as reported by DAOS directly."
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "leader" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rebuild" : {
            "description" : "Rebuild status of the pool, if available.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPoolRebuildResponse"
            }, {
              "type" : "null"
            } ]
          },
          "targetsTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total targets."
          },
          "targetsActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active targets."
          },
          "targetsDisabled" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of disabled targets."
          },
          "enginesTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of engines that manage the pool."
          },
          "version" : {
            "type" : "integer",
            "format" : "int32"
          },
          "upgradeLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "tierStats" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolTierStatsResponse"
            },
            "description" : "Data usage per storage tier."
          }
        },
        "required" : [ "uuid", "name", "state", "stateRaw", "tierStats" ]
      },
      "DaosPoolRebuildResponse" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS pool rebuild status."
          },
          "state" : {
            "description" : "DAOS pool rebuild state, parsed into an enum. Unrecognized values are mapped to \"UNKNOWN\".",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolRebuildState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "DAOS pool rebuild state, as reported directly from DAOS."
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "record" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "state", "stateRaw" ]
      },
      "DaosPoolRebuildState" : {
        "type" : "string",
        "enum" : [ "IDLE", "DONE", "BUSY", "UNKNOWN" ]
      },
      "DaosPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "uuid" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name/label of the pool."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "DaosPoolStorageMediaType" : {
        "type" : "string",
        "enum" : [ "SCM", "NVME", "UNKNOWN" ]
      },
      "DaosPoolTierStatsResponse" : {
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total space available, in bytes."
          },
          "free" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Free space available, in bytes."
          },
          "min" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Minimum space used across NVMes, in bytes."
          },
          "max" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Maximum space used across NVMes, in bytes."
          },
          "mean" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Mean space used across NVMes, in bytes."
          },
          "mediaType" : {
            "description" : "Storage media type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolStorageMediaType"
          },
          "mediaTypeRaw" : {
            "type" : "string",
            "description" : "Storage media type, as reported by DAOS directly."
          }
        },
        "required" : [ "mediaType", "mediaTypeRaw" ]
      },
      "DaosPosixDiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the DAOS disk."
          },
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in."
          },
          "pool" : {
            "description" : "Label of the DAOS pool where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "poolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in."
          },
          "containerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class."
          },
          "nvmeofDisks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF disks that use this disk."
          },
          "nvmeofGateways" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF clusters that use this disk."
          },
          "nvmeofGatewayLabels" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of names of NVMe-oF clusters that use this disk."
          },
          "error" : {
            "description" : "Configuration errors for this cluster, if any.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HintResponse"
            }, {
              "type" : "null"
            } ]
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          },
          "usedByNvmeof" : {
            "type" : "boolean",
            "description" : "True if this disk is currently being used in a NVMe-oF cluster."
          }
        },
        "required" : [ "name", "pool", "container", "poolLabel", "containerLabel", "nvmeofDisks", "nvmeofGateways", "nvmeofGatewayLabels", "sizeFormatted" ]
      },
      "DaosProperty" : {
        "type" : "object",
        "required" : [ "name", "description", "type", "allowed" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "editable" : {
            "type" : "boolean"
          },
          "type" : {
            "$ref" : "#/components/schemas/DaosPropertyType"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPropertyUnit"
            }, {
              "type" : "null"
            } ]
          },
          "allowed" : {
            "type" : "array",
            "items" : { }
          }
        }
      },
      "DaosPropertyResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property."
          },
          "description" : {
            "type" : "string",
            "description" : "Description for the property as reported by DAOS."
          },
          "value" : {
            "type" : "array",
            "description" : "Value of the property, may be arbitrary JSON."
          }
        }
      },
      "DaosPropertyType" : {
        "type" : "string",
        "enum" : [ "String", "Enum", "EnumList", "Int", "IntList" ]
      },
      "DaosPropertyUnit" : {
        "type" : "string",
        "enum" : [ "Percentage", "Bytes", "Seconds" ]
      },
      "DaosRanksRequest" : {
        "type" : "object",
        "properties" : {
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "The list of ranks to work on. If empty or omitted, all ranks are used."
          }
        }
      },
      "DaosServerConfig" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "provider" : {
            "type" : [ "string", "null" ]
          },
          "isAccessPoint" : {
            "type" : "boolean"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "engines" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosEngineConfig"
            }
          },
          "isClientNode" : {
            "type" : "boolean"
          }
        },
        "required" : [ "engines" ]
      },
      "DaosSystemMemberResponse" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the server"
          },
          "addr" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/DaosMemberState"
          },
          "stateRaw" : {
            "type" : "string"
          },
          "faultDomain" : {
            "type" : "string"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "incarnation" : {
            "type" : "integer",
            "format" : "int64"
          },
          "uuid" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "fabricUri" : {
            "type" : "string"
          },
          "fabricContexts" : {
            "type" : "integer",
            "format" : "int32"
          },
          "info" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "string"
          }
        },
        "required" : [ "addr", "state", "stateRaw", "faultDomain", "uuid", "fabricUri", "info", "lastUpdate" ]
      },
      "DaosVerificationError" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationErrorOrWarning" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationResult" : {
        "type" : "object",
        "required" : [ "warnings", "errors", "daosConfig" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationErrorOrWarning"
            }
          },
          "errors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationError"
            }
          },
          "daosConfig" : {
            "$ref" : "#/components/schemas/DaosConfig"
          }
        }
      },
      "DaosVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "DashboardRoleCreateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ]
          },
          "permissions" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          }
        }
      },
      "DashboardRolePermission" : {
        "type" : "string",
        "enum" : [ "read", "create", "update", "delete" ]
      },
      "DashboardRoleUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "addPerms" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "delPerms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DashboardUserCreateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DashboardUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          },
          "passwordHash" : {
            "type" : [ "string", "null" ]
          },
          "setRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "addRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "delRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DataPoint" : {
        "description" : "One point in a plot",
        "type" : "object",
        "properties" : {
          "v" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Value, see unit property of the axis"
          },
          "t" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unix timestamp in seconds"
          }
        }
      },
      "DefaultImageRequest" : {
        "type" : "object",
        "properties" : {
          "overrideServers" : {
            "type" : "boolean"
          },
          "default" : {
            "$ref" : "#/components/schemas/UUID"
          }
        },
        "required" : [ "default" ]
      },
      "DefaultImageResponse" : {
        "type" : "object",
        "required" : [ "uuid" ],
        "properties" : {
          "uuid" : {
            "type" : "string"
          }
        }
      },
      "DeleteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "acl" : {
            "description" : "ACL to delete. May be provided instead of the principal, the principal of this ACL will then be used.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosAclEntry"
            }, {
              "type" : "null"
            } ]
          },
          "principal" : {
            "type" : [ "string", "null" ],
            "description" : "Principal whose ACL is to be removed. May be provided as alternative to the ACL."
          },
          "isGroup" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether the principal is a group or user. Only needs to be provided when providing the principal name instead of the entire ACL."
          }
        }
      },
      "DeleteDiskRequest" : {
        "type" : "object",
        "properties" : {
          "deleteData" : {
            "type" : "boolean",
            "description" : "Delete RBD image in Ceph"
          }
        }
      },
      "DestroyedOsdId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "host" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DestroyedOsdIds" : {
        "type" : "object",
        "required" : [ "destroyedOsds" ],
        "properties" : {
          "destroyedOsds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DestroyedOsdId"
            }
          }
        }
      },
      "DeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "DiskDeleteRequest" : {
        "description" : "Request to wipe a disk",
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server containing the disk"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk"
          },
          "serial" : {
            "type" : "string",
            "description" : "Serial of the disk (confirmation to prevent wiping the wrong disk by mistake)"
          },
          "destroy" : {
            "type" : "boolean",
            "description" : "Whether to destroy the corresponding OSD in the CRUSH map. Defaults to false."
          }
        },
        "required" : [ "serial" ]
      },
      "DiskDeleteRequestWrapper" : {
        "description" : "Request to wipe several disks",
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskDeleteRequest"
            }
          }
        }
      },
      "DiskDeviceClass" : {
        "type" : "string",
        "enum" : [ "hdd", "ssd", "nvme", "pmem" ]
      },
      "DiskPathResponse" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk that this path belongs to."
          },
          "devName" : {
            "type" : "string",
            "description" : "Name of the kernel device that represents this path."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the path is active."
          },
          "state" : {
            "type" : "string",
            "description" : "State of the path. Typically only useful for non-active paths."
          }
        },
        "required" : [ "devName", "state" ]
      },
      "DiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "type" : {
            "description" : "Type of disk. Doesn't refer to the disk's model or device class, but if it's a multipath disk or not.",
            "type" : "string",
            "$ref" : "#/components/schemas/DiskType"
          },
          "serial" : {
            "type" : "string"
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "serials" : {
            "type" : "object"
          },
          "wwns" : {
            "type" : "object"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes. See \"sizeFormatted\" for a human-readable string."
          },
          "name" : {
            "type" : "string",
            "description" : "Model name of the disk."
          },
          "pathRaw" : {
            "type" : "string",
            "description" : "Path of the disk. Will be outdated/invalid in case the disk is missing."
          },
          "info" : {
            "type" : [ "string", "null" ]
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdFragmentation" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bootedFrom" : {
            "type" : "boolean"
          },
          "daemonRunning" : {
            "type" : [ "boolean", "null" ]
          },
          "serviceHealth" : {
            "description" : "Current service health of the service associated (if any) with the disk if it is running;can be null if the service or server was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "identifyLed" : {
            "type" : "boolean"
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ],
            "description" : "PCI address for NVMe disks"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this disk belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this disk belongs to one"
          },
          "mpathInfo" : {
            "description" : "Multipath information, if this is a multipath disk.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MultipathInfoResponse"
            }, {
              "type" : "null"
            } ]
          },
          "stats" : {
            "description" : "Disk statistics (when requested)",
            "type" : "object",
            "$ref" : "#/components/schemas/DiskStatsResponse"
          },
          "bootable" : {
            "type" : "boolean",
            "description" : "If this disk has croit isntalled on it and can be booted from"
          },
          "status" : {
            "type" : "string",
            "description" : "Disk role with some extra information related to the role."
          },
          "capacity" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Deprecated, use \"size\" instead. Capacity of the disk rounded to GB."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk as a human-readable string."
          },
          "roleLabel" : {
            "type" : "string",
            "description" : "Pretty name for the disk role."
          },
          "isMultipathed" : {
            "type" : "boolean",
            "description" : "True if this is a multipathed disks."
          },
          "path" : {
            "type" : [ "string", "null" ],
            "description" : "Path of the disk or null if the disk is missing."
          },
          "pathFormatted" : {
            "type" : "string",
            "description" : "Path of the disk, or an info string in case the disk is missing."
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the disk belongs to."
          }
        },
        "required" : [ "hostname", "role", "type", "serial", "serials", "wwns", "name", "pathRaw", "deviceClass", "lastSeen", "serverLastSeen", "smart", "stats", "status", "sizeFormatted", "roleLabel", "pathFormatted", "numaNodeFormatted" ]
      },
      "DiskRole" : {
        "type" : "string",
        "enum" : [ "unassigned", "mon", "osd", "journal", "other", "raid", "deleting", "updating", "mon_unused", "old_osd", "old_mon", "daos_nvme", "daos_scm", "boot" ]
      },
      "DiskSmartStatus" : {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "type" : "string",
            "description" : "SMART health status extracted from the SMART health details."
          },
          "temperature" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Temperature extracted from the SMART health details, in Celsius."
          },
          "details" : {
            "type" : [ "string", "null" ],
            "description" : "SMART health details."
          }
        }
      },
      "DiskStatsResponse" : {
        "type" : "object",
        "properties" : {
          "read" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Reads measured in bytes per second"
          },
          "write" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Writes measured in bytes per second"
          },
          "iopsRead" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Read IOPS"
          },
          "iopsWrite" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Write IOPS"
          },
          "ioLoad" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Overall IO load as percentage"
          },
          "readFormatted" : {
            "type" : "string"
          },
          "writeFormatted" : {
            "type" : "string"
          },
          "iopsReadFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "iopsWriteFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "ioLoadFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "readFormatted", "writeFormatted", "ioLoadFormatted" ]
      },
      "DiskType" : {
        "type" : "string",
        "enum" : [ "normal", "mpath" ]
      },
      "DiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "role" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DiskRole"
            }, {
              "type" : "null"
            } ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "identifyLed" : {
            "type" : [ "boolean", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          }
        }
      },
      "Distribution" : {
        "type" : "string",
        "enum" : [ "DEBIAN", "SUSE", "SLES", "UNKNOWN" ]
      },
      "DownloadableObject" : {
        "type" : "object",
        "required" : [ "fileName", "data", "url" ],
        "properties" : {
          "fileName" : {
            "type" : "string"
          },
          "data" : {
            "type" : "string",
            "writeOnly" : true
          },
          "url" : {
            "type" : "string",
            "format" : "uri"
          },
          "fileContents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "ErasureCodeProfileDump" : {
        "type" : "object",
        "properties" : {
          "k" : {
            "type" : "integer",
            "format" : "int32"
          },
          "m" : {
            "type" : "integer",
            "format" : "int32"
          },
          "plugin" : {
            "type" : "string"
          },
          "technique" : {
            "type" : "string"
          },
          "crush-device-class" : {
            "type" : [ "string", "null" ]
          },
          "crush-failure-domain" : {
            "type" : [ "string", "null" ]
          },
          "crush-root" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "plugin", "technique" ]
      },
      "EventHookEvent" : {
        "type" : "string",
        "enum" : [ "PreNetworkConfig", "PostNetworkConfig", "PreDaemonStart", "PostDaemonStart", "PreFormatDisk", "PostFormatDisk", "PostCephDaemonStart", "OnHealthDegrade", "OnHealthImprove", "OnHealthRecover", "PreCrushMapChange", "PostCrushMapChange", "PostConfigChanged", "OnDhcpLeaseUpdate", "OnPersistentAvailable", "OnCephFsSnapshotComplete", "OnRbdSnapshotComplete", "OnAudit", "OnCroitStartup", "OnCroitAsyncStartup" ]
      },
      "ExportFormats" : {
        "type" : "string",
        "enum" : [ "raw", "cat", "short", "with-unit" ]
      },
      "FieldCondition" : {
        "description" : "Conditions that can be applied to a specific field.",
        "type" : "object",
        "properties" : {
          "_eq" : {
            "type" : [ "string", "null" ],
            "description" : "Equal to the specified value."
          },
          "_neq" : {
            "type" : [ "string", "null" ],
            "description" : "Not equal to the specified value."
          },
          "_gt" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than the specified value."
          },
          "_gte" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than or equal to the specified value."
          },
          "_lt" : {
            "type" : [ "string", "null" ],
            "description" : "Less than the specified value."
          },
          "_lte" : {
            "type" : [ "string", "null" ],
            "description" : "Less than or equal to the specified value."
          },
          "_regex" : {
            "type" : [ "string", "null" ],
            "description" : "Matches the specified regular expression."
          },
          "_in" : {
            "type" : [ "string", "null" ],
            "description" : "Value is in the specified list or contains the specified substring."
          },
          "_contains" : {
            "type" : [ "string", "null" ],
            "description" : "Value contains the specified item(s)."
          },
          "_nin" : {
            "type" : [ "string", "null" ],
            "description" : "Value is not in the specified list."
          }
        }
      },
      "Finding" : {
        "type" : "object",
        "required" : [ "severity", "category", "shortDescription", "description", "id" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/Severity"
          },
          "category" : {
            "$ref" : "#/components/schemas/Category"
          },
          "shortDescription" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "FreeIp" : {
        "type" : "object",
        "required" : [ "ip", "subnetShort" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "subnetShort" : {
            "type" : "string"
          }
        }
      },
      "GeneratedId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "GraphAxisResponse" : {
        "description" : "Collection of plots with the same unit",
        "type" : "object",
        "required" : [ "unit", "graphs" ],
        "properties" : {
          "unit" : {
            "$ref" : "#/components/schemas/StatsUnit"
          },
          "graphs" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Plot"
            }
          }
        }
      },
      "GraphResponse" : {
        "description" : "A single diagram/graph",
        "type" : "object",
        "required" : [ "name", "axis1" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Suggested title for the graph"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Suggested description for the graph"
          },
          "axis1" : {
            "description" : "Data associated with the first y axis",
            "type" : "object",
            "$ref" : "#/components/schemas/GraphAxisResponse"
          },
          "axis2" : {
            "description" : "Optional data associated with the second y axis",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/GraphAxisResponse"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "HaGroup" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServer"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers" ]
      },
      "HaGroupAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "haGroupId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "HaGroupResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServerResponse"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          },
          "serversFormatted" : {
            "type" : "string"
          },
          "serviceLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers", "serversFormatted", "serviceLabel" ]
      },
      "HaGroupServer" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupServerResponse" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ]
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupService" : {
        "type" : "string",
        "enum" : [ "nfs", "rgw", "smb", "iscsi", "none" ]
      },
      "HardwareResponse" : {
        "type" : "object",
        "properties" : {
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "coresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "cpuFreq" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "mainboardSerial" : {
            "type" : [ "string", "null" ]
          },
          "ipmi" : {
            "type" : [ "object", "null" ]
          },
          "ramFormatted" : {
            "type" : "string"
          },
          "cpuFreqFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "ramFormatted", "cpuFreqFormatted" ]
      },
      "HealthCheckMuteRequest" : {
        "description" : "Request to mute a health check.",
        "type" : "object",
        "properties" : {
          "ttl" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Time in seconds until the health check is unmuted."
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Whether or not the health check should stay muted even after it is resolved."
          }
        }
      },
      "HintResponse" : {
        "type" : "object",
        "required" : [ "message", "severity" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "severity" : {
            "$ref" : "#/components/schemas/HintSeverity"
          }
        }
      },
      "HintSeverity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARN", "ERROR" ]
      },
      "HookInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptName" : {
            "type" : "string"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "serverNames" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "scriptName", "event", "serverIds", "serverNames" ]
      },
      "HookPointInfo" : {
        "type" : "object",
        "required" : [ "name", "description", "parameters" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "canChooseServer" : {
            "type" : "boolean",
            "description" : "True for hook points running on Ceph nodes. False for hook points running on the management node."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the hook point."
          },
          "parameters" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookScriptParameter"
            },
            "description" : "Information on parameters passed to the script."
          }
        }
      },
      "HookRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        },
        "required" : [ "event", "serverIds" ]
      },
      "HookScriptParameter" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "HookScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          }
        }
      },
      "HookUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "event" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/EventHookEvent"
            }, {
              "type" : "null"
            } ]
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ImageInfoResponse" : {
        "type" : "object",
        "required" : [ "description" ],
        "properties" : {
          "description" : {
            "type" : "string"
          }
        }
      },
      "ImageListReply" : {
        "type" : "object",
        "properties" : {
          "latestX86" : {
            "description" : "Latest X86_64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "latestArm64" : {
            "description" : "Latest ARM64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultX86" : {
            "description" : "Currently configured default x86_64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultArm64" : {
            "description" : "Currently configured default ARM64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "images" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total number of images. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination offset. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination limit. Only provided when using pagination."
          }
        }
      },
      "ImagePackage" : {
        "type" : "object",
        "required" : [ "name", "version", "release" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "version" : {
            "type" : "string"
          },
          "release" : {
            "type" : "string"
          }
        }
      },
      "ImageResponse" : {
        "type" : "object",
        "required" : [ "flags", "id", "description", "timestamp", "os", "osVersion", "osName", "osRepoVersion", "cpuArchitecture", "cephVersionShort", "kernelVersion", "sambaVersion", "commit", "ganeshaVersion", "flagsFormatted" ],
        "properties" : {
          "flags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "os" : {
            "$ref" : "#/components/schemas/Distribution"
          },
          "osVersion" : {
            "type" : "string"
          },
          "osName" : {
            "type" : "string"
          },
          "osRepoVersion" : {
            "type" : "string"
          },
          "cpuArchitecture" : {
            "$ref" : "#/components/schemas/CpuArchitecture"
          },
          "cephVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephVersion"
            }, {
              "type" : "null"
            } ]
          },
          "cephVersionShort" : {
            "type" : "string"
          },
          "kernelVersion" : {
            "type" : "string"
          },
          "sambaVersion" : {
            "type" : "string"
          },
          "commit" : {
            "type" : "string"
          },
          "ganeshaVersion" : {
            "$ref" : "#/components/schemas/SemanticVersion"
          },
          "daosVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "isDefault" : {
            "type" : "boolean"
          },
          "isDeprecated" : {
            "type" : "boolean"
          },
          "isNightly" : {
            "type" : "boolean"
          },
          "isExtended" : {
            "type" : "boolean"
          },
          "hasSssd" : {
            "type" : "boolean"
          },
          "supportsBoot" : {
            "type" : "boolean"
          },
          "downloaded" : {
            "type" : "boolean"
          },
          "downloading" : {
            "type" : "boolean"
          },
          "fileSize" : {
            "type" : "integer",
            "format" : "int64"
          },
          "progress" : {
            "type" : "integer",
            "format" : "int64"
          },
          "downloadError" : {
            "type" : [ "string", "null" ]
          },
          "flagsFormatted" : {
            "type" : "string"
          }
        }
      },
      "InitialMonServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "hostname", "ips" ]
      },
      "InstallCroitRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/BootDiskRequest"
            }
          }
        }
      },
      "InterfaceResponse" : {
        "type" : "object",
        "required" : [ "ips", "interfaces" ],
        "properties" : {
          "ips" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpResponse"
            }
          },
          "interfaces" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "currentInterface" : {
            "type" : [ "string", "null" ]
          },
          "currentIp" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IpAddressInfo" : {
        "type" : "object",
        "required" : [ "nic", "vlan", "hagroup", "smb" ],
        "properties" : {
          "nic" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicAddressInfo"
            }
          },
          "vlan" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanAddressInfo"
            }
          },
          "hagroup" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupAddressInfo"
            }
          },
          "smb" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbAddressInfo"
            }
          }
        }
      },
      "IpGeneralInfo" : {
        "description" : "Contains generalized information about an IP address.",
        "type" : "object",
        "required" : [ "ip", "type" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/IpType"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server that this IP is configured for"
          },
          "subnet" : {
            "description" : "The subnet the IP address resides in",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkInfo"
            }, {
              "type" : "null"
            } ]
          },
          "subnetShort" : {
            "type" : [ "string", "null" ],
            "description" : "CIDR notation for the subnet (e.g. 10.0.0.0/24)"
          },
          "inDHCPPool" : {
            "type" : "boolean",
            "description" : "True if this IP is part of a DHCP pool configured in croit"
          }
        }
      },
      "IpResponse" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int16"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "IpType" : {
        "type" : "string",
        "enum" : [ "NIC", "SERVER", "VLAN", "HA_GROUP", "SMB" ]
      },
      "IpmiAccess" : {
        "description" : "Access details for an IPMI device",
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Username to use"
          },
          "password" : {
            "type" : "string",
            "description" : "Password to use"
          },
          "keepAdminPassword" : {
            "type" : "boolean",
            "description" : "Whether to change the password to the croit default"
          }
        }
      },
      "IpmiConfig" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "IpmiDevice" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "server" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServerInfo"
            }, {
              "type" : "null"
            } ]
          },
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "ip", "mac", "warnings" ]
      },
      "IpmiDeviceRequest" : {
        "description" : "Request to add an IPMI device that is not managed by croit's DHCP server",
        "type" : "object",
        "required" : [ "ip", "access" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "IP address of the IPMI device"
          },
          "access" : {
            "description" : "How to access this device",
            "type" : "object",
            "$ref" : "#/components/schemas/IpmiAccess"
          }
        }
      },
      "IpmiDeviceState" : {
        "type" : "object",
        "properties" : {
          "power" : {
            "type" : "boolean"
          },
          "sysTemperature" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpuTemperatures" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          },
          "fanSpeeds" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "cpuTemperatures", "fanSpeeds" ]
      },
      "IpmiDeviceStateWrapper" : {
        "type" : "object",
        "required" : [ "warnings" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IpmiInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "ip", "mac" ]
      },
      "IscsiAddDiskToClientRequest" : {
        "type" : "object",
        "required" : [ "pool", "name", "backstore" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB if the image does not exist yet, pass null to add an existing image"
          },
          "backstore" : {
            "$ref" : "#/components/schemas/IscsiBackstore"
          }
        }
      },
      "IscsiBackstore" : {
        "type" : "string",
        "enum" : [ "USER", "KERNEL" ]
      },
      "IscsiClientChangeRequest" : {
        "type" : "object",
        "properties" : {
          "username" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientCreationRequest" : {
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "group" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientLun" : {
        "type" : "object",
        "required" : [ "pool", "image", "wwn" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "wwn" : {
            "type" : "string"
          }
        }
      },
      "IscsiClientResponse" : {
        "type" : "object",
        "required" : [ "name", "group", "username", "password", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "group" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiGatewayConfig" : {
        "type" : "object",
        "required" : [ "iqn", "gateways", "clients", "groups", "disks", "selectedTarget", "targets" ],
        "properties" : {
          "iqn" : {
            "type" : "string"
          },
          "gateways" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiServerResponse"
            }
          },
          "clients" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientResponse"
            }
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGroupResponse"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          },
          "selectedTarget" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "gatewayVersion" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "IscsiGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "IscsiGatewayDisksResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name of the disk."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name where the RBD is located at."
          },
          "wwn" : {
            "type" : "string",
            "description" : "WWN of the disk in iSCSI."
          },
          "lunId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Lun ID of the disk in iSCSI."
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Groups that use this disk."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Host IQNs that use this disk."
          }
        },
        "required" : [ "image", "pool", "wwn", "groups", "hosts" ]
      },
      "IscsiGatewayGroupsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "group" : {
            "type" : "string",
            "description" : "Name of the group."
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Hosts in the group."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this group."
          }
        },
        "required" : [ "group", "members", "luns" ]
      },
      "IscsiGatewayHostsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "iqn" : {
            "type" : "string",
            "description" : "IQN of the host."
          },
          "username" : {
            "type" : "string",
            "description" : "CHAP username."
          },
          "password" : {
            "type" : "string",
            "description" : "CHAP password."
          },
          "group" : {
            "type" : "string",
            "description" : "Group that the host belongs to."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this host."
          }
        },
        "required" : [ "iqn", "username", "password", "group", "luns" ]
      },
      "IscsiGatewayServer" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string",
            "description" : "Client-facing IP address of this gateway, must be configured on the server."
          }
        },
        "required" : [ "ip" ]
      },
      "IscsiGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP of the server used for iSCSI"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "IscsiGatewayService" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServer"
            },
            "minItems" : 1
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiGroupResponse" : {
        "type" : "object",
        "required" : [ "name", "members", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiImageChangeRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB"
          }
        }
      },
      "IscsiImageDetails" : {
        "type" : "object",
        "properties" : {
          "image" : {
            "type" : [ "string", "null" ]
          },
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "backstore" : {
            "type" : [ "string", "null" ]
          },
          "controls" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : { }
          },
          "backstoreParsed" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IscsiBackstore"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IscsiImagesResponse" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "details" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "$ref" : "#/components/schemas/IscsiImageDetails"
            }
          }
        }
      },
      "IscsiServerResponse" : {
        "type" : "object",
        "required" : [ "name", "ip" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "IscsiServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "KeyUpdateRequest" : {
        "description" : "List of SSH keys allowed to access managed servers.",
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "LicenseCephStatus" : {
        "type" : "object",
        "required" : [ "health", "utilizationByDeviceClass" ],
        "properties" : {
          "health" : {
            "type" : "string"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/LicenseDeviceClassUtilization"
            }
          }
        }
      },
      "LicenseDeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "LicenseDiskCapacities" : {
        "type" : "object",
        "properties" : {
          "unassigned" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of unassigned disks."
          },
          "osd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of OSD disks (not including separate DB/WAL partitions)."
          },
          "journal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DB/WAL disks."
          },
          "mon" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of mon disks."
          },
          "daosNvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS NVMes."
          },
          "daosScm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS SCMs."
          },
          "other" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of all other disks."
          }
        }
      },
      "LicenseInfo" : {
        "type" : "object",
        "properties" : {
          "fsid" : {
            "type" : [ "string", "null" ]
          },
          "croitId" : {
            "type" : "string"
          },
          "licenseId" : {
            "type" : "string"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "licenseRestrictions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SignedLicenseData"
            }, {
              "type" : "null"
            } ]
          },
          "registered" : {
            "type" : "boolean"
          },
          "preSetup" : {
            "type" : "boolean"
          }
        },
        "required" : [ "croitId", "licenseId", "validUntil", "nextRefresh" ]
      },
      "LicensePatchRequest" : {
        "type" : "object",
        "properties" : {
          "email" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "LicenseReply" : {
        "description" : "Current license state and usage.",
        "type" : "object",
        "required" : [ "license", "message", "usageFormatted" ],
        "properties" : {
          "license" : {
            "description" : "The currently active license",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseInfo"
          },
          "currentUsage" : {
            "description" : "Cluster usage for licensing purposes",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseUsage"
            }, {
              "type" : "null"
            } ]
          },
          "message" : {
            "type" : "string",
            "description" : "Informational message with license details, e.g., a reason why it is invalid"
          },
          "email" : {
            "type" : [ "string", "null" ],
            "description" : "Configured email address for license notifications."
          },
          "active" : {
            "type" : "boolean",
            "description" : "Whether the license is active"
          },
          "registered" : {
            "type" : "boolean",
            "description" : "Whether the cluster is registered with portal.croit.io"
          },
          "usageFormatted" : {
            "type" : "string",
            "description" : "A string representing current usage and license limits."
          }
        }
      },
      "LicenseUsage" : {
        "description" : "Current cluster usage for licensing purposes.",
        "type" : "object",
        "required" : [ "osds", "rawCapacityGb", "disks", "servers", "rawDaosCapacity" ],
        "properties" : {
          "osds" : {
            "description" : "Number of OSDs by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Raw capacity for ceph by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Used capacity for ceph by device type. (incl. replication overhead)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "netUsageGb" : {
            "description" : "Used capacity for ceph by device type (excl. replication overhead).",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "disks" : {
            "description" : "Raw disk capacity by device type as reported by the nodes, ignoring ceph.",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseDiskCapacities"
          },
          "cephStatus" : {
            "description" : "Cluster status reported by ceph. Contains similar information to rawCapacityGb and usedCapacityGb, but in raw bytes, and with information on data balance across OSDs.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseCephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "servers" : {
            "description" : "Number of servers.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "daosClusters" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of DAOS clusters."
          },
          "daosServers" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of servers running DAOS."
          },
          "rawDaosCapacity" : {
            "description" : "Raw capacity for DAOS by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosCapacity"
          }
        }
      },
      "LogsQLRequest" : {
        "description" : "VictoriaLogs request that wraps PaginationRequest with additional parameters. Used for both LogViewer Websocket and Log export.",
        "type" : "object",
        "required" : [ "query", "type" ],
        "properties" : {
          "query" : {
            "description" : "Base pagination request for filtering, sorting and limiting",
            "type" : "object",
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "type" : {
            "description" : "Type of logs query - either 'tail' to stream recent logs or 'query' for logs within a time range",
            "type" : "string",
            "$ref" : "#/components/schemas/LogsQLRequestType"
          },
          "start" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Start time for query type requests (required for 'query' type)"
          },
          "end" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "End time for query type requests (required for 'query' type)"
          }
        }
      },
      "LogsQLRequestType" : {
        "type" : "string",
        "enum" : [ "tail", "query" ]
      },
      "MainIpRequest" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "ManagedTask" : {
        "description" : "A long-running task that goes on in the background after this task is completed. See tasks endpoints for details",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "ManagedTaskProgress" : {
        "type" : "object",
        "description" : "Progress indication of a background task.",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "ManagedTaskState" : {
        "type" : "string",
        "enum" : [ "WAITING", "RUNNING", "FINISHED", "FAILED", "CANCELED" ]
      },
      "ManagedThreadTask" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "done" : {
            "type" : "boolean"
          },
          "result" : { },
          "cancelled" : {
            "type" : "boolean",
            "writeOnly" : true
          },
          "questionLock" : {
            "type" : "object",
            "writeOnly" : true
          },
          "condition" : {
            "type" : "object",
            "writeOnly" : true
          },
          "question" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestion"
            }, {
              "type" : "null"
            } ]
          },
          "thread" : {
            "type" : "object",
            "writeOnly" : true
          },
          "output" : {
            "type" : "string"
          },
          "interactive" : {
            "type" : "boolean"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "MaxMdsSetting" : {
        "type" : "object",
        "properties" : {
          "maxMds" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Max Mds for CephFS. Shouldn't be higher than the number of servers minus one, to leave at least one standby MDS."
          }
        }
      },
      "MdsOnlineStatus" : {
        "type" : "object",
        "properties" : {
          "active" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standbyReplay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standby" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MdsRankEntry" : {
        "type" : "object",
        "properties" : {
          "filesystemId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "status" ]
      },
      "MgrCrashReport" : {
        "description" : "List of Ceph daemon crashes",
        "type" : "object",
        "required" : [ "crashes" ],
        "properties" : {
          "crashes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            }
          }
        }
      },
      "MgrCrashReportEntry" : {
        "type" : "object",
        "description" : "Summarized report of a crashed Ceph daemon",
        "required" : [ "id", "timestamp" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "process" : {
            "type" : [ "string", "null" ],
            "description" : "ceph process identifier if available, e.g., ceph-osd@123"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Host on which the process was running"
          },
          "archived" : {
            "type" : "boolean",
            "description" : "Whether this crash is archived; crashes without this flag trigger a Ceph health warning."
          }
        }
      },
      "MinCompatClientVersion" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "description" : "Ceph release version to set min compat client to.",
            "type" : "string",
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "MonServiceRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MonitorRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "MonitoredRbd" : {
        "type" : "object",
        "required" : [ "poolName", "rbdName", "namespace" ],
        "properties" : {
          "poolName" : {
            "type" : "string",
            "description" : "The pool image"
          },
          "rbdName" : {
            "type" : "string",
            "description" : "The Rbd image"
          },
          "namespace" : {
            "type" : "string",
            "description" : "The pool namespace"
          }
        }
      },
      "MultiServerServiceResponse" : {
        "type" : "object",
        "required" : [ "id", "name", "type", "state", "multiServer", "typeLabel", "status" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used for systemd."
          },
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServiceState"
          },
          "subState" : {
            "description" : "Service-specific sub-state for MGR and MDS services. Indicates active and standby daemons.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceSubState"
            }, {
              "type" : "null"
            } ]
          },
          "mdsInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MdsRankEntry"
            }, {
              "type" : "null"
            } ]
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "running" : {
            "type" : "boolean"
          },
          "multiServer" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "health" : {
            "description" : "Current service health, can be null if the service was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the DAOS cluster that this service belongs to."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port used by the service. Only available for RGW services."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "TLS/SSL Port used by the service. Only available for RGW services."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "DNS name for an RGW service. Only available for RGW services."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "RGW zone configured for this service. Only available for RGW services."
          },
          "typeLabel" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string",
            "description" : "Extra status information for the service. Only available for MGR, MDS and RGW."
          }
        }
      },
      "MultipartUploadListing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "MultipathInfoResponse" : {
        "type" : "object",
        "required" : [ "paths", "pathsFormatted", "info", "stateLabel" ],
        "properties" : {
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of paths with their information."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "List of paths parsed into a single string."
          },
          "numActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active paths."
          },
          "numTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total paths."
          },
          "numMax" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "maximum number of paths that croit ever saw for this disk."
          },
          "info" : {
            "type" : "string",
            "description" : "Multipath info summarized as a simple string to display in the UI."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "True if all paths are active."
          },
          "stateLabel" : {
            "type" : "string",
            "description" : "Label containing the states of the paths."
          }
        }
      },
      "NetworkInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this network, generated internally"
          },
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool emd address"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : "string",
            "$ref" : "#/components/schemas/NetworkType"
          },
          "description" : {
            "type" : "string",
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null indicates the default MTU of 1500"
          }
        },
        "required" : [ "ip", "type", "description" ]
      },
      "NetworkType" : {
        "type" : "string",
        "enum" : [ "other", "ceph_public", "ceph_internal", "croit", "ipmi" ]
      },
      "NetworkUpdateRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address, required if poolEnd is set"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool end address, required if poolStart is set"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkType"
            }, {
              "type" : "null"
            } ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null sets the default MTU of 1500"
          }
        }
      },
      "NewActiveDirectorySmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path", "roUsers", "rwUsers" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "roUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          }
        }
      },
      "NewNfsGatewayExport" : {
        "type" : "object",
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ],
        "properties" : {
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        }
      },
      "NewNfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewNfsGatewayExport"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewSimpleSmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : "boolean",
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : "boolean",
            "description" : "Enable access for the croit-ro user."
          }
        }
      },
      "NewSmbGatewayShare" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "simple" : "#/components/schemas/NewSimpleSmbGatewayShare",
            "ad" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
          }
        },
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          }
        }
      },
      "NewUserRequest" : {
        "type" : "object",
        "required" : [ "uid", "name" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "tenant" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewVlanRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsExportPermission" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsExportPermissionResponse" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "NfsGatewayExport" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ]
      },
      "NfsGatewayExportResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermissionResponse"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocolsResponse"
          },
          "filesystem" : {
            "type" : "string"
          },
          "accessJoined" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem", "accessJoined" ]
      },
      "NfsGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "Management IP of the server"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "NfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExport"
            }
          }
        }
      },
      "NfsGatewayServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "servers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsProtocols" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NfsProtocolsResponse" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NicAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "NicBondType" : {
        "type" : "string",
        "enum" : [ "lacp", "active_passive" ]
      },
      "NicResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicType"
            }, {
              "type" : "null"
            } ]
          },
          "bondedNics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NICs that are part of this bond"
          },
          "bond" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Bond this NIC is a part of"
          },
          "bondedNicsFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "NICs that are part of this bond (formatted for the frontend to display in a column"
          },
          "bondFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "Bond this NIC is a part of (formatted for the frontend to display in a column"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "vlans" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            }
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "lldp" : {
            "type" : "array",
            "items" : { }
          },
          "bondType" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicBondType"
            }, {
              "type" : "null"
            } ]
          },
          "bondPrimary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "isVirtual" : {
            "type" : "boolean"
          },
          "infinibandMac" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this NIC belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this NIC belongs to one"
          },
          "ipFormatted" : {
            "type" : "string"
          },
          "ip6Formatted" : {
            "type" : "string"
          },
          "vlansJoined" : {
            "type" : "string"
          },
          "speedFormatted" : {
            "type" : "string"
          },
          "neighbor" : {
            "type" : "string"
          },
          "bondTypeLabel" : {
            "type" : "string"
          },
          "port" : {
            "type" : "string",
            "description" : "Port description from LLDP"
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the NIC belongs to"
          }
        },
        "required" : [ "mac", "name", "lastSeen", "serverLastSeen", "vlans", "lldp", "ipFormatted", "ip6Formatted", "vlansJoined", "speedFormatted", "neighbor", "bondTypeLabel", "port", "numaNodeFormatted" ]
      },
      "NicType" : {
        "type" : "string",
        "enum" : [ "normal", "bond", "infiniband" ]
      },
      "NicUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "bond" : {
            "description" : "Updatable bond properties",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/BondUpdateRequest"
            }, {
              "type" : "null"
            } ]
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "Address of the new NIC when replacing NICs. Only applicable for offline servers."
          }
        }
      },
      "NvmeOFBdevType" : {
        "type" : "string",
        "enum" : [ "CEPH", "DAOS" ]
      },
      "NvmeOFCephClusterResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in the NVMe-oF target services."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Client ID to use for this cluster. If null, the croit internal default client for NVMe-oF will be used."
          }
        }
      },
      "NvmeOFDiskCreateRequest" : {
        "type" : "object",
        "required" : [ "type", "subsystems" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the disk to."
          },
          "blockSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NVMe-oF subsystems to attach this disk to."
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "RBD pool name in ceph (required for ceph disks)."
          },
          "image" : {
            "type" : [ "string", "null" ],
            "description" : "RBD image name in ceph (required for ceph disks)."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace in ceph (currently not supported!)."
          },
          "cluster" : {
            "type" : [ "string", "null" ],
            "description" : "RBD cluster configuration that this disk is configured for. If null, the cluster \"croit_cluster\" will be used."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS disk ID in croit. For DAOS disks, either this ID needs to be specified to choose an existing disk, or all of the other DAOS parameters to create a new disk."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the new DAOS disk in croit (required when creating a new DAOS disk)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster ID in croit (required when creating a new DAOS disk)."
          },
          "daosPool" : {
            "description" : "DAOS pool UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "DAOS container UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "totalSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total size in bytes for the disk (required and only applicable when creating a new DAOS disks)."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class to use for the disk (optional when creating a new DAOS disks)."
          }
        }
      },
      "NvmeOFDiskResponse" : {
        "type" : "object",
        "required" : [ "type", "bdevNames", "namespaceNGUID", "namespaceEUI64", "namespaceUUID", "hints", "subsystemNqns", "hosts", "pool", "image", "cluster", "daosPoolLabel", "daosContainerLabel", "oclass", "subsystemsFormatted", "blockSizeFormatted", "sizeFormatted" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NVMe-oF disk in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this disk belongs to."
          },
          "bdevNames" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Map of subsystem IDs to the bdev name used for each subsystem in the NVMe-oF target services."
          },
          "namespaceNGUID" : {
            "type" : "string",
            "description" : "NVMe NGUID device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceEUI64" : {
            "type" : "string",
            "description" : "NVMe EUI-64 device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceUUID" : {
            "description" : "NVMe UUID device identifier that will be used when attaching this disk to a subsystem.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          },
          "subsystemNqns" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Subsystem NQNs that this disk is attached to."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the same subsystem as this disk."
          },
          "blockSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name in ceph (provided if this is a Ceph bdev)."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name in ceph (provided if this is a Ceph bdev)."
          },
          "cluster" : {
            "type" : "string",
            "description" : "RBD cluster configuration that this disk is configured for (provided if this is a Ceph bdev)."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosPool" : {
            "description" : "UUID of the DAOS pool where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "UUID of the DAOS container where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosPoolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosContainerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in (provided if this is a DAOS bdev)."
          },
          "oclass" : {
            "type" : "string",
            "description" : "DAOS object class (provided if this is a DAOS bdev)."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this disk is attached to."
          },
          "blockSizeFormatted" : {
            "type" : "string",
            "description" : "Block size configured for the disk."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          }
        }
      },
      "NvmeOFDiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New image size for the disk."
          }
        }
      },
      "NvmeOFDisksAttachRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the NVMe-oF disks in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFGatewayCreateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Optional name for the cluster to display to the user."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional default configurations for transports to use for NVMe-oF target services."
          },
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
            },
            "description" : "NVMe-oF target services to set up for the new cluster."
          }
        },
        "required" : [ "transportDefaults", "services" ]
      },
      "NvmeOFGatewayResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that can be used in other cluster requests."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in croit. Only used to display it to the user."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the cluster in croit. Only used to display it to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Default configurations for transports to use for NVMe-oF target services."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          }
        },
        "required" : [ "name", "description", "transportDefaults", "hints" ]
      },
      "NvmeOFGatewayUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "New description for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "forceSecure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Force secure channel for listeners. Omit if the current setting should not be changed."
          },
          "transportDefaults" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "New default configurations for transports to use for NVMe-oF target services. Overwrites all existing ones if provided."
          }
        }
      },
      "NvmeOFHostCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the host to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host. The NQN has to be unique within a cluster."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Optional shared key to use for authentication. If omitted, the host won't need to authenticate."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of IDs for subsystems that the host should be attached to."
          }
        },
        "required" : [ "nqn", "subsystems" ]
      },
      "NvmeOFHostResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the host in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key that the host will need to authenticate to NVMe-oF target services."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for subsystems that this host is attached to."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the same subsystem as this host."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this host is attached to."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          },
          "hasSharedKey" : {
            "type" : "boolean",
            "description" : "Whether the host has a shared key for authentication with NVMe-oF target services configured."
          }
        },
        "required" : [ "nqn", "subsystems", "disks", "subsystemsFormatted", "disksFormatted" ]
      },
      "NvmeOFHostUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key to use for authentication. If omitted, the host won't need to authenticate."
          }
        }
      },
      "NvmeOFHostsAttachRequest" : {
        "type" : "object",
        "required" : [ "hosts" ],
        "properties" : {
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the hosts in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFListenerConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the listener belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the listener is configured on."
          },
          "listenerId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the listener."
          },
          "type" : {
            "description" : "Transport type for this listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NIC that this listener is configured to use."
          },
          "nicName" : {
            "type" : "string",
            "description" : "Name of the NIC that this this listener is configured to use."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the VLAN that this listener is configured to use, if at all."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN that this this listener is configured to use, if at all."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port configured for the listener. If null, the cluster's default port will be used."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Secure flag. If true, the listener is configured to use TLS. The cluster's configuration may overwrite this."
          }
        },
        "required" : [ "type", "nicName" ]
      },
      "NvmeOFListenerCreateRequest" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "description" : "Type of the listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the nic that this listener is configured on."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the vlan that this listener is configured on, if at all."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port that the service should listen on."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFListenerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port that the service should listen on (required for TCP and RDMA)."
          },
          "secure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFServiceCreateRequest" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that this service is to be created on."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional transports configurations."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "Optional listeners configurations."
          }
        },
        "required" : [ "transports", "listeners" ]
      },
      "NvmeOFServiceResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the service belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit that this service is installed on."
          },
          "serverHostname" : {
            "type" : "string",
            "description" : "Hostname of the server that this service is installed on."
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages configured for the server."
          },
          "anaState" : {
            "description" : "ANA state to set for all listeners in this service.",
            "type" : "string",
            "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used as systemd name and is automatically generated. Cannot be changed."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the service in croit. Only used to display it to the user."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfigResponse"
            },
            "description" : "Transport configs specific for this service. Note that the cluster's default configs may extend these."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "Listener configs for this service."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this service, if any."
          }
        },
        "required" : [ "serverHostname", "anaState", "name", "description", "transports", "listeners", "hints" ]
      },
      "NvmeOFServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "anaState" : {
            "description" : "Optional ANA state to set for all listeners in this service.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
            }, {
              "type" : "null"
            } ]
          },
          "transports" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "List of transport configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          },
          "listeners" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "List of listeners configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          }
        }
      },
      "NvmeOFSubsystemCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the subsystem to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem. The NQN has to be unique within a cluster."
          }
        },
        "required" : [ "nqn" ]
      },
      "NvmeOFSubsystemResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the subsystem in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem."
          },
          "serialNumber" : {
            "type" : "string",
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : "string",
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Maximum number of bdevs that can be attached."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the subsystem."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the subsystem."
          },
          "hostsFormatted" : {
            "type" : "string",
            "description" : "List of hosts attached to the subsystem."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          }
        },
        "required" : [ "nqn", "serialNumber", "modelNumber", "hosts", "disks", "hostsFormatted", "disksFormatted" ]
      },
      "NvmeOFSubsystemUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "serialNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Maximum number of disks that can be attached."
          }
        }
      },
      "NvmeOFTransportConfig" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "NvmeOFTransportConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the transport config belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the transport config belongs to."
          },
          "type" : {
            "description" : "Transport type. The transport config is applied to all listeners of this type.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "I/O unit size (bytes)."
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of IO qpairs per controller."
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of in-capsule data size."
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Max I/O size (bytes)."
          }
        },
        "required" : [ "type" ]
      },
      "NvmeOFTransportType" : {
        "type" : "string",
        "enum" : [ "TCP", "RDMA" ]
      },
      "OidcClientAuth" : {
        "type" : "string",
        "enum" : [ "None", "Post", "Basic" ]
      },
      "OidcConfigCreateRequest" : {
        "type" : "object",
        "required" : [ "name", "discoveryUrl", "clientId", "groupPointer", "roleMapping", "defaultRoles", "scope" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OidcClientAuth"
            }, {
              "type" : "null"
            } ]
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "Scopes for OIDC requests, separated by spaces (default: \"openid profile\")"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          }
        }
      },
      "OidcConfigResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the OIDC config/provider in croit"
          },
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : "string",
            "$ref" : "#/components/schemas/OidcClientAuth"
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "OIDC scope to query for"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          },
          "defaultMaxExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "defaultMinExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "providerName" : {
            "type" : "string"
          },
          "roleMappingFormatted" : {
            "type" : "string"
          },
          "clientAuthLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "discoveryUrl", "clientId", "clientAuth", "groupPointer", "roleMapping", "defaultRoles", "scope", "defaultMaxExpiry", "defaultMinExpiry", "providerName", "roleMappingFormatted", "clientAuthLabel" ]
      },
      "OidcProvider" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "OktaLoginRequest" : {
        "type" : "object",
        "required" : [ "idToken" ],
        "properties" : {
          "idToken" : {
            "type" : "string"
          }
        }
      },
      "OktaOAuthConfig" : {
        "type" : "object",
        "required" : [ "baseUrl", "clientId", "issuer", "mapRoles" ],
        "properties" : {
          "baseUrl" : {
            "type" : "string"
          },
          "clientId" : {
            "type" : "string"
          },
          "issuer" : {
            "type" : "string"
          },
          "audience" : {
            "type" : [ "string", "null" ]
          },
          "mapRoles" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "OnlineStatus" : {
        "type" : "object",
        "properties" : {
          "online" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "healthy" : {
            "type" : "boolean"
          }
        }
      },
      "OptionalPaginationResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseObject"
        }, {
          "type" : "array",
          "items" : { },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseAccount" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseAccount"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/Account"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseApiTokenInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseApiTokenInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ApiTokenInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephFSSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephFSSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephPoolResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephPoolResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephPoolResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephfsClientInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephfsClientInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephfsClientInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseConfigTemplateResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseConfigTemplateResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ConfigTemplateResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCrushRuleResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCrushRuleResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CrushRuleResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseDiskResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseDiskResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/DiskResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseFreeIp" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseFreeIp"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/FreeIp"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHaGroupResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHaGroupResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HaGroupResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHookInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHookInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HookInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpGeneralInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpGeneralInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpGeneralInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpmiDevice" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpmiDevice"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpmiDevice"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMgrCrashReportEntry" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMgrCrashReportEntry"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MgrCrashReportEntry"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMultiServerServiceResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMultiServerServiceResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MultiServerServiceResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNetworkInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNetworkInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NetworkInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNicResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNicResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NicResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseOidcConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseOidcConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/OidcConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponsePoolStatsInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponsePoolStatsInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/PoolStatsInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRbdSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRbdSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RbdSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwBucketResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwBucketResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwBucketResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseScriptIdentifier" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseScriptIdentifier"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ScriptIdentifier"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseServerResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseServerResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ServerResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseSupervisorModuleJson" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseSupervisorModuleJson"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/SupervisorModuleJson"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseVlanInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseVlanInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/VlanInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OsdCreationRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OsdCreationRequestEntry"
            }
          }
        }
      },
      "OsdCreationRequestEntry" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for DB or DB/WAL (if walDisk is null)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for WAL."
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "reuseOsdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "crushDeviceClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "OsdFullRatios" : {
        "type" : "object",
        "properties" : {
          "nearfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "backfillfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "full" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "OsdStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DOWN", "DESTROYED", "UNKNOWN" ]
      },
      "OverwriteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "entries" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries to overwrite the existing ones with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "aclFile" : {
            "type" : [ "string", "null" ],
            "description" : "ACL file to overwrite the existing one with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "ownerUser" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (user), if provided. Only possible with containers."
          },
          "ownerGroup" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (group), if provided. Only possible with containers."
          }
        }
      },
      "PaginationRequest" : {
        "type" : "object",
        "description" : "Pagination request. When supplied, the result will be filtered, sorted and limited according to this request object.",
        "properties" : {
          "sortBy" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SortBy"
            },
            "description" : "Optional sorting rules for the items. Items are sorted before the limit is applied."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional maximum number of items to return. If omitted, all items are returned."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of items, defaults to 0."
          },
          "where" : {
            "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/FieldCondition"
            },
            "type" : [ "object", "null" ],
            "properties" : {
              "_and" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical AND operator. All conditions must be satisfied."
              },
              "_or" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical OR operator. At least one condition must be satisfied."
              },
              "_not" : {
                "description" : "Logical NOT operator. The condition must not be satisfied.",
                "type" : [ "object", "null", "null" ],
                "anyOf" : [ {
                  "$ref" : "#/components/schemas/WhereCondition"
                }, {
                  "type" : "null"
                } ]
              },
              "_search" : {
                "type" : [ "string", "null" ],
                "description" : "Full-text search across all searchable fields."
              }
            }
          }
        }
      },
      "PaginationResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseAccount" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Account"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseApiTokenInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiTokenInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFSSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPgStat" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPgStat"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPoolResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephfsClientInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephfsClientInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseConfigTemplateResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ConfigTemplateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCroitDependency" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitDependency"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCrushRuleResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosCertificateResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCertificateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerListResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerListResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPoolDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPosixDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPosixDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPropertyResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPropertyResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosSystemMemberResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosSystemMemberResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskPathResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseFreeIp" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FreeIp"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHaGroupResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHookInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpGeneralInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpGeneralInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpmiDevice" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpmiDevice"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayDisksResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayGroupsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayGroupsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayHostsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayHostsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMgrCrashReportEntry" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMultiServerServiceResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MultiServerServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNetworkInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NetworkInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayExportResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExportResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNicResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFCephClusterResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFGatewayResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFGatewayResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFHostResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFHostResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFListenerConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFServiceResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFSubsystemResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFSubsystemResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseObject" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseOidcConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OidcConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponsePoolStatsInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolStatsInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdImageResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdImageResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwBucketResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptIdentifier" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptIdentifier"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptInfo" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseServerResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayShareResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSupervisorModuleJson" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SupervisorModuleJson"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseTaskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TaskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseVlanInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "ParsedDaosAcl" : {
        "type" : "object",
        "required" : [ "type", "flags", "principal", "permissions", "principalType", "raw" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/DaosAclType"
          },
          "flags" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclFlag"
            }
          },
          "principal" : {
            "type" : "string"
          },
          "permissions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclPermission"
            }
          },
          "isGroup" : {
            "type" : "boolean"
          },
          "principalType" : {
            "$ref" : "#/components/schemas/DaosAclPrincipalType"
          },
          "raw" : {
            "type" : "string"
          }
        }
      },
      "PasswordChangeRequest" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "PerOsdLimit" : {
        "description" : "Limit OSD number or usage by device class, -1 means unlimited",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs."
          },
          "hdd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as HDD."
          },
          "ssd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as SSD."
          },
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as NVMe."
          },
          "unknown" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs that couldn't be identified (for net usage: also crush rules not matching a device class)."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more OSDs/storage"
          }
        }
      },
      "PingMetricsConfiguration" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean"
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PingMetricsSummary" : {
        "type" : "object",
        "properties" : {
          "fromId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "toId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "median" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "dropPercent" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "PingParameters" : {
        "type" : "object",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of ICMP echo requests sent to each host."
          },
          "period" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time between consecutive packets to a single host in milliseconds."
          },
          "fromId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Server ID of the requesting host. 0 for management host."
          },
          "toIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Server IDs of the responding hosts. 0 for management host."
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Network ID of the network within which the packets should be sent."
          }
        },
        "required" : [ "toIds" ]
      },
      "PingResult" : {
        "type" : "object",
        "properties" : {
          "xmt" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rcv" : {
            "type" : "integer",
            "format" : "int32"
          },
          "lossPercent" : {
            "type" : "number",
            "format" : "double"
          },
          "min" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "max" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "avg" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "results" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "results" ]
      },
      "PlacementGroupOverview" : {
        "type" : "object",
        "required" : [ "poolName" ],
        "properties" : {
          "poolName" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "okay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "warn" : {
            "type" : "integer",
            "format" : "int32"
          },
          "error" : {
            "type" : "integer",
            "format" : "int32"
          },
          "inactive" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "Plot" : {
        "type" : "object",
        "description" : "A single plot/line for a diagram",
        "required" : [ "datapoints", "name", "tags" ],
        "properties" : {
          "datapoints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DataPoint"
            }
          },
          "name" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Tags (e.g., server id, osd id, ...) associated with this graph"
          }
        }
      },
      "PoolCompressionAlgorithm" : {
        "type" : "string",
        "enum" : [ "LZ4", "Snappy", "Zlib", "Zstd", "None" ]
      },
      "PoolCompressionMode" : {
        "type" : "string",
        "enum" : [ "None", "Passive", "Aggressive", "Force" ]
      },
      "PoolCompressionSettings" : {
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionAlgorithm"
            }, {
              "type" : "null"
            } ]
          },
          "mode" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionMode"
            }, {
              "type" : "null"
            } ]
          },
          "requiredRatio" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "minBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PoolPermission" : {
        "type" : "object",
        "description" : "A pool-specific permission, optionally restricted to a namespace within the pool.",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, either this or wildcardPoolPermissions must be set"
          },
          "wildcardPoolPermissions" : {
            "description" : "Grant a wildcard pool permission, either this or pool must be set",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WildcardPoolPermission"
            }, {
              "type" : "null"
            } ]
          },
          "permissions" : {
            "description" : "Permissions to grant on the pool",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolPermissionType"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Only allow access to a specific namespace within this pool"
          }
        },
        "required" : [ "permissions" ]
      },
      "PoolPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE" ]
      },
      "PoolState" : {
        "type" : "string",
        "enum" : [ "Creating", "Ready", "Destroying", "Degraded", "Unknown" ]
      },
      "PoolStatsInfo" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-pool-name query parameter"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description of the pool"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the pool if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the pool if configured"
          }
        }
      },
      "PoolStatsResponse" : {
        "type" : "object",
        "properties" : {
          "bytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "readIops" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIops" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "writeBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "bytesFormatted" : {
            "type" : "string"
          },
          "readIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSecFormatted" : {
            "type" : "string"
          },
          "writeBytesPerSecFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "bytesFormatted", "readBytesPerSecFormatted", "writeBytesPerSecFormatted" ]
      },
      "QOSSettingsCommandSchema" : {
        "description" : "Ceph QOS Settings Command",
        "type" : "object",
        "required" : [ "command", "displayName", "description" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "QOSSettingsCommands" : {
        "description" : "List of ceph commands available to define QOS SETTINGS limits (nautilus and above).",
        "type" : "string",
        "enum" : [ "RBD_QOS_IOPS_LIMIT", "RBD_QOS_BPS_LIMIT", "RBD_QOS_READ_IOPS_LIMIT", "RBD_QOS_WRITE_IOPS_LIMIT", "RBD_QOS_READ_BPS_LIMIT", "RBD_QOS_WRITE_BPS_LIMIT", "RBD_QOS_BPS_BURST", "RBD_QOS_IOPS_BURST", "RBD_QOS_READ_BPS_BURST", "RBD_QOS_READ_IOPS_BURST", "RBD_QOS_WRITE_BPS_BURST", "RBD_QOS_WRITE_IOPS_BURST" ]
      },
      "QosCommandAppliedResponse" : {
        "type" : "object",
        "required" : [ "command", "errorMessage" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "success" : {
            "type" : "boolean"
          },
          "errorMessage" : {
            "type" : "string"
          }
        }
      },
      "QosCommandLimit" : {
        "description" : "The Qos command to be executed.",
        "type" : "object",
        "required" : [ "command" ],
        "properties" : {
          "command" : {
            "type" : "string",
            "description" : "The command to be executed.",
            "pattern" : "\\S"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit to be set as an unsigned integer (0 means no limit).",
            "minimum" : 0
          }
        }
      },
      "QosCommandsResponse" : {
        "description" : "The Qos setting as defined in the doc.",
        "type" : "object",
        "required" : [ "setting" ],
        "properties" : {
          "setting" : {
            "description" : "Detail of the command.",
            "type" : "object",
            "required" : [ "command", "displayName", "description" ],
            "properties" : {
              "command" : {
                "type" : "string"
              },
              "displayName" : {
                "type" : "string"
              },
              "description" : {
                "type" : "string"
              }
            }
          },
          "value" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The current limit."
          },
          "inherited" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit inherited from pool settings, if there is any."
          }
        }
      },
      "QueryOrder" : {
        "type" : "string",
        "enum" : [ "ASC", "DESC" ]
      },
      "RankReintegrateRequest" : {
        "type" : "object",
        "properties" : {
          "rank" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Rank to reintegrate. If omitted, all ranks will be attempted."
          }
        }
      },
      "RawCephPermissions" : {
        "type" : "object",
        "properties" : {
          "mon" : {
            "type" : [ "string", "null" ]
          },
          "mgr" : {
            "type" : [ "string", "null" ]
          },
          "osd" : {
            "type" : [ "string", "null" ]
          },
          "mds" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RawDaosAcl" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "type" : "string"
          }
        }
      },
      "RbdCephPermissions" : {
        "description" : "Ceph permissions for RBD clients",
        "type" : "object",
        "required" : [ "pools" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            },
            "description" : "List of pools or wildcard specs this key has access to"
          }
        }
      },
      "RbdDeleteRequest" : {
        "description" : "Details for an RBD deletion request",
        "type" : "object",
        "required" : [ "pool", "rbd" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool to operate on, repeated for safety"
          },
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD to delete, repeated for safety"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace to operate on, optional, default is the default namespace, repeated for safety"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ],
            "description" : "Must be set to \"I'm really sure that I want to delete this\""
          }
        }
      },
      "RbdFeature" : {
        "type" : "string",
        "enum" : [ "LAYERING", "EXCLUSIVE_LOCK", "OBJECT_MAP", "FAST_DIFF", "DEEP_FLATTEN", "JOURNALING" ]
      },
      "RbdImageCreationRequest" : {
        "description" : "Details of an RBD image that is to be created",
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Store actual data in a separate erasure-coded pool. The main pool will only store metadata."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace (omit/null for the default namespace)"
          }
        }
      },
      "RbdImageMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "journal", "snapshot" ]
      },
      "RbdImageMirrorState" : {
        "type" : "string",
        "enum" : [ "disabled", "primary", "mirror" ]
      },
      "RbdImageResponse" : {
        "type" : "object",
        "required" : [ "name", "pool", "features", "mirrorInfo", "hints", "sizeFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where this image resides in"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "parent" : {
            "description" : "Parent image if this is a linked clone (not for creating images, use clone endpoint)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdParentDump"
            }, {
              "type" : "null"
            } ]
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Separate erasure-coded pool in which the image data is stored. The main pool will only store metadata."
          },
          "mirrorInfo" : {
            "description" : "RBD mirror information for this RBD image.",
            "type" : "object",
            "$ref" : "#/components/schemas/RbdMirrorImageInfo"
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the pool/namespace of this image.",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "snaps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageSnapshot"
            },
            "description" : "Snapshots of this image (not for creating images), default = default Ceph features"
          },
          "withDetails" : {
            "type" : "boolean",
            "description" : "Whether or not image details are included"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to be displayed in the UI, such as errors that happened while fetching RBD details."
          },
          "sizeFormatted" : {
            "type" : "string"
          }
        }
      },
      "RbdImageSnapshot" : {
        "description" : "Details of an RBD image snapshot",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot"
          },
          "protect" : {
            "type" : "boolean",
            "description" : "True if this snapshot is protected"
          }
        },
        "required" : [ "name" ]
      },
      "RbdImageUsedSizeResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "snapshot" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the snapshot if this entry is an RBD snapshot, otherwise null"
          },
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the RBD has in total (in bytes)"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used on the RBD (in bytes)"
          }
        }
      },
      "RbdJournalingUpdateRequest" : {
        "description" : "Request to enable/disable journaling on all images",
        "type" : "object",
        "properties" : {
          "enableJournaling" : {
            "type" : "boolean",
            "description" : "Enable/Disable journaling on all images."
          }
        }
      },
      "RbdMirrorDirection" : {
        "type" : "string",
        "enum" : [ "rx_tx", "rx_only", "tx_only" ]
      },
      "RbdMirrorImageInfo" : {
        "description" : "RBD mirroring details and status of an RBD image.",
        "type" : "object",
        "required" : [ "imageMirrorMode", "mirrorState" ],
        "properties" : {
          "imageMirrorMode" : {
            "description" : "Mirror mode set for the image (disabled, journal or snapshot, snapshot is only supported in octopus or later).",
            "type" : "string",
            "examples" : [ "journal" ],
            "$ref" : "#/components/schemas/RbdImageMirrorMode"
          },
          "mirrorState" : {
            "description" : "State describing if the image is mirrored as primary, mirrored as non-primary, or has mirroring disabled.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdImageMirrorState"
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this image is primary, or null if mirroring is disabled."
          },
          "globalId" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "RBD mirroring global ID (if mirroring is enabled on this image). This ID isn't used by croit."
          },
          "state" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring state (if mirroring is enabled on this image).",
            "examples" : [ "up+replaying" ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring status description (if mirroring is enabled on this image).",
            "examples" : [ "replaying, master_position=[object_number=3, tag_tid=1, entry_tid=3], mirror_position=[object_number=3, tag_tid=1, entry_tid=3], entries_behind_master=0" ]
          },
          "lastUpdate" : {
            "type" : [ "string", "null" ],
            "description" : "Time of the latest RBD mirroring update (if mirroring is enabled on this image).",
            "examples" : [ "2020-08-06 10:32:34" ]
          },
          "daemonHost" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server on which the rbd-mirror daemon is running.",
            "examples" : [ "croit-host01" ]
          },
          "peerSites" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Peer sites which this image is mirrored from or mirrored to."
          }
        }
      },
      "RbdMirrorImageUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD image",
        "type" : "object",
        "properties" : {
          "journaling" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable/disable journaling."
          },
          "imageMirrorMode" : {
            "description" : "Mirror mode (disable, journaling or snapshot), enabling mirroring is only possible if the pool is in image mirror mode, and snapshot is only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdImageMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "Make image primary/non-primary, only possible if mirroring is enabled on the image."
          }
        }
      },
      "RbdMirrorPeer" : {
        "description" : "RBD mirroring peer details.",
        "type" : "object",
        "required" : [ "id", "siteName", "clientName" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Global ID of the peer (generated separately from the cluster IDs).",
            "examples" : [ "268847dc-e379-462b-901b-298260b7b7c6" ]
          },
          "siteName" : {
            "type" : "string",
            "description" : "Name of the peer cluster, by default its cluster ID.",
            "examples" : [ "ad5a99dd-4a08-41c3-bafa-d0ea8f5ced18" ]
          },
          "clientName" : {
            "type" : "string",
            "description" : "Name of the ceph key on the peer cluster, this ceph user is used by the rbd-mirror daemon to connect to the peer cluster. Croit uses the default from the bootstrap token (client.rbd-mirror-peer).",
            "examples" : [ "client.rbd-mirror-peer" ]
          },
          "direction" : {
            "description" : "Mirror direction, rx-tx, rx-only or tx-only. Only available with Ceph Octopus or later. Croit uses the default of the bootstrap method: rx-tx. Should this still be set to tx-only, try removing the peers from the pool on both clusters and reimport the bootstrap token.",
            "type" : [ "string", "null" ],
            "examples" : [ "client.rbd-mirror-peer" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorPeerCreateRequest" : {
        "description" : "Request to create a new peer using a bootstrap token",
        "type" : "object",
        "required" : [ "peerToken", "direction" ],
        "properties" : {
          "peerToken" : {
            "type" : "string",
            "description" : "Bootstrap token obtained from the peer cluster.",
            "examples" : [ "eyJmc2lkIjoiYmYzNTQ4MzAtZjBmZi00ZGRkLWEwNzUtMjRjNjZlNjVjODdlIiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFDdUlYTmZEeS8yS2hBQUEwMnFISm5mWDdkWSthR2l5bzRQRXc9PSIsIm1vbl9ob3N0IjoiMTcyLjMxLjExMS4xMjQ6Njc4OSwgMTcyLjMxLjExMS4xMzY6Njc4OSwgMTcyLjMxLjExMS4xMjE6Njc4OSJ9" ]
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "localSiteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of this cluster that will be displayed on the peer cluster.",
            "examples" : [ "clusterB" ]
          },
          "direction" : {
            "description" : "Direction setting for the peer, rx-tx (default), rx-only or (starting with octopus) tx-only.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdMirrorDirection"
          }
        }
      },
      "RbdMirrorPeerUpdateRequest" : {
        "description" : "Request to update mirroring settings of a mirror peer",
        "type" : "object",
        "properties" : {
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "monHosts" : {
            "type" : [ "string", "null" ],
            "description" : "Mon hosts of the peer cluster. Changing this can break the peer connection."
          },
          "direction" : {
            "description" : "New direction setting for the peer (rx-tx, rx-only or tx-only). Changing this can break the peer connection. Only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          },
          "client" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the remote client with read-access for RBD pools. Changing this can break the peer connection."
          }
        }
      },
      "RbdMirrorPoolInfo" : {
        "description" : "RBD mirroring details and status of an RBD pool+namespace.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace, will be null when referring to the pool only without namespace.",
            "examples" : [ "ns1" ]
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the RBD pool (disabled, pool or image).",
            "type" : "string",
            "examples" : [ "pool" ],
            "$ref" : "#/components/schemas/RbdPoolMirrorMode"
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Site name of the pool.",
            "examples" : [ "clusterA" ]
          },
          "peers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdMirrorPeer"
            },
            "description" : "List of peers setup for RBD mirroring, currently only one peer is supported and returned."
          },
          "statusHealth" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirror status (if mirroring is enabled on this pool).",
            "examples" : [ "OK" ]
          },
          "statusStates" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "RBD mirror status states (if mirroring is enabled on this pool).",
            "examples" : [ {
              "replaying" : 2,
              "stopped" : 1
            } ]
          }
        },
        "required" : [ "poolMirrorMode", "peers" ]
      },
      "RbdMirrorPoolUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD pool",
        "type" : "object",
        "properties" : {
          "poolMirrorMode" : {
            "description" : "Rbd mirror mode (pool, image, disabled).",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorSiteNameUpdateRequest" : {
        "description" : "Request to update the site name of a pool.",
        "type" : "object",
        "required" : [ "siteName" ],
        "properties" : {
          "siteName" : {
            "type" : "string",
            "description" : "Site name for the pool.",
            "examples" : [ "clusterA" ]
          }
        }
      },
      "RbdMirrorSnapshot" : {
        "description" : "Mirror snapshot information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot.",
            "examples" : [ 10 ]
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot.",
            "examples" : [ ".mirror.primary.4fe60c6d-bafc-4399-850f-d43783af38dc.95e9cd1b-f327-4c21-9cbe-7b2e3a575885" ]
          }
        },
        "required" : [ "name" ]
      },
      "RbdMirrorSnapshotSchedule" : {
        "description" : "Mirror snapshot schedule information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, or \"-\"/null if the schedule affects all pools.",
            "examples" : [ "poolName" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace with in the pool, or \"-\"/null if the schedule affects all namespaces.",
            "examples" : [ "-" ]
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the RBD image, or \"-\"/null if the schedule affects all images.",
            "examples" : [ "-" ]
          },
          "interval" : {
            "type" : "string",
            "description" : "Interval time of the schedule specified as time in days, hours or minutes (with suffixes d/h/m, e.g. 7d, 12h or 30m).",
            "examples" : [ "10h" ]
          },
          "startTime" : {
            "type" : [ "string", "null" ],
            "description" : "Optional start time of the schedule specified in the ISO 8601 time format.",
            "examples" : [ "14:00:00" ]
          }
        },
        "required" : [ "interval" ]
      },
      "RbdNameResponse" : {
        "description" : "An RBD name including pool and namespace.",
        "type" : "object",
        "required" : [ "rbd", "pool" ],
        "properties" : {
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD."
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where the RBD resides in."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace used for the RBD, or null for the default namespace of the pool."
          }
        }
      },
      "RbdNamespace" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "RbdParentDump" : {
        "type" : "object",
        "required" : [ "pool", "image", "snapshot" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "snapshot" : {
            "type" : "string"
          }
        }
      },
      "RbdPoolInfo" : {
        "description" : "Contains basic information on an RBD pool with namespace.",
        "type" : "object",
        "required" : [ "pool", "hints" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace or null for the default namespace."
          },
          "ec" : {
            "type" : "boolean",
            "description" : "Whether or not the pool is an erasure-coded pool."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the pool's PGs are all active or peering."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "List of hints to display in the UI, e.g. errors that happened while this pool."
          }
        }
      },
      "RbdPoolMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "pool", "image" ]
      },
      "RbdSnapshotPath" : {
        "description" : "Name of an RBD image or pool.",
        "type" : "object",
        "required" : [ "pool" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the RBD pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace."
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional RBD image, if omitted, the entire pool is used."
          }
        }
      },
      "RbdSnapshotSchedule" : {
        "description" : "Information for an RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          },
          "pathsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "failedSnapshots", "pathsFormatted" ]
      },
      "RbdSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a RBD snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot.",
            "minItems" : 1
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\""
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotUpdateRequest" : {
        "description" : "Details for an snapshot update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Rename the snapshot to this new name"
          },
          "protect" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable or disable snapshot protection"
          }
        }
      },
      "RbdUpdateRequest" : {
        "description" : "Details for a RBD update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name of the image"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New size of the image in bytes, sizes can only increase"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "New list of features to be enabled"
          }
        }
      },
      "RbdUsedSizeResponse" : {
        "type" : "object",
        "properties" : {
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the namespace (or the single RBD specified in the request) has in total in bytes"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used in the namespace (or the single RBD specified in the request) in bytes"
          },
          "rbds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageUsedSizeResponse"
            }
          }
        }
      },
      "RecommendationResponse" : {
        "type" : "object",
        "required" : [ "taskUuid", "finding", "suggestions", "links", "updatedAt" ],
        "properties" : {
          "taskUuid" : {
            "description" : "A UUID to identify this recommendation by in other requests.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "finding" : {
            "description" : "Information on this recommendation, including what should be shown in the UI.",
            "type" : "object",
            "$ref" : "#/components/schemas/Finding"
          },
          "suggestions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Suggestions that can be applied to fix or execute this advisor recommendation. Maps suggestion ID to a human-readable string."
          },
          "links" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Links to display for more info."
          },
          "hide" : {
            "type" : "boolean",
            "description" : "If true, this recommendation was muted by the user and should be hidden in the UI."
          },
          "affected" : {
            "description" : "The object affected by this recommendation. Used for linking in the UI."
          },
          "updatedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp when this recommendation was last added or updated."
          }
        }
      },
      "RecoverySpeed" : {
        "type" : "object",
        "properties" : {
          "speed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Recovery speed setting from 1 (slowest) to 10 (fastest). Set to <= 0 to restore the default configured in ceph.conf."
          }
        }
      },
      "ReplaceOsdRequest" : {
        "type" : "object",
        "properties" : {
          "osd" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "OSD ID to replace."
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to use for the replacement, meaning the OSD will be put on this disk."
          },
          "encrypted" : {
            "type" : [ "boolean", "null" ],
            "description" : "If true, the newly created OSD will be encrypted. If null, the setting of the old OSD (if available) will be used."
          },
          "keepDbWal" : {
            "type" : "boolean",
            "description" : "If true, the newly created OSD will use the same DB/WAL as the replaced disk."
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the DB partition (if at all)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the WAL partition (if at all)."
          },
          "resizeOsd" : {
            "type" : "boolean",
            "description" : "If true, the OSD will be resized to match the new disk."
          }
        }
      },
      "ReplaceOsdsRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ReplaceOsdRequest"
            }
          }
        }
      },
      "RestartPolicy" : {
        "type" : "string",
        "enum" : [ "NEVER", "ON_FAILURE", "ALWAYS" ]
      },
      "RgwBucketResponse" : {
        "type" : "object",
        "required" : [ "bucket", "placement_rule", "id", "owner", "usage", "bucket_quota", "tenant", "usageSum" ],
        "properties" : {
          "bucket" : {
            "type" : "string"
          },
          "placement_rule" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          },
          "owner" : {
            "type" : "string"
          },
          "zonegroup" : {
            "type" : [ "string", "null" ]
          },
          "mtime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "usage" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RgwBucketUsageResponse"
            },
            "description" : "Data usage by zone."
          },
          "bucket_quota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "tenant" : {
            "type" : "string"
          },
          "usageSum" : {
            "$ref" : "#/components/schemas/RgwBucketUsageResponse"
          }
        }
      },
      "RgwBucketSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwBucketUsageResponse" : {
        "type" : "object",
        "properties" : {
          "sizeKiB" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeKiBActual" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numObjects" : {
            "type" : "number",
            "format" : "double"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiB instead."
          },
          "size_kb_actual" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiBActual instead."
          },
          "num_objects" : {
            "type" : "number",
            "format" : "double",
            "description" : "Deprecated, use numObjects instead."
          }
        },
        "required" : [ "sizeFormatted" ]
      },
      "RgwDefaultPlacementRequest" : {
        "type" : "object",
        "required" : [ "placementRule" ],
        "properties" : {
          "placementRule" : {
            "type" : "string",
            "description" : "The name of the placement rule to set as default."
          },
          "storageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional storage class for the placement rule to use as default."
          }
        }
      },
      "RgwDetailedUsage" : {
        "type" : "object",
        "required" : [ "bucketName", "bucketOwner", "time" ],
        "properties" : {
          "bucketName" : {
            "type" : "string"
          },
          "bucketOwner" : {
            "type" : "string"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "bytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bytesUploaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "successfulOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "failedOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "metadataBytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwKeyRequest" : {
        "type" : "object",
        "required" : [ "user", "access_key", "secret_key" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : "string"
          },
          "secret_key" : {
            "type" : "string"
          }
        }
      },
      "RgwPlacementPolicyResponse" : {
        "type" : "object",
        "required" : [ "name", "storageClass", "dataPool", "indexPool", "dataExtraPool" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The unique name of the placement policy."
          },
          "storageClass" : {
            "type" : "string",
            "description" : "Name of the storage class used for this placement policy."
          },
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data for the placement + storage class."
          },
          "indexPool" : {
            "type" : "string",
            "description" : "The pool used to store the bucket index"
          },
          "dataExtraPool" : {
            "type" : "string",
            "description" : "The pool used to store extra metadata."
          },
          "isDefault" : {
            "type" : "boolean"
          }
        }
      },
      "RgwPlacementRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          },
          "indexPool" : {
            "type" : [ "string", "null" ],
            "description" : "The pool used as an index for buckets. Can't be erasure coded."
          },
          "dataExtraPool" : {
            "type" : [ "string", "null" ],
            "description" : "An extra data pool for metadata. Can't be erasure coded."
          }
        }
      },
      "RgwPlacementResponse" : {
        "type" : "object",
        "properties" : {
          "defaultPlacementRule" : {
            "type" : [ "string", "null" ],
            "description" : "Default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default storage class of the default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "placements" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total placements available under the requested filter. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Offset in the list of total placements that was requested. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of placements requested. Only provided when using pagination."
          }
        }
      },
      "RgwQuotaRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size. Use a negative number to disable the size quota."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects. Use a negative number to disable the objects quota."
          },
          "max_size_kb" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes). Use a negative number to disable the size quota."
          },
          "max_objects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects. Use a negative number to disable the objects quota."
          }
        }
      },
      "RgwQuotaResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size in bytes."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects."
          },
          "max_size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes)."
          },
          "max_objects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects."
          },
          "maxSizeFormatted" : {
            "type" : "string"
          },
          "maxObjectsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "maxSizeFormatted", "maxObjectsFormatted" ]
      },
      "RgwSslCertChangeRequest" : {
        "type" : "object",
        "properties" : {
          "certificate" : {
            "type" : [ "string", "null" ]
          },
          "doRollingRestart" : {
            "type" : "boolean"
          }
        }
      },
      "RgwStorageClassRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          }
        }
      },
      "RgwSubUser" : {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubUserPermission" : {
        "type" : "string",
        "enum" : [ "full-control", "read-write", "read", "write", "NONE" ]
      },
      "RgwSubuserRequest" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserResponse" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwUpdateKeysRequest" : {
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwKeyRequest"
            }
          }
        }
      },
      "RgwUpdateSubusersRequest" : {
        "type" : "object",
        "required" : [ "subusers" ],
        "properties" : {
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserRequest"
            }
          }
        }
      },
      "RgwUserKey" : {
        "type" : "object",
        "required" : [ "user" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : [ "string", "null" ]
          },
          "secret_key" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RgwUserResponse" : {
        "type" : "object",
        "required" : [ "uid", "name", "email", "subusers", "bucketQuota", "userQuota", "subusersFormatted" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "email" : {
            "type" : "string"
          },
          "suspended" : {
            "type" : "boolean"
          },
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserResponse"
            }
          },
          "bucketQuota" : {
            "description" : "This quota is applied to all buckets owned by this user.",
            "type" : "object",
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "userQuota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          },
          "subusersFormatted" : {
            "type" : "string"
          }
        }
      },
      "RgwUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "suspended" : {
            "type" : [ "boolean", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RoleEnum" : {
        "type" : "string",
        "enum" : [ "admin", "viewer", "securefolder" ]
      },
      "RunScriptRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Execute previously uploaded script by id, mutually exclusive with script"
          },
          "script" : {
            "type" : [ "string", "null" ],
            "description" : "Execute verbatim script, mutually exclusive with scriptId"
          },
          "args" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of parameters passed to the script"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of servers the script will be run on"
          }
        },
        "required" : [ "args", "servers" ]
      },
      "S3BucketName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-bucket-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the bucket if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the bucket if configured"
          }
        }
      },
      "S3BucketVersioningConfiguration" : {
        "type" : "string",
        "enum" : [ "OFF", "ENABLED", "SUSPENDED", "UNKNOWN" ]
      },
      "S3Listing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3PrefixDetail"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "S3Metadata" : {
        "type" : "object",
        "properties" : {
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "contentType" : {
            "type" : "string"
          },
          "etag" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "userMetadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "versionId" : {
            "type" : [ "string", "null" ]
          },
          "contentDisposition" : {
            "type" : [ "string", "null" ]
          },
          "cacheControl" : {
            "type" : [ "string", "null" ]
          },
          "expirationTime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "expirationTimeRuleId" : {
            "type" : [ "string", "null" ]
          },
          "contentEncoding" : {
            "type" : [ "string", "null" ]
          },
          "contentLanguage" : {
            "type" : [ "string", "null" ]
          },
          "contentMD5" : {
            "type" : [ "string", "null" ]
          },
          "httpExpiresDate" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "raw" : {
            "type" : "object",
            "additionalProperties" : { }
          }
        },
        "required" : [ "contentType", "userMetadata", "raw" ]
      },
      "S3MultipartUpload" : {
        "type" : "object",
        "required" : [ "key", "uploadId", "owner", "initiator", "storageClass", "initiated", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "uploadId" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "storageClass" : {
            "type" : "string"
          },
          "initiated" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3MultipartUploadResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3MultipartUpload"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3ObjectResponse" : {
        "type" : "object",
        "required" : [ "key", "bucketName", "owner", "eTag", "lastModified", "storageClass", "sizeFormatted", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "bucketName" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "eTag" : {
            "type" : "string"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "lastModified" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "storageClass" : {
            "type" : "string"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3ObjectsResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3ObjectResponse"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3Owner" : {
        "type" : "object",
        "required" : [ "id", "displayName" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          }
        }
      },
      "S3PrefixDetail" : {
        "type" : "object",
        "required" : [ "prefix" ],
        "properties" : {
          "prefix" : {
            "type" : "string"
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          }
        }
      },
      "S3UsageForBucketByUserResponse" : {
        "description" : "Usage data for a bucket, split by user performing the operation.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All users (unauthenticated access is mapped to \"anonymous\") accessing this bucket, entries are split into 1 hour intervals."
          }
        }
      },
      "S3UsageForUserByBucketResponse" : {
        "description" : "Usage data for a user, split by bucket.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All buckets accessed by this user, entries are split into 1 hour intervals"
          }
        }
      },
      "S3UserName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-user-name query parameter"
          }
        }
      },
      "SambaServiceDNSNameUpdateRequest" : {
        "type" : "object",
        "required" : [ "serviceDnsName" ],
        "properties" : {
          "serviceDnsName" : {
            "type" : "string",
            "description" : "The new DNS name for the SMB cluster"
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          },
          "joinServer" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Server to use when joining the new DNS name. Optional, if not supplied, the first server from the database is used."
          }
        }
      },
      "SambaServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "virtualIps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit-read read-only user."
          },
          "domainController" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "SambaShareType" : {
        "type" : "string",
        "enum" : [ "SIMPLE", "ADS" ]
      },
      "SchedulingSettings" : {
        "type" : "object",
        "required" : [ "timezone" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          }
        }
      },
      "ScriptIdentifier" : {
        "type" : "object",
        "deprecated" : true,
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "ScriptInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          },
          "hookNames" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "name" ]
      },
      "ScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SemanticVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "ServerAccessPasswords" : {
        "description" : "Passwords to access servers.",
        "type" : "object",
        "properties" : {
          "rootPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password for (physical) shell access as root user, password login for SSH is disabled."
          },
          "ipmiPassword" : {
            "type" : [ "string", "null" ],
            "description" : "IPMI password for the ADMIN user of IPMI interfaces managed by croit."
          }
        }
      },
      "ServerHealth" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double"
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean"
          }
        }
      },
      "ServerHealthResponse" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double",
            "description" : "Approximate time difference between this server and the management server, negative values indicate the server is behind."
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean",
            "description" : "True if this server was booted from disk instead of PXE."
          },
          "uptimeFormatted" : {
            "type" : "string"
          },
          "freeRamFormatted" : {
            "type" : "string"
          },
          "bootSource" : {
            "type" : "string",
            "description" : "What the server used to boot, either 'Disk' or 'PXE'"
          }
        },
        "required" : [ "uptimeFormatted", "freeRamFormatted", "bootSource" ]
      },
      "ServerInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "type" : [ "object", "null" ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "services" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "servicesRunning" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "osds" : {
            "type" : "integer",
            "format" : "int32"
          },
          "osdsRunning" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealth"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ]
          },
          "hasSambaSssd" : {
            "type" : "boolean"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "machineId" : {
            "type" : "string"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "services", "servicesRunning", "usedPorts", "ips", "health", "machineId" ]
      },
      "ServerLimit" : {
        "description" : "Limit number of servers",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of servers allowed (0 or a negative number means no limit)."
          },
          "gracePercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Grace in percent for having servers above the limit."
          },
          "graceValue" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Grace in number of servers for having servers above the limit. Overrides gracePercent when provided."
          }
        }
      },
      "ServerNameAndId" : {
        "description" : "Server id/hostname pairs for querying the stats APIs.",
        "type" : "object",
        "required" : [ "hostname" ],
        "properties" : {
          "hostname" : {
            "type" : "string",
            "description" : "The hostname"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Use this id as template parameter."
          }
        }
      },
      "ServerRebootRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ServerResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HardwareResponse"
            }, {
              "type" : "null"
            } ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ports used by this server's services."
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "IPs configured on all NICs, only these are valid for the main IP."
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealthResponse"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "hasSambaSssd" : {
            "type" : "boolean",
            "description" : "True if the server is running Samba with sssd"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this server belongs to one"
          },
          "imageDescription" : {
            "type" : "string",
            "description" : "Description for the image that is configured on the server"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) configured for the server when using it for DAOS or NVMe-oF."
          },
          "machineId" : {
            "type" : "string",
            "description" : "Machine ID"
          },
          "services" : {
            "$ref" : "#/components/schemas/ServerServicesResponse"
          },
          "ramUsageFormatted" : {
            "type" : "string"
          },
          "stateLabel" : {
            "type" : "string"
          },
          "macsFormatted" : {
            "type" : "string",
            "description" : "MAC addresses if the management interface as a comma-separated string (there are multiple if it's a bond)"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "usedPorts", "ips", "health", "imageDescription", "machineId", "services", "ramUsageFormatted", "stateLabel", "macsFormatted" ]
      },
      "ServerServicesResponse" : {
        "type" : "object",
        "required" : [ "osd", "mon", "mgr", "smb", "nfs", "mds", "iscsi", "rgw", "rbdMirror", "nvmfTgt", "daosServer", "daosAgent" ],
        "properties" : {
          "osd" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mon" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mgr" : {
            "$ref" : "#/components/schemas/Service"
          },
          "smb" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nfs" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mds" : {
            "$ref" : "#/components/schemas/Service"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rgw" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rbdMirror" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nvmfTgt" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosServer" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosAgent" : {
            "$ref" : "#/components/schemas/Service"
          }
        }
      },
      "ServerState" : {
        "type" : "string",
        "enum" : [ "booting", "running", "offline", "rebooting", "shutting_down" ]
      },
      "ServerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ]
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "image" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) to configure for services that require it."
          }
        }
      },
      "Service" : {
        "type" : "object",
        "properties" : {
          "deployed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of deployed instances of this services."
          },
          "running" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of running instances of this services."
          },
          "isDeployed" : {
            "type" : "boolean",
            "description" : "Whether an instance of this service is deployed."
          },
          "isRunning" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether an instance of this service is running."
          }
        }
      },
      "ServiceControlRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The service ID, or in case of an OSD the daemon ID."
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Required for multi-server services"
          },
          "isOsd" : {
            "type" : "boolean",
            "description" : "If this service is an OSD."
          }
        }
      },
      "ServiceHealthResponse" : {
        "description" : "Health information about a running service",
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Uptime in seconds"
          },
          "memory" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Memory usage (RSS) in GiB"
          },
          "uptimeFormatted" : {
            "type" : "string",
            "description" : "Uptime in seconds"
          },
          "memoryFormatted" : {
            "type" : "string",
            "description" : "Memory usage (RSS) in GiB"
          }
        },
        "required" : [ "uptimeFormatted", "memoryFormatted" ]
      },
      "ServiceNvmeofAnaState" : {
        "type" : "string",
        "enum" : [ "optimized", "non_optimized", "inaccessible" ]
      },
      "ServiceState" : {
        "type" : "string",
        "enum" : [ "creating", "enabled", "disabled", "creation_failed" ]
      },
      "ServiceSubState" : {
        "type" : "string",
        "enum" : [ "ACTIVE", "STANDBY" ]
      },
      "ServiceTypePath" : {
        "type" : "string",
        "enum" : [ "osds", "mons", "radosgws", "mds", "mgrs", "nfs_gateways", "iscsis", "smbs", "rbd_mirrors", "daos_server", "daos_agent", "nvmf_tgts" ]
      },
      "ServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port for the service. Only relevant for RGW."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "SSL/TLS port for the service. Only relevant for RGW."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW DNS name to use for this service. Only relevant for RGW."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW zone to use for this service. Only relevant for RGW."
          }
        }
      },
      "SetDaosAclRequest" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "description" : "ACL entry to update. If it doesn't exist, it will be created.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosAclEntry"
          }
        }
      },
      "SetDaosContainerOwnerRequest" : {
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "The new owner."
          },
          "isGroup" : {
            "type" : "boolean",
            "description" : "Whether the owner is a group instead of a user."
          }
        }
      },
      "SetDaosPropertyRequest" : {
        "type" : "object",
        "required" : [ "name", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property to set."
          },
          "value" : {
            "type" : "string",
            "description" : "Value that the property should be set to."
          }
        }
      },
      "Severity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARNING", "CRITICAL" ]
      },
      "SignedLicenseData" : {
        "description" : "Signed license information as received from https://api.croit.io.",
        "type" : "object",
        "required" : [ "nextRefresh", "features", "osds", "rawCapacityGb", "usedCapacityGb", "netCapacityGb", "storage", "servers", "croitVersions" ],
        "properties" : {
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "License server needs to be contacted by this time."
          },
          "cephUuid" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Ceph FSID"
          },
          "gracePeriodDays" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace period when the license or nextRefresh was exceeded."
          },
          "features" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "boolean"
            },
            "description" : "Limit features explicitly, setting a feature to false here disables it explicitly. Features missing here use the default setting."
          },
          "osds" : {
            "description" : "Limit the number of OSDs that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Limit the raw available capacity of the cluster.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Limit the used capacity of the cluster (incl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "netCapacityGb" : {
            "description" : "Limit the net data stored by this cluster (excl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "storage" : {
            "description" : "Limit the available hardware storage.",
            "type" : "object",
            "$ref" : "#/components/schemas/StorageLimit"
          },
          "servers" : {
            "description" : "Limit the number of nodes that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "croitVersions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "Set of croit versions this license is valid for. Empty set means all versions."
          },
          "offline" : {
            "type" : "boolean",
            "description" : "License is applicable to offline croit instances."
          },
          "free" : {
            "type" : "boolean",
            "description" : "License is a free license (not paid for, but community edition or trial)"
          }
        }
      },
      "SimpleDaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "clusterName", "name", "description" ]
      },
      "SimpleHookInfo" : {
        "type" : "object",
        "required" : [ "event" ],
        "properties" : {
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "SimpleRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "startBucket", "independent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "startBucket" : {
            "type" : "string"
          },
          "independent" : {
            "type" : "string"
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "SmbAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SmbGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean"
          }
        },
        "required" : [ "description", "type", "virtualIps" ]
      },
      "SmbGatewayServerRequest" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          }
        }
      },
      "SmbGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "hostname", "virtualIps" ]
      },
      "SmbGatewayServerResponse1" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "virtualIps" ]
      },
      "SmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "adminPassword", "readonlyPassword", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : "string",
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : "string",
            "description" : "Password of the croit-read read-only user."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewSimpleSmbGatewayShare"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SmbGatewayServiceResponse" : {
        "type" : "object",
        "required" : [ "type", "servers", "virtualIps", "shares" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse1"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "minItems" : 1
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Joined with adcli+sssd."
          }
        }
      },
      "SmbGatewayShareResponse" : {
        "type" : "object",
        "required" : [ "type", "share", "path" ],
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Type of the SMB cluster that this share belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the SMB cluster that this share belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of this share."
          },
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the croit-ro user."
          },
          "roUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          },
          "roUsersFormatted" : {
            "type" : [ "string", "null" ]
          },
          "rwUsersFormatted" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SortBy" : {
        "type" : "object",
        "required" : [ "column", "order" ],
        "properties" : {
          "column" : {
            "type" : "string",
            "description" : "Which column to sort by."
          },
          "order" : {
            "description" : "Whether to sort ascending or descending.",
            "type" : "string",
            "$ref" : "#/components/schemas/QueryOrder"
          }
        }
      },
      "SsdPrimaryRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "ssdStartBucket", "ssdIndependent", "hddStartBucket", "hddIndependent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ssdStartBucket" : {
            "type" : "string"
          },
          "ssdIndependent" : {
            "type" : "string"
          },
          "ssdDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "hddStartBucket" : {
            "type" : "string"
          },
          "hddIndependent" : {
            "type" : "string"
          },
          "hddDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "ssdCopies" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "StandbyReplaySetting" : {
        "type" : "object",
        "properties" : {
          "allowStandbyReplay" : {
            "type" : "boolean"
          },
          "cephFsName" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "StatsUnit" : {
        "type" : "string",
        "enum" : [ "IOPS", "BYTES_PER_SECOND", "BITS_PER_SECOND", "OBJECTS_PER_SECOND", "OBJECTS", "BYTES", "SECONDS", "MILLISECONDS", "MICROSECONDS", "PERCENT", "COUNT", "NONE" ]
      },
      "StorageLimit" : {
        "type" : "object",
        "description" : "Limit available hardware storage",
        "properties" : {
          "osds" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, excluding DB/WAL (negative number means no limit)."
          },
          "osdsWithJournal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL (negative number means no limit)."
          },
          "osdsTotal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL and not yet used disks."
          },
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for all disks."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more storage"
          }
        }
      },
      "SupervisorModuleJson" : {
        "type" : "object",
        "required" : [ "name", "command", "restartPolicy" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "healthy" : {
            "type" : "boolean"
          },
          "disabled" : {
            "type" : "boolean"
          },
          "command" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "restartPolicy" : {
            "$ref" : "#/components/schemas/RestartPolicy"
          },
          "running" : {
            "type" : "boolean"
          },
          "pid" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "SurveyCeph" : {
        "type" : "object",
        "properties" : {
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "rawCapacityGB" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "fullPercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolSurvey"
            }
          },
          "rgwBuckets" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketSurvey"
            }
          },
          "cephFsStats" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephfsSurvey"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "pools", "rgwBuckets" ]
      },
      "SurveyConfigResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          }
        }
      },
      "SurveyDisk" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "sizeGB" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "type" : {
            "$ref" : "#/components/schemas/DiskType"
          },
          "numPaths" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "role", "name", "deviceClass", "smart", "type" ]
      },
      "SurveyNic" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/NicType"
          },
          "bondSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numVlans" : {
            "type" : "integer",
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "SurveyReport" : {
        "type" : "object",
        "required" : [ "services", "disks", "servers", "nics" ],
        "properties" : {
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyService"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyDisk"
            }
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyServer"
            }
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyNic"
            }
          },
          "ceph" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SurveyCeph"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "SurveyServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "totalCores" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "virtualCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "physicalCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "SurveyService" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SurveyUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "TaskAdvisorUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hide" : {
            "type" : "boolean"
          }
        }
      },
      "TaskProgressResponse" : {
        "type" : "object",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "TaskQuestion" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "defaultResponse" : {
            "type" : "string"
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "priority" : {
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "timeout" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
          },
          "response" : {
            "type" : "string",
            "writeOnly" : true
          },
          "timeLeft" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "TaskQuestionAnswer" : {
        "type" : "object",
        "required" : [ "token", "response" ],
        "properties" : {
          "token" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "response" : {
            "type" : "string"
          }
        }
      },
      "TaskQuestionPriority" : {
        "type" : "string",
        "enum" : [ "Standard", "Urgent" ]
      },
      "TaskQuestionResponse" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string",
            "description" : "Task question message to display to the user."
          },
          "defaultResponse" : {
            "type" : "string",
            "description" : "Default response if user doesn't answer in time."
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Response options to offer to the user."
          },
          "priority" : {
            "description" : "Priority for this question.",
            "type" : "string",
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Token used for the reply request."
          },
          "timeout" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total time to respond to the question (in milliseconds)."
          },
          "timeLeft" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Time left to respond to the question (in milliseconds)."
          }
        }
      },
      "TaskResponse" : {
        "description" : "A long running tasks.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "description" : "Progress indication of a background task.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskProgressResponse"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          },
          "cancelled" : {
            "type" : "boolean"
          },
          "question" : {
            "description" : "Question that a task might prompt for.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestionResponse"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "TemplateObject" : {
        "type" : "object",
        "required" : [ "content", "type" ],
        "properties" : {
          "content" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/TemplateVariable"
            }
          },
          "nullable" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          }
        }
      },
      "TemplateVariable" : {
        "type" : "object",
        "properties" : {
          "nullable" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      },
      "TerminalConnection" : {
        "type" : "object",
        "required" : [ "path", "authToken", "validUntil" ],
        "properties" : {
          "path" : {
            "type" : "string",
            "description" : "Connect here."
          },
          "tlsPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for TLS."
          },
          "plaintextPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for an unencrypted connection."
          },
          "authToken" : {
            "description" : "Pass as Authorization header.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "URL is valid until this time, existing connections stay connected afterwards."
          },
          "iscsi" : {
            "type" : "boolean",
            "description" : "Whether this is a connection to an iSCSI gateway."
          }
        }
      },
      "TimezoneSettings" : {
        "type" : "object",
        "required" : [ "timezone", "options" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          },
          "options" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "Token" : {
        "description" : "Token Response",
        "type" : "object",
        "required" : [ "access_token", "token_type", "roles" ],
        "properties" : {
          "access_token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Access token, should be handled as an opaque value as the format may change in the future."
          },
          "token_type" : {
            "type" : "string",
            "description" : "OAuth2 token type, always \"bearer\"."
          },
          "expires_in" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Remaining validity."
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "All roles of the user the token is associated with."
          },
          "userId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Internal id of the user this token is associated with."
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean",
            "description" : "Set if the user never changed their password."
          }
        }
      },
      "TokenInfoReply" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "oidcId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcSubject" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "UUID" : {
        "type" : "string",
        "format" : "uuid",
        "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
      },
      "UnencryptedBackupRequest" : {
        "type" : "object",
        "required" : [ "file" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          }
        }
      },
      "UpdateGrubRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "UploadS3ObjectRequest" : {
        "type" : "object",
        "required" : [ "key", "file" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "UserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "VPNConfigRequest" : {
        "description" : "Croit VPN configuartion request to https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "croitVersionString" : {
            "type" : [ "string", "null" ],
            "description" : "Croit version as a string (omitted if unknown)."
          },
          "croitVersion" : {
            "description" : "Croit version (omitted if unknown).",
            "type" : "object",
            "anyOf" : [ {
              "$ref" : "#/components/schemas/VPNCroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname to use for the croit VPN."
          },
          "extraArgs" : {
            "type" : [ "string", "null" ],
            "description" : "Extra arguments to pass to the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        },
        "required" : [ "hostname" ]
      },
      "VPNConfigResponse" : {
        "description" : "Croit VPN configuartion as received from https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID for the vpn configuration."
          },
          "envs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Environment variables to set for the croit VPN container."
          },
          "image" : {
            "description" : "Image to use for the croit VPN container.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNCroitDockerImage"
          },
          "stateDir" : {
            "type" : "string",
            "description" : "Directory to use for the croit VPN configuration. Should be mounted from a docker volume."
          },
          "resetState" : {
            "type" : "boolean",
            "description" : "If true, the croit client requesting the VPN config needs to reset the VPN state directory."
          },
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          }
        },
        "required" : [ "envs", "image", "stateDir", "reqId" ]
      },
      "VPNConnectInfo" : {
        "description" : "Croit VPN connection confirmation and information on the client.",
        "type" : "object",
        "required" : [ "reqId", "hostname", "fqdn", "ip", "errorMessage", "vpnLogs" ],
        "properties" : {
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          },
          "connected" : {
            "type" : "boolean",
            "description" : "Whether or not connection was successful."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname assigned by the croit VPN."
          },
          "fqdn" : {
            "type" : "string",
            "description" : "FQDN assigned by the croit VPN."
          },
          "ip" : {
            "type" : "string",
            "description" : "IP assigned by the croit VPN."
          },
          "errorMessage" : {
            "type" : "string",
            "description" : "Error message if VPN failed to connect."
          },
          "vpnLogs" : {
            "type" : "string",
            "description" : "VPN logs if VPN failed to connect."
          }
        }
      },
      "VPNConnectionInfo" : {
        "type" : "object",
        "required" : [ "status", "suggestedHostname" ],
        "properties" : {
          "status" : {
            "description" : "Croit VPN connection status.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNConnectionStatus"
          },
          "configuredHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to be used in the croit VPN as configured by the user."
          },
          "suggestedHostname" : {
            "type" : "string",
            "description" : "Hostname to be used in the croit VPN as suggested by croit."
          }
        }
      },
      "VPNConnectionRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to use for the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        }
      },
      "VPNConnectionStatus" : {
        "type" : "object",
        "properties" : {
          "containerRunning" : {
            "type" : "boolean",
            "description" : "True if croit VPN container is running."
          },
          "connected" : {
            "type" : "boolean",
            "description" : "True if connected to the croit VPN."
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Version of the tailscale client."
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname in the croit VPN."
          },
          "fqdn" : {
            "type" : [ "string", "null" ],
            "description" : "FQDN in the croit VPN."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Tailscale ID in the croit VPN"
          },
          "userId" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "User ID in the croit VPN"
          },
          "ips" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of IPs of this host in the croit VPN."
          },
          "reason" : {
            "type" : "string",
            "description" : "If disconnected, the reason why croit assumes that the VPN is not connected."
          }
        },
        "required" : [ "reason" ]
      },
      "VPNCroitDockerImage" : {
        "type" : "object",
        "description" : "Docker image specification.",
        "properties" : {
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "Registry to use. If omitted, the default registry (docker hub) is used."
          },
          "login" : {
            "type" : [ "object", "null" ],
            "description" : "Login to use. If omitted, no login data is provided to the registry (the image needs to be public)."
          },
          "name" : {
            "type" : "string",
            "description" : "Image name."
          },
          "tag" : {
            "type" : "string",
            "description" : "Image tag."
          }
        },
        "required" : [ "name", "tag" ]
      },
      "VPNCroitVersion" : {
        "type" : "object",
        "description" : "Croit version.",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Major croit release version (e.g. 2303)."
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Minor croit release version (e.g. 1)."
          },
          "patch" : {
            "type" : "string",
            "description" : "Patch version (only relevant for nightly or dev builds)."
          },
          "cephRelease" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph release (e.g. quincy)."
          }
        },
        "required" : [ "patch" ]
      },
      "VlanAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlanId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "VlanInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "VlanUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "WhereCondition" : {
        "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
        "additionalProperties" : {
          "$ref" : "#/components/schemas/FieldCondition"
        },
        "type" : [ "object", "null" ],
        "properties" : {
          "_and" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical AND operator. All conditions must be satisfied."
          },
          "_or" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical OR operator. At least one condition must be satisfied."
          },
          "_not" : {
            "description" : "Logical NOT operator. The condition must not be satisfied.",
            "type" : [ "object", "null", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WhereCondition"
            }, {
              "type" : "null"
            } ]
          },
          "_search" : {
            "type" : [ "string", "null" ],
            "description" : "Full-text search across all searchable fields."
          }
        }
      },
      "WildcardPoolPermission" : {
        "type" : "string",
        "enum" : [ "ALL_POOLS", "ALL_CEPHFS_POOLS" ]
      }
    }
  },
  "tags" : [ {
    "name" : "api-tokens",
    "description" : "Manage croit API tokens."
  }, {
    "name" : "audit",
    "description" : "Query croit audit logs."
  }, {
    "name" : "authentication",
    "description" : "OAuth2 authentication."
  }, {
    "name" : "ceph-keys",
    "description" : "Manage Ceph access keys."
  }, {
    "name" : "ceph-pools",
    "description" : "Manage ceph pools."
  }, {
    "name" : "cephfs",
    "description" : "CephFS file management."
  }, {
    "name" : "change-requests"
  }, {
    "name" : "cluster"
  }, {
    "name" : "config",
    "description" : "Configure settings for croit and ceph."
  }, {
    "name" : "config-templates",
    "description" : "Manage templates for config files."
  }, {
    "name" : "croit",
    "description" : "Information about the croit application."
  }, {
    "name" : "crush",
    "description" : "CRUSH map and rule management."
  }, {
    "name" : "daos",
    "description" : "Configure and manage DAOS."
  }, {
    "name" : "disks",
    "description" : "Manage server disks."
  }, {
    "name" : "extra-files",
    "description" : "Static web server for files located in /config/extra-files (or in /config/extra-files-secure, requiring authentication), to be downloaded by hook scripts on the servers."
  }, {
    "name" : "ha-groups",
    "description" : "Manage high availability groups and floating IPs."
  }, {
    "name" : "hooks",
    "description" : "Hook scripts for specific events."
  }, {
    "name" : "images",
    "description" : "Manage OS images."
  }, {
    "name" : "ipmi",
    "description" : "Manage IPMI interfaces."
  }, {
    "name" : "license",
    "description" : "croit license information."
  }, {
    "name" : "logs",
    "description" : "Log file API."
  }, {
    "name" : "maintenance",
    "description" : "Cluster maintenance and recovery APIs."
  }, {
    "name" : "networks",
    "description" : "Manage networks."
  }, {
    "name" : "osds",
    "description" : "OSD inventory, status, and topology management."
  }, {
    "name" : "placement-groups",
    "description" : "Manage placement groups."
  }, {
    "name" : "qos-settings",
    "description" : "QOS Settings."
  }, {
    "name" : "rbd-mirror",
    "description" : "Manage RBD mirroring for RBD pools. To configure RBD mirroring, first start an RBD mirror service on the cluster that data should be mirrored to. Then use this API to enable mirroring on pools with the same name on both clusters. To connect the two clusters, generate a bootstrap token on one of the pools, and import the token on the same pool on the other cluster."
  }, {
    "name" : "rbds",
    "description" : "Manage RBD images in pools."
  }, {
    "name" : "s3",
    "description" : "Manage S3 access."
  }, {
    "name" : "servers",
    "description" : "Manage server hardware, configuration, and services."
  }, {
    "name" : "services",
    "description" : "Manage services, this includes both Ceph services and croit-specific services running on both the ceph servers and management node."
  }, {
    "name" : "setup",
    "description" : "Initial setup of croit."
  }, {
    "name" : "snapshot-schedule",
    "description" : "Schedule automatic snapshots for CephFS and RBD."
  }, {
    "name" : "stats",
    "description" : "Get statistics of the cluster and servers."
  }, {
    "name" : "status",
    "description" : "Backend status."
  }, {
    "name" : "supervisor",
    "description" : "Manage supervisor operations."
  }, {
    "name" : "support",
    "description" : "Connect to croit support."
  }, {
    "name" : "survey",
    "description" : "Manage participation in the croit hardware survey."
  }, {
    "name" : "task-advisor",
    "description" : "Admin task advisor."
  }, {
    "name" : "tasks",
    "description" : "Status and overview of long running background tasks."
  }, {
    "name" : "users",
    "description" : "Manage croit users."
  } ],
  "paths" : {
    "/api-tokens" : {
      "get" : {
        "summary" : "List all configured api tokens.",
        "operationId" : "ApiTokenResource_getApiTokens",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseApiTokenInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured API tokens with their names, roles, and expiration status for access management.",
          "usage" : [ "Call when auditing API access permissions or reviewing token lifecycle management.", "Use to identify expired or soon-to-expire tokens requiring renewal or cleanup." ],
          "response_shape" : "OptionalPaginationResponse<ApiTokenInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "API token management queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/api-tokens", "/auth/whoami" ],
          "postprocessing_hint" : "Highlight expiring tokens; group by role; display creation dates and last-used timestamps if available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a new API token. Returns the secret token (which should only be shown once to the user).",
        "operationId" : "ApiTokenResource_createApiToken",
        "tags" : [ "api-tokens" ],
        "requestBody" : {
          "description" : "API token creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new API token for programmatic access to the croit API with specified roles and expiration.",
          "usage" : [ "Call when setting up new services or automation that needs API access.", "Use to generate tokens for CI/CD pipelines, monitoring systems, or integration tools." ],
          "response_shape" : "String (secret token)",
          "workflow_guidance" : {
            "pre_check" : "Name is unique; Roles are valid; Admin has interactive session",
            "post_action" : "Token created and returned; Secret shown only once; Token immediately usable"
          },
          "request_parameters" : [ {
            "name" : "expiry",
            "in" : "body",
            "description" : "Expiry parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "roles",
            "in" : "body",
            "description" : "Roles parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "API token creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens", "/api-tokens/{id}" ],
          "postprocessing_hint" : "Store the returned token securely - it cannot be retrieved again; only shown once for security.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "API tokens provide programmatic access and should be created carefully"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/api-tokens/{id}" : {
      "patch" : {
        "summary" : "Update an API token.",
        "operationId" : "ApiTokenResource_updateApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "API token update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for an existing API token to adjust access levels without regenerating the token.",
          "usage" : [ "Call when service requirements change and need different permission levels.", "Use to grant or revoke specific access rights while preserving the token secret." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Token exists; Valid role configuration; Admin has interactive session",
            "post_action" : "Token permissions updated; Changes effective immediately; Services continue using same token"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "Roles parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "API token ID to update from GET /api-tokens.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "API token updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens", "/api-tokens/{id}" ],
          "postprocessing_hint" : "Permission changes are immediate; verify services still function correctly with new role assignments.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an API token.",
        "operationId" : "ApiTokenResource_deleteApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete an API token to revoke access for automated systems or services.",
          "usage" : [ "Call when decommissioning services or revoking access for compromised tokens.", "Use for cleanup of unused or expired API tokens to maintain security hygiene." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "API token ID to delete from GET /api-tokens.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "API token management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens" ],
          "postprocessing_hint" : "Token is immediately invalid; update any services that were using this token before deletion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting API tokens will immediately revoke access for any services using this token"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit" : {
      "get" : {
        "summary" : "Get audit logs.",
        "operationId" : "AuditResource_getAuditLogs",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "description" : "Limit number of results returned, max = 100, default = 50.",
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 1
          }
        }, {
          "description" : "Offset for pagination, default = 0.",
          "name" : "offset",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 0
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AuditInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve audit logs for compliance monitoring and security analysis of system activities.",
          "usage" : [ "Call when investigating security incidents or reviewing user actions for compliance audits.", "Use to monitor administrative changes and track system access patterns." ],
          "response_shape" : "List<AuditInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Audit log queries"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/audit/{id}" ],
          "postprocessing_hint" : "Group by action type and timestamp; highlight security-relevant events; show user context for each action.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-ad-logs" : {
      "post" : {
        "summary" : "Fix Samba AD audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaADLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clean up vulnerable Samba Active Directory audit logs containing leaked credentials (CVE-2025-29305).",
          "usage" : [ "Call when security vulnerability scanner identifies exposed AD credentials in audit logs.", "Use as immediate remediation action to remove sensitive authentication data from logs." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Vulnerable AD logs detected; Admin privileges confirmed; Backup considerations reviewed",
            "post_action" : "Vulnerable audit log entries cleaned; Task advisor updated; Security vulnerability resolved"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Security remediation actions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/audit", "/audit/actions/fix-samba-simple-logs" ],
          "postprocessing_hint" : "Monitor task progress for completion; verify with task advisor that vulnerability is resolved; logs are permanently modified.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This action will permanently remove audit log entries containing AD credentials"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-simple-logs" : {
      "post" : {
        "summary" : "Fix Samba simple audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaSimpleLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clean up vulnerable Samba simple authentication audit logs containing exposed credentials (CVE-2025-29305).",
          "usage" : [ "Call when security scanner detects exposed simple authentication credentials in audit logs.", "Use for immediate security remediation to remove leaked password data from system logs." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Vulnerable simple auth logs detected; Admin privileges confirmed; Backup considerations reviewed",
            "post_action" : "Vulnerable audit log entries cleaned; Task advisor updated; Security vulnerability resolved"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Security remediation actions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/audit", "/audit/actions/fix-samba-ad-logs" ],
          "postprocessing_hint" : "Monitor task progress for completion; verify with task advisor that vulnerability is resolved; log modifications are permanent.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This action will permanently remove audit log entries containing simple authentication credentials"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/{id}" : {
      "get" : {
        "summary" : "Get specific audit log by ID.",
        "operationId" : "AuditResource_getAuditLog",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AuditInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed information for a specific audit log entry by its unique identifier.",
          "usage" : [ "Call when investigating specific security events or analyzing detailed context of an action.", "Use to get complete audit record details including request parameters and response data." ],
          "response_shape" : "AuditInfo",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Unique audit log entry identifier.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Individual audit record queries"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/audit" ],
          "postprocessing_hint" : "Display complete audit context including user, timestamp, action details, and any request/response data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/login" : {
      "post" : {
        "summary" : "OAuth 2 authentication via HTTP basic authentication, see Section 4.4 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginBasic",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform OAuth 2 client credentials authentication using HTTP Basic Auth (RFC 6749 Section 4.4).",
          "usage" : [ "Call from API clients or services that need to authenticate with client credentials.", "Use for machine-to-machine authentication without user interaction." ],
          "response_shape" : "Token",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Client credential authentication"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login-form", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; set Cache-Control and Pragma headers prevent caching.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/login-form" : {
      "post" : {
        "summary" : "OAuth 2 authentication with all parameters as url-encoded form, see Section 4.3 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginForm",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type", "username", "password" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  },
                  "username" : {
                    "type" : "string"
                  },
                  "password" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform OAuth 2 password grant authentication using form-encoded credentials (RFC 6749 Section 4.3).",
          "usage" : [ "Call from login forms where users enter username and password directly.", "Use for web applications requiring traditional username/password authentication." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "User account exists and is active; Password is correct; No account lockout in effect",
            "post_action" : "Session token generated; User authenticated; Cache-Control headers set"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Password authentication attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; password field is redacted from audit logs for security.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/logout" : {
      "post" : {
        "summary" : "Log out the current user session",
        "operationId" : "AuthResource_logout",
        "tags" : [ "authentication" ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Terminate the current user session and invalidate the authentication token.",
          "usage" : [ "Call when users explicitly log out or when sessions need to be terminated.", "Use in security flows to ensure clean session termination." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid session token provided; User is authenticated",
            "post_action" : "Session invalidated; Authentication cookies removed; User logged out"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Logout operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/login-form", "/auth/token-info" ],
          "postprocessing_hint" : "Clear all client-side tokens and redirect to login page; session cookies are automatically removed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/auth/oidc" : {
      "get" : {
        "summary" : "List of all OIDC configs.",
        "operationId" : "AuthResource_getOidcConfigs",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseOidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed configuration for every registered OIDC provider.",
          "usage" : [ "Open the identity provider administration view", "Review provider settings before editing or deleting entries" ],
          "response_shape" : "OptionalPaginationResponse<OidcConfigResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "OIDC admin view"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc/{id}", "/auth/oidc/providers" ],
          "postprocessing_hint" : "Mask client secrets when rendering and avoid persisting them client-side.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create new OIDC configuration",
        "operationId" : "AuthResource_createOidcConfig",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "OIDC configuration creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new OIDC identity provider configuration for external authentication.",
          "usage" : [ "Call when adding a new identity provider like Auth0, Azure AD, or Google Workspace.", "Use to enable SSO authentication for users from external systems." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "OIDC discovery URL is accessible; Client credentials are valid; Admin has interactive session",
            "post_action" : "Provider configuration saved; OIDC discovery cached; Provider available for user authentication"
          },
          "request_parameters" : [ {
            "name" : "authorizeUrl",
            "in" : "body",
            "description" : "AuthorizeUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "callbackBaseUri",
            "in" : "body",
            "description" : "CallbackBaseUri parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "clientAuth",
            "in" : "body",
            "description" : "ClientAuth parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "clientId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "clientSecret",
            "in" : "body",
            "description" : "ClientSecret parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "defaultRoles",
            "in" : "body",
            "description" : "DefaultRoles parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "discoveryUrl",
            "in" : "body",
            "description" : "DiscoveryUrl parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "groupPointer",
            "in" : "body",
            "description" : "GroupPointer parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "issuerUrl",
            "in" : "body",
            "description" : "IssuerUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "jwksUrl",
            "in" : "body",
            "description" : "JwksUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "manualRoles",
            "in" : "body",
            "description" : "ManualRoles parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "roleMapping",
            "in" : "body",
            "description" : "RoleMapping parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "scope",
            "in" : "body",
            "description" : "Scope parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "tokenUrl",
            "in" : "body",
            "description" : "TokenUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "userinfoUrl",
            "in" : "body",
            "description" : "UserinfoUrl parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}", "/auth/oidc/providers" ],
          "postprocessing_hint" : "Monitor task for completion; test provider with GET /auth/oidc/{id}/login before enabling for users.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Adding OIDC providers affects user authentication and requires network access to external systems"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/callback" : {
      "post" : {
        "summary" : "Handle OIDC callback",
        "operationId" : "AuthResource_oidcCallback",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "code",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "error",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "state",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Process OIDC authorization callback from identity provider and complete user authentication.",
          "usage" : [ "Called automatically by the browser after user completes authentication at identity provider.", "Handles the OAuth 2 authorization code exchange and user session creation." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "Valid authorization code from provider; State parameter matches; Provider configuration exists",
            "post_action" : "User session created; Authentication cookies set; User redirected to application"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "OIDC callback processing"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/{id}/login", "/auth/token-info" ],
          "postprocessing_hint" : "Automatically called by browser; session token is returned for client-side storage; manual audit logging included.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/oidc/providers" : {
      "get" : {
        "summary" : "Get list of OIDC provider options",
        "operationId" : "AuthResource_getOidcProviders",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/OidcProvider"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured OIDC providers for login selection screens.",
          "usage" : [ "Call on the login page to show available identity providers", "Cache provider names between sessions unless configuration changes" ],
          "response_shape" : "array<OidcProvider>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/oidc/{id}/login", "/auth/oidc" ],
          "postprocessing_hint" : "Sort providers alphabetically before rendering the list.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/oidc/{id}" : {
      "put" : {
        "summary" : "Update OIDC configuration",
        "operationId" : "AuthResource_updateOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC configuration update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing OIDC identity provider configuration and invalidate affected user sessions.",
          "usage" : [ "Call when modifying provider settings like discovery URL, client credentials, or role mappings.", "Use to fix authentication issues or update provider configurations." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; New discovery URL is accessible; Admin has interactive session",
            "post_action" : "Provider configuration updated; Existing user sessions invalidated; Users must re-authenticate"
          },
          "request_parameters" : [ {
            "name" : "authorizeUrl",
            "in" : "body",
            "description" : "AuthorizeUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "callbackBaseUri",
            "in" : "body",
            "description" : "CallbackBaseUri parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "clientAuth",
            "in" : "body",
            "description" : "ClientAuth parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "clientId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "clientSecret",
            "in" : "body",
            "description" : "ClientSecret parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "defaultRoles",
            "in" : "body",
            "description" : "DefaultRoles parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "discoveryUrl",
            "in" : "body",
            "description" : "DiscoveryUrl parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "groupPointer",
            "in" : "body",
            "description" : "GroupPointer parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "issuerUrl",
            "in" : "body",
            "description" : "IssuerUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "jwksUrl",
            "in" : "body",
            "description" : "JwksUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "manualRoles",
            "in" : "body",
            "description" : "ManualRoles parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "roleMapping",
            "in" : "body",
            "description" : "RoleMapping parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "scope",
            "in" : "body",
            "description" : "Scope parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "tokenUrl",
            "in" : "body",
            "description" : "TokenUrl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "userinfoUrl",
            "in" : "body",
            "description" : "UserinfoUrl parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to update.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}", "/auth/oidc/{id}/invalidate" ],
          "postprocessing_hint" : "Monitor task for completion; affected users will need to re-authenticate; test updated configuration.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Updating OIDC providers will log out all users from this provider and may affect authentication"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get specific OIDC configuration",
        "operationId" : "AuthResource_getOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch a single OIDC provider configuration for editing.",
          "usage" : [ "Load details when the admin selects a provider from the list", "Validate configuration values before saving changes" ],
          "response_shape" : "OidcConfigResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-provider detail fetch"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Do not log clientSecret fields; redact before telemetry.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete OIDC configuration",
        "operationId" : "AuthResource_deleteOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an OIDC identity provider configuration and invalidate all related user sessions.",
          "usage" : [ "Call when decommissioning an identity provider or migrating to a different provider.", "Use to clean up test providers or providers that are no longer trusted." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; No critical users depend solely on this provider; Admin has interactive session",
            "post_action" : "Provider configuration deleted; All user sessions from this provider invalidated; Users must re-authenticate"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to remove.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}/invalidate" ],
          "postprocessing_hint" : "Verify removal with GET /auth/oidc; affected users will need alternative authentication methods configured.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting OIDC providers will immediately log out all users from that provider and prevent future logins"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/invalidate" : {
      "post" : {
        "summary" : "Invalidate all OIDC user sessions",
        "operationId" : "AuthResource_invalidateOidcSessions",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Forcibly invalidate all active user sessions from a specific OIDC identity provider.",
          "usage" : [ "Call when suspecting compromised provider credentials or after security incidents.", "Use to force users to re-authenticate after provider configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; Admin has interactive session; Understanding that users will be logged out",
            "post_action" : "All user sessions from this provider invalidated; Users must re-authenticate"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to invalidate sessions for.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Session invalidation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/{id}", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Affected users will need to re-authenticate; consider notifying users before performing this action.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This will immediately log out all users authenticated via this OIDC provider"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/login" : {
      "get" : {
        "summary" : "Initiate OIDC login flow",
        "operationId" : "AuthResource_oidcLogin",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off the browser-based OIDC authorization flow and obtain a redirect response.",
          "usage" : [ "Invoke when the user selects an external provider on the login screen", "Immediately follow the redirect location to continue the OIDC handshake" ],
          "response_shape" : "HTTP 302 redirect",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier returned by GET /auth/oidc/providers",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "User login attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/providers", "/auth/oidc/callback", "/auth/token-info" ],
          "postprocessing_hint" : "Persist the generated state token client-side (e.g. in session storage) before following the redirect.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/okta/login" : {
      "post" : {
        "summary" : "Login with Okta ID token",
        "operationId" : "AuthResource_loginWithOktaIdToken",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "Okta login request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OktaLoginRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Authenticate users using Okta ID tokens with role mapping and session creation.",
          "usage" : [ "Call after user completes Okta authentication and obtains an ID token.", "Use for Okta-specific SSO integration with custom role mapping." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "Okta configuration exists; ID token is valid and not expired; User has assigned groups",
            "post_action" : "User session created; Role mapping applied; Authentication cookies set"
          },
          "request_parameters" : [ {
            "name" : "idToken",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Okta token authentication"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/okta/signInConfig", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; group claims are mapped to croit roles based on configuration.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/okta/signInConfig" : {
      "get" : {
        "summary" : "Get Okta OAuth configuration",
        "operationId" : "AuthResource_getOktaCfg",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OktaOAuthConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve Okta OAuth metadata required to render the Okta login widget.",
          "usage" : [ "Call once when loading the Okta-based login page", "Refresh only if the frontend detects configuration changes" ],
          "response_shape" : "OktaOAuthConfig",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/okta/login", "/auth/token-info" ],
          "postprocessing_hint" : "Persist issuer and audience client-side for token verification before invoking /auth/okta/login.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/token-info" : {
      "get" : {
        "summary" : "Get auth info for the request bearer token.",
        "operationId" : "AuthResource_tokenInfo",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TokenInfoReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the current bearer token to derive username, roles and expiry.",
          "usage" : [ "Call immediately after successful login to cache session metadata", "Re-run when showing account settings to refresh expiry information" ],
          "response_shape" : "TokenInfoReply",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Session inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/logout", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Persist expiry and provider IDs locally so subsequent calls are avoided.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients" : {
      "get" : {
        "summary" : "List all currently connected CephFS clients.",
        "operationId" : "CephFsListingResource_listCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephfsClientInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the active CephFS clients reported by the MDS.",
          "usage" : [ "Show currently connected clients in admin dashboards", "Refresh on demand when diagnosing stuck sessions" ],
          "response_shape" : "OptionalPaginationResponse<CephfsClientInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Client inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/clients/evict", "/stats" ],
          "postprocessing_hint" : "Highlight clients with stale sessions (zero age) before allowing eviction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients/evict" : {
      "post" : {
        "summary" : "Evict (kick) a connected client, the client can reconnect but must do so explicitly.",
        "operationId" : "CephFsListingResource_evictCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "description" : "ID of the client to evict",
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int64"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Forcefully disconnect CephFS clients",
          "usage" : [ "Evict misbehaving or stuck clients", "Force clients to reconnect after configuration changes" ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Client management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/clients" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/copy" : {
      "put" : {
        "summary" : "Copy a file or directory recursively.",
        "operationId" : "CephFsListingResource_copyCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Copy a file or directory recursively while preserving permissions and ownership.",
          "usage" : [ "Create backups of important directories", "Duplicate directory structures for different projects", "Copy files between different CephFS locations" ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "post_action" : "Monitor the returned ManagedTask for progress updates"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Resource intensive copy operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/move", "/cephfs/delete", "/tasks" ],
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Large copy operations can consume significant storage and time"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/create-directory" : {
      "post" : {
        "summary" : "Create a new directory recursively.",
        "operationId" : "CephFsListingResource_createCephFsDirectory",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsNewDirectoryRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new directory recursively with optional pool and namespace layout configuration.",
          "usage" : [ "Create new directories for organizing CephFS data", "Set up directories with specific storage pools for performance optimization" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "body",
            "description" : "Dir parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Directory creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/layout", "/cephfs/quota" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/delete" : {
      "delete" : {
        "summary" : "Delete files or directories recursively.",
        "operationId" : "CephFsListingResource_deleteCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "deleteSnapshots",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete files or directories recursively from CephFS",
          "usage" : [ "Remove unwanted files or entire directories", "Clean up snapshots when deleteSnapshots=true" ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "File operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/ls", "/cephfs/files" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Recursive deletion is permanent and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/download" : {
      "get" : {
        "summary" : "Download a file.",
        "operationId" : "CephFsListingResource_downloadCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate a download token for a CephFS file and stream its content.",
          "usage" : [ "Invoke when the user requests to download a file", "Do not poll; each request creates a fresh download token" ],
          "response_shape" : "DownloadableObject",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/upload" ],
          "postprocessing_hint" : "Immediately follow the returned download URL; token lifetimes are short.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files" : {
      "patch" : {
        "summary" : "Update or rename a file/directory.",
        "operationId" : "CephFsListingResource_patchCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsFileUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update file or directory metadata including path, permissions, and ownership.",
          "usage" : [ "Rename files or directories to new locations", "Change file permissions (mode) for access control", "Update ownership (uid/gid) for proper access management" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "absolutePath",
            "in" : "body",
            "description" : "AbsolutePath parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "gid",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "mode",
            "in" : "body",
            "description" : "Mode parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/move", "/cephfs/files", "/cephfs/stats" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List files in a directory.",
        "operationId" : "CephFsListingResource_listCephFsFiles",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntries"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List directory entries (names only) along with directory metadata.",
          "usage" : [ "Load before rendering a CephFS directory tree", "Refresh after uploads or deletions to update the listing" ],
          "response_shape" : "CephFsDirectoryEntries",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files-with-stats", "/cephfs/files-paginated", "/cephfs/download" ],
          "postprocessing_hint" : "Sort entries client-side and merge with stats if needed from /files-with-stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-paginated" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesPaginated",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephFsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate CephFS directory entries with full stats to avoid huge payloads.",
          "usage" : [ "Use in UIs with infinite scroll for large directories", "Request subsequent pages by adjusting pagination.after" ],
          "response_shape" : "PaginationResponse<CephFsResponse>",
          "common_parameters" : {
            "pagination.limit" : "Keep limits <= 500 to avoid timeouts."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Paginated directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-with-stats" ],
          "postprocessing_hint" : "Use pagination.after from response to fetch the next chunk.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-with-stats" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesWithStats",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntriesWithStats"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return directory entries together with full CephFS statistics for each item.",
          "usage" : [ "Use when a UI needs size, permissions or type information per entry", "Prefer /files-paginated for very large directories to avoid heavy payloads" ],
          "response_shape" : "CephFsDirectoryEntriesWithStats",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Heavy directory stats"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-paginated" ],
          "postprocessing_hint" : "Gracefully handle entries disappearing during traversal (nulls are skipped).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout" : {
      "put" : {
        "summary" : "Change the pool a file or directory is stored in.",
        "description" : "Files can only be changed if they are empty. Changing a directory only affects new files and subdirectories.",
        "operationId" : "CephFsListingResource_setCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS layout configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsLayout"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage pool and namespace layout for files and directories.",
          "usage" : [ "Assign directories to specific storage pools for performance optimization", "Configure namespace isolation for multi-tenant scenarios", "Migrate empty files to different storage tiers" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Layout configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/layout", "/cephfs/layout/pools", "/cephfs/create-directory" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the pool a file or directory is stored in.",
        "operationId" : "CephFsListingResource_getCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsLayout"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the pool and namespace layout attributes for a file or directory.",
          "usage" : [ "Call before modifying layout to display current targets", "Use during troubleshooting to confirm where data is stored" ],
          "response_shape" : "CephFsLayout",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Layout inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cephfs/layout/pools", "/cephfs/layout" ],
          "postprocessing_hint" : "Display null pools as 'default' in UI for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout/pools" : {
      "get" : {
        "summary" : "Get pools that are eligible as data storage location in the layout API.",
        "operationId" : "CephFsListingResource_getPoolsForCephfsLayout",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CephFS data pools that can be assigned via the layout API.",
          "usage" : [ "Populate pool dropdowns when editing directory layouts", "Refresh when filesystem topology changes" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Layout configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cephfs/layout", "/pools" ],
          "postprocessing_hint" : "Display pool names with human-friendly descriptions from /pools if needed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/move" : {
      "put" : {
        "summary" : "Rename a file or directory.",
        "operationId" : "CephFsListingResource_moveCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rename or move a file or directory to a new location within CephFS.",
          "usage" : [ "Rename files or directories to better organize data", "Move files between different directory structures", "Reorganize CephFS hierarchy for better management" ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File move operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/copy", "/cephfs/files", "/cephfs/delete" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/quota" : {
      "put" : {
        "summary" : "Set the quota of a directory.",
        "operationId" : "CephFsListingResource_setCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsQuota"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage quotas for CephFS directories to control space and file count usage.",
          "usage" : [ "Set byte limits to prevent directories from consuming too much storage", "Configure file count limits to prevent excessive small file creation", "Remove quotas by setting values to null or zero" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "maxBytes",
            "in" : "body",
            "description" : "MaxBytes parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "maxFiles",
            "in" : "body",
            "description" : "MaxFiles parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Quota configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/quota", "/cephfs/files", "/cephfs/create-directory" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the quota of a directory.",
        "operationId" : "CephFsListingResource_getCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsQuota"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch byte and file quotas applied to a CephFS directory.",
          "usage" : [ "Display current quota before allowing edits", "Check quota status while troubleshooting capacity issues" ],
          "response_shape" : "CephFsQuota",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Quota inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/quota", "/cephfs/files" ],
          "postprocessing_hint" : "Display null values as 'unlimited'.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/stats" : {
      "post" : {
        "summary" : "Get stats for a list of files.",
        "operationId" : "CephFsListingResource_listCephfsFiles",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "description" : "Absolute paths of the requested files.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch CephFS metadata for a provided list of absolute paths.",
          "usage" : [ "Batch resolve file metadata before rendering mixed selections in the UI.", "Validate existence of specific paths during automation scripts." ],
          "response_shape" : "array<CephFsResponse>",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Ad-hoc metadata lookups"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-with-stats" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/upload" : {
      "put" : {
        "summary" : "Upload a file.",
        "operationId" : "CephFsListingResource_uploadCephFsFile",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsUploadRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Upload a file to CephFS using multipart form data.",
          "usage" : [ "Upload files from client applications to CephFS storage", "Restore backed up files to CephFS", "Transfer files from external sources into the cluster" ],
          "response_shape" : "Response (201 CREATED)",
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "File upload operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/download", "/cephfs/files", "/cephfs/delete" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests" : {
      "get" : {
        "summary" : "Get all pending change requests.",
        "operationId" : "ChangeRequestResource_getPendingChangeRequests",
        "tags" : [ "change-requests" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ChangeRequest"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all pending change requests awaiting admin approval for CRUSH map modifications.",
          "usage" : [ "Call to review pending infrastructure changes before approving or rejecting them.", "Use to monitor the change approval workflow and track what modifications are queued." ],
          "response_shape" : "List<ChangeRequest>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Change request monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/change-requests/{id}/approve", "/change-requests/{id}/reject", "/crush" ],
          "postprocessing_hint" : "Display change details with affected objects; highlight requests by age and impact; show who created each request.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/change-requests/{id}/approve" : {
      "post" : {
        "summary" : "Approve a pending change request.",
        "operationId" : "ChangeRequestResource_approveChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Approve a pending change request to execute CRUSH map modifications with proper validation and safety checks.",
          "usage" : [ "Call after reviewing change request details to execute approved CRUSH map changes.", "Use when ready to apply storage layout modifications that have been validated." ],
          "response_shape" : "ManagedTask (or null if no CRUSH changes)",
          "workflow_guidance" : {
            "pre_check" : "Change request exists; No concurrent CRUSH operations; OSD creation lock available",
            "post_action" : "CRUSH map updated; Change request processed; Task advisor validates changes; Hooks executed"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Change request ID to approve and execute.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "CRUSH map modifications"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/change-requests", "/change-requests/{id}/reject", "/crush" ],
          "postprocessing_hint" : "Monitor task progress for CRUSH map updates; default CRUSH rules may be created automatically; task advisor checks map validity.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Approving change requests will modify the CRUSH map and potentially affect data placement"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests/{id}/reject" : {
      "post" : {
        "summary" : "Reject a pending change request.",
        "operationId" : "ChangeRequestResource_rejectChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reject a pending change request to prevent execution of CRUSH map modifications.",
          "usage" : [ "Call when change request review determines that proposed changes should not be applied.", "Use to cancel change requests that are unsafe or no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Change request exists; Not already processed; Admin review completed",
            "post_action" : "Change request rejected; No CRUSH map changes applied; Request removed from pending list"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Change request ID to reject and cancel.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Change request management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/change-requests", "/change-requests/{id}/approve" ],
          "postprocessing_hint" : "Rejection is immediate; no CRUSH map changes are applied; audit log records the rejection decision.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Rejecting change requests will permanently cancel proposed CRUSH map modifications"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_createCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bootstrap a brand-new Ceph cluster using the selected MON disk and IP address.",
          "usage" : [ "Invoke immediately after fetching candidates from GET /cluster/create/mons.", "Monitor the returned ManagedTask via /tasks/{id} until the bootstrap completes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "diskId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "ipv6",
            "in" : "body",
            "description" : "Ipv6 parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "serverId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Cluster bootstrap is a one-time operation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/maintenance/migrations" ],
          "postprocessing_hint" : "Persist the returned task id and stream updates from /tasks/{id} until state=FINISHED.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bootstrapping the cluster is destructive if a cluster already exists."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/create/mons" : {
      "get" : {
        "summary" : "List all servers that have a MON disk.",
        "operationId" : "ClusterResource_getMonCandidates",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/InitialMonServer"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List servers eligible to host the initial Ceph MON during cluster bootstrap.",
          "usage" : [ "Call prior to POST /cluster to populate the MON selection UI.", "Refresh after wiping disks or changing roles to see newly eligible servers." ],
          "response_shape" : "array<InitialMonServer>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Cluster bootstrap planning"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster", "/disks/create-osds" ],
          "postprocessing_hint" : "Sort by hostname and display both IPv4/IPv6 entries so the installer can choose the correct address.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/deploy" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_deployCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterDeployRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy the initial Ceph monitors using multiple preselected MON disks.",
          "usage" : [ "Call once during bootstrap after validating candidates from GET /cluster/create/mons.", "Track the returned ManagedTask via /tasks/{id} to follow wiping and MON provisioning progress." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "mons",
            "in" : "body",
            "description" : "Mons parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Initial deployment should run once"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Store the returned task id and display wiping/installation progress until done.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deploying multiple monitors may wipe disks that contain existing data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/releases" : {
      "get" : {
        "summary" : "Get running Ceph releases",
        "operationId" : "ClusterResource_clusterReleases",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephReleases"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the Ceph release distribution currently running across cluster daemons.",
          "usage" : [ "Call before triggering upgrades to confirm the cluster is homogeneous.", "Poll during migrations to track remaining hosts still on older releases." ],
          "response_shape" : "CephReleases",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Upgrade monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status", "/maintenance/migrations" ],
          "postprocessing_hint" : "Highlight releases other than the target to communicate remaining upgrade tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status" : {
      "get" : {
        "summary" : "Get croit cluster status",
        "operationId" : "ClusterResource_clusterStatus",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph and croit service health snapshot.",
          "usage" : [ "Call before running Ceph-altering workflows to ensure the cluster is healthy", "Refresh every 10 seconds when rendering live dashboards" ],
          "response_shape" : "ClusterStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure Ceph is configured; if not, expect cephStatus to be null.",
            "post_action" : "Surface warnings or degraded services in the UI."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared across dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status/detail", "/status" ],
          "postprocessing_hint" : "Cache the response for <=5s client-side to avoid excess load.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/detail" : {
      "get" : {
        "summary" : "Get Ceph health detail.",
        "operationId" : "ClusterResource_clusterHealthDetail",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephStatusHealth"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect detailed Ceph health checks including summaries and explanations.",
          "usage" : [ "Call after detecting warnings in GET /cluster/status", "Use sparingly for drill-down views to reduce payload size" ],
          "response_shape" : "CephHealthDetail",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Detail view heavy payload"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/mute/{check}" ],
          "postprocessing_hint" : "Limit the number of displayed checks and truncate long detail strings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history" : {
      "get" : {
        "summary" : "List available past cluster state timestamps.",
        "operationId" : "ClusterResource_clusterStatusHistoryEntries",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int64"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available historical snapshots for later retrieval.",
          "usage" : [ "Fetch once to populate a history selector", "Choose the latest timestamp to investigate recent incidents" ],
          "response_shape" : "array<long>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Used sparingly when opening timelines"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history/{timestamp}" ],
          "postprocessing_hint" : "Sort timestamps descending before presenting to users.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history/{timestamp}" : {
      "get" : {
        "summary" : "Get cluster state as close as possible to a specific timestamp.",
        "operationId" : "ClusterResource_getClusterPastState",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "description" : "Timestamp as returned by /cluster/status/history",
          "name" : "timestamp",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a cached cluster status snapshot close to the requested time.",
          "usage" : [ "Call after selecting a timestamp from GET /cluster/status/history", "Prefer timestamps not older than 15 minutes for accurate diagnostics" ],
          "response_shape" : "ClusterStatus",
          "path_parameters" : [ {
            "name" : "timestamp",
            "in" : "path",
            "description" : "timestamp parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "timestamp",
            "in" : "path",
            "description" : "Epoch seconds returned by GET /cluster/status/history",
            "required" : true,
            "example" : "1700000000"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Timeline exploration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history", "/cluster/status/detail" ],
          "postprocessing_hint" : "Indicate the actual snapshot timestamp compared to the requested value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/mute/{check}" : {
      "post" : {
        "summary" : "Mute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckMute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HealthCheckMuteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Temporarily mute a specific Ceph health check to suppress alerts.",
          "usage" : [ "Call immediately before acknowledging a known issue to keep dashboards quiet.", "Specify ttl when scheduling an automatic unmute; otherwise rely on a manual POST /cluster/status/unmute/{check}." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "sticky",
            "in" : "body",
            "description" : "Sticky parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "ttl",
            "in" : "body",
            "description" : "Ttl parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "check parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check identifier (e.g. OSD_DOWN).",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Alert suppression"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/unmute/{check}" ],
          "postprocessing_hint" : "Immediately refresh GET /cluster/status to reflect the muted check.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/status/nagios" : {
      "get" : {
        "summary" : "Get overall Ceph health status formatted for Nagios.",
        "operationId" : "ClusterResource_clusterHealthSummaryForNagios",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose Ceph health in a Nagios-compatible single line format.",
          "usage" : [ "Integrate with external Nagios/icinga style monitors", "Use when plain text status codes are required" ],
          "response_shape" : "text/plain",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "External monitoring poll"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios/{check}" ],
          "postprocessing_hint" : "Use first token to determine Nagios state before logging.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/nagios/{check}" : {
      "get" : {
        "summary" : "Get a specific Ceph health check in Nagios text format.",
        "operationId" : "ClusterResource_clusterHealthForNagios",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a Nagios-compatible status line for a specific Ceph health check code.",
          "usage" : [ "Configure Nagios/Icinga service checks for individual Ceph alerts", "Provide targeted status for dashboards that focus on specific health codes" ],
          "response_shape" : "text/plain",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "check parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check code, e.g. SLOW_OPS",
            "required" : true,
            "example" : "SLOW_OPS"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Per-check polling"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios" ],
          "postprocessing_hint" : "Split first word to extract Nagios state before piping to external tools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/unmute/{check}" : {
      "post" : {
        "summary" : "Unmute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckUnmute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Re-enable a previously muted Ceph health check.",
          "usage" : [ "Call after resolving the underlying issue so alerts resume.", "Use to cancel a sticky mute created via POST /cluster/status/mute/{check}." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "check parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "check",
            "in" : "path",
            "description" : "Health check identifier to unmute.",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Alert management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status/mute/{check}", "/cluster/status" ],
          "postprocessing_hint" : "Trigger a status refresh to confirm the check is now active.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config" : {
      "put" : {
        "summary" : "Set Ceph configuration option",
        "operationId" : "CephConfigResource_setCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update Ceph cluster configuration settings or croit-specific application settings.",
          "usage" : [ "Call when tuning cluster performance parameters or changing service behavior.", "Use to apply configuration changes that require cluster-wide propagation." ],
          "response_shape" : "ManagedThreadTask or null",
          "workflow_guidance" : {
            "pre_check" : "Configuration option exists; Value type matches expected format; Cluster is healthy",
            "post_action" : "Configuration applied cluster-wide; Services restarted if needed; Warning shown for RGW frontend conflicts"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "Value parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/config", "/config/available", "/config/rgw-ssl-cert" ],
          "postprocessing_hint" : "For RGW frontends config, warn about potential port conflicts with existing RGW services that may cause S3 downtime.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all ceph configs.",
        "operationId" : "CephConfigResource_getCephConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph configuration options that have been modified from their defaults.",
          "usage" : [ "Call when reviewing current cluster configuration settings.", "Use before making configuration changes to understand current state." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Configuration inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config/available", "/config/modified" ],
          "postprocessing_hint" : "Display modified values prominently; group by service type for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete Ceph configuration option",
        "operationId" : "CephConfigResource_deleteCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph configuration option to revert to default value",
          "usage" : [ "Remove custom configuration overrides", "Revert settings to Ceph defaults" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Config management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/config", "/config (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing config options may affect cluster behavior"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates" : {
      "get" : {
        "summary" : "List of all templates.",
        "operationId" : "TemplateResource_getTemplates",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseConfigTemplateResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available configuration templates for system files like GRUB, network setup, and disk configuration.",
          "usage" : [ "Call when loading the template management UI to show available and current templates.", "Use to understand which templates are active and what alternatives are available." ],
          "response_shape" : "OptionalPaginationResponse<ConfigTemplateResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Template configuration access"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/config-templates/templates/{template}", "/config-templates/helpers" ],
          "postprocessing_hint" : "Display current template prominently; group available templates by category for easy selection.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/helpers" : {
      "get" : {
        "summary" : "Get template helpers",
        "operationId" : "TemplateResource_getHelpers",
        "tags" : [ "config-templates" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available handlebars helper functions for use in custom configuration templates.",
          "usage" : [ "Call when building template editors to show available helper functions.", "Use to understand what processing functions are available for template variables." ],
          "response_shape" : "map<string,string>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Template helper discovery"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/config-templates", "/config-templates/templates/{template}/variables" ],
          "postprocessing_hint" : "Use helpers in handlebars syntax like {{helper variable}} when building custom templates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/templates/{template}" : {
      "put" : {
        "summary" : "Set configuration template",
        "operationId" : "TemplateResource_setTemplate",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Template configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ConfigTemplateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a system configuration template and deploy it across all affected servers.",
          "usage" : [ "Call when customizing GRUB configuration, network setup, or disk templates.", "Use to switch between predefined templates or deploy custom configurations." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Template syntax is valid; Servers are accessible; GRUB/network changes confirmed",
            "post_action" : "Template deployed to all servers; GRUB reconfigured if applicable; Servers may require reboot for changes to take effect"
          },
          "request_parameters" : [ {
            "name" : "customTemplate",
            "in" : "body",
            "description" : "CustomTemplate parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "predefinedTemplate",
            "in" : "body",
            "description" : "PredefinedTemplate parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "template",
            "in" : "path",
            "description" : "template parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "template",
            "in" : "path",
            "description" : "Template identifier (e.g., 'grub-config', 'network-setup', 'cmdline-disk').",
            "required" : true,
            "example" : "grub-config"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "System template updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/config-templates", "/config-templates/templates/{template}/variables" ],
          "postprocessing_hint" : "Monitor task progress carefully; test server boot behavior after GRUB or kernel changes; rollback capability may require manual intervention.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Template changes affect all servers and may cause boot failures if misconfigured"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates/templates/{template}/variables" : {
      "get" : {
        "summary" : "Get template variables",
        "operationId" : "TemplateResource_getVariables",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TemplateObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available template variables and context data for a specific configuration template.",
          "usage" : [ "Call when building template editors to show available variables for substitution.", "Use to validate custom templates against available context data." ],
          "response_shape" : "TemplateObject",
          "path_parameters" : [ {
            "name" : "template",
            "in" : "path",
            "description" : "template parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "template",
            "in" : "path",
            "description" : "Template identifier to get variables for.",
            "required" : true,
            "example" : "grub-config"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Template variable access"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/config-templates", "/config-templates/helpers" ],
          "postprocessing_hint" : "Use variable names in handlebars syntax ({{variable}}) when building custom templates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/available" : {
      "get" : {
        "summary" : "Get available Ceph configuration options",
        "operationId" : "CephConfigResource_getAvailableOptions",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/CephConfigResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all available Ceph configuration options including current values, defaults, and metadata.",
          "usage" : [ "Call when building configuration management UI to show all possible settings.", "Use before making configuration changes to understand available options and their defaults." ],
          "response_shape" : "Map<String, CephConfigResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Configuration metadata retrieval"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config", "/config/availableAsList", "/config/modified" ],
          "postprocessing_hint" : "Exclude DEV-level options from UI; group by category; highlight non-default values.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/availableAsList" : {
      "get" : {
        "summary" : "List available ceph configs.",
        "operationId" : "CephConfigResource_getAvailableOptionsAsList",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all available Ceph configuration options as a paginated list, combining configured and unconfigured options.",
          "usage" : [ "Call when populating configuration dropdown lists or search interfaces.", "Use for comprehensive configuration management where all options need to be browsable." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "Configuration list retrieval"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config/available", "/config/modified" ],
          "postprocessing_hint" : "Sort by modified status first; exclude DEV-level options unless explicitly requested; provide search functionality.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/client" : {
      "get" : {
        "summary" : "Download client Ceph configuration file",
        "operationId" : "CephConfigResource_getConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate and download a client-specific Ceph configuration file for external access.",
          "usage" : [ "Call when setting up external Ceph clients that need cluster access.", "Use to provide configuration files for applications connecting to the Ceph cluster." ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; Authentication configured properly",
            "post_action" : "Client configuration file generated; Contains only client-relevant settings"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Client configuration downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/download/full", "/config" ],
          "postprocessing_hint" : "Downloaded file should be renamed to ceph.conf and placed in /etc/ceph/ on client systems.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/full" : {
      "get" : {
        "summary" : "Download full Ceph configuration file",
        "operationId" : "CephConfigResource_getFullConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate and download the complete Ceph cluster configuration file including all settings.",
          "usage" : [ "Call when backing up cluster configuration or preparing for cluster migration.", "Use for troubleshooting or when full configuration details are needed for support." ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; All configuration sources available",
            "post_action" : "Complete configuration file generated; Contains all cluster and service settings"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 300,
            "note" : "Full configuration downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/download/client", "/config" ],
          "postprocessing_hint" : "Contains sensitive configuration details; secure appropriately when used for backups or migrations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/modified" : {
      "get" : {
        "summary" : "List modified ceph configs.",
        "operationId" : "CephConfigResource_getCephOrCroitConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List only Ceph configuration options that have been modified from their default values.",
          "usage" : [ "Call when auditing configuration changes or identifying customized settings.", "Use to understand what has been tuned compared to default Ceph installation." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Modified configuration inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config", "/config/available" ],
          "postprocessing_hint" : "Display value changes prominently; show impact level for each modified setting.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/rgw-ssl-cert" : {
      "put" : {
        "summary" : "Set RGW SSL certificate",
        "operationId" : "CephConfigResource_setRgwSslCert",
        "tags" : [ "config" ],
        "requestBody" : {
          "description" : "RGW SSL certificate configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSslCertChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW SSL certificate and perform rolling restart of RGW services to apply changes.",
          "usage" : [ "Call when replacing expired SSL certificates for S3/Swift endpoints.", "Use to deploy new certificates from a certificate authority or enable custom SSL." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Certificate format valid; SSH access to RGW servers; RGW services healthy",
            "post_action" : "Certificate uploaded to /etc/ceph/rgwcert.pem on all RGW servers; RGW services restarted; New certificate active"
          },
          "request_parameters" : [ {
            "name" : "certificate",
            "in" : "body",
            "description" : "Certificate parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "doRollingRestart",
            "in" : "body",
            "description" : "DoRollingRestart parameter",
            "required" : true,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "SSL certificate updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/config/rgw-ssl-cert", "/services" ],
          "postprocessing_hint" : "Verify SSL endpoints work with new certificate; rolling restart prevents S3/Swift downtime during certificate deployment.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW SSL certificate",
        "operationId" : "CephConfigResource_getRgwSslCert",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current RGW SSL certificate content for inspection or backup.",
          "usage" : [ "Call when auditing SSL certificate configuration for S3/Swift endpoints.", "Use to backup current certificate before updating to a new one." ],
          "response_shape" : "String",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Certificate inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/rgw-ssl-cert" ],
          "postprocessing_hint" : "Parse certificate to extract expiration date and issuer for certificate management.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies" : {
      "get" : {
        "summary" : "List croit app dependencies.",
        "operationId" : "CroitAppResource_getAllDependencies",
        "tags" : [ "croit" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCroitDependency"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all third-party dependencies used by the croit application with their licenses and legal information.",
          "usage" : [ "Call when preparing compliance reports or auditing software licenses for legal requirements.", "Use to understand the dependency stack and licensing obligations for croit deployments." ],
          "response_shape" : "PaginationResponse<CroitDependency>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dependency information queries"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/croit/dependencies/cyclonedx" ],
          "postprocessing_hint" : "Group dependencies by license type; highlight license obligations; show dependency counts per license category.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies/cyclonedx" : {
      "get" : {
        "summary" : "Download croit app dependencies as CycloneDX SBOM.",
        "operationId" : "CroitAppResource_cyclonedx",
        "tags" : [ "croit" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the complete Software Bill of Materials (SBOM) in CycloneDX format for compliance and security scanning.",
          "usage" : [ "Call when integrating with security scanning tools that require CycloneDX SBOM format.", "Use for automated compliance workflows or vulnerability management systems." ],
          "response_shape" : "DownloadableObject (JSON file)",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "SBOM downloads"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/croit/dependencies" ],
          "postprocessing_hint" : "Save as bom.cyclonedx.json; use with security scanning tools like OWASP Dependency-Check or Snyk.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush" : {
      "post" : {
        "summary" : "Update the current CRUSH map.",
        "operationId" : "CrushResource_setCrushMap",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "CRUSH map update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CrushTree"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ChangeRequest"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Submit CRUSH map topology changes as a change request for review and approval before execution.",
          "usage" : [ "Use when restructuring cluster topology, moving OSDs between buckets, or changing weights.", "Call after planning placement changes to create a reviewable change request." ],
          "response_shape" : "ChangeRequest",
          "request_parameters" : [ {
            "name" : "allNodes",
            "in" : "body",
            "description" : "AllNodes parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "nodes",
            "in" : "body",
            "description" : "Nodes parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "nodesById",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "stray",
            "in" : "body",
            "description" : "Stray parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "CRUSH map modifications"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush", "/change-requests", "/crush/rules" ],
          "postprocessing_hint" : "Review change request details carefully; CRUSH changes may cause data rebalancing; monitor cluster health during execution.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "CRUSH map changes can trigger significant data movement and affect cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current CRUSH map.",
        "operationId" : "CrushResource_getCrushMap",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CrushTree"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Get complete list of OSDs with their status and location - PRIMARY endpoint for OSD inventory and topology.",
          "usage" : [ "Get complete list of OSDs with their status and location.", "Primary endpoint for OSD inventory and topology.", "Call before planning placement rule changes or visualising data distribution.", "Refresh after running ceph osd crush set commands to verify topology updates." ],
          "response_shape" : "CrushTree",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "OSD listing and CRUSH inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/disks", "/crush/rules", "/disks/create-osds", "/pools" ],
          "postprocessing_hint" : "PRIMARY OSD listing endpoint. Extract OSDs from tree.nodes where type='osd'. Summarize weight totals per bucket and highlight destroyed OSDs for operators. Group OSDs by host/rack for topology visualization.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/destroyed-osd-ids" : {
      "get" : {
        "summary" : "Get list of destroyed OSD IDs",
        "operationId" : "CrushResource_getDestroyedOsdIds",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DestroyedOsdIds"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List OSDs marked as destroyed to identify failed storage devices requiring replacement.",
          "usage" : [ "Call during maintenance planning to identify hardware failures needing attention.", "Use before OSD cleanup operations to track which devices were previously failed." ],
          "response_shape" : "DestroyedOsdIds",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Destroyed OSD tracking"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/disks", "/maintenance" ],
          "postprocessing_hint" : "Group destroyed OSDs by host; highlight OSDs ready for physical replacement or purge operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/ec-profiles" : {
      "get" : {
        "summary" : "Get all EC profiles.",
        "operationId" : "CrushResource_getEcProfiles",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/ErasureCodeProfileDump"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve erasure coding profiles with their data/parity configurations for pool planning.",
          "usage" : [ "Call when creating EC pools to select appropriate data protection levels.", "Use to audit existing EC configurations and plan capacity requirements." ],
          "response_shape" : "Map<String, ErasureCodeProfileDump>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "EC profile queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools", "/crush/rules" ],
          "postprocessing_hint" : "Display k+m ratios prominently; show storage efficiency and minimum cluster size for each profile.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/osd/{osdId}/metadata" : {
      "get" : {
        "summary" : "Retrieve OSD metadata, resulting JSON contains runtime information about the OSD and varies by Ceph version.",
        "operationId" : "CrushResource_getOsdMetaData",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch Ceph-reported metadata for a specific OSD (host, bucket, state, etc.).",
          "usage" : [ "Inspect placement and attributes before migrating or removing an OSD.", "Verify metadata differences after ceph osd metadata commands or crush map edits." ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "osdId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Metadata inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/disks", "/maintenance/osd-full-ratios" ],
          "postprocessing_hint" : "Present key-value pairs grouped by section (e.g., device, network) to improve readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules" : {
      "get" : {
        "summary" : "List CRUSH rules.",
        "operationId" : "CrushResource_getCrushRules",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCrushRuleResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CRUSH rules with their steps to analyze data placement policies.",
          "usage" : [ "Fetch before assigning rules to pools or creating new ones.", "Compare rules after modifications to ensure parameters match expectations." ],
          "response_shape" : "OptionalPaginationResponse<CrushRuleResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Rule inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/pools", "/crush/rules/simple" ],
          "postprocessing_hint" : "Group replicated vs erasure rules and display chooseleaf steps prominently for operators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/classes" : {
      "get" : {
        "summary" : "List CRUSH device classes.",
        "operationId" : "CrushResource_getCrushRuleClasses",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available CRUSH device classes to understand storage tiers and constraints for rule creation.",
          "usage" : [ "Call when designing CRUSH rules to target specific device types (ssd, hdd, nvme).", "Use to validate device class names before creating placement rules." ],
          "response_shape" : "List<String>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Device class queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush/rules", "/crush/rules/simple", "/disks" ],
          "postprocessing_hint" : "Display device classes with counts of OSDs in each class; common classes are ssd, hdd, nvme.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/simple" : {
      "post" : {
        "summary" : "Create a simple CRUSH rule.",
        "operationId" : "CrushResource_newSimpleCrushRule",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "Simple CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimpleRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a basic replicated or erasure-coded CRUSH rule targeting a specific bucket/device class.",
          "usage" : [ "Use when onboarding new pools requiring dedicated placement rules.", "Provide deviceClass to avoid mixing drive types in future expansions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "deviceClass",
            "in" : "body",
            "description" : "DeviceClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "ErasureCoding parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "independent",
            "in" : "body",
            "description" : "Independent parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "startBucket",
            "in" : "body",
            "description" : "StartBucket parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule authoring"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/crush" ],
          "postprocessing_hint" : "After creation, associate the rule with a pool and run ceph osd map to verify placement.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating CRUSH rules affects placement decisions for subsequent pools."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/ssdPrimary" : {
      "post" : {
        "summary" : "Create SSD primary CRUSH rule",
        "operationId" : "CrushResource_newSsdPrimaryCrushRule",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "SSD primary CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SsdPrimaryRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a specialized CRUSH rule that places primary replicas on SSD and secondary replicas on HDD for tiered storage.",
          "usage" : [ "Use when implementing hybrid storage strategies to optimize performance and cost.", "Call to create rules that ensure fast SSD access for primary reads while using cheaper HDD for redundancy." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "hddDeviceClass",
            "in" : "body",
            "description" : "HddDeviceClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "hddIndependent",
            "in" : "body",
            "description" : "HddIndependent parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "hddStartBucket",
            "in" : "body",
            "description" : "HddStartBucket parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "ssdCopies",
            "in" : "body",
            "description" : "SsdCopies parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "ssdDeviceClass",
            "in" : "body",
            "description" : "SsdDeviceClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ssdIndependent",
            "in" : "body",
            "description" : "SsdIndependent parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "ssdStartBucket",
            "in" : "body",
            "description" : "SsdStartBucket parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Specialized CRUSH rule creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/crush/rules/simple" ],
          "postprocessing_hint" : "Test with ceph osd map after creation; verify SSD primaries and HDD secondaries placement before assigning to pools.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "SSD primary rules affect data placement and performance characteristics of pools"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/{name}" : {
      "delete" : {
        "summary" : "Delete specified CRUSH rule.",
        "operationId" : "CrushResource_deleteCrushRule",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an existing CRUSH rule from the cluster.",
          "usage" : [ "Ensure no pools reference the rule before calling this endpoint.", "Perform after migrating pools to alternate rules to keep the CRUSH map tidy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "CRUSH rule name to delete.",
            "required" : true,
            "example" : "replicated-ssd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/pools" ],
          "postprocessing_hint" : "Dump the CRUSH map to confirm the rule is gone and no orphaned references remain.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing rules impacting pool placement may lead to data movement if referenced inadvertently."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos" : {
      "get" : {
        "summary" : "Retrieve all DAOS configs.",
        "operationId" : "DaosClusterResource_getDaosClusters",
        "tags" : [ "daos" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/SimpleDaosConfig"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a list of all configured DAOS clusters with basic configuration details.",
          "usage" : [ "Call to display DAOS cluster overview and selection interfaces.", "Use for monitoring dashboards to show all available DAOS storage systems." ],
          "response_shape" : "List<SimpleDaosConfig>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "DAOS cluster listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Display cluster status, server count, and basic health information for each DAOS system.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS cluster.",
        "operationId" : "DaosClusterResource_createDaosCluster",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new DAOS cluster with specified servers and configuration after validation.",
          "usage" : [ "Call after successful verification to create and configure a DAOS storage cluster.", "Use to deploy DAOS infrastructure on validated servers with network configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Servers verified; Network configured; No existing DAOS cluster conflicts; Sufficient resources",
            "post_action" : "DAOS cluster created; Services deployed; Pool and container caches initialized; Cluster ready for use"
          },
          "request_parameters" : [ {
            "name" : "clusterName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "provider",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "targets",
            "in" : "body",
            "description" : "Targets parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "threads",
            "in" : "body",
            "description" : "Threads parameter",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 3600,
            "note" : "DAOS cluster creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/verify", "/daos/{daosId}" ],
          "postprocessing_hint" : "Monitor task progress for deployment status; cluster becomes available after successful creation; automatic verification warnings require confirmation.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating DAOS cluster will deploy storage services across multiple servers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/verify" : {
      "post" : {
        "summary" : "Verify if the servers can be used to set up DAOS.",
        "operationId" : "DaosClusterResource_verifyDaosSetup",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation request for verification",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosVerificationResult"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Verify if selected servers meet requirements for DAOS cluster setup without making changes.",
          "usage" : [ "Call before creating DAOS cluster to validate server configuration and compatibility.", "Use to check hardware requirements, network configuration, and software prerequisites." ],
          "response_shape" : "DaosVerificationResult",
          "workflow_guidance" : {
            "pre_check" : "Servers exist; Network configuration valid; DAOS prerequisites available",
            "post_action" : "Verification results returned; No changes made to system; Ready for cluster creation if successful"
          },
          "request_parameters" : [ {
            "name" : "clusterName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "provider",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "targets",
            "in" : "body",
            "description" : "Targets parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "threads",
            "in" : "body",
            "description" : "Threads parameter",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS verification operations"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/daos", "/daos/{daosId}" ],
          "postprocessing_hint" : "Review verification results for warnings and errors; address any issues before proceeding with cluster creation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}" : {
      "get" : {
        "summary" : "Retrieve a DAOS cluster by ID.",
        "operationId" : "DaosClusterResource_getDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed configuration and status information for a specific DAOS cluster.",
          "usage" : [ "Call when displaying DAOS cluster details, configuration review, or troubleshooting.", "Use to fetch complete cluster setup before making modifications or monitoring health." ],
          "response_shape" : "DaosConfig",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "Unique identifier of the DAOS cluster to retrieve.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "DAOS cluster details"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos", "/daos/{daosId}/members", "/daos/{daosId}/containers" ],
          "postprocessing_hint" : "Display server assignments, engine configurations, and network settings; highlight any configuration warnings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS cluster.",
        "operationId" : "DaosClusterResource_deleteDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete a DAOS cluster and all associated data, pools, and containers.",
          "usage" : [ "Call when decommissioning DAOS storage systems or removing failed cluster configurations.", "Use to clean up test or development DAOS clusters that are no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to delete permanently.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "DAOS cluster deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos", "/daos/{daosId}" ],
          "postprocessing_hint" : "Monitor task progress for deletion status; services are removed from all cluster servers; pool and container caches are cleared; operation cannot be undone.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting DAOS cluster will permanently destroy all data, pools, and containers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs" : {
      "get" : {
        "summary" : "Retrieve a list of certificates for the DAOS cluster.",
        "operationId" : "DaosCertificateResource_getDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosCertificateResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all certificates (system and client) for a DAOS cluster.",
          "usage" : [ "Call to display certificate management interface and monitor certificate expiration dates.", "Use for security audits and certificate lifecycle management in DAOS clusters." ],
          "response_shape" : "PaginationResponse<DaosCertificateResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to list certificates for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Certificate listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/certs/{certId}/crtFile", "/daos/{daosId}/certs/{certId}/keyFile" ],
          "postprocessing_hint" : "Highlight expiring certificates; group by type (CA, server, admin, agent, client); show expiry dates prominently.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new client certificate to the DAOS cluster.",
        "operationId" : "DaosCertificateResource_createDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new client certificate for secure DAOS cluster access with specified name and description.",
          "usage" : [ "Call when setting up new clients that need authenticated access to DAOS cluster.", "Use to generate client certificates for applications or users requiring DAOS connectivity." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate name is unique; CA is operational",
            "post_action" : "Client certificate created; Certificate files available for download; Client can authenticate to cluster"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID where the certificate will be created.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Certificate creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}" ],
          "postprocessing_hint" : "Monitor task for certificate generation; download certificate files after creation; distribute securely to client applications.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/reparse-expiries" : {
      "post" : {
        "summary" : "Reparse all expiries from the CRT files.",
        "operationId" : "DaosCertificateResource_reparseDaosCertsExpiries",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reparse certificate expiration dates from CRT files to update database with current expiry information.",
          "usage" : [ "Call when certificate expiry information appears outdated or inconsistent.", "Use after manual certificate updates or when expiry warnings seem incorrect." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate files accessible; Database writable",
            "post_action" : "Certificate expiry dates updated; Database synchronized with file system; Expiry warnings accurate"
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing certificates to reparse.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 1800,
            "note" : "Certificate parsing operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs" ],
          "postprocessing_hint" : "Monitor task for parsing progress; expiry information will be updated in database; certificate warnings will reflect current file contents.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}" : {
      "patch" : {
        "summary" : "Update a client certificate's name or description.",
        "operationId" : "DaosCertificateResource_updateDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update metadata for a DAOS client certificate including display name and description.",
          "usage" : [ "Call when certificate labeling needs to be updated for better organization.", "Use to add or modify descriptive information without regenerating the certificate." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate is client type; Valid metadata provided",
            "post_action" : "Certificate metadata updated; Display information refreshed; Certificate remains functional"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "certId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID to update (must be a client certificate).",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Certificate metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}" ],
          "postprocessing_hint" : "Metadata changes are immediate; certificate functionality and security remain unchanged; only display information updated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a client certificate from the DAOS cluster. The admin/agent/server and CA certificates cannot be deleted.",
        "operationId" : "DaosCertificateResource_deleteDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a client certificate from the DAOS cluster to revoke access for specific clients.",
          "usage" : [ "Call when revoking access for DAOS clients or cleaning up unused certificates.", "Use for security management to remove certificates that should no longer have cluster access." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "certId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate to delete.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Client certificate ID to delete (must be >0; system certificates cannot be deleted).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Certificate deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/create" ],
          "postprocessing_hint" : "Monitor task progress; certificate removal is immediate; revoked clients lose access; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting certificates immediately revokes client access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/crtFile" : {
      "get" : {
        "summary" : "Download the crt file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCrtFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the certificate (.crt) file for a specific DAOS certificate for client authentication.",
          "usage" : [ "Call to obtain certificate files needed for DAOS client connections and authentication.", "Use when setting up new clients or troubleshooting authentication issues." ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "certId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID (-1: CA, -2: Server, -3: Admin, -4: Agent, >0: Client).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Certificate downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}/keyFile" ],
          "postprocessing_hint" : "File expires after 15 minutes; use with corresponding key file for complete authentication setup.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/daos-configs.{type}" : {
      "get" : {
        "summary" : "Download a tar package containing all necessary files to connect to DAOS with the chosen certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCertPackage",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Download as tar or as zip file.",
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : "zip|tar"
          }
        }, {
          "description" : "Include admin config and certificate files.",
          "name" : "withAdmin",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        }
      }
    },
    "/daos/{daosId}/certs/{certId}/keyFile" : {
      "get" : {
        "summary" : "Download the key file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosKeyFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the private key (.key) file for a specific DAOS certificate for client authentication.",
          "usage" : [ "Call to obtain private key files required for DAOS client authentication and secure connections.", "Use when configuring DAOS clients or troubleshooting authentication setup." ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "certId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID (-1: CA, -2: Server, -3: Admin, -4: Agent, >0: Client).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Private key downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}/crtFile" ],
          "postprocessing_hint" : "File expires after 15 minutes; secure key storage required; combine with certificate file for authentication.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Private key files contain sensitive cryptographic material that must be handled securely"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/container-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available container properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosContainerProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available container properties supported by the DAOS cluster version for container configuration.",
          "usage" : [ "Call before creating or modifying DAOS containers to understand supported configuration options.", "Use to validate container property names and value ranges when building container creation requests." ],
          "response_shape" : "List<DaosProperty>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to get version-specific container properties for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Property schema queries"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 3600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/containers", "/daos/{daosId}/pool-props" ],
          "postprocessing_hint" : "Group properties by category; show data types and validation rules; cache for container creation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/containers" : {
      "get" : {
        "summary" : "Retrieve all DAOS containers in the cluster.",
        "operationId" : "DaosClusterResource_getAllDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all DAOS containers across all pools in the cluster.",
          "usage" : [ "Call to display container management interfaces and monitor data distribution.", "Use for capacity planning and tracking container usage across the entire DAOS cluster." ],
          "response_shape" : "PaginationResponse<DaosContainerDetails>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to list containers from.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Container listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{poolId}/containers" ],
          "postprocessing_hint" : "Aggregate containers by pool; show storage usage and health status; schedule automatic updates for returned data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/disks" : {
      "get" : {
        "summary" : "Retrieve all DAOS disks.",
        "operationId" : "DaosDiskResource_getDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPosixDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List DAOS POSIX disks along with usage metadata and NVMe-oF associations.",
          "usage" : [ "Populate storage management views that show where DAOS disks are mapped.", "Assess impact before deleting pools or containers that host disks." ],
          "response_shape" : "PaginationResponse<DaosPosixDiskResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Disk inventory lookup"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/containers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new DAOS disk.",
        "operationId" : "DaosDiskResource_createDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS disk creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosDiskCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a DAOS POSIX disk record and persist capacity metadata.",
          "usage" : [ "Add disks for NVMe-oF gateway exports after provisioning storage.", "Automate DAOS disk onboarding as part of infrastructure pipelines." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Validate the target container is POSIX and sufficient space is available.",
            "post_action" : "Monitor the returned task and refresh the disk list once completed."
          },
          "request_parameters" : [ {
            "name" : "container",
            "in" : "body",
            "description" : "Container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "oclass",
            "in" : "body",
            "description" : "Oclass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Disk provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/disks", "/daos/{daosId}/pools/{pool}/containers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/disks/{daosDiskId}" : {
      "delete" : {
        "summary" : "Remove a DAOS disk.",
        "operationId" : "DaosDiskResource_removeDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosDiskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove the DAOS disk record and reconfigure NVMe-oF gateways that reference it.",
          "usage" : [ "Decommission disks that are no longer exported via NVMe-oF.", "Clean up records after deleting the underlying DAOS storage." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Warn operators when the disk feeds NVMe-oF gateways; plan replacement first.",
            "post_action" : "Track the task for NVMe-oF reconfiguration and refresh disk listings on completion."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosDiskId",
            "in" : "path",
            "description" : "daosDiskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "daosDiskId",
            "in" : "path",
            "description" : "Internal croit disk ID.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Disk removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/disks", "/gateways/nvmeof/{gatewayId}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing the disk triggers NVMe-oF reconfiguration and deletes associated metadata."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/members" : {
      "get" : {
        "summary" : "Retrieve member states of the DAOS cluster.",
        "operationId" : "DaosClusterResource_getDaosState",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosSystemMemberResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed status and state information for all members in a DAOS cluster.",
          "usage" : [ "Call to monitor DAOS cluster health and identify problematic nodes.", "Use for troubleshooting cluster issues and verifying node participation in the cluster." ],
          "response_shape" : "PaginationResponse<DaosSystemMemberResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to query member states for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "DAOS member state queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/containers" ],
          "postprocessing_hint" : "Group members by state; highlight failed or excluded nodes; show fabric connectivity status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pool-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available pool properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosPoolProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available pool properties supported by the DAOS cluster version for pool configuration.",
          "usage" : [ "Call before creating or modifying DAOS pools to understand supported configuration options.", "Use to validate pool property names and value ranges when building pool creation requests." ],
          "response_shape" : "List<DaosProperty>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to get version-specific pool properties for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Property schema queries"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 3600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/container-props" ],
          "postprocessing_hint" : "Group properties by category; show data types and validation rules; cache for pool creation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools" : {
      "get" : {
        "summary" : "List all DAOS pools.",
        "operationId" : "DaosPoolResource_getDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPoolDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return paginated DAOS pool details including rebuild and usage statistics.",
          "usage" : [ "Render the DAOS pools overview with live capacity and rebuild status information.", "Fetch before executing maintenance that depends on pool health (draining ranks, container operations)." ],
          "response_shape" : "PaginationResponse<DaosPoolDetails>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Expensive pool detail aggregation"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 20,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/simple", "/daos/{daosId}/pools/{pool}" ],
          "postprocessing_hint" : "Call daosPoolCache.scheduleUpdates already returns warm data; avoid re-querying DAOS individually unless a field changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS pool.",
        "operationId" : "DaosPoolResource_createDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosPoolRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new DAOS pool with the requested capacity, ranks, and properties.",
          "usage" : [ "Create pools during initial DAOS onboarding workflows.", "Allocate separate pools for workload isolation or QoS changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "nranks",
            "in" : "body",
            "description" : "Nranks parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "properties",
            "in" : "body",
            "description" : "Properties parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "ranks",
            "in" : "body",
            "description" : "Ranks parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "scmPerc",
            "in" : "body",
            "description" : "ScmPerc parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Pool creation is an administrative action"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/simple" : {
      "get" : {
        "summary" : "List all DAOS pools without any query information.",
        "operationId" : "DaosPoolResource_getSimpleDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosPoolResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve lightweight identifiers for every DAOS pool in the cluster cache.",
          "usage" : [ "Populate selection widgets before drilling into detailed pool metrics.", "Fetch once when composing DAOS ACL or container workflows that only need name/UUID pairs." ],
          "response_shape" : "array<DaosPoolResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Read-only pool listings"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}" ],
          "postprocessing_hint" : "Sort pools alphabetically client-side; the cache preserves the natural DAOS order.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}" : {
      "get" : {
        "summary" : "Get detailed info on a single pool.",
        "operationId" : "DaosPoolResource_getDaosPoolInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosPoolDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect a specific DAOS pool including rebuild progress, tier stats, and leader information.",
          "usage" : [ "Drill into a pool after selecting it from the overview to display health diagnostics.", "Validate pool presence and status before submitting ACL or container changes that reference it." ],
          "response_shape" : "DaosPoolDetails",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Targeted pool inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/reintegrate", "/daos/{daosId}/pools/{pool}/props" ],
          "postprocessing_hint" : "Surface rebuild.state/status prominently; stale data can be detected via the status timestamp fields.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS pool.",
        "operationId" : "DaosPoolResource_deleteDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a DAOS pool from the specified cluster and remove cached metadata.",
          "usage" : [ "Clean up pools that are no longer required before reclaiming storage.", "Recreate pools with different properties after explicitly removing the old instance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID to delete.",
            "required" : true,
            "example" : "8601f8c6-..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "DAOS pool deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/reintegrate" ],
          "postprocessing_hint" : "Trigger a DAOS pool cache refresh to update UI listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl" : {
      "post" : {
        "summary" : "Update or add a pool ACL entry.",
        "operationId" : "DaosPoolResource_updatePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update a single principal entry within the DAOS pool ACL.",
          "usage" : [ "Grant a user access without rebuilding the entire ACL file.", "Tighten permissions iteratively while monitoring audit results." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "ACL updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the pool ACL.",
        "operationId" : "DaosPoolResource_overwritePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire DAOS pool ACL with a new definition.",
          "usage" : [ "Restore ACLs from a backup file.", "Bulk apply a curated ACL template across multiple pools." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "aclFile",
            "in" : "body",
            "description" : "AclFile parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "entries",
            "in" : "body",
            "description" : "Entries parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ownerGroup",
            "in" : "body",
            "description" : "OwnerGroup parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ownerUser",
            "in" : "body",
            "description" : "OwnerUser parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "ACL overwrite"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the DAOS pool ACL in structured and raw form.",
          "usage" : [ "Display current permissions before proposing edits.", "Export ACLs for backup or replication to other clusters." ],
          "response_shape" : "DaosAclResponse",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl-structured", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a pool ACL entry.",
        "operationId" : "DaosPoolResource_deletePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific principal from the DAOS pool ACL.",
          "usage" : [ "Call while revoking access for a user or group that no longer needs pool permissions.", "Use as part of cleanup workflows when rotating credentials." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "isGroup",
            "in" : "body",
            "description" : "IsGroup parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "principal",
            "in" : "body",
            "description" : "Principal parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "ACL removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "postprocessing_hint" : "Inform operators if the returned ACL still lists the principal, indicating DAOS refused the removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl-structured" : {
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the pool ACL entries parsed into structured principals and permissions only.",
          "usage" : [ "Use when editing specific principals without needing raw ACL strings.", "Fetch for validation routines that expect parsed grant semantics." ],
          "response_shape" : "array<DaosAclEntry>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL parsing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "postprocessing_hint" : "Map entries by principal for quick lookup when rendering editors.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/aclFile" : {
      "get" : {
        "summary" : "Get pool ACL file.",
        "operationId" : "DaosPoolResource_getPoolACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the raw DAOS ACL file for the pool.",
          "usage" : [ "Backup ACLs before performing bulk modifications.", "Feed into automation that expects DAOS native ACL format." ],
          "response_shape" : "string",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL export"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "postprocessing_hint" : "Store original ACL files securely to enable rollback if an overwrite fails.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers" : {
      "get" : {
        "summary" : "List all DAOS containers with details in a pool.",
        "operationId" : "DaosContainerResource_getDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return paginated DAOS container details for a pool, including type and health metadata.",
          "usage" : [ "Render the containers table while monitoring pool utilisation.", "Refresh after provisioning or deleting containers to keep UI state in sync." ],
          "response_shape" : "PaginationResponse<DaosContainerDetails>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Container detail listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 20,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/list", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS container.",
        "operationId" : "DaosContainerResource_createDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS container creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosContainerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a DAOS container inside the selected pool with optional class and property overrides.",
          "usage" : [ "Create containers during onboarding or workload separation workflows.", "Automate provisioning for application namespaces with tailored properties." ],
          "response_shape" : "DaosContainerDetails",
          "workflow_guidance" : {
            "pre_check" : "Ensure the pool has sufficient capacity and that the requested label is unique.",
            "post_action" : "Update UI caches and present the new container's ACL for review."
          },
          "request_parameters" : [ {
            "name" : "chunkSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "directoryObjectClass",
            "in" : "body",
            "description" : "DirectoryObjectClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "fileObjectClass",
            "in" : "body",
            "description" : "FileObjectClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "objectClass",
            "in" : "body",
            "description" : "ObjectClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "properties",
            "in" : "body",
            "description" : "Properties parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Type parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Container creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/list" : {
      "get" : {
        "summary" : "List all DAOS containers in a pool.",
        "operationId" : "DaosContainerResource_listDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerListResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a lightweight list of DAOS container UUID + labels for selection workflows.",
          "usage" : [ "Populate dropdowns before choosing a container for ACL or property updates.", "Use prior to bulk operations to confirm inventory size." ],
          "response_shape" : "PaginationResponse<DaosContainerListResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container quick list"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 45,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}" : {
      "get" : {
        "summary" : "Get detailed info on a single container.",
        "operationId" : "DaosContainerResource_getDaosContainerInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect a single DAOS container with its metrics, type, and redundancy settings.",
          "usage" : [ "Open the details view after selecting a container from the list.", "Validate container existence before editing ACLs or properties programmatically." ],
          "response_shape" : "DaosContainerDetails",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Container inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}/props" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS container.",
        "operationId" : "DaosContainerResource_deleteDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Force delete the container.",
          "name" : "force",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Destroy a DAOS container and invalidate related caches.",
          "usage" : [ "Remove retired datasets prior to freeing pool capacity.", "Force-delete containers that failed provisioning after confirming the data is no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Warn users if the container holds active data; consider exporting ACLs first.",
            "post_action" : "Refresh container and pool lists to confirm the removal."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Container deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Container deletion permanently erases stored data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl" : {
      "post" : {
        "summary" : "Update or add a container ACL entry.",
        "operationId" : "DaosContainerResource_updateContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update a single ACL principal on the container.",
          "usage" : [ "Grant a user access during onboarding workflows.", "Iteratively adjust permissions while monitoring audit events." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ACL updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the container ACL.",
        "operationId" : "DaosContainerResource_overwriteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire container ACL and optionally adjust owner fields.",
          "usage" : [ "Restore ACLs from backup exports.", "Apply a predefined template across multiple containers." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "aclFile",
            "in" : "body",
            "description" : "AclFile parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "entries",
            "in" : "body",
            "description" : "Entries parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ownerGroup",
            "in" : "body",
            "description" : "OwnerGroup parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ownerUser",
            "in" : "body",
            "description" : "OwnerUser parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 600,
            "note" : "Container ACL overwrite"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile", "/daos/{daosId}/pools/{pool}/containers/{container}/acl" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the DAOS container ACL including owner information.",
          "usage" : [ "Inspect permissions before editing or auditing access.", "Export ACLs to apply them to sibling containers." ],
          "response_shape" : "DaosAclResponse",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container ACL inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured", "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a container ACL entry.",
        "operationId" : "DaosContainerResource_deleteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific principal from the container ACL.",
          "usage" : [ "Revoke access after a user or group offboarding.", "Tighten permissions as part of security audits." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "isGroup",
            "in" : "body",
            "description" : "IsGroup parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "principal",
            "in" : "body",
            "description" : "Principal parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ACL removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "postprocessing_hint" : "Confirm the returned ACL no longer lists the principal; otherwise inform the operator.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" : {
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the container ACL parsed into structured DAOS ACL entries only.",
          "usage" : [ "Drive UI editors that need per-principal permission flags.", "Validate expected principals programmatically without parsing raw strings." ],
          "response_shape" : "array<DaosAclEntry>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container ACL parsing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" ],
          "postprocessing_hint" : "Index entries by principal for quick comparison with desired policy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" : {
      "get" : {
        "summary" : "Get container ACL file.",
        "operationId" : "DaosContainerResource_getContainerACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the raw DAOS ACL file for the container.",
          "usage" : [ "Backup ACLs before bulk modifications or migrations.", "Provide to external tooling that expects the DAOS-native ACL format." ],
          "response_shape" : "string",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL export"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "postprocessing_hint" : "Store exports with metadata identifying pool/container to ease restores.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/owner" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerOwner",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS container owner request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosContainerOwnerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the owner of the DAOS container to a user or group.",
          "usage" : [ "Reassign ownership after team transitions.", "Align DAOS permissions with identity management automation." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "isGroup",
            "in" : "body",
            "description" : "IsGroup parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "owner",
            "in" : "body",
            "description" : "Owner parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ownership changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/props" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a DAOS container property value and refresh caches.",
          "usage" : [ "Adjust container behaviour parameters (e.g., redundancy, checksum).", "Automate configuration changes during deployment pipelines." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "Value parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container property changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/props", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container properties.",
        "operationId" : "DaosContainerResource_getContainerProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all DAOS container properties and their values.",
          "usage" : [ "Display configuration before editing properties.", "Audit properties across containers for compliance." ],
          "response_shape" : "PaginationResponse<DaosPropertyResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "container parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Property inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}", "/daos/{daosId}/pools/{pool}/containers/{container}/props" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/props" : {
      "put" : {
        "summary" : "Set a pool property.",
        "operationId" : "DaosPoolResource_setPoolProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a single DAOS pool property value.",
          "usage" : [ "Tune pool behaviour (e.g., redundancy) as part of maintenance.", "Automate property changes during rollout scripts." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "Value parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Property changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/props", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool properties.",
        "operationId" : "DaosPoolResource_getPoolProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the list of DAOS pool properties and their current values.",
          "usage" : [ "Display pool configuration before applying property changes.", "Audit property states across pools during compliance checks." ],
          "response_shape" : "PaginationResponse<DaosPropertyResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Property inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}", "/daos/{daosId}/pools/{pool}/props" ],
          "postprocessing_hint" : "Normalize values (especially JSON nodes) before diffing between clusters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/reintegrate" : {
      "post" : {
        "summary" : "Reintegrate a DAOS rank, or all ranks available, for a pool.",
        "operationId" : "DaosPoolResource_reintegrateDaosRank",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Rank reintegrate request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RankReintegrateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off a ManagedThreadTask that reintegrates one or all DAOS ranks for the pool.",
          "usage" : [ "Run after failed engines return to service so the pool can rebalance data.", "Trigger from automated remediation when pool rebuild states remain degraded." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Resolve outstanding rebuild errors and determine whether a specific rank requires reintegration.",
            "post_action" : "Follow the returned task until completion; refresh pool details afterwards to confirm healthy state."
          },
          "request_parameters" : [ {
            "name" : "rank",
            "in" : "body",
            "description" : "Rank parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Rank reintegration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}", "/tasks/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers" : {
      "post" : {
        "summary" : "Add a server as client to DAOS.",
        "operationId" : "DaosClusterResource_addDaosServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server configuration for DAOS client",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosClientCreationServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enroll an existing croit server as a DAOS client node and restart the local DAOS services.",
          "usage" : [ "Expand the DAOS cluster with new client nodes after hardware rollout.", "Re-add a server after reinstalling the OS while preserving DAOS configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Confirm the server is not already part of another DAOS cluster and that NUMA/port information is available.",
            "post_action" : "Monitor the returned task; once complete, verify membership via GET /daos/{daosId}/members."
          },
          "request_parameters" : [ {
            "name" : "id",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nics",
            "in" : "body",
            "description" : "Nics parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "Port parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "provider",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "targets",
            "in" : "body",
            "description" : "Targets parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "threads",
            "in" : "body",
            "description" : "Threads parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "DAOS server enrollment"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/members", "/daos/{daosId}/servers/{serverId}/reconfigure" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from a DAOS cluster.",
        "operationId" : "DaosClusterResource_removeServerFromDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach a DAOS client node from the cluster and remove its configuration.",
          "usage" : [ "Retire client nodes prior to decommissioning hardware.", "Temporarily remove a host before reimaging or repurposing it." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify the server operates as a DAOS client; server nodes cannot be removed via this endpoint.",
            "post_action" : "Track the ManagedThreadTask and unregister the host from dependent tooling if needed."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID to remove.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "DAOS server removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/servers", "/daos/{daosId}/servers/{serverId}/reconfigure" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing the server disconnects it from DAOS and may interrupt workloads using that client."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure and restart DAOS on the server.",
        "operationId" : "DaosClusterResource_restartDaosOnServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart DAOS services on a specific server using the current cluster configuration.",
          "usage" : [ "Apply configuration changes after editing engine settings.", "Recover a node that drifted from the desired DAOS configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Ensure the server still belongs to the cluster and is reachable.",
            "post_action" : "Follow the ManagedThreadTask progress; if successful, confirm the node reports healthy via GET /daos/{daosId}/members."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID to restart.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "DAOS server reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/members", "/daos/{daosId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "DaosClusterResource_testSshConnectionDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Test SSH connectivity to all servers in a DAOS cluster to verify remote access and network reachability.",
          "usage" : [ "Call to verify SSH access before performing cluster operations or troubleshooting connectivity issues.", "Use for network diagnostics when DAOS services report communication problems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; SSH keys configured; Network connectivity available",
            "post_action" : "SSH connectivity verified; Remote access confirmed; Network path validated"
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID to test SSH connectivity for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "SSH connectivity testing"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Test runs 5 iterations with specified sleep interval; successful completion indicates SSH access is working for cluster operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/start-ranks" : {
      "post" : {
        "summary" : "Start a list of ranks.",
        "operationId" : "DaosClusterResource_startDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to start",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start specified DAOS engine ranks in a cluster to bring storage services online.",
          "usage" : [ "Call to start stopped DAOS ranks after maintenance or troubleshooting.", "Use to bring storage capacity back online by starting specific engine ranks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Specified ranks are stopped; No conflicting operations",
            "post_action" : "Target ranks started; Storage capacity available; Cluster rebalancing may occur"
          },
          "request_parameters" : [ {
            "name" : "ranks",
            "in" : "body",
            "description" : "Ranks parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the ranks to start.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS rank management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/stop-ranks", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Starting ranks brings storage capacity online; cluster may rebalance data automatically; monitor rank status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/stop-ranks" : {
      "post" : {
        "summary" : "Stop a list of ranks.",
        "operationId" : "DaosClusterResource_stopDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to stop",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop specified DAOS engine ranks in a cluster to take storage services offline for maintenance.",
          "usage" : [ "Call to stop DAOS ranks for maintenance, troubleshooting, or graceful shutdown.", "Use before server maintenance to safely take storage capacity offline." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Specified ranks are running; No critical operations in progress",
            "post_action" : "Target ranks stopped; Storage capacity offline; Data access may be affected"
          },
          "request_parameters" : [ {
            "name" : "ranks",
            "in" : "body",
            "description" : "Ranks parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "daosId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the ranks to stop.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS rank management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/start-ranks", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Stopping ranks removes storage capacity; ensure redundancy before stopping; data may become inaccessible if insufficient replicas.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Stopping DAOS ranks will take storage capacity offline and may affect data availability"
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks" : {
      "get" : {
        "summary" : "List of all disks across all servers.",
        "operationId" : "DiskResource_getAllDisks",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all disks including their OSD assignments - shows which disks are used as OSDs with detailed hardware metadata.",
          "usage" : [ "List all disks including their OSD assignments.", "Find which disks are used as OSDs.", "Build storage inventory dashboards before drilling into per-server views", "Refresh after provisioning or wiping disks to confirm state changes" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "common_parameters" : {
            "pagination.limit" : "Restrict large clusters to manageable chunks.",
            "pagination.where" : "Filter by role='osd' to get OSD disks, or by health/hostname before exporting."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Fleet-wide disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/servers/{id}/disks", "/disks/paths" ],
          "postprocessing_hint" : "Filter OSDs by role='osd' field. Check osdId for OSD number, deviceClass for type. Highlight disks with missing stats and merge in SMART data where available. Use /crush for complete OSD topology with CRUSH hierarchy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/create-osds" : {
      "post" : {
        "summary" : "Create multiple OSDs",
        "operationId" : "DiskResource_createMultipleOsds",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "description" : "OSD creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ManagedTask"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision one or more OSD daemons on the specified servers and disks.",
          "usage" : [ "Call after planning OSD placement; chunk large batches per server to keep tasks manageable.", "Monitor each returned ManagedTask to verify disk wiping, ceph-volume, and CRUSH integration steps." ],
          "response_shape" : "array<ManagedTask>",
          "request_parameters" : [ {
            "name" : "osds",
            "in" : "body",
            "description" : "Osds parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Resource-intensive provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/replace-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Display one task per server; surface WARN logs for disks requiring manual cleanup.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating OSDs wipes disks and alters CRUSH topology."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/install-croit" : {
      "post" : {
        "summary" : "Install croit to disks.",
        "operationId" : "DiskResource_installCroitToDisk",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "description" : "Disk installation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/InstallCroitRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Install the croit management image onto selected boot disks across one or more servers.",
          "usage" : [ "Deploy croit onto fresh hardware before adding the servers to the cluster.", "Reinstall the management stack after wiping or replacing boot drives." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "Disks parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Boot disk installation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/wipe", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "After the task succeeds, reboot the servers from the freshly installed disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/paths" : {
      "get" : {
        "summary" : "List of all known multipath disk paths across all servers.",
        "operationId" : "DiskResource_getAllDiskPaths",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDiskPathResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect multipath device paths and their states across all servers.",
          "usage" : [ "Check path health when diagnosing disk or fabric issues", "Filter by inactive paths before dispatching remediation tasks" ],
          "response_shape" : "PaginationResponse<DiskPathResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipath inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/disks", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Group entries by diskId and surface inactive paths prominently.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/replace-osds" : {
      "post" : {
        "summary" : "Replace failed OSDs with new hardware without cluster rebalancing. This endpoint destroys offline OSDs and recreates them on new unassigned disks using the same OSD IDs. By preserving the original CRUSH map positions, no data migration occurs during the replacement process. Use this when disk hardware has failed but the server remains operational and replacement disks are available. The operation is particularly useful for maintaining cluster performance during hardware maintenance.",
        "operationId" : "DiskResource_replaceOsds",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReplaceOsdsRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace failed OSDs by destroying old instances and creating new ones on different disks with the same OSD ID, preserving CRUSH map positions to avoid rebalancing.",
          "usage" : [ "Replace OSDs when disk hardware has failed and new unassigned disks are available on the same server.", "Offline/failed OSDs are destroyed and recreated on new hardware with identical OSD IDs.", "Use resizeOsd=true to reweight the OSD after moving it to a larger disk.", "Preserves cluster topology - no data migration or rebalancing occurs since CRUSH map positions remain unchanged." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "osds",
            "in" : "body",
            "description" : "Osds parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Disk replacement workload"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/create-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Review warnings emitted in the ManagedTask to address multi-disk or journal ambiguities.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Destroys existing OSDs and overwrites target disks with new OSD instances, preserving cluster topology."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/wipe" : {
      "delete" : {
        "summary" : "Securely wipe disks",
        "description" : "\n\t\t\tSecurely wipes one or more disks by completely erasing their contents, optionally destroying\n\t\t\tassociated OSDs in the Ceph cluster map. This operation permanently destroys all data on the\n\t\t\tselected disks and cannot be undone.\n\n\t\t\t**Critical**: This operation permanently destroys all data on the specified disks.\n\t\t\tEnsure you have backups and that data is properly replicated before proceeding.\n\n\t\t\t**Workflow for OSD disks**:\n\t\t\t1. Use this endpoint with `destroy=true` to remove OSDs and wipe disks in one operation\n\t\t\t2. Optionally recreate OSDs with `POST /disks/create-osds`\n\n\t\t\t**Use this endpoint for**:\n\t\t\t- Preparing disks for reuse after OSD removal\n\t\t\t- Securely erasing disks before decommissioning hardware\n\t\t\t- Cleaning drives prior to repurposing\n\t\t\t- Destroying data for security compliance\n\n\t\t\t**Safety features**:\n\t\t\t- Requires serial number confirmation to prevent accidental wipes\n\t\t\t- Validates disk ownership and prevents wiping boot media\n\t\t\t- Checks for DAOS usage and active services\n\t\t\t- Returns detailed task logs for monitoring progress\n\n\t\t\t**Prerequisites**: For OSD disks, ensure OSDs are properly removed from cluster first.\n\t\t",
        "operationId" : "DiskResource_wipeDisksRequest",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskDeleteRequestWrapper"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Securely wipe one or more disks, optionally destroying associated OSDs in the cluster map.",
          "usage" : [ "Prepare disks for reuse after removing OSDs or other data.", "Clean drives prior to decommissioning hardware from the cluster." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "For OSD disks: Set destroy=true to remove OSD from cluster during wipe operation",
            "post_action" : "OSDs destroyed (if destroy=true); Disks wiped; Available for reuse or recreation"
          },
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "Disks parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 3600,
            "note" : "Disk wiping"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/create-osds", "/tasks" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion and run hardware detection to confirm disks are blank.",
          "idempotent" : true,
          "requires_confirmation" : false,
          "workflow_dependencies" : {
            "prerequisite" : "For OSD disks: Set destroy=true to remove OSD and wipe disk in single operation",
            "order" : "1. Wipe disk with destroy=true → 2. Recreate OSD if needed"
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}" : {
      "delete" : {
        "summary" : "Remove disk from inventory",
        "description" : "\n\t\t\tRemoves a disk entry from the croit inventory database without performing any cluster operations.\n\t\t\tThis is a lightweight inventory cleanup operation that only affects the database record.\n\n\t\t\t**Important**: This endpoint does NOT interact with Ceph or perform OSD operations.\n\t\t\tIt only removes the disk entry from croit's inventory database.\n\n\t\t\t**Use this endpoint when**:\n\t\t\t- Cleaning up stale inventory entries after hardware removal\n\t\t\t- Removing disk records after physical decommission\n\t\t\t- Correcting inventory after disk replacement\n\t\t\t- Database housekeeping tasks\n\n\t\t\t**Do NOT use this endpoint for**:\n\t\t\t- Removing active OSDs (use `DELETE /disks/wipe` with destroy=true instead)\n\t\t\t- Any operation requiring cluster coordination\n\t\t\t- Live disk operations on running systems\n\n\t\t\t**Prerequisites**: Ensure the disk is not in active use by Ceph OSDs or DAOS before removal.\n\t\t\tFor OSD disks, use DELETE /disks/wipe with destroy=true to properly handle OSD lifecycle.\n\t\t",
        "operationId" : "DiskResource_deleteDiskWithoutServerId",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk entry from the inventory, typically after permanent removal or decommissioning.",
          "usage" : [ "Call after detaching hardware or replacing a disk so it no longer appears in inventory.", "Use only when the disk is not referenced by DAOS or active OSDs." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Identifier of the disk from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Inventory cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks", "/disks/create-osds", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Refresh GET /disks or /servers/{id}/disks to confirm the entry is gone.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}/benchmark/basic" : {
      "post" : {
        "summary" : "Benchmark disk performance",
        "operationId" : "DiskResource_benchmarkDisk",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a basic synchronous write benchmark on an unassigned disk to measure worst-case journal throughput.",
          "usage" : [ "Evaluate new disks before assigning them to critical roles (journals/DB).", "Collect performance metrics for hardware surveys or troubleshooting." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Disk benchmarking"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks", "/servers/{id}/disks", "/disks/install-croit" ],
          "postprocessing_hint" : "Capture the ManagedTask output for archival or hardware survey submissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/download/{token}/{fileName}" : {
      "get" : {
        "summary" : "Download file by token",
        "operationId" : "DownloadResource_download",
        "parameters" : [ {
          "name" : "fileName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "token",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download files using temporary access tokens provided by other API endpoints.",
          "usage" : [ "Called automatically by browser or download tools using URLs from file generation endpoints.", "Use token-based URLs returned from certificate downloads, backups, exports, and file generation operations." ],
          "response_shape" : "Binary file stream",
          "path_parameters" : [ {
            "name" : "token",
            "in" : "path",
            "description" : "token parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "fileName",
            "in" : "path",
            "description" : "fileName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "token",
            "in" : "path",
            "description" : "Temporary access token UUID provided by file generation endpoints.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          }, {
            "name" : "fileName",
            "in" : "path",
            "description" : "Original filename for the download (must match token registration).",
            "required" : true,
            "example" : "backup-cluster-20241201.tar.gz"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "regenerate_token",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "File downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs/{certId}/crtFile", "/s3/backups", "/maintenance/export" ],
          "postprocessing_hint" : "Files auto-expire (15min-1hr); download immediately after receiving URL; supports both static files and dynamic streams.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/events/hook-scripts" : {
      "get" : {
        "summary" : "List all script files with their linked hooks.",
        "operationId" : "EventResource_getScriptsWithHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseScriptInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all hook scripts with their event hook associations for comprehensive automation management.",
          "usage" : [ "Call to view scripts and their linked event triggers in one unified view.", "Use to audit and manage event-driven automation configurations." ],
          "response_shape" : "PaginationResponse<ScriptInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Hook script listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts/{id}", "/events/hooks" ],
          "postprocessing_hint" : "Response includes script content, names, and associated hook events; use for managing automation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file and link hooks.",
        "operationId" : "EventResource_createScriptAndLinkHooks",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new hook script file and automatically link it to specified event hooks for automation.",
          "usage" : [ "Call when creating new automation scripts that should run on specific system events.", "Use to set up event-driven automation with script and hook configuration in one operation." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Script name is unique; Hook configurations are valid; Admin privileges confirmed",
            "post_action" : "Script created; Hooks linked; Script cache updated; Automation active on specified events"
          },
          "request_parameters" : [ {
            "name" : "contents",
            "in" : "body",
            "description" : "Contents parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "hooks",
            "in" : "body",
            "description" : "Hooks parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Script and hook creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script is immediately available for execution; hooks will trigger script on configured events; test automation carefully.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hook-scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file and linked hooks.",
        "operationId" : "EventResource_replaceScriptAndHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a script file and automatically synchronize changes to all linked event hooks.",
          "usage" : [ "Call when modifying script logic or renaming scripts used by multiple hooks.", "Use to maintain script content and hook associations in a single operation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Name is unique if changing; Valid script syntax; Hook points exist",
            "post_action" : "Script updated; Content deployed to servers; Hook associations updated; Changes effective immediately"
          },
          "request_parameters" : [ {
            "name" : "contents",
            "in" : "body",
            "description" : "Contents parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "hooks",
            "in" : "body",
            "description" : "Hooks parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to update from hook script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script content updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script changes propagate to all linked hooks; test script execution after updates; verify hook triggering works correctly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks" : {
      "get" : {
        "summary" : "List of all installed hook scripts.",
        "deprecated" : true,
        "operationId" : "EventResource_getHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHookInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured hook event associations for automation monitoring and management.",
          "usage" : [ "Call to view all active event-script associations in the system.", "Use to audit which scripts run on which system events." ],
          "response_shape" : "OptionalPaginationResponse<HookInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Hook listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks/{id}" ],
          "postprocessing_hint" : "Response shows script-event associations; deprecated in favor of /hook-scripts endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_createHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Link an existing script to a system event hook point for automated execution.",
          "usage" : [ "Call to configure script execution on specific system events.", "Use to create event-driven automation with existing scripts." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Event name is valid; Server targeting is configured; No duplicate hooks",
            "post_action" : "Hook created; Script will execute on specified events; Hook cache updated"
          },
          "request_parameters" : [ {
            "name" : "allServers",
            "in" : "body",
            "description" : "AllServers parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "event",
            "in" : "body",
            "description" : "Event parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "scriptId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverIds",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Hook creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks/hook-points" ],
          "postprocessing_hint" : "Hook is immediately active; deprecated in favor of /hook-scripts endpoint for combined operations.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks/hook-points" : {
      "get" : {
        "summary" : "List of all available hook points.",
        "operationId" : "EventResource_getHookPoints",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/HookPointInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover all available system event hook points where scripts can be executed automatically.",
          "usage" : [ "Call to view all event types where scripts can be triggered for automation.", "Use to understand hook point parameters and server targeting options." ],
          "response_shape" : "List<HookPointInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Hook point discovery"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/events/hooks", "/events/hook-scripts" ],
          "postprocessing_hint" : "Use event names from response for hook creation; canChooseServer indicates if server targeting is available; parameters show script inputs.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/events/hooks/{id}" : {
      "patch" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_updateHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing hook configuration to change script, event, or server targeting.",
          "usage" : [ "Call to modify hook event associations or server targeting.", "Use to update automation configuration without recreating hooks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Hook exists; New configuration is valid; Server IDs exist if specified",
            "post_action" : "Hook updated; Changes effective immediately; Hook cache updated"
          },
          "request_parameters" : [ {
            "name" : "allServers",
            "in" : "body",
            "description" : "AllServers parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "event",
            "in" : "body",
            "description" : "Event parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "scriptId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "serverIds",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Hook ID to update from hook listings.",
            "required" : true,
            "example" : "456"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Hook update operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hooks", "/events/hook-scripts/{id}" ],
          "postprocessing_hint" : "Hook changes are immediate; deprecated in favor of /hook-scripts/{id} endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a hook event.",
        "deprecated" : true,
        "operationId" : "EventResource_deleteHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a hook event configuration to stop script execution at specific system events.",
          "usage" : [ "Call when removing automation that should no longer run on system events.", "Use for cleanup when event-driven scripts are no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Hook event exists; Admin understands impact on automation",
            "post_action" : "Hook deleted; Hook cache updated; Script will no longer run on specified events"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Hook event ID to delete from the hook configuration.",
            "required" : true,
            "example" : "456"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Hook management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hooks", "/events/scripts" ],
          "postprocessing_hint" : "Hook removal is immediate; scripts stop executing on events; hook cache updates automatically.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting hooks will stop automated script execution on system events"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts" : {
      "get" : {
        "summary" : "List all script files.",
        "deprecated" : true,
        "operationId" : "EventResource_getScripts",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseScriptIdentifier"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available hook script files for management and selection.",
          "usage" : [ "Call to view all stored scripts before selecting one for hook configuration.", "Use to browse available automation scripts in the system." ],
          "response_shape" : "OptionalPaginationResponse<ScriptIdentifier>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Script listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Use script IDs from response for hook creation or script content retrieval; deprecated in favor of /hook-scripts.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_createScript",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new script file for later use in hook configurations.",
          "usage" : [ "Call to store new automation scripts for later hook assignment.", "Use when separating script creation from hook configuration." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Script name is unique; Admin privileges confirmed",
            "post_action" : "Script created; Script cache updated; Script available for hook configuration"
          },
          "request_parameters" : [ {
            "name" : "contents",
            "in" : "body",
            "description" : "Contents parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks" ],
          "postprocessing_hint" : "Use returned script ID for hook creation; deprecated in favor of /hook-scripts endpoint.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/execute" : {
      "post" : {
        "summary" : "Run a script immediately.",
        "operationId" : "EventResource_runHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script execution configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RunScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a script immediately on specified servers for testing, troubleshooting, or manual operations.",
          "usage" : [ "Call to run stored scripts on demand for testing or manual maintenance tasks.", "Use to execute custom scripts with parameters on selected cluster nodes." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Script exists or content provided; Servers accessible; SSH connections available",
            "post_action" : "Script executed on target servers; Output captured in task logs; Temporary files cleaned up"
          },
          "request_parameters" : [ {
            "name" : "args",
            "in" : "body",
            "description" : "Args parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "script",
            "in" : "body",
            "description" : "Script parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "scriptId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 600,
            "note" : "Script execution operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Monitor task progress for execution status; script output appears in task logs; connection failures are logged per server.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Script execution will run arbitrary code on cluster servers and may affect system state"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_replaceScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update script content or rename script files used in hook configurations.",
          "usage" : [ "Call to modify existing script logic or change script names.", "Use when updating automation scripts without changing hook associations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; New name is unique if changing; Valid script syntax",
            "post_action" : "Script updated; Changes effective in existing hooks; Script cache updated"
          },
          "request_parameters" : [ {
            "name" : "contents",
            "in" : "body",
            "description" : "Contents parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to update from script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Script modification operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hook-scripts/{id}" ],
          "postprocessing_hint" : "Script changes affect all linked hooks; deprecated in favor of /hook-scripts/{id} endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the script file contents.",
        "operationId" : "EventResource_getScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the raw script content for editing, review, or debugging purposes.",
          "usage" : [ "Call to view script code before making modifications.", "Use to review script logic or debug hook automation issues." ],
          "response_shape" : "String (script content)",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID from script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Script content retrieval"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Returns raw script content as plain text; use for editing or review purposes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a script file.",
        "operationId" : "EventResource_deleteScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a hook script file and update the script cache to remove it from available scripts.",
          "usage" : [ "Call when removing unused or outdated hook scripts from the system.", "Use for cleanup when scripts are no longer needed or have been replaced." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Not currently linked to active hooks (or hooks will be orphaned)",
            "post_action" : "Script file deleted; Script cache updated; Script no longer available for hook creation"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to delete from the script database.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script deletion updates cache immediately; existing hooks using this script may become invalid.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting scripts may break existing hooks that depend on this script"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/extra-files-secure/{path}" : {
      "get" : {
        "summary" : "Authenticated static file server for files stored in /config/extra-files-secure, requires a croit account with the SECURE_FOLDER role.",
        "operationId" : "ExtraFileSecureResource_downloadSecureExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/extra-files/{path}" : {
      "get" : {
        "summary" : "Publicly accessible static file server for files stored in /config/extra-files.",
        "operationId" : "ExtraFileResource_downloadExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/gateways/iscsi" : {
      "get" : {
        "summary" : "List all iSCSI gateways.",
        "operationId" : "IscsiGatewayResource_getIscsiGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured iSCSI gateway clusters and descriptive metadata.",
          "usage" : [ "Call when rendering the iSCSI gateway overview page.", "Refresh after edits to confirm descriptions and service IDs." ],
          "response_shape" : "PaginationResponse<IscsiGatewayConfigResponse>",
          "common_parameters" : {
            "pagination.order.description" : "Sort stable lists of gateways for operators."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/servers", "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Render serviceId prominently so follow-up calls can reference it.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/disks" : {
      "get" : {
        "summary" : "List all iSCSI disks.",
        "operationId" : "IscsiGatewayResource_getIscsiDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayDisksResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the list of iSCSI-exposed RBD LUNs with group/host usage details.",
          "usage" : [ "Call when showing which RBD images are exported over iSCSI.", "Refresh after mapping or unmapping LUNs to confirm group/host assignments." ],
          "response_shape" : "PaginationResponse<IscsiGatewayDisksResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Highlight disks with empty groups to spot unused exports quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/groups" : {
      "get" : {
        "summary" : "List all iSCSI groups.",
        "operationId" : "IscsiGatewayResource_getIscsiGroups",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayGroupsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve iSCSI initiator groups with their members and mapped LUNs.",
          "usage" : [ "Load before editing group memberships or presenting access summaries.", "Refresh after changes to the iSCSI gateway config to confirm group composition." ],
          "response_shape" : "PaginationResponse<IscsiGatewayGroupsResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI config snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/hosts", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Group response entries by serviceId and surface luns list so UI can expand per group.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/hosts" : {
      "get" : {
        "summary" : "List all iSCSI hosts.",
        "operationId" : "IscsiGatewayResource_getIscsiHosts",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayHostsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate iSCSI hosts, their credentials, group membership, and attached LUNs.",
          "usage" : [ "Fetch when displaying host access configuration or auditing CHAP credentials.", "Refresh after modifying hosts/groups to verify the resulting mappings." ],
          "response_shape" : "PaginationResponse<IscsiGatewayHostsResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI host snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Mask passwords when presenting to users lacking admin privileges; rely on username and luns for detail.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/servers" : {
      "get" : {
        "summary" : "List all iSCSI servers.",
        "operationId" : "IscsiGatewayResource_getIscsiServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Show iSCSI target services mapped to servers including health state and addresses.",
          "usage" : [ "Fetch when presenting the iSCSI server list so operators can verify IP and health.", "Re-query after modifying gateway services or Ceph config to validate deployment." ],
          "response_shape" : "PaginationResponse<IscsiGatewayServerResponse>",
          "common_parameters" : {
            "pagination.where.healthy" : "Filter down to unhealthy targets for remediation.",
            "pagination.order.hostname" : "Keep server ordering predictable across refreshes."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "iSCSI server status polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi", "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Cross-reference config.gateways from Ceph to highlight servers known to Ceph but missing in croit.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs" : {
      "get" : {
        "summary" : "List all nfs clusters.",
        "operationId" : "NfsGatewayResource_getNfsGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate configured NFS gateway clusters and their base configuration.",
          "usage" : [ "Call to populate the NFS gateway overview before drilling into servers or exports.", "Refresh after creating or editing a gateway to verify forceSecure and transport defaults." ],
          "response_shape" : "PaginationResponse<NfsGatewayConfigResponse>",
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS before attaching hosts.",
            "pagination.order.description" : "Sort consistently for large environments."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs/servers", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Surface entries with non-empty hints first so admins notice configuration issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/exports" : {
      "get" : {
        "summary" : "List all nfs exports.",
        "operationId" : "NfsGatewayResource_getNfsExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayExportResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NFS exports, paths, and client permissions for all clusters.",
          "usage" : [ "Call before presenting export configuration so ACLs and protocols are visible.", "Refresh after creating, patching, or deleting exports to confirm the resulting state." ],
          "response_shape" : "PaginationResponse<NfsGatewayExportResponse>",
          "common_parameters" : {
            "pagination.where.serviceId" : "Limit exports to a single gateway before editing.",
            "pagination.where.path" : "Search for exports pointing at specific CephFS directories."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS export inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/servers" ],
          "postprocessing_hint" : "Group results by serviceId and display accessJoined for quick ACL review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/servers" : {
      "get" : {
        "summary" : "List all nfs servers.",
        "operationId" : "NfsGatewayResource_getNfsServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NFS gateway services per server including health information.",
          "usage" : [ "Fetch when rendering the NFS server table to expose hostnames, IPs and health.", "Re-query after restarting services or adjusting HA settings to confirm status changes." ],
          "response_shape" : "PaginationResponse<NfsGatewayServerResponse>",
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy entries for alerting.",
            "pagination.order.hostname" : "Keep server order stable across refreshes."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS server status refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Highlight servers with healthy=false or missing IPs so admins can remediate quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof" : {
      "get" : {
        "summary" : "List all NVMe-oF clusters.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFGatewayResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF gateway clusters including transport defaults and configuration hints.",
          "usage" : [ "Call before displaying the NVMe-oF overview dashboard.", "Refresh after task-based changes (e.g. add/delete gateway) to confirm state and surface hints." ],
          "response_shape" : "PaginationResponse<NvmeOFGatewayResponse>",
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS.",
            "pagination.order.name" : "Keep cluster ordering stable for operators."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF gateway inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Flag gateways with non-empty hints to prompt admins to run remediation tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new NVMe-oF gateway cluster for high-performance block storage over fabrics.",
          "usage" : [ "Call when setting up NVMe-oF block storage access for client applications.", "Use to create scalable, high-performance storage access over RDMA or TCP networks." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Servers have SPDK support; NICs accessible; Network fabric configured; Valid transport settings",
            "post_action" : "Cluster created; Default subsystem added; Target services deployed; Listeners configured on fabrics"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "forceSecure",
            "in" : "body",
            "description" : "ForceSecure parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "services",
            "in" : "body",
            "description" : "Services parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "transportDefaults",
            "in" : "body",
            "description" : "TransportDefaults parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "NVMe-oF cluster creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/{gatewayId}" ],
          "postprocessing_hint" : "Monitor task progress for cluster setup; services will be configured with SPDK; cluster ready for subsystem and namespace configuration.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating NVMe-oF cluster requires SPDK configuration and may affect server networking"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters" : {
      "post" : {
        "summary" : "Add a new NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_setNvmeOFCephCluster",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all NVMe-oF ceph cluster configurations.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFCephClusters",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFCephClusterResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured Ceph cluster connections for NVMe-oF block device access.",
          "usage" : [ "Call when setting up NVMe-oF gateways to show available Ceph clusters for block device sources.", "Use to verify cluster connectivity before creating new block device mappings." ],
          "response_shape" : "PaginationResponse<NvmeOFCephClusterResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Cluster configuration access"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/bdevs", "/gateways/nvmeof" ],
          "postprocessing_hint" : "Display cluster connectivity status; clusters are used as sources for RBD block devices in NVMe-oF subsystems.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters/{name}" : {
      "delete" : {
        "summary" : "Remove a NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFCephCluster",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks" : {
      "get" : {
        "summary" : "List all NVMe-oF disks.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF disks (Ceph RBD or DAOS) with identifiers, size, hints, and subsystem memberships.",
          "usage" : [ "Fetch before attaching disks to subsystems or auditing exported storage.", "Refresh after provisioning tasks to confirm image size lookups and DAOS metadata resolved without errors." ],
          "response_shape" : "PaginationResponse<NvmeOFDiskResponse>",
          "common_parameters" : {
            "pagination.where.type" : "Filter to CEPH or DAOS disks depending on workflow.",
            "pagination.where.subsystems" : "Identify disks already attached to specific subsystems."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Draw attention to entries with non-empty hints to highlight disks that need remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_addNvmeOFBdev",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NVMe-oF disk backed by either a Ceph RBD image or a DAOS object.",
          "usage" : [ "Expose a freshly created RBD image to NVMe-oF hosts via selected subsystems.", "Attach an existing DAOS disk to NVMe-oF after validating cluster prerequisites." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "blockSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "cluster",
            "in" : "body",
            "description" : "Cluster parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "daosContainer",
            "in" : "body",
            "description" : "DaosContainer parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "daosDisk",
            "in" : "body",
            "description" : "DaosDisk parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "daosDiskName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "daosId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "daosPool",
            "in" : "body",
            "description" : "DaosPool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "image",
            "in" : "body",
            "description" : "Image parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "oclass",
            "in" : "body",
            "description" : "Oclass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "subsystems",
            "in" : "body",
            "description" : "Subsystems parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "totalSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Type parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/disks to confirm the disk appears with the expected subsystem bindings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_updateNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an NVMe-oF disk and propagate changes to the backing storage (Ceph RBD or DAOS).",
          "usage" : [ "Expand a Ceph-backed NVMe-oF LUN after increasing the application quota.", "Grow DAOS-backed exports once additional capacity has been provisioned." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk resize"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/disks/{diskId}", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDiskRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an NVMe-oF disk from the gateway, optionally deleting the backing RBD image.",
          "usage" : [ "Retire LUNs no longer needed by clients.", "Remove test disks while optionally cleaning up Ceph data." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "DeleteData parameter",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/services/{serviceId}/transports/{type}", "/gateways/nvmeof/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts" : {
      "get" : {
        "summary" : "List all NVMe-oF hosts.",
        "operationId" : "NvmeOFHostResource_getNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFHostResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF hosts (NQNs) with shared key status, subsystem memberships, and attached disks.",
          "usage" : [ "Fetch when auditing NVMe-oF access or before attaching hosts to subsystems.", "Refresh after task-managed host changes to confirm shared key masking and assignments." ],
          "response_shape" : "PaginationResponse<NvmeOFHostResponse>",
          "common_parameters" : {
            "pagination.where.hasSharedKey" : "Identify hosts that require TLS PSK enrollment.",
            "pagination.where.subsystems" : "Filter hosts attached to specific subsystems before detaching."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF host inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Mask sharedKey unless the actor has admin privileges; rely on hasSharedKey for UX cues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_addNvmeOFHost",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a new NVMe-oF host (client) with authentication credentials for subsystem access.",
          "usage" : [ "Call when onboarding new clients that need NVMe-oF storage access.", "Use to create host entries with optional authentication for secure storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; NQN is unique; Valid shared key format; Subsystems exist and match cluster",
            "post_action" : "Host registered; Authentication configured; Access granted to specified subsystems"
          },
          "request_parameters" : [ {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nqn",
            "in" : "body",
            "description" : "Nqn parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "sharedKey",
            "in" : "body",
            "description" : "SharedKey parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "subsystems",
            "in" : "body",
            "description" : "Subsystems parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Host registration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for host registration; shared keys require secure channel configuration; host can immediately access specified subsystems.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Shared keys are experimental and require secure channels; ensure proper security configuration"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts/{hostId}" : {
      "put" : {
        "summary" : "Update an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_updateNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF host update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NVMe-oF host configuration including NQN and access credentials.",
          "usage" : [ "Call when updating host identification or authentication settings.", "Use to modify host metadata or reconfigure security credentials." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Host exists; NQN is valid if specified; Authentication data is properly formatted",
            "post_action" : "Host configuration updated; New credentials deployed; Subsystem access updated; Active connections may require reauthentication"
          },
          "request_parameters" : [ {
            "name" : "sharedKey",
            "in" : "body",
            "description" : "SharedKey parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "hostId",
            "in" : "path",
            "description" : "hostId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "hostId",
            "in" : "path",
            "description" : "Host ID to update.",
            "required" : true,
            "example" : "8"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for gateway-specific results; hosts may need to reconnect for authentication changes to take effect.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_removeNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NVMe-oF host registration and revoke all subsystem access permissions.",
          "usage" : [ "Call when decommissioning clients or revoking NVMe-oF storage access.", "Use to clean up host registrations for clients no longer needing storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Host exists; Understand connection impact; Data safety confirmed",
            "post_action" : "Host registration removed; All subsystem access revoked; Active connections terminated"
          },
          "path_parameters" : [ {
            "name" : "hostId",
            "in" : "path",
            "description" : "hostId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "hostId",
            "in" : "path",
            "description" : "Host ID to remove from host listings.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Host removal operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for host removal; client loses immediate access to all subsystems; connections terminated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing host will immediately terminate all connections and revoke storage access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/listeners" : {
      "get" : {
        "summary" : "List all NVMe-oF listeners.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFListeners",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFListenerConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate NVMe-oF listeners across services including NIC, VLAN, port and TLS settings.",
          "usage" : [ "Call when displaying listener configuration to operators or ahead of network audits.", "Refresh after adding/removing listeners to confirm the configurator committed changes." ],
          "response_shape" : "PaginationResponse<NvmeOFListenerConfigResponse>",
          "common_parameters" : {
            "pagination.where.gatewayId" : "Filter listeners to a specific cluster before editing.",
            "pagination.where.secure" : "Identify listeners that already enforce TLS."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof" ],
          "postprocessing_hint" : "Display nicName and vlan to align network automation with listener placement.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/services" : {
      "get" : {
        "summary" : "List all NVMe-oF services.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF target services per server with hugepage config, NIC bindings, and errors.",
          "usage" : [ "Fetch when reviewing NVMe-oF deployment health to inspect service-level hints.", "Poll after task-managed changes (add/remove service, update listeners) to confirm the configurator applied updates." ],
          "response_shape" : "PaginationResponse<NvmeOFServiceResponse>",
          "common_parameters" : {
            "pagination.where.error" : "Filter services with outstanding configurator hints.",
            "pagination.order.serverHostname" : "Maintain ordering by host for easier comparisons."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF service health"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Highlight entries with non-null error or mismatched nrHugepages to prompt corrective actions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/subsystems" : {
      "get" : {
        "summary" : "List all NVMe-oF subsystems.",
        "operationId" : "NvmeOFSubsystemResource_getNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFSubsystemResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF subsystems with host and disk membership metadata.",
          "usage" : [ "Fetch before presenting subsystem details or attaching hosts/disks.", "Refresh after task operations (attach/detach) to validate membership state." ],
          "response_shape" : "PaginationResponse<NvmeOFSubsystemResponse>",
          "common_parameters" : {
            "pagination.where.hosts" : "Filter subsystems that already expose to specific hosts.",
            "pagination.where.disks" : "Identify subsystems using a particular disk ID."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF subsystem inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Expose hostsFormatted and disksFormatted so UIs can show readable membership chips.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_addNvmeOFSubsystem",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new NVMe-oF subsystem for organizing namespaces and controlling host access to storage.",
          "usage" : [ "Call when setting up new storage partitions for different applications or tenants.", "Use to create isolated storage access domains within an NVMe-oF cluster." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; NQN is unique; Valid NQN format; Cluster services running",
            "post_action" : "Subsystem created; Available for host and disk attachment; Cluster configuration updated"
          },
          "request_parameters" : [ {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nqn",
            "in" : "body",
            "description" : "Nqn parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Subsystem creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for subsystem creation; ready for host and namespace configuration; use attach endpoints to add storage and access controls.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_updateNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Subsystem update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Modify configuration of an existing NVMe-oF subsystem including namespaces and host access.",
          "usage" : [ "Call when adding/removing block devices from subsystems or updating access controls.", "Use to modify subsystem metadata or reconfigure allowed hosts for security." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem exists; NQN is valid if specified; Block devices and hosts exist; No active I/O disruption planned",
            "post_action" : "Subsystem reconfigured; Namespace mappings updated; Host access controls applied; Active connections may require reconnection"
          },
          "request_parameters" : [ {
            "name" : "maxNamespaces",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "modelNumber",
            "in" : "body",
            "description" : "ModelNumber parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "serialNumber",
            "in" : "body",
            "description" : "SerialNumber parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to update.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Subsystem configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts", "/gateways/nvmeof/bdevs" ],
          "postprocessing_hint" : "Monitor task for per-gateway results; clients may need to rediscover namespaces after block device changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_removeNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an NVMe-oF subsystem and remove all associated namespaces and host access controls.",
          "usage" : [ "Call when decommissioning storage partitions or cleaning up unused subsystems.", "Use to remove storage access domains that are no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem exists; No active client connections; Data backed up if needed",
            "post_action" : "Subsystem deleted; Namespaces removed; Host access revoked; Cluster configuration updated"
          },
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to delete from subsystem listings.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Subsystem deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for deletion progress; client connections will be terminated; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting subsystem will remove all namespaces and terminate client access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" : {
      "post" : {
        "summary" : "Attach disks to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Disk attachment configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Attach storage devices to an NVMe-oF subsystem as namespaces for client access.",
          "usage" : [ "Call when adding storage capacity to existing subsystems.", "Use to expose new block devices through NVMe-oF to connected clients." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and disks exist; Same cluster; Within namespace limits; No DAOS conflicts",
            "post_action" : "Disks attached as namespaces; Storage exposed to clients; Namespace IDs assigned"
          },
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "Disks parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to attach storage devices to.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Storage attachment operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Monitor task for storage attachment; clients may need to rescan for new namespaces; check namespace limits before adding more disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-hosts" : {
      "post" : {
        "summary" : "Attach hosts to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Grant host access to an NVMe-oF subsystem by attaching hosts to the access control list.",
          "usage" : [ "Call when granting new clients access to storage subsystems.", "Use to expand access permissions for existing storage partitions." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and hosts exist; Hosts belong to same cluster; Valid access permissions",
            "post_action" : "Hosts granted access; ACLs updated; Clients can connect to subsystem"
          },
          "request_parameters" : [ {
            "name" : "hosts",
            "in" : "body",
            "description" : "Hosts parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to attach hosts to.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host access management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for access configuration; attached hosts can now connect to subsystem namespaces.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-disks" : {
      "post" : {
        "summary" : "Detach disks from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove storage devices from an NVMe-oF subsystem to stop exposing them as namespaces.",
          "usage" : [ "Call when removing storage capacity or decommissioning storage devices.", "Use to stop exposing block devices through NVMe-oF to connected clients." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and disks exist; No active I/O; Data safety confirmed; Clients notified",
            "post_action" : "Disks detached; Namespaces removed; Storage no longer accessible to clients"
          },
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "Disks parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to detach storage devices from.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Storage detachment operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Monitor task for storage detachment; namespaces removed from client view; ensure client applications handle namespace removal gracefully.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Detaching disks will remove namespaces and may cause data unavailability for clients"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-hosts" : {
      "post" : {
        "summary" : "Detach hosts from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Revoke host access from an NVMe-oF subsystem by removing hosts from the access control list.",
          "usage" : [ "Call when revoking client access to storage subsystems for security.", "Use to remove access permissions during client decommissioning." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and hosts exist; Understand connection impact; Data safety confirmed",
            "post_action" : "Host access revoked; ACLs updated; Active connections terminated"
          },
          "request_parameters" : [ {
            "name" : "hosts",
            "in" : "body",
            "description" : "Hosts parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "subsystemId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to detach hosts from.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host access revocation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for access revocation; detached hosts lose immediate access; connections terminated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Detaching hosts will immediately terminate their connections to the subsystem"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}" : {
      "patch" : {
        "summary" : "Update name or description of an NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update configuration settings for an existing NVMe-oF gateway cluster.",
          "usage" : [ "Call when modifying gateway cluster name or description for better organization.", "Use to update gateway metadata without affecting active connections." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Gateway exists; New name is unique if specified; Cluster is accessible",
            "post_action" : "Gateway metadata updated; Changes visible in management UI; Active connections unaffected"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "forceSecure",
            "in" : "body",
            "description" : "ForceSecure parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "transportDefaults",
            "in" : "body",
            "description" : "TransportDefaults parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "Gateway cluster ID to update.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Gateway configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/{gatewayId}" ],
          "postprocessing_hint" : "Verify changes with GET /gateways/nvmeof/{gatewayId}; metadata changes don't affect I/O performance.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an NVMe-oF cluster. This also deletes all services and configuration associated with the cluster.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an NVMe-oF gateway cluster and all associated services, subsystems, and configurations.",
          "usage" : [ "Call when decommissioning NVMe-oF storage access or cleaning up unused clusters.", "Use for complete removal of NVMe-oF infrastructure from specific servers." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; No active client connections; Data backed up if needed",
            "post_action" : "All services stopped; SPDK targets removed; Configuration cleaned up; Cluster deleted"
          },
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to delete from cluster listings.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Cluster deletion operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task progress for cleanup; client connections will be terminated; servers will release SPDK resources; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting NVMe-oF cluster will stop all storage access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF service configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add a new NVMe-oF target service to an existing cluster for expanded storage access points.",
          "usage" : [ "Call when scaling out NVMe-oF cluster to additional servers or network fabrics.", "Use to add redundant target services for high availability storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; Server has SPDK support; NICs accessible; No listener conflicts",
            "post_action" : "Target service deployed; Hugepages configured; Listeners bound to fabrics; Service ready for subsystem attachment"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "listeners",
            "in" : "body",
            "description" : "Listeners parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "NrHugepages parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "transports",
            "in" : "body",
            "description" : "Transports parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to add the service to.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Service addition operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/{gatewayId}", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task for service deployment; hugepages allocated on server; service available for subsystem configuration.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure the NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_reconfigureNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "fromScratch",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reconfigure and redeploy NVMe-oF cluster services to apply configuration changes or fix issues.",
          "usage" : [ "Call after configuration changes to apply updates across all cluster services.", "Use to recover from configuration drift or service deployment issues." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; Services accessible; Configuration valid; Backup recommended",
            "post_action" : "Services reconfigured; SPDK targets updated; Listeners rebound; Configuration synchronized"
          },
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to reconfigure.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Cluster reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/{gatewayId}", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task for service restart progress; brief service interruption expected; configuration drift resolved after completion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Reconfiguration may temporarily interrupt client connections during service restart"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NVMe-oF service metadata, ANA state, transports, listeners, or hugepage settings.",
          "usage" : [ "Modify service parameters after hardware or configuration changes.", "Adjust ANA state or listener definitions as part of maintenance." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "anaState",
            "in" : "body",
            "description" : "AnaState parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "listeners",
            "in" : "body",
            "description" : "Listeners parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "NrHugepages parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "transports",
            "in" : "body",
            "description" : "Transports parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF service reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to ensure updated settings are reflected before proceeding.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/errors" : {
      "delete" : {
        "summary" : "Forget any config errors associated with this service.",
        "operationId" : "NvmeOFGatewayResource_forgetNvmeOFConfigErrors",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clear cached NVMe-oF service configuration errors after they have been addressed.",
          "usage" : [ "Call once operators have fixed the reported misconfiguration and want the dashboard to reset.", "Use to acknowledge resolved errors before triggering a fresh service rescan." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID whose error cache should be cleared.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF error acknowledgements"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/services to confirm the error array is empty.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" : {
      "post" : {
        "summary" : "Add a new listener to an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NVMe-oF listener bound to a specific NIC/VLAN for a target service.",
          "usage" : [ "Call when onboarding new fabrics or scaling out access points for an NVMe-oF service.", "Use right after provisioning additional NICs to expose the service on the new network segment." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "nicId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "Port parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "secure",
            "in" : "body",
            "description" : "Secure parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "vlanId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 600,
            "note" : "NVMe-oF listener creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/listeners to verify the listener appears with the expected NIC/VLAN.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF listener's configuration.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust port or TLS settings for an existing NVMe-oF listener.",
          "usage" : [ "Modify listener ports during maintenance without recreating the listener.", "Enable or disable TLS when policy changes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "port",
            "in" : "body",
            "description" : "Port parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "secure",
            "in" : "body",
            "description" : "Secure parameter",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "listenerId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID owning the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier to update.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF listener updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/listeners to confirm new port/TLS state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a listener from an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NVMe-oF listener so the service stops exposing that network endpoint.",
          "usage" : [ "Call during listener maintenance (e.g. decommissioning a NIC or VLAN).", "Use ahead of recreating the listener with new parameters to avoid duplicate bindings." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "listenerId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Target service that owns the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier as returned by the listeners API.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Refresh GET /gateways/nvmeof/listeners to ensure the listener ID disappears.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports/{type}" : {
      "delete" : {
        "summary" : "Delete a transport configuration.",
        "operationId" : "NvmeOFGatewayResource_deleteTransportConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a custom NVMe-oF transport configuration so the service falls back to cluster defaults.",
          "usage" : [ "Call after reverting transport tuning or decommissioning a transport type from the service.", "Use before recreating the transport with new parameters to avoid conflicting overrides." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "gatewayId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "Numeric identifier of the NVMe-oF gateway cluster.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Internal service ID within the gateway.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Transport to remove (TCP, RDMA, etc.).",
            "required" : true,
            "example" : "TCP"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF transport removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to confirm the service no longer lists the transport override.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/smb" : {
      "get" : {
        "summary" : "List all SMB clusters with their config.",
        "operationId" : "SmbGatewayResource_getSmbGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured SMB gateway clusters with Active Directory and VIP metadata.",
          "usage" : [ "Query before rendering the SMB configuration overview.", "Refresh after editing domain settings or virtual IP pools to confirm changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayConfigResponse>",
          "common_parameters" : {
            "pagination.where.type" : "Filter clusters by Samba share type before managing shares.",
            "pagination.order.description" : "Maintain deterministic ordering across refreshes."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Expose joinWithSssd and domain details so administrators can confirm integration status quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/servers" : {
      "get" : {
        "summary" : "List all SMB servers.",
        "operationId" : "SmbGatewayResource_getSmbServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List SMB gateway servers with their NIC bindings, VLANs, and CTDB health.",
          "usage" : [ "Fetch when presenting the SMB server grid to monitor HA status and virtual IP placement.", "Re-query after rebalancing CTDB or adjusting NIC assignments to confirm effective changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayServerResponse>",
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy nodes for quick remediation.",
            "pagination.order.hostname" : "Keep server lists stable between refreshes."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB server health refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Highlight servers without virtual IPs or with unhealthy=false to draw operator focus.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/shares" : {
      "get" : {
        "summary" : "List all SMB shares.",
        "operationId" : "SmbGatewayResource_getSmbShares",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayShareResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return SMB shares, underlying paths, and access control definitions.",
          "usage" : [ "Fetch prior to editing share permissions or exposing share listings to operators.", "Refresh after share mutations to confirm guest/rw/ro settings and AD mappings." ],
          "response_shape" : "PaginationResponse<SmbGatewayShareResponse>",
          "common_parameters" : {
            "pagination.where.share" : "Search for a particular share name quickly.",
            "pagination.where.type" : "Filter to simple vs Active Directory shares when auditing access."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB share inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/servers" ],
          "postprocessing_hint" : "Surface rwUsersFormatted/roUsersFormatted alongside share names for quick permission audits.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images" : {
      "get" : {
        "summary" : "List available images",
        "operationId" : "ImageResource_listImages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available croit node images with metadata and default selections.",
          "usage" : [ "Call to populate the image catalog UI before allowing selection or download.", "Refresh after invoking POST /images/refresh or /images/default to ensure state is current." ],
          "response_shape" : "ImageListReply",
          "common_parameters" : {
            "pagination.where" : "Filter by cpuArchitecture, isDefault or isNightly before presenting to users.",
            "pagination.order" : "Sort by timestamp desc to show latest images first."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Catalog refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/images/refresh", "/images/{image}", "/images/archs" ],
          "postprocessing_hint" : "When pagination is absent use the `images` array; otherwise combine `data` and `total` for pagination UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/archs" : {
      "put" : {
        "summary" : "Set enabled architectures",
        "operationId" : "ImageResource_setEnabledArch",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Architecture configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ArchConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure which CPU architectures are supported for image deployment and server management.",
          "usage" : [ "Call when adding or removing support for different CPU architectures in the cluster.", "Use to control which architecture types can receive image deployments and OS installations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "At least one architecture enabled; Consider impact on existing servers; Admin understands implications",
            "post_action" : "Architecture support updated; Image availability filtered by enabled architectures; Server compatibility checked"
          },
          "request_parameters" : [ {
            "name" : "arm64",
            "in" : "body",
            "description" : "Arm64 parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "x86_64",
            "in" : "body",
            "description" : "X86_64 parameter",
            "required" : true,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Architecture configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images/archs", "/images" ],
          "postprocessing_hint" : "Architecture changes are immediate; only enabled architectures show in image listings; verify server compatibility before changes.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Architecture changes affect which servers can receive images and may impact cluster operations"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get enabled architectures",
        "operationId" : "ImageResource_getEnabledArch",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ArchConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report which CPU architectures are currently enabled for croit images.",
          "usage" : [ "Read before displaying architecture toggles in the UI.", "Confirm the enabled state after PUT /images/archs or POST /images/default." ],
          "response_shape" : "ArchConfig",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Architecture toggle refresh"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images/archs (PUT)", "/images/default" ],
          "postprocessing_hint" : "Disable UI flows that assume images exist when an architecture flag is false.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/default" : {
      "post" : {
        "summary" : "Set default image",
        "operationId" : "ImageResource_setDefaultImage",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Default image request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/DefaultImageRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the default boot image for an architecture and optionally update existing servers to use it.",
          "usage" : [ "Call when establishing or changing the default image for new server deployments.", "Use to standardize cluster nodes on a specific OS image version across the architecture." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Image exists and is downloaded; Architecture supported; Server access available if overriding",
            "post_action" : "Default image updated; New deployments use new default; Existing servers updated if requested"
          },
          "request_parameters" : [ {
            "name" : "default",
            "in" : "body",
            "description" : "Default parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "overrideServers",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Default image changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images/default", "/images" ],
          "postprocessing_hint" : "Monitor task if overrideServers=true; new servers will use this image by default; existing servers updated based on override setting.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Setting default image affects new server deployments and may update existing servers"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get default image for architecture",
        "operationId" : "ImageResource_getDefaultImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "arch",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DefaultImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the default boot image UUID for a requested CPU architecture.",
          "usage" : [ "Call durant automated installs to learn which image croit nodes should boot by default.", "Verify that a default image is configured before prompting users to enable an architecture." ],
          "response_shape" : "DefaultImageResponse",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/archs", "/images/default (POST)" ],
          "postprocessing_hint" : "Treat the returned UUID as authoritative until the image catalog refreshes.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/images/packages/{image}" : {
      "get" : {
        "summary" : "Get packages installed in an image",
        "operationId" : "ImageResource_getImagePackages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ImagePackage"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List OS packages baked into a specific croit image for compliance or troubleshooting.",
          "usage" : [ "Fetch when an operator inspects package versions before rolling out the image.", "Compare package sets between images to validate upgrade impact." ],
          "response_shape" : "array<ImagePackage>",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "image",
            "in" : "path",
            "description" : "UUID from GET /images representing the image to inspect.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "Package audit"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Sort packages alphabetically and surface notable version differences to the user.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/refresh" : {
      "post" : {
        "summary" : "Refresh available images",
        "operationId" : "ImageResource_refreshImages",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Refresh the available images catalog from the remote repository to update local metadata.",
          "usage" : [ "Call when new images are expected to be available from the repository.", "Use to update image list after repository changes or to resolve missing images." ],
          "response_shape" : "ImageListReply",
          "workflow_guidance" : {
            "pre_check" : "Network connectivity available; Repository accessible; Admin privileges confirmed",
            "post_action" : "Image catalog updated; New images available for download; Existing image metadata refreshed"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Image catalog refresh"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Updated catalog includes new images and revised metadata; refresh UI to show current available images.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/unused" : {
      "delete" : {
        "summary" : "Delete all unused images from disk. This includes all images that are not the default image and are not used by any server.",
        "operationId" : "ImageResource_deleteUnused",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete all unused images from disk storage to free up space while preserving active and default images.",
          "usage" : [ "Call for regular cleanup to remove images no longer needed by any servers.", "Use for maintenance to reclaim disk space by removing orphaned or outdated images." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Sufficient disk permissions; Default images identified; Server image usage analyzed",
            "post_action" : "Unused images deleted; Storage space freed; Default and active images preserved; Task completion reported"
          },
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 3600,
            "note" : "Bulk image cleanup operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Cleanup runs as background task; default images and images in use by servers are preserved; significant storage space may be freed.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bulk image deletion will permanently remove multiple images from disk storage"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}" : {
      "get" : {
        "summary" : "Get image information",
        "operationId" : "ImageResource_getImageInfo",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageInfoResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a concise description for a specific image (used by automated installers).",
          "usage" : [ "Call from provisioning workflows that need a human-readable label for the selected image.", "Validate that an image UUID obtained earlier still resolves before starting downloads." ],
          "response_shape" : "ImageInfoResponse",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "image",
            "in" : "path",
            "description" : "Image UUID returned by GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer metadata lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}/{file}", "/images/default" ],
          "postprocessing_hint" : "Display the description verbatim; it already includes timestamp and UUID.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      },
      "delete" : {
        "summary" : "Delete a downloaded image from disk",
        "operationId" : "ImageResource_deleteImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a specific downloaded image from disk to free up storage space.",
          "usage" : [ "Call when removing outdated or unused OS images to reclaim disk space.", "Use for cleanup when images are no longer needed for server deployments." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Image exists; Not currently used by any servers; Sufficient admin privileges",
            "post_action" : "Image file deleted from disk; Storage space freed; Image no longer available for deployment"
          },
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "image",
            "in" : "path",
            "description" : "UUID of the image to delete from disk storage.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Image management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/unused" ],
          "postprocessing_hint" : "Image deletion is immediate; servers using this image are unaffected; re-download needed to restore image.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting images permanently removes them from disk and they must be re-downloaded if needed again"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/startDownload" : {
      "post" : {
        "summary" : "Start downloading an image",
        "operationId" : "ImageResource_startImageDownload",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate download of a specific image from the repository to local storage for server deployment.",
          "usage" : [ "Call when an image needs to be available locally before server deployment or upgrade.", "Use to pre-download images for faster server provisioning or offline deployment scenarios." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Image exists in catalog; Sufficient storage space; Repository accessible; No concurrent download",
            "post_action" : "Download initiated; Image will be available for deployment when complete; Progress trackable via status"
          },
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "image",
            "in" : "path",
            "description" : "Image identifier to download from the repository.",
            "required" : true,
            "example" : "croit-node-22.04-x86_64"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Image download initiation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Monitor download progress via image status; large images may take significant time; downloaded images are immediately available for deployment.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/{file}" : {
      "get" : {
        "summary" : "Download an image file",
        "operationId" : "ImageResource_downloadImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "file",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download a raw croit OS image artifact for offline storage or provisioning.",
          "usage" : [ "Call when an administrator explicitly requests the binary image payload.", "Use ahead of manual provisioning workflows that need the kernel/initrd bundle on disk." ],
          "response_shape" : "application/octet-stream",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "file",
            "in" : "path",
            "description" : "file parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "image",
            "in" : "path",
            "description" : "Image identifier from GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          }, {
            "name" : "file",
            "in" : "path",
            "description" : "Filename within the image directory (e.g. rootfs.img, initrd).",
            "required" : true,
            "example" : "rootfs.img"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Large image download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}", "/images/refresh" ],
          "postprocessing_hint" : "Stream the response directly to persistent storage and avoid logging binary data.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/install" : {
      "get" : {
        "summary" : "Get croit installation script",
        "operationId" : "InstallResource_getInstallScript",
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the automated croit installation script for setting up new cluster nodes.",
          "usage" : [ "Call when preparing to install croit on new servers or cluster nodes.", "Use to get the latest installation script with current configuration and dependencies." ],
          "response_shape" : "text/plain (shell script)",
          "workflow_guidance" : {
            "pre_check" : "Cluster configuration available; Template system initialized",
            "post_action" : "Installation script generated; Ready for execution on target servers"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Installation script downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster", "/servers" ],
          "postprocessing_hint" : "Execute script with root privileges on target servers; script contains cluster-specific configuration and connection details; verify network connectivity before execution.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/ipmi" : {
      "get" : {
        "summary" : "Show all IPMI devices",
        "operationId" : "IpmiResource_getIpmiDevices",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpmiDevice"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all IPMI devices in the cluster with their current power and health status.",
          "usage" : [ "Call when displaying server hardware management interface.", "Use to monitor server power states and hardware health across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<IpmiDevice>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI device queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/ipmi/poll-state", "/ipmi/config", "/servers" ],
          "postprocessing_hint" : "Display power state prominently; group devices by server rack or location; cache status data for dashboard updates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/add" : {
      "post" : {
        "summary" : "Add an IPMI device that is not managed by croit's DHCP server",
        "operationId" : "IpmiResource_addIpmiServer",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI device information",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiDeviceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a new IPMI device that is not managed by croit's DHCP server for remote server management.",
          "usage" : [ "Call when adding servers with static IPMI configuration or external DHCP management.", "Use to integrate existing servers with configured IPMI into croit cluster management." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "IP address accessible; IPMI credentials valid; No existing device with same IP",
            "post_action" : "IPMI device registered; Available for server management operations; Power control enabled"
          },
          "request_parameters" : [ {
            "name" : "access",
            "in" : "body",
            "description" : "Access parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "IPMI device registration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "Device will appear in IPMI list; test connectivity with identify or power status commands; credentials stored securely.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/config" : {
      "patch" : {
        "summary" : "Set the global IPMI configuration",
        "operationId" : "IpmiResource_setIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update global IPMI configuration including passwords for hardware management interfaces.",
          "usage" : [ "Call when setting up initial IPMI access or rotating IPMI passwords for security.", "Use after hardware changes or when standardizing IPMI credentials across the cluster." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid license active; IPMI interfaces accessible; New password meets complexity requirements",
            "post_action" : "IPMI admin password updated on all reachable devices; Task tracks per-device success/failure"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "IPMI configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/config", "/server-access/passwords" ],
          "postprocessing_hint" : "Monitor task progress for per-device results; failed devices may need manual password reset via BMC interface.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing IPMI passwords affects hardware access and may require physical intervention if connections fail"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the global IPMI configuration",
        "operationId" : "IpmiResource_getIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpmiConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve global IPMI configuration settings including admin password for hardware management.",
          "usage" : [ "Call when displaying IPMI settings in the administration interface.", "Use to verify current IPMI credentials before performing device operations." ],
          "response_shape" : "IpmiConfig",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI configuration queries"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/ipmi/config", "/server-access/passwords" ],
          "postprocessing_hint" : "Handle password securely; display configuration status rather than actual password value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/poll-state" : {
      "get" : {
        "summary" : "Poll the state of the given IPMI devices.",
        "operationId" : "IpmiResource_pollIpmiState",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/IpmiDeviceStateWrapper"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Poll current power and health status of specific IPMI devices for real-time monitoring.",
          "usage" : [ "Call when refreshing server status in dashboards or before performing power operations.", "Use to verify current device states before hardware management actions." ],
          "response_shape" : "Map<Int, IpmiDeviceStateWrapper>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "IPMI status polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/ipmi", "/ipmi/config" ],
          "postprocessing_hint" : "Cache results for 5 seconds; displays current power state, temperature, and connectivity status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}" : {
      "delete" : {
        "summary" : "Remove an IPMI device, it will be re-detected if it still exists",
        "operationId" : "IpmiResource_deleteIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an IPMI device entry from croit's database (will be re-detected if device still exists).",
          "usage" : [ "Call when cleaning up stale IPMI device entries after hardware removal.", "Use to force re-detection of IPMI devices with updated network settings." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "IPMI device exists in database; Device is not critical for ongoing operations",
            "post_action" : "Device entry removed from database; Device will be re-detected if still accessible"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to remove from GET /ipmi.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "IPMI device management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "Device will automatically reappear in /ipmi if it's still network-accessible during next detection cycle.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/identify" : {
      "post" : {
        "summary" : "Turns on the identify LED for 5 minutes.",
        "operationId" : "IpmiResource_identifyIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Activate the server identification LED to physically locate hardware in a datacenter rack.",
          "usage" : [ "Call when physically locating servers for maintenance or troubleshooting.", "Use to identify specific hardware before performing physical operations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server supports LED identification",
            "post_action" : "Identification LED activated for 4 minutes; LED blinks to identify physical server location"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to identify from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI identification operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/servers" ],
          "postprocessing_hint" : "LED will blink for 4 minutes to help locate server; safe operation with no impact on server functionality.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}/initialize" : {
      "post" : {
        "summary" : "Initialize an IPMI device to be used with croit.",
        "description" : "Sets boot device to PXE, and turns on power and optionally configures the ADMIN password to the default croit password.",
        "operationId" : "IpmiResource_initializeIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Optional information for accessing the IPMI device if it uses a non-default password.",
          "required" : false,
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiAccess"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initialize an IPMI device for croit management by configuring PXE boot, passwords, and power state.",
          "usage" : [ "Call when preparing new servers for cluster integration via PXE boot.", "Use to standardize IPMI configuration and ensure servers can be managed remotely." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Current credentials available if needed",
            "post_action" : "Password changed to croit default; Boot device set to PXE; Server powered on; Ready for cluster integration"
          },
          "request_parameters" : [ {
            "name" : "keepAdminPassword",
            "in" : "body",
            "description" : "KeepAdminPassword parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "username",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to initialize from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "IPMI initialization operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on" ],
          "postprocessing_hint" : "Monitor task progress for initialization steps; server will boot from PXE after completion; verify network boot sequence.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "IPMI initialization changes passwords and power state, potentially affecting server accessibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/ipmi-controller-reset" : {
      "post" : {
        "summary" : "Reboots the IPMI management controller itself.",
        "operationId" : "IpmiResource_rebootIpmiController",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reset the IPMI management controller (BMC) itself to resolve BMC issues or restore connectivity.",
          "usage" : [ "Call when IPMI interface becomes unresponsive or exhibits erratic behavior.", "Use as troubleshooting step for BMC firmware issues or network connectivity problems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; BMC is experiencing issues requiring reset",
            "post_action" : "BMC controller reset initiated; IPMI interface will be temporarily unavailable; BMC reboots and reinitializes"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID whose controller should be reset from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "BMC reset operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "BMC will be unavailable for 1-3 minutes during reset; monitor connectivity; may resolve persistent IPMI issues.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "BMC reset will temporarily disable all IPMI functionality until the controller reboots"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-cycle" : {
      "post" : {
        "summary" : "Reboots a server.",
        "operationId" : "IpmiResource_rebootIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot a server remotely via IPMI with PXE boot for troubleshooting or configuration updates.",
          "usage" : [ "Call to restart unresponsive servers or apply configuration changes.", "Use to force server restart when software reboot is not possible." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is currently running",
            "post_action" : "Boot device set to PXE; Server power cycled; Server reboots from network"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to reboot from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "IPMI reboot operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on", "/ipmi/{id}/power-off" ],
          "postprocessing_hint" : "Server will reboot from PXE; monitor boot sequence; cluster services will restart; expect 2-5 minute downtime.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Rebooting servers will temporarily interrupt cluster operations and may affect data availability"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-off" : {
      "post" : {
        "summary" : "Shutdown a server.",
        "operationId" : "IpmiResource_powerOffIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Shutdown a server remotely via IPMI for maintenance, power saving, or emergency situations.",
          "usage" : [ "Call to gracefully shutdown servers for maintenance or cluster operations.", "Use for emergency shutdown when servers become unresponsive." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is currently powered on",
            "post_action" : "Server shutdown command sent; Server powers down; Hardware enters standby state"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to power off from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "IPMI power operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Monitor server status in cluster view; ensure data safety before shutdown; server will remain off until manually powered on.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Powering off servers will make them unavailable for cluster operations and may affect data availability"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-on" : {
      "post" : {
        "summary" : "Boots a server.",
        "operationId" : "IpmiResource_powerOnIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Power on a server remotely via IPMI with PXE boot configuration for cluster operations.",
          "usage" : [ "Call to start servers for cluster operations or after maintenance.", "Use to boot servers into croit-managed OS from network." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is powered off or in standby",
            "post_action" : "Boot device set to PXE; Server power turned on; Server boots from network"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to power on from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "IPMI power operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-off", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Server will boot from PXE; monitor network boot sequence; verify server appears in cluster within 5-10 minutes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/reboot-to-bios" : {
      "post" : {
        "summary" : "Reboots a server and opens the BIOS setup menu.",
        "operationId" : "IpmiResource_rebootToBiosIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot a server and enter BIOS setup menu for hardware configuration or troubleshooting.",
          "usage" : [ "Call when BIOS settings need to be changed for hardware configuration.", "Use for hardware troubleshooting or firmware updates requiring BIOS access." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server supports BIOS boot override",
            "post_action" : "Boot device set to BIOS; Server power cycled; Server boots to BIOS setup menu"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to reboot to BIOS from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "BIOS boot operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Server will boot to BIOS setup; requires physical console or KVM access; remember to reset boot device after BIOS changes.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Server will boot to BIOS and require manual intervention to return to normal operation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys" : {
      "get" : {
        "summary" : "List all Ceph users/keys.",
        "operationId" : "KeyResource_getCephKeys",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "description" : "Include Ceph and croit service keys (default: false)",
          "name" : "includeSystemKeys",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph authentication keys with their permissions and capabilities for access management.",
          "usage" : [ "Call when auditing Ceph access permissions or reviewing user authentication configurations.", "Use to identify which keys have access to specific pools, monitors, or metadata servers." ],
          "response_shape" : "OptionalPaginationResponse<CephUserResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Ceph key listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/keys/{user}", "/keys/{user}/download" ],
          "postprocessing_hint" : "Group by permission type; highlight admin/system keys; show capability summaries for each key.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new Ceph user/key, the specified user must not exist yet",
        "operationId" : "KeyResource_addCephKey",
        "tags" : [ "ceph-keys" ],
        "requestBody" : {
          "description" : "Ceph user/key configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph authentication key with specified permissions for client or service access.",
          "usage" : [ "Call when setting up new clients or services that need authenticated access to Ceph cluster.", "Use to create application-specific keys with minimal required permissions for security." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User name is unique; Permissions are valid; Ceph auth service accessible",
            "post_action" : "Ceph key created; User can authenticate to cluster; Key available for download"
          },
          "request_parameters" : [ {
            "name" : "comment",
            "in" : "body",
            "description" : "Comment parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "Permissions parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "body",
            "description" : "User parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Ceph key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}", "/keys/{user}/download" ],
          "postprocessing_hint" : "Key is immediately active; download keyring file for client configuration; warning issued if name resembles system key.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd" : {
      "get" : {
        "summary" : "Deploy the Ceph Container Storage Interface (CSI) driver for RBD",
        "operationId" : "KeyResource_downloadKubernetesCsiRbdConf",
        "tags" : [ "ceph-keys" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download Kubernetes CSI driver deployment configuration for Ceph RBD persistent volume provisioning.",
          "usage" : [ "Call when deploying Ceph CSI driver to Kubernetes cluster for the first time.", "Use to get standard CSI driver manifests for dynamic RBD volume provisioning." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "CSI driver downloads"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/keys/kubernetes-csi/rbd/config/{user}/{pool}" ],
          "postprocessing_hint" : "Deploy to Kubernetes with kubectl apply -f csi-rbd.yml; configure StorageClass and Secrets separately using config endpoint; requires Kubernetes 1.14+.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd/config/{user}/{pool}" : {
      "get" : {
        "summary" : "Generate the ConfigMap, StorageClass, and Secret objects needed by ceph-csi to provision a RBD backed PersistentVolume",
        "operationId" : "KeyResource_downloadKubernetesCsiCroitConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate Kubernetes CSI configuration (ConfigMap, StorageClass, Secret) for Ceph RBD persistent volumes.",
          "usage" : [ "Call when setting up Kubernetes persistent storage using Ceph RBD volumes.", "Use to generate CSI driver configuration for specific user and pool combinations." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "user parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "path",
            "description" : "Ceph user name for RBD access (without client. prefix).",
            "required" : true,
            "example" : "kubernetes"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Ceph pool name for RBD volume provisioning.",
            "required" : true,
            "example" : "kubernetes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Kubernetes CSI configuration generation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/pools", "/keys/kubernetes-csi/rbd" ],
          "postprocessing_hint" : "Apply to Kubernetes cluster using kubectl apply -f csi-croit.yml; contains ConfigMap, StorageClass, and Secret resources.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes/{user}/{pool}" : {
      "get" : {
        "summary" : "Download Kubernetes configuration",
        "operationId" : "KeyResource_downloadKubernetesConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate legacy Kubernetes configuration for Ceph RBD storage integration (deprecated in favor of CSI).",
          "usage" : [ "Call when setting up older Kubernetes clusters with legacy RBD volume provisioning.", "Use for compatibility with Kubernetes versions prior to CSI driver adoption." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "user parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "path",
            "description" : "Ceph user name for RBD access (without client. prefix).",
            "required" : true,
            "example" : "kubernetes"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Ceph pool name for RBD volume storage.",
            "required" : true,
            "example" : "kubernetes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Legacy Kubernetes configuration generation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/pools", "/keys/kubernetes-csi/rbd/config/{user}/{pool}" ],
          "postprocessing_hint" : "Apply to Kubernetes using kubectl apply -f; consider migrating to CSI driver for modern Kubernetes clusters; contains legacy StorageClass and Secret configurations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}" : {
      "patch" : {
        "summary" : "Update an existing Ceph user",
        "operationId" : "KeyResource_updateCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Ceph user/key update configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserUpdate"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update permissions or metadata for an existing Ceph user key without regenerating the authentication secret.",
          "usage" : [ "Call when user access requirements change and need permission adjustments.", "Use to add comments or modify capabilities while preserving the existing key secret." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Permissions are valid; Ceph auth service accessible; Admin confirms changes for system keys",
            "post_action" : "User permissions updated; Changes effective immediately; Key secret remains unchanged"
          },
          "request_parameters" : [ {
            "name" : "comment",
            "in" : "body",
            "description" : "Comment parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "Permissions parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "user parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to update.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Ceph key updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Permission changes are immediate; test user access after updates; warning issued for system key modifications.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Updating system or admin keys can impact cluster functionality; permission changes are immediate"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a Ceph user",
        "operationId" : "KeyResource_deleteCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph authentication key to revoke access for a specific user or service.",
          "usage" : [ "Call when decommissioning users or services that no longer need Ceph access.", "Use to clean up unused authentication keys for security compliance." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User key exists; Not a critical system key; Admin understands impact on services",
            "post_action" : "Ceph user key deleted; Authentication immediately revoked; Services using this key will fail"
          },
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "user parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to delete.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Ceph key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Key deletion is immediate; update any services that were using this key; system keys generate warnings.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting Ceph keys will immediately revoke access for services using this authentication"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}/download" : {
      "get" : {
        "summary" : "Download a ceph.client.XYZ.keyring file",
        "operationId" : "KeyResource_downloadCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download a Ceph keyring file containing authentication credentials for a specific user.",
          "usage" : [ "Call when configuring Ceph clients that need authentication credentials.", "Use to distribute authentication keys to applications or services accessing Ceph storage." ],
          "response_shape" : "DownloadableObject (keyring file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "user parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to download keyring for.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "Keyring downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Place keyring file in /etc/ceph/ on client systems; set appropriate file permissions (600); contains secret key material.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/license" : {
      "patch" : {
        "summary" : "Update license info.",
        "operationId" : "LicenseResource_patchLicenseInfo",
        "tags" : [ "license" ],
        "requestBody" : {
          "description" : "License update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/LicensePatchRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update license configuration settings including notification email address for license alerts.",
          "usage" : [ "Call when changing the email address for license expiration notifications.", "Use to configure or update license contact information without affecting license validity." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid email format provided; Admin permissions verified",
            "post_action" : "License notification email updated; Future license alerts sent to new address"
          },
          "request_parameters" : [ {
            "name" : "email",
            "in" : "body",
            "description" : "Email parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "License configuration updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/license" ],
          "postprocessing_hint" : "Email address change is immediate; test email delivery for license notifications; affects future alert delivery only.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get license info.",
        "operationId" : "LicenseResource_licenseInfo",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current croit license status, usage limits, and compliance information.",
          "usage" : [ "Call when displaying license information in the administration interface.", "Use to check license compliance before enabling premium features or scaling the cluster." ],
          "response_shape" : "LicenseReply",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "License status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/license", "/croit/dependencies" ],
          "postprocessing_hint" : "Display usage vs. limits prominently; show expiration warnings; indicate registration status with portal.croit.io.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/license/refresh" : {
      "post" : {
        "summary" : "Refresh license info.",
        "operationId" : "LicenseResource_refreshLicense",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Refresh license information by checking with the license server for updated status and usage limits.",
          "usage" : [ "Call when license status appears outdated or after changes to cluster configuration.", "Use to validate license compliance after adding new capacity or features." ],
          "response_shape" : "LicenseReply",
          "workflow_guidance" : {
            "pre_check" : "Network connectivity available; License server accessible; Valid license configuration",
            "post_action" : "License status updated; Usage limits refreshed; Compliance status current"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "License server queries"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/license" ],
          "postprocessing_hint" : "Updated license information reflects current server status; check for any compliance warnings or usage limit changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/logs/export" : {
      "get" : {
        "summary" : "Export Logs",
        "operationId" : "VictoriaLogsResource_exportLogs",
        "tags" : [ "logs" ],
        "parameters" : [ {
          "description" : "The optional output format. `json` is the default VictoriaLogs output format, while the others represent `journalctl -o output` formats.",
          "name" : "format",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/ExportFormats"
          },
          "required" : true
        }, {
          "name" : "query",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/LogsQLRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Export VictoriaLogs data based on a LogsQL query for offline analysis.",
          "usage" : [ "Build a LogsQLRequest with desired filters and optional time range", "Call this endpoint on-demand when a user requests a zipped log export" ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Validate that the query JSON is well-formed and that requested servers exist.",
            "post_action" : "Store the returned download token and present a download link to the user."
          },
          "common_parameters" : {
            "query.limit" : "Limit response size to avoid enormous exports.",
            "query.where" : "Apply filters to shrink the dataset before export."
          },
          "default_values" : {
            "format" : "raw"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "retry_on_502",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Expensive log export"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "WS /logs", "/cluster/status" ],
          "postprocessing_hint" : "The response is a streaming ZIP; pipe it to disk before presenting to users.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Exports may contain sensitive audit data"
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/allow-standby-replay" : {
      "put" : {
        "summary" : "Enable or disable standby replay.",
        "operationId" : "MaintenanceResource_setAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Standby replay configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/StandbyReplaySetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable CephFS standby replay for the specified filesystem.",
          "usage" : [ "Turn on standby replay to improve failover times for CephFS clients.", "Disable standby replay when reducing resource usage or during troubleshooting." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "allowStandbyReplay",
            "in" : "body",
            "description" : "AllowStandbyReplay parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "cephFsName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "CephFS standby replay toggle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/allow-standby-replay", "/maintenance/max-mds" ],
          "postprocessing_hint" : "Sleep for a few seconds (as the method already does) then refresh GET /maintenance/allow-standby-replay to confirm.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the standby-replay setting (false if there is no cephfs)",
        "operationId" : "MaintenanceResource_getAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/StandbyReplaySetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose whether CephFS standby replay is enabled for the default filesystem.",
          "usage" : [ "Fetch when displaying the standby replay toggle in the CephFS settings.", "Re-query after PATCH /maintenance/allow-standby-replay to confirm the applied state." ],
          "response_shape" : "StandbyReplaySetting",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS flag read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/allow-standby-replay (PATCH)", "/maintenance/max-mds" ],
          "postprocessing_hint" : "If cephFsName is null, display the cluster default CephFS name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/backup" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFile",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup archive for offline storage.",
          "usage" : [ "Invoke when an administrator requests a manual backup download from the UI.", "Use before major maintenance to archive the current configuration." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/backup/basic-auth" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFileBasicAuth",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitUser"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup using Basic Auth credentials.",
          "usage" : [ "Trigger from automation scripts relying on Basic Auth to fetch configuration backups.", "Invoke before maintenance when API clients cannot supply bearer tokens." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/backup", "/maintenance/config-backups" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups" : {
      "patch" : {
        "summary" : "Configure cloud configuration backups.",
        "operationId" : "MaintenanceResource_setBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Backup configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloudConfigBackupConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable automatic offsite configuration backups.",
          "usage" : [ "Toggle cloud backups from the maintenance settings view.", "Disable backups temporarily before entering offline maintenance mode." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Configuration toggles"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "After turning backups on, prompt the administrator to immediately generate and store the encryption key.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if cloud configuration backups are enabled and working.",
        "operationId" : "MaintenanceResource_getBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CloudConfigBackupStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Describe whether cloud configuration backups are enabled and the metadata of the last successful run.",
          "usage" : [ "Fetch when opening the backup settings page to show current status.", "Refresh after enabling, disabling, or running a backup to display the latest timestamp and checksum." ],
          "response_shape" : "CloudConfigBackupStatus",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/config-backups (PATCH)", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Mask the backupEncryptionKey when presenting the data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/create" : {
      "post" : {
        "summary" : "Perform a cloud backup now.",
        "operationId" : "MaintenanceResource_runBackup",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an immediate cloud backup using the current encryption key.",
          "usage" : [ "Run after large configuration changes to capture the new state.", "Use when the UI indicates the last automatic backup failed." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "On-demand backup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Stream task progress to the UI and surface the resulting timestamp and checksum once finished.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/generate-new-key" : {
      "post" : {
        "summary" : "Generates a new crypto key used for all future backups.",
        "operationId" : "MaintenanceResource_regenerateKey",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate the encryption key used for cloud configuration backups.",
          "usage" : [ "Run after a key compromise to generate a fresh encryption key.", "Rotate keys during scheduled security maintenance before triggering new backups." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Key rotation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Display the new key UUID and instruct operators to download the key material immediately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/croit-auto-update" : {
      "get" : {
        "summary" : "Get croit auto-update parameters.",
        "operationId" : "MaintenanceResource_getCroitAutoUpdateConfig",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the configured croit auto-update schedule and registry overrides.",
          "usage" : [ "Fetch to pre-fill the auto-update configuration form.", "Re-query after PUT /maintenance/croit-auto-update or /maintenance/update-now to ensure settings persisted." ],
          "response_shape" : "CroitAutoUpdateConfigRequest",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update (PUT)", "/maintenance/update-now" ],
          "postprocessing_hint" : "Redact registry credentials before logging or persisting the response.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "put" : {
        "summary" : "Change croit auto-update parameters.",
        "operationId" : "MaintenanceResource_configureCroitAutoUpdate",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Croit auto-update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the automatic croit container update schedule and optional custom registry settings.",
          "usage" : [ "Enable scheduled updates after defining an appropriate maintenance window.", "Switch to a private registry or custom image tags for controlled rollouts." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "croitTag",
            "in" : "body",
            "description" : "CroitTag parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "custom",
            "in" : "body",
            "description" : "Custom parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "imageName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "registry",
            "in" : "body",
            "description" : "Registry parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "registryPassword",
            "in" : "body",
            "description" : "RegistryPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "registryUsername",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Auto-update scheduling"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/croit-auto-update", "/maintenance/update-now" ],
          "postprocessing_hint" : "Re-query GET /maintenance/croit-auto-update to verify the applied configuration.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/disable-cpu-idle-states" : {
      "put" : {
        "summary" : "Disable CPU idle states above set limit.",
        "operationId" : "MaintenanceResource_toggleHighPerformanceCPUMode",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "CPU idle state limit",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : [ "integer", "null" ],
                "format" : "int32"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the maximum allowed CPU idle state (C-state) to favor performance over power savings.",
          "usage" : [ "Enable high-performance mode on latency-sensitive clusters.", "Revert to default behaviour by sending null when the tuning window ends." ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "CPU tuning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/disable-cpu-idle-states", "/maintenance/update-now" ],
          "postprocessing_hint" : "Follow with GET /maintenance/disable-cpu-idle-states to show the applied value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if CPU idle states are disabled.",
        "operationId" : "MaintenanceResource_getIdleStates",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "integer",
                  "format" : "int32"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the configured CPU idle state limit for high performance mode.",
          "usage" : [ "Call when rendering the performance tuning page.", "Fetch again after PUT /maintenance/disable-cpu-idle-states to show the applied threshold." ],
          "response_shape" : "integer|null",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Lightweight configuration read"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/maintenance/disable-cpu-idle-states (PUT)" ],
          "postprocessing_hint" : "Display non-null values as the maximum allowed C-state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags" : {
      "get" : {
        "summary" : "Ceph cluster flag overview.",
        "operationId" : "MaintenanceResource_getClusterFlags",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFlagReponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate Ceph cluster flags alongside recommended and current states.",
          "usage" : [ "Call when rendering the Ceph flag management screen.", "Refresh after toggling a flag to confirm the updated cluster state." ],
          "response_shape" : "array<CephFlagReponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "UI refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/flags/{flag}/set", "/maintenance/flags/{flag}/unset" ],
          "postprocessing_hint" : "Highlight entries where currentState differs from recommendedState.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags/{flag}/set" : {
      "put" : {
        "summary" : "Set a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_setClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable a Ceph cluster flag (e.g. noout, norecover).",
          "usage" : [ "Put the cluster into a maintenance posture before planned hardware work.", "Rapidly toggle debug flags during incident response." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "flag",
            "in" : "path",
            "description" : "flag parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "flag",
            "in" : "path",
            "description" : "Ceph cluster flag name.",
            "required" : true,
            "example" : "noout"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 600,
            "note" : "Ceph flag toggles"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/flags", "/maintenance/flags/{flag}/unset" ],
          "postprocessing_hint" : "Re-query GET /maintenance/flags to confirm the flag state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/flags/{flag}/unset" : {
      "put" : {
        "summary" : "Unset a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_unsetClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable a previously set Ceph cluster flag.",
          "usage" : [ "Return the cluster to normal behaviour after maintenance.", "Switch off debug or throttling flags post-investigation." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "flag",
            "in" : "path",
            "description" : "flag parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "flag",
            "in" : "path",
            "description" : "Ceph cluster flag name.",
            "required" : true,
            "example" : "noout"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 600,
            "note" : "Ceph flag toggles"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/flags", "/maintenance/flags/{flag}/set" ],
          "postprocessing_hint" : "Check Ceph health once the flag is cleared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/max-mds" : {
      "put" : {
        "summary" : "Set the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_setMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Maximum MDS configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MaxMdsSetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust the CephFS max_mds value controlling the number of active metadata servers.",
          "usage" : [ "Increase max_mds when adding additional MDS daemons to scale read/write workloads.", "Lower max_mds after removing MDS servers or during troubleshooting." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "maxMds",
            "in" : "body",
            "description" : "MaxMds parameter",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "CephFS MDS scaling"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/allow-standby-replay", "/maintenance/max-mds" ],
          "postprocessing_hint" : "Monitor CephFS client health and re-fetch GET /maintenance/max-mds to confirm the new value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_getMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaxMdsSetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report the configured CephFS max_mds value (active MDS count).",
          "usage" : [ "Fetch when rendering the CephFS scaling settings.", "Refresh after PUT /maintenance/max-mds to ensure the new limit is in effect." ],
          "response_shape" : "MaxMdsSetting",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/max-mds (PUT)", "/maintenance/allow-standby-replay" ],
          "postprocessing_hint" : "Validate UI input to stay within the available MDS server count.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations" : {
      "get" : {
        "summary" : "Check which Ceph upgrades or container switches can be performed.",
        "operationId" : "MaintenanceResource_availableMigrations",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AvailableMigrationTasks"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Summarise which Ceph major upgrades or container switches are still available.",
          "usage" : [ "Fetch before presenting the upgrade wizard so only valid actions are shown.", "Re-query after completing an upgrade or container switch to refresh the UI state." ],
          "response_shape" : "AvailableMigrationTasks",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/migrations/{release}", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Use `switchTarget` to highlight the recommended container tag.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations/switch-container" : {
      "post" : {
        "summary" : "Switch to the correct croit container.",
        "operationId" : "MaintenanceResource_switchContainer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Switch the running croit container to the image required by the target Ceph release.",
          "usage" : [ "Invoke when GET /maintenance/migrations indicates a container switch is required before continuing upgrades.", "Use to realign container versions after manual changes." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Container switch"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/{release}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/migrations/{release}" : {
      "post" : {
        "summary" : "Perform a Ceph major version upgrade.",
        "operationId" : "MaintenanceResource_upgrade",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "release",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off a Ceph major upgrade to the specified release.",
          "usage" : [ "Upgrade Ceph to a newer supported release following the guided migration flow.", "Resume an interrupted upgrade by reissuing the same release once prerequisites are satisfied." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "release",
            "in" : "path",
            "description" : "release parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "release",
            "in" : "path",
            "description" : "Target Ceph release (e.g. quincy, reef).",
            "required" : true,
            "example" : "reef"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Ceph major upgrade"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Monitor the ManagedTask and validate cluster health after completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/min-compat-client" : {
      "put" : {
        "summary" : "Set the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_setMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Minimum compatible client version",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MinCompatClientVersion"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Raise or lower the minimum allowed Ceph client version (min-compat-client).",
          "usage" : [ "Enforce a newer client baseline before rolling out features that require it.", "Relax the requirement temporarily when supporting older clients during migrations." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "release",
            "in" : "body",
            "description" : "Release parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Client compatibility update"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/min-compat-client" ],
          "postprocessing_hint" : "Notify client owners about the new minimum version requirement.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_getMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephRelease"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the enforced minimum Ceph client release (min-compat-client).",
          "usage" : [ "Fetch when displaying the client compatibility settings.", "Refresh after PUT /maintenance/min-compat-client to verify the cluster accepted the change." ],
          "response_shape" : "CephRelease|null",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/min-compat-client (PUT)" ],
          "postprocessing_hint" : "Render releases using standard Ceph codenames.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd-full-ratios" : {
      "patch" : {
        "summary" : "Update OSD full ratios.",
        "operationId" : "MaintenanceResource_setOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "OSD full ratios update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdFullRatios"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust the Ceph OSD fullness thresholds (nearfull/backfillfull/full) to control when warnings and backfill throttling occur.",
          "usage" : [ "Tighten thresholds before maintenance to trigger earlier alerts.", "Relax thresholds temporarily during capacity expansions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "backfillfull",
            "in" : "body",
            "description" : "Backfillfull parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "full",
            "in" : "body",
            "description" : "Full parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "nearfull",
            "in" : "body",
            "description" : "Nearfull parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "OSD fullness tuning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/osd-full-ratios" ],
          "postprocessing_hint" : "After applying, monitor osd perf counters to ensure new thresholds behave as expected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get OSD full ratios.",
        "operationId" : "MaintenanceResource_getOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OsdFullRatios"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph OSD fullness thresholds (nearfull/backfillfull/full).",
          "usage" : [ "Call when rendering the OSD fullness configuration panel before allowing edits.", "Refresh immediately after PATCH /maintenance/osd-full-ratios to confirm the applied values." ],
          "response_shape" : "OsdFullRatios",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/osd-full-ratios (PATCH)" ],
          "postprocessing_hint" : "Convert decimals to percentages with two decimals before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd/{osdId}/deep-scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to deep-scrub all its PGs.",
        "operationId" : "MaintenanceResource_deepScrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request a deep scrub (byte-for-byte verification) for all PGs on a specific OSD.",
          "usage" : [ "Run after hardware incidents to validate data integrity.", "Supplement automatic deep scrubs for clusters with extended intervals." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "osdId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Manual deep scrubs"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/osd/{osdId}/scrub", "/pools/{name}/deep-scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/osd/{osdId}/scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to scrub all its PGs.",
        "operationId" : "MaintenanceResource_scrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request an immediate scrub for all placement groups hosted by a specific OSD.",
          "usage" : [ "Invoke after resolving data inconsistencies or performing disk maintenance.", "Trigger periodic manual scrubs for critical OSDs outside automatic scheduling." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "osdId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual OSD scrubs"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/osd/{osdId}/deep-scrub", "/pools/{name}/scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/reboot-all-servers" : {
      "post" : {
        "summary" : "Reboot all servers not running their configured image.",
        "operationId" : "MaintenanceResource_rebootServersToUpdateImage",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot every server that is not running its configured croit image to apply pending updates.",
          "usage" : [ "Execute after updating the default image to ensure all nodes boot the latest version.", "Use when maintenance tasks require a coordinated restart across the fleet." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Fleet-wide reboot"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/reboot", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "Monitor host status and service health once the task completes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/recovery-speed" : {
      "put" : {
        "summary" : "Set the recovery speed.",
        "description" : "This can be used to fine-tune the balance between client IOPS and data rebalancing.",
        "operationId" : "MaintenanceResource_setRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Recovery speed configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RecoverySpeed"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tune Ceph OSD recovery throttling using a normalized 1–10 scale (higher = faster recovery).",
          "usage" : [ "Slow down recovery during peak client traffic to preserve performance.", "Speed up rebalancing after large hardware events or OSD additions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "speed",
            "in" : "body",
            "description" : "Speed parameter",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Recovery speed tuning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/recovery-speed" ],
          "postprocessing_hint" : "Monitor recovery IOPS and client latency after changing the speed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the recovery speed.",
        "operationId" : "MaintenanceResource_getRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RecoverySpeed"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the effective Ceph recovery throttle speed normalised to the 1-10 slider.",
          "usage" : [ "Fetch when rendering the recovery speed configuration form.", "Re-query after updating the throttle to confirm the active value." ],
          "response_shape" : "RecoverySpeed",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Admin-only configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/recovery-speed (PUT)" ],
          "postprocessing_hint" : "Map `speed` to the UI slider; 10 represents the default fastest behaviour.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/restart-croit" : {
      "post" : {
        "summary" : "Restart the croit container. Will only work if the restart policy in docker has been configured correctly.",
        "operationId" : "MaintenanceResource_restartCroit",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger a restart of the croit management container.",
          "usage" : [ "Call after applying configuration updates that require a management restart.", "Monitor the returned ManagedTask to ensure the restart completes before issuing further API calls." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Management restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/update-now", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Use the ManagedTask id to poll /tasks/{id} and wait for completion before calling other management APIs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Restarting the management container interrupts active sessions and background jobs."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/schedulingTimezone" : {
      "patch" : {
        "summary" : "Update the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_patchSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Scheduling timezone update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SchedulingSettings"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the timezone used for scheduled maintenance jobs and cron-like tasks.",
          "usage" : [ "Align scheduled tasks with a new operations timezone after datacenter handover.", "Adjust cron execution times for daylight-saving or corporate policy changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "timezone",
            "in" : "body",
            "description" : "Timezone parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Scheduling configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/schedulingTimezone", "/maintenance/croit-auto-update" ],
          "postprocessing_hint" : "Update user documentation because cron expressions continue to run but interpreted in the new timezone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_getSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TimezoneSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide the timezone used for scheduled jobs along with available options.",
          "usage" : [ "Call to populate the scheduling timezone dropdown.", "Re-query after PATCH /maintenance/schedulingTimezone to confirm the new selection." ],
          "response_shape" : "TimezoneSettings",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Rare settings read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/schedulingTimezone (PATCH)" ],
          "postprocessing_hint" : "Use the `options` list to render a dropdown of valid timezones.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/update-now" : {
      "post" : {
        "summary" : "Check for updates now.",
        "operationId" : "MaintenanceResource_updateNow",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Immediately check for and apply available croit container updates.",
          "usage" : [ "Run after adjusting auto-update settings to validate connectivity and registry credentials.", "Trigger a one-off update outside the scheduled window." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Manual update trigger"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/croit-auto-update", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules" : {
      "get" : {
        "summary" : "List ceph mgr modules.",
        "operationId" : "MgrModuleResource_listModules",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephModuleStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available Ceph manager modules with their enabled/disabled status and capabilities.",
          "usage" : [ "Call when displaying the cluster module management interface.", "Use to check which modules are available before enabling specific functionality." ],
          "response_shape" : "CephModuleStatus",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Module status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/services", "/modules/dashboard/enable", "/modules/balancer/enable" ],
          "postprocessing_hint" : "Group modules by category; highlight enabled modules; show balancer status separately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/balancer/disable" : {
      "put" : {
        "summary" : "Toggle balancer module off.",
        "operationId" : "MgrModuleResource_disableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable the Ceph balancer module to stop automatic PG distribution optimization.",
          "usage" : [ "Call when manual control over PG placement is needed or during maintenance windows.", "Use to stop automatic balancing that may be impacting cluster performance." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Balancer module is currently enabled; Ceph manager is healthy",
            "post_action" : "Balancer module disabled; Automatic PG balancing stopped; Manual PG management required"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Module lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/balancer/enable", "/modules" ],
          "postprocessing_hint" : "PG distribution will remain static until balancer is re-enabled or manual ceph osd reweight commands are used.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/balancer/enable" : {
      "put" : {
        "summary" : "Toggle balancer module on.",
        "operationId" : "MgrModuleResource_enableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable the Ceph balancer module to automatically optimize PG distribution across OSDs.",
          "usage" : [ "Call after adding or removing OSDs to rebalance data distribution automatically.", "Use to enable automated PG balancing instead of manual intervention." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All clients support upmap feature; Ceph manager is healthy; No active balancing operations",
            "post_action" : "Balancer module enabled; Minimum client compatibility set to Luminous; Upmap mode activated"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Module lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/balancer/disable", "/modules" ],
          "postprocessing_hint" : "Monitor cluster performance during initial balancing; pre-Luminous clients will be disconnected.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling balancer will start automatic data movement and may disconnect pre-Luminous clients"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "operationId" : "MgrModuleResource_listCrashes",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "description" : "Include archived and old crashes (older than 2 weeks with default config)",
          "name" : "show-all",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMgrCrashReportEntry"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph daemon crash reports collected by the manager crash module for troubleshooting.",
          "usage" : [ "Call when investigating cluster health warnings related to daemon crashes.", "Use to monitor system stability and identify patterns in daemon failures." ],
          "response_shape" : "OptionalPaginationResponse<MgrCrashReportEntry>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Crash report queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/crashes/{crashId}", "/modules/crashes/archive-all", "/status" ],
          "postprocessing_hint" : "Sort by timestamp; highlight unarchived crashes that trigger health warnings; group by hostname for pattern analysis.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/archive-all" : {
      "post" : {
        "summary" : "Archive all recent crash reports, clearing all warnings.",
        "operationId" : "MgrModuleResource_archiveAllCrashReports",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Archive all unarchived Ceph daemon crash reports to clear health warnings.",
          "usage" : [ "Call after investigating crashes to clean up cluster health status.", "Use for bulk cleanup when multiple crashes have been addressed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Manager crash module is enabled; Cluster connectivity available",
            "post_action" : "All recent crashes archived; Health warnings cleared; Status cache updated"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Crash report management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/crashes", "/status" ],
          "postprocessing_hint" : "Check cluster health status to confirm warnings are cleared; archived crashes remain available for analysis.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This archives all crash reports and may hide important diagnostic information"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes/{crashId}" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "description" : "The return value is the raw json as reported by Ceph and may change with minor Ceph releases.",
        "operationId" : "MgrModuleResource_getCrashDetails",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed crash information for a specific Ceph daemon crash for debugging and analysis.",
          "usage" : [ "Call when investigating specific crashes to get stack traces and diagnostic details.", "Use for providing detailed crash data to Ceph support or for root cause analysis." ],
          "response_shape" : "object",
          "path_parameters" : [ {
            "name" : "crashId",
            "in" : "path",
            "description" : "crashId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "crashId",
            "in" : "path",
            "description" : "Crash ID from GET /modules/crashes to get details for.",
            "required" : true,
            "example" : "2023-09-19_08:42:36.123456Z_osd.3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Crash detail queries"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/modules/crashes", "/modules/crashes/{crashId}/archive" ],
          "postprocessing_hint" : "Parse stack trace for error patterns; extract relevant daemon and version info; raw JSON format may vary between Ceph versions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/{crashId}/archive" : {
      "post" : {
        "summary" : "Archive a crash report, clearing the Ceph health warning related to it.",
        "operationId" : "MgrModuleResource_archiveCrashReport",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Archive a specific Ceph daemon crash report to clear the associated health warning.",
          "usage" : [ "Call after investigating a crash to remove it from active health warnings.", "Use when individual crashes have been analyzed and no longer require attention." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Crash exists and is not already archived; Manager crash module enabled",
            "post_action" : "Crash marked as archived; Health warning cleared; Status cache updated"
          },
          "path_parameters" : [ {
            "name" : "crashId",
            "in" : "path",
            "description" : "crashId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "crashId",
            "in" : "path",
            "description" : "Crash ID from GET /modules/crashes to archive.",
            "required" : true,
            "example" : "2023-09-19_08:42:36.123456Z_osd.3"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Individual crash archival"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/crashes", "/modules/crashes/archive-all", "/status" ],
          "postprocessing_hint" : "Status cache is automatically updated; archived crash remains visible with show-all=true.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/disable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module off.",
        "operationId" : "MgrModuleResource_disableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable the Ceph manager dashboard module to shut down the web-based monitoring interface.",
          "usage" : [ "Call when disabling web access to Ceph dashboard for security or maintenance.", "Use to free up manager resources by disabling the dashboard module." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module is currently enabled; Ceph manager is healthy",
            "post_action" : "Dashboard module disabled; Web interface inaccessible; Manager resources freed"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Dashboard lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/enable", "/modules" ],
          "postprocessing_hint" : "Dashboard web interface will be unavailable; use CLI tools for cluster management.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/enable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module on.",
        "operationId" : "MgrModuleResource_enableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable the Ceph manager dashboard module with user migration and SSL configuration.",
          "usage" : [ "Call when setting up Ceph dashboard access for administrators and monitoring.", "Use to enable the built-in Ceph web interface with croit user integration." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Ceph manager is healthy; Dashboard module is available; User accounts exist",
            "post_action" : "Dashboard enabled; SSL disabled; Users migrated; Password policies disabled; Pseudo role created"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Dashboard lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/disable", "/modules/dashboard/users", "/modules/dashboard/roles" ],
          "postprocessing_hint" : "Monitor task for user migration results; dashboard accessible via manager; SSL disabled for DashboardProxy.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling dashboard will migrate croit users and disable SSL for proxy compatibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/roles" : {
      "get" : {
        "summary" : "List ceph mgr dashboard roles.",
        "operationId" : "MgrModuleResource_listDashboardRoles",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardRole"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available Ceph Dashboard roles with their permissions for user management.",
          "usage" : [ "Call when displaying role selection options during user creation or modification.", "Use to understand available permission sets before assigning roles to users." ],
          "response_shape" : "List<CephDashboardRole>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dashboard role queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/dashboard/roles/{rolename}", "/modules/dashboard/users" ],
          "postprocessing_hint" : "Hide reserved croit-import-pseudo-role from UI; group permissions by scope for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/roles/{rolename}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_updateDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing Ceph Dashboard role by adding or removing specific permissions.",
          "usage" : [ "Call when modifying role permissions without recreating the entire role.", "Use to fine-tune access control by adding or removing specific permission scopes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Role exists; Role not reserved; Add/delete operations don't conflict",
            "post_action" : "Role permissions updated; Changes immediately effective for all users with this role"
          },
          "request_parameters" : [ {
            "name" : "addPerms",
            "in" : "body",
            "description" : "AddPerms parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "delPerms",
            "in" : "body",
            "description" : "DelPerms parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "rolename parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name of the dashboard role to update (cannot be reserved).",
            "required" : true,
            "example" : "cluster-viewer"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/roles/{rolename}" ],
          "postprocessing_hint" : "Permission changes affect all users with this role immediately; users may need to refresh dashboard.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_deleteDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a custom Ceph Dashboard role to clean up unused permission sets.",
          "usage" : [ "Call when decommissioning custom roles that are no longer needed.", "Use to maintain a clean role hierarchy by removing obsolete permission sets." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "rolename parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name of the dashboard role to delete (cannot be croit-import-pseudo-role).",
            "required" : true,
            "example" : "custom-readonly"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard role management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/users" ],
          "postprocessing_hint" : "Verify removal by checking GET /modules/dashboard/roles; ensure no users are left without appropriate permissions.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting roles may affect user access permissions in Ceph Dashboard"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_addDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph Dashboard role with specified permissions for fine-grained access control.",
          "usage" : [ "Call when creating custom roles with specific permission sets for different user types.", "Use to implement role-based access control for dashboard functionality." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module enabled; Role name not reserved; Permission structure valid",
            "post_action" : "Dashboard role created; Role available for user assignment; Permissions active"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "Permissions parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "rolename parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name for the new dashboard role (cannot be reserved name).",
            "required" : true,
            "example" : "cluster-viewer"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Dashboard role management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/roles/{rolename}" ],
          "postprocessing_hint" : "Assign role to users via PUT/PATCH user endpoints; role takes effect immediately.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/users" : {
      "get" : {
        "summary" : "List ceph mgr dashboard users.",
        "operationId" : "MgrModuleResource_listDashboardUsers",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardUser"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph Dashboard user accounts with their roles and metadata.",
          "usage" : [ "Call when displaying the dashboard user management interface.", "Use to audit user access permissions and role assignments in Ceph Dashboard." ],
          "response_shape" : "List<CephDashboardUser>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dashboard user queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/dashboard/users/{username}", "/modules/dashboard/roles" ],
          "postprocessing_hint" : "Distinguish croit-imported users from manually created ones; display role assignments clearly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/users/{username}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_updateDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing Ceph Dashboard user's password, password hash, or role assignments.",
          "usage" : [ "Call when changing user passwords or modifying role assignments.", "Use to add/remove specific roles without replacing the entire role set." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Parameters are not conflicting; Dashboard module enabled",
            "post_action" : "User password/roles updated; Changes immediately effective; User can log in with new credentials"
          },
          "request_parameters" : [ {
            "name" : "addRoles",
            "in" : "body",
            "description" : "AddRoles parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "delRoles",
            "in" : "body",
            "description" : "DelRoles parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "passwordHash",
            "in" : "body",
            "description" : "PasswordHash parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "setRoles",
            "in" : "body",
            "description" : "SetRoles parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "username parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "username",
            "in" : "path",
            "description" : "Username of the dashboard user to update.",
            "required" : true,
            "example" : "dashboard-admin"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard user updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/users", "/modules/dashboard/users/{username}" ],
          "postprocessing_hint" : "Role changes are immediate; user may need to log out and back in to see new permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_deleteDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph Dashboard user account to revoke access (excludes croit-imported users).",
          "usage" : [ "Call when decommissioning dashboard-only user accounts.", "Use to clean up test or temporary accounts that are no longer needed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "username parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "username",
            "in" : "path",
            "description" : "Username of the dashboard user to delete (cannot delete croit-imported users).",
            "required" : true,
            "example" : "temp-user"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard user management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/users" ],
          "postprocessing_hint" : "Confirm removal with GET /modules/dashboard/users; user sessions will be invalidated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting users revokes their access to Ceph Dashboard permanently"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_addDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph Dashboard user account with the specified username and configuration.",
          "usage" : [ "Call when adding new administrators or users who need dashboard access.", "Use to create dashboard-specific user accounts separate from croit users." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module enabled; Username not conflicting with croit users; Valid password provided",
            "post_action" : "Dashboard user created; Random password generated if not provided; User available for role assignment"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "username parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "username",
            "in" : "path",
            "description" : "Username for the new dashboard user account.",
            "required" : true,
            "example" : "dashboard-admin"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Dashboard user management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/users", "/modules/dashboard/users/{username}" ],
          "postprocessing_hint" : "Assign roles to the new user; password is randomly generated if not specified in request.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/services" : {
      "get" : {
        "summary" : "List live ceph mgr module services.",
        "operationId" : "MgrModuleResource_listServices",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the live Ceph manager service endpoints (dashboard, REST API, etc.).",
          "usage" : [ "Display URLs for active mgr modules in the UI.", "Verify that mgr-managed services are reachable before automation proceeds." ],
          "response_shape" : "map<string,string>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Mgr service discovery"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules", "/modules/balancer" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics" : {
      "put" : {
        "summary" : "Configure ping metrics.",
        "operationId" : "PingResource_updateMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping metrics configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingMetricsConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure network ping metrics collection including enabling/disabling and setting target network.",
          "usage" : [ "Call when setting up network monitoring or changing which network to monitor.", "Use to enable/disable automatic ping collection between servers for performance tracking." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists (if specified); Servers have IP addresses in target network; ICMP allowed between servers",
            "post_action" : "Ping metrics collection enabled/disabled; Target network configured; Automatic pinging starts/stops"
          },
          "request_parameters" : [ {
            "name" : "enable",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "network",
            "in" : "body",
            "description" : "Network parameter",
            "required" : false,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Metrics configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/netping/metrics", "/netping/metrics/summary", "/networks" ],
          "postprocessing_hint" : "Monitor warnings for servers not found in target network; metrics appear in summary after collection interval.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling ping metrics will start regular ICMP traffic between servers which may impact network performance"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get ping metrics configuration.",
        "operationId" : "PingResource_getMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PingMetricsConfiguration"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current ping metrics collection configuration including enabled status and monitored network.",
          "usage" : [ "Call when displaying network monitoring settings in the UI.", "Use to check if ping metrics collection is active before requesting performance data." ],
          "response_shape" : "PingMetricsConfiguration",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Metrics configuration queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/netping/metrics", "/netping/metrics/summary" ],
          "postprocessing_hint" : "Show network name if configured; indicate collection status prominently in monitoring UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics/summary" : {
      "get" : {
        "summary" : "Get ping metrics summary.",
        "operationId" : "PingResource_getMetricsSummary",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/PingMetricsSummary"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve network latency and packet loss statistics between servers for performance analysis.",
          "usage" : [ "Call when displaying network performance dashboards or investigating connectivity issues.", "Use to identify network bottlenecks or problematic server connections." ],
          "response_shape" : "List<PingMetricsSummary>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Network performance queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/netping/metrics", "/netping/ping" ],
          "postprocessing_hint" : "Display as network topology heat map; highlight high latency or packet loss between server pairs.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/ping" : {
      "post" : {
        "summary" : "Ping hosts.",
        "operationId" : "PingResource_ping",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping parameters",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingParameters"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/PingResult"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute ICMP ping tests between servers to diagnose network connectivity issues.",
          "usage" : [ "Call when troubleshooting network connectivity problems between cluster nodes.", "Use to verify network performance before deploying new services or during maintenance." ],
          "response_shape" : "Map<Int, PingResult>",
          "workflow_guidance" : {
            "pre_check" : "Source and target servers exist; Network connectivity available; ICMP allowed",
            "post_action" : "Ping results returned with latency and packet loss statistics"
          },
          "request_parameters" : [ {
            "name" : "count",
            "in" : "body",
            "description" : "Number of items",
            "required" : true,
            "example" : "10"
          }, {
            "name" : "fromId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "network",
            "in" : "body",
            "description" : "Network parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "period",
            "in" : "body",
            "description" : "Period parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "toIds",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Network diagnostic operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/netping/metrics", "/networks" ],
          "postprocessing_hint" : "Analyze packet loss and latency for network performance; high loss or latency indicates connectivity issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/networks" : {
      "get" : {
        "summary" : "List all configured networks.",
        "operationId" : "NetworkResource_getNetworks",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNetworkInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all configured network segments and their settings for cluster communication and traffic segregation.",
          "usage" : [ "Call to display network configuration overview and validate network setup.", "Use for network planning and troubleshooting connectivity issues across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<NetworkInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Network configuration queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/networks/{id}", "/servers" ],
          "postprocessing_hint" : "Group networks by purpose (storage, management, client); highlight subnet conflicts; show DHCP status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new network",
        "operationId" : "NetworkResource_addNetwork",
        "tags" : [ "networks" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NetworkInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new network configuration for cluster communication, storage traffic, or management purposes.",
          "usage" : [ "Call when setting up network segregation for different traffic types (storage, management, client).", "Use to define network segments for cluster expansion or infrastructure organization." ],
          "response_shape" : "NetworkInfo",
          "workflow_guidance" : {
            "pre_check" : "IP range is valid; No network overlaps; DHCP service accessible; Network type appropriate",
            "post_action" : "Network created; DHCP server updated; Gateway configuration checked; Network available for assignment"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "gateway",
            "in" : "body",
            "description" : "Gateway parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "mtu",
            "in" : "body",
            "description" : "Mtu parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "netmask",
            "in" : "body",
            "description" : "Netmask parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "poolEnd",
            "in" : "body",
            "description" : "PoolEnd parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "poolStart",
            "in" : "body",
            "description" : "PoolStart parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Type parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Network configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/networks/{id}" ],
          "postprocessing_hint" : "Network is immediately available for server assignment; DHCP configuration updated automatically; gateway settings validated asynchronously.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/networks/{id}" : {
      "put" : {
        "summary" : "Replace a network, must provide the full network config",
        "operationId" : "NetworkResource_replaceNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Completely replace an existing network configuration with new settings and update DHCP server accordingly.",
          "usage" : [ "Call when network requirements change significantly and need complete reconfiguration.", "Use to update all network parameters including IP range, gateway, and DHCP settings in one operation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists; New configuration is valid; No network overlaps; DHCP service accessible",
            "post_action" : "Network configuration replaced; DHCP server updated; Gateway configuration checked; Network available for assignment"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "gateway",
            "in" : "body",
            "description" : "Gateway parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "mtu",
            "in" : "body",
            "description" : "Mtu parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "netmask",
            "in" : "body",
            "description" : "Netmask parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "poolEnd",
            "in" : "body",
            "description" : "PoolEnd parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "poolStart",
            "in" : "body",
            "description" : "PoolStart parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Type parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Network ID to replace configuration for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Network replacement operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/networks" ],
          "postprocessing_hint" : "Network changes are immediate; may affect server connectivity; DHCP configuration updated automatically; gateway settings validated asynchronously.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Network replacement affects all servers using this network and may disrupt connectivity"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a network by its ID",
        "operationId" : "NetworkResource_deleteNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a network configuration and update DHCP server to reflect the change.",
          "usage" : [ "Call when decommissioning network segments or consolidating network configurations.", "Use to clean up unused network definitions that are no longer part of the cluster architecture." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists; No active connections depend on this network; DHCP server accessible",
            "post_action" : "Network configuration removed; DHCP server updated; Task advisor recommendations refreshed"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Network ID to delete from the configuration.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Network configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/servers" ],
          "postprocessing_hint" : "DHCP server is automatically updated; task advisor checks network connectivity; verify cluster connectivity after deletion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting networks may affect cluster connectivity and server accessibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs" : {
      "get" : {
        "summary" : "List all PGs in a pool.",
        "operationId" : "PlacementGroupResource_getPgDetails",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephPgStat"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve status and statistics for all placement groups across all pools in the cluster.",
          "usage" : [ "Call to monitor placement group health and identify stuck or degraded PGs.", "Use for capacity planning and understanding data distribution across the cluster." ],
          "response_shape" : "PaginationResponse<CephPgStat>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "PG status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pgs/{pg}/details", "/cluster/status" ],
          "postprocessing_hint" : "Group PGs by state (active, degraded, stuck); highlight problematic PGs requiring attention; sort by pool for better organization.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/backfill" : {
      "post" : {
        "summary" : "Force backfill of a placement group",
        "operationId" : "PlacementGroupResource_forceBackfill",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force backfill operation to redistribute data in a placement group after OSD changes or rebalancing.",
          "usage" : [ "Call when data redistribution is stuck or needs prioritization after cluster changes.", "Use to expedite data movement when rebalancing is proceeding too slowly." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG needs rebalancing; Target OSDs available; Sufficient network bandwidth",
            "post_action" : "Backfill initiated; Data redistribution in progress; Network utilization increased"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to force backfill (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "Backfill operations (bandwidth intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/recover" ],
          "postprocessing_hint" : "Monitor backfill progress and network utilization; operation may take considerable time depending on data volume.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Force backfill will consume significant network bandwidth and may impact cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/deep-scrub" : {
      "post" : {
        "summary" : "Start deep scrubbing a placement group",
        "operationId" : "PlacementGroupResource_deepScrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate a deep scrub operation that reads all data from disk and verifies both checksums and replica consistency.",
          "usage" : [ "Call when thorough data verification is needed or after detecting data corruption.", "Use for comprehensive integrity checking that validates data on disk against replicas." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG exists; Cluster healthy; Sufficient I/O capacity; No ongoing scrub operations",
            "post_action" : "Deep scrub initiated; High I/O load expected; Comprehensive data verification in progress"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to deep scrub (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "Deep scrub operations (I/O intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/scrub" ],
          "postprocessing_hint" : "Monitor cluster performance during deep scrub; operation may take significant time; all data read from disk for verification.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deep scrub is I/O intensive and may impact cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/details" : {
      "get" : {
        "summary" : "Get detailed information about a placement group",
        "operationId" : "PlacementGroupResource_queryPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve comprehensive diagnostic information for a specific placement group including state, recovery progress, and OSD mapping.",
          "usage" : [ "Call when investigating specific PG issues or monitoring recovery operations.", "Use for detailed troubleshooting when PGs are stuck, degraded, or showing errors." ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID in format 'pool.pg' (e.g., '1.a3').",
            "required" : true,
            "example" : "1.a3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Detailed PG queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pgs", "/pgs/{pg}/scrub", "/pgs/{pg}/repair" ],
          "postprocessing_hint" : "Raw Ceph JSON format; extract key fields like state, recovery_progress, and acting OSDs; format varies by Ceph version.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/recover" : {
      "post" : {
        "summary" : "Force recovery of a placement group",
        "operationId" : "PlacementGroupResource_forceRecovery",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force recovery of a placement group that is stuck in an incomplete or degraded state.",
          "usage" : [ "Call when a PG is stuck in recovery and standard recovery mechanisms have failed.", "Use as last resort to restore access to data when automatic recovery is blocked." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG is stuck in recovery; Standard recovery failed; Admin understands potential data loss risk",
            "post_action" : "Recovery forced; PG may become active; Potential data loss if insufficient replicas"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to force recovery (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Force recovery operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/backfill" ],
          "postprocessing_hint" : "Monitor PG status after force recovery; verify data accessibility; may need follow-up repair operations.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Force recovery may result in data loss if insufficient healthy replicas exist"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/repair" : {
      "post" : {
        "summary" : "Repair a placement group",
        "operationId" : "PlacementGroupResource_repairPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Repair inconsistencies in a placement group by rebuilding corrupted or missing objects from replicas.",
          "usage" : [ "Call when scrub operations detect inconsistencies that need correction.", "Use to fix data corruption or replica mismatches in a specific placement group." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG has detected inconsistencies; Sufficient healthy replicas available; Cluster stable",
            "post_action" : "Repair operation initiated; Corrupted objects rebuilt; Data consistency restored"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to repair (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "PG repair operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/scrub" ],
          "postprocessing_hint" : "Monitor repair progress in PG status; verify data consistency after completion; may involve significant I/O activity.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Repair operations modify data and may impact application performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/scrub" : {
      "post" : {
        "summary" : "Start scrubbing a placement group",
        "operationId" : "PlacementGroupResource_scrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate a scrub operation on a placement group to verify data integrity by checking object checksums.",
          "usage" : [ "Call when investigating data integrity issues or performing routine maintenance checks.", "Use to verify object consistency and detect silent data corruption in a specific PG." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG exists; Cluster healthy; No ongoing deep-scrub on same PG",
            "post_action" : "Scrub operation initiated; Progress visible in PG status; Inconsistencies reported if found"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "pg parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to scrub (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 600,
            "note" : "PG maintenance operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/deep-scrub" ],
          "postprocessing_hint" : "Monitor PG status for scrub completion; scrub may take time depending on data volume; inconsistencies logged if detected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools" : {
      "get" : {
        "summary" : "List all pools.",
        "operationId" : "PoolResource_getPools",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephPoolResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph storage pools with capacity, protection and usage stats.",
          "usage" : [ "Populate the pool overview grid before drilling into details", "Refresh periodically when monitoring utilization or pool flags" ],
          "response_shape" : "OptionalPaginationResponse<CephPoolResponse>",
          "common_parameters" : {
            "pagination.limit" : "Limit results on large clusters to keep responses manageable.",
            "pagination.where" : "Filter by deleteProtected or application before executing actions."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{name}/details", "/pools/{name}/compression", "/stats/pool-names" ],
          "postprocessing_hint" : "Derive warning badges for pools with erasureCodingOverwriteSupportMissing or nearing quotas.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a pool.",
        "operationId" : "PoolResource_createPool",
        "tags" : [ "ceph-pools" ],
        "requestBody" : {
          "description" : "Pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new Ceph pool with optional erasure coding, quotas, and CRUSH rule adjustments.",
          "usage" : [ "Call when onboarding new application workloads requiring dedicated pools.", "Follow up with GET /pools to confirm quotas, size, and application flags." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "application",
            "in" : "body",
            "description" : "Application parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "compression",
            "in" : "body",
            "description" : "Compression parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "crushRule",
            "in" : "body",
            "description" : "CrushRule parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "dataChunks",
            "in" : "body",
            "description" : "DataChunks parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "ErasureCoding parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "fastRead",
            "in" : "body",
            "description" : "FastRead parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "minSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "parityChunks",
            "in" : "body",
            "description" : "ParityChunks parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "PgNum parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "quotaMaxBytes",
            "in" : "body",
            "description" : "QuotaMaxBytes parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "quotaMaxObjects",
            "in" : "body",
            "description" : "QuotaMaxObjects parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "unprotect",
            "in" : "body",
            "description" : "Unprotect parameter",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Pool provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}", "/crush" ],
          "postprocessing_hint" : "If creating an EC pool, verify allow_ec_overwrites succeeded in the ManagedTask logs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating pools impacts cluster placement groups and storage utilization."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/all-infos" : {
      "get" : {
        "summary" : "Get mirror infos on all pools.",
        "operationId" : "RbdMirrorResource_getAllPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Aggregate mirroring status for every pool with mirroring enabled.",
          "usage" : [ "Show the global mirroring overview dashboard.", "Run before bulk configuration changes to confirm current peer connectivity." ],
          "response_shape" : "array<RbdMirrorPoolInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Pool mirror inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/rbd-mirror/schedules" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/schedules" : {
      "get" : {
        "summary" : "Get mirror snapshot schedules of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getSnapshotSchedules",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured RBD mirror snapshot schedules across pools and namespaces",
          "usage" : [ "Review current snapshot scheduling configuration", "Audit mirroring automation settings", "Identify scheduled replication intervals" ],
          "response_shape" : "List<RbdMirrorSnapshotSchedule>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Schedule listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Schedules apply at pool, namespace, or image level; check granularity for each entry.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a schedule for RBD mirror snapshots. Call this endpoint with the same request body as when adding a schedule (via POST). The task returned by this endpoint will not provide information on whether or not a schedule was removed. To check if deletion was successful, request the list of schedules and check for any changes.",
        "operationId" : "RbdMirrorResource_deleteSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a snapshot mirroring schedule at pool/image/namespace granularity.",
          "usage" : [ "Clean up schedules after converting images away from snapshot-based mirroring.", "Remove erroneously configured intervals prior to creating new ones." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "interval",
            "in" : "body",
            "description" : "Interval parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Rbd parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "startTime",
            "in" : "body",
            "description" : "StartTime parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror schedule management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/rbd-mirror/schedules (POST)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new schedule for rbd mirror snapshots.",
        "operationId" : "RbdMirrorResource_createSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "description" : "Snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a snapshot mirroring schedule scoped to a pool, namespace, or individual image.",
          "usage" : [ "Automate regular snapshot creation for mirroring to remote clusters.", "Set up per-image schedules when different intervals are required." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "interval",
            "in" : "body",
            "description" : "Interval parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Rbd parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "startTime",
            "in" : "body",
            "description" : "StartTime parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror schedule management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/rbd-mirror/schedules (DELETE)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}" : {
      "patch" : {
        "summary" : "Update pool flags.",
        "operationId" : "PoolResource_updatePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update pool metadata, quotas, or replication settings without recreating the pool.",
          "usage" : [ "Adjust pg_num, quotas, or CRUSH rules during capacity planning.", "Rename pools or toggle delete protection after confirming migration plans." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "application",
            "in" : "body",
            "description" : "Application parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "compression",
            "in" : "body",
            "description" : "Compression parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "crushRule",
            "in" : "body",
            "description" : "CrushRule parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "dataChunks",
            "in" : "body",
            "description" : "DataChunks parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "ErasureCoding parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "fastRead",
            "in" : "body",
            "description" : "FastRead parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "minSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "parityChunks",
            "in" : "body",
            "description" : "ParityChunks parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "PgNum parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "quotaMaxBytes",
            "in" : "body",
            "description" : "QuotaMaxBytes parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "quotaMaxObjects",
            "in" : "body",
            "description" : "QuotaMaxObjects parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "unprotect",
            "in" : "body",
            "description" : "Unprotect parameter",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Current pool name.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Pool configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Monitor ceph health for remapping/backfill and refresh GET /pools to confirm updated stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete pool.",
        "operationId" : "PoolResource_deletePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph pool after confirming it no longer holds important data.",
          "usage" : [ "Call once all data is migrated away and the pool is unprotected (include the confirmation token).", "Monitor ceph health after deletion to ensure PGs return to active/clean state." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "poolId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "ThisWillDeleteData parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name to remove.",
            "required" : true,
            "example" : "rbd-old"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Pool deletion risk"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/s3/buckets" ],
          "postprocessing_hint" : "Watch ceph health and PG states for the affected pool until no longer listed.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting a pool irreversibly removes data and affects the CRUSH map."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/compression" : {
      "get" : {
        "summary" : "Get pool compression info.",
        "operationId" : "PoolResource_getCompressionSettings",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PoolCompressionSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve compression settings for a specific pool to validate configuration.",
          "usage" : [ "Open the compression settings dialog before editing", "Check current values after updating compression policies" ],
          "response_shape" : "PoolCompressionSettings",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool configuration viewing"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{name}", "/pools" ],
          "postprocessing_hint" : "Display human-readable algorithm labels using PoolCompressionAlgorithm.cephName.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/deep-scrub" : {
      "post" : {
        "summary" : "Add pool to deep scrub queue.",
        "operationId" : "PoolResource_deepScrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a deep scrub for the pool to read and verify all data blocks.",
          "usage" : [ "Trigger after hardware issues or inconsistent PGs to perform a thorough validation.", "Schedule less frequent deep scrubs on mission-critical pools between maintenance windows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for deep scrub.",
            "required" : true,
            "example" : "ec-archive"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Deep scrub scheduling"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Watch ceph health detail for deep-scrub progress and follow up on any reported inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/details" : {
      "get" : {
        "summary" : "Get pool details.",
        "operationId" : "PoolResource_getPoolDetails",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose raw Ceph pool detail JSON for diagnostics and advanced tooling.",
          "usage" : [ "Fetch when the admin opens the pool detail drawer", "Use in support bundles or advanced troubleshooting" ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Detailed pool inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Render only relevant fields and hide sensitive Ceph internals in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/enable-ec-overwrites" : {
      "post" : {
        "summary" : "Enable the ec_overwrites flag for the pool.",
        "description" : "croit tries to enable this when creating the pool, however, this may fail if there are non-Bluestore OSDs. Pools that should have this flag but don't can be identified by the field 'erasureCodingOverwriteSupportMissing'.",
        "operationId" : "PoolResource_enableEcOverwrites",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable Ceph erasure-coded overwrites so the pool can host RBD or CephFS workloads.",
          "usage" : [ "Run after upgrading legacy OSDs when the UI shows erasureCodingOverwriteSupportMissing=true.", "Execute immediately after creating an EC pool if the automatic flag enable failed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools.",
            "required" : true,
            "example" : "ec-data"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "EC overwrite toggles"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{name}", "/pools/{name}/details" ],
          "postprocessing_hint" : "Refresh GET /pools/{name} to confirm erasureCodingOverwriteSupportMissing cleared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/scrub" : {
      "post" : {
        "summary" : "Add pool to scrub queue.",
        "operationId" : "PoolResource_scrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a standard scrub for the pool to validate replica consistency.",
          "usage" : [ "Run after resolving object errors to force Ceph to rescan the pool.", "Schedule periodic health checks for critical pools outside the automatic window." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for scrubbing.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Manual pool scrubs"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Monitor ceph health detail until the scrub completes without new inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a pool and optional namespace.",
        "operationId" : "PoolRbdResource_forceCacheUpdate",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for a specific namespace within the pool.",
          "usage" : [ "Refresh cached metadata after editing images in a single tenant namespace.", "Call after restoring from backup scripts that bypass croit caching." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the namespace.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 3600,
            "note" : "Namespace cache invalidation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbd-namespaces" ],
          "postprocessing_hint" : "Issue a GET with details=true to rebuild cache entries on demand.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update-all" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for pool including all namespaces.",
        "operationId" : "PoolRbdResource_forceCacheUpdateAll",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on (including all of its namespaces)",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for all namespaces in the pool.",
          "usage" : [ "Force croit to refresh image metadata after bulk CLI changes.", "Clear stale size/feature information before audits." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose cache should be flushed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Cache invalidation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "postprocessing_hint" : "Follow with GET requests to rebuild the cache for affected workloads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/qos" : {
      "post" : {
        "summary" : "Set qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_setPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Apply or update QoS limits for an entire RBD pool.",
          "usage" : [ "Throttle IOPS/BPS for all images in a pool with shared workloads.", "Restore defaults by submitting commands with null/0 limits to remove overrides." ],
          "response_shape" : "array<QosCommandAppliedResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose QoS should be adjusted.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/qos", "/pools/{pool}/rbds/{rbd}/qos" ],
          "postprocessing_hint" : "Retrieve GET /pools/{pool}/qos to verify each command's result.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_listPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve QoS (Quality of Service) limits configured for a pool",
          "usage" : [ "Display current IOPS and bandwidth limits for a pool", "Check QoS configuration before modifying limits" ],
          "response_shape" : "List<QosCommandsResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to query QoS settings",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "QoS query"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{pool}/qos (POST)", "/pools/{pool}/qos (DELETE)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_deletePoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove previously configured pool-level QoS limits for all images in the pool.",
          "usage" : [ "Reset QoS settings before applying new limits across the pool.", "Clear inherited limits when migrating to per-image QoS policies." ],
          "response_shape" : "QosCommandAppliedResponse",
          "request_parameters" : [ {
            "name" : "command",
            "in" : "body",
            "description" : "Command parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "limit",
            "in" : "body",
            "description" : "Limit parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose QoS limit should be removed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/qos", "/pools/{pool}/rbds/{rbd}/qos" ],
          "postprocessing_hint" : "Fetch GET /pools/{pool}/qos to confirm the command is absent.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update a pool's mirroring settings.",
        "operationId" : "RbdMirrorResource_updatePoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to update.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Pool mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RBD mirroring mode for a pool (disabled/pool/image)",
          "usage" : [ "Enable or disable mirroring for an entire pool", "Switch between pool-based and image-based mirroring modes" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Check for existing peers and mirrored images before disabling",
            "post_action" : "Monitor task for any image-level conflicts when changing modes"
          },
          "request_parameters" : [ {
            "name" : "poolMirrorMode",
            "in" : "body",
            "description" : "PoolMirrorMode parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to update mirroring for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing mirror modes affects data replication"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a pool's mirroring settings for all namespaces.",
        "operationId" : "RbdMirrorResource_getPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to get mirror settings of.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional RBD namespace, or the default namespace if null.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect mirroring configuration and peer status for a single pool/namespace.",
          "usage" : [ "Drill into a pool's mirroring state before adjusting settings.", "Confirm mirror health when troubleshooting replication issues." ],
          "response_shape" : "RbdMirrorPoolInfo",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to inspect.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Per-pool mirror inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/token", "/pools/{pool}/rbd-mirror/peers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/journaling" : {
      "post" : {
        "summary" : "Enable/Disable journaling for all images not in snapshot mode in the pool.",
        "operationId" : "RbdMirrorResource_updatePoolJournalingSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool with the images.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional).",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Journaling update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdJournalingUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Toggle journaling on all non-snapshot mirrored images within a pool.",
          "usage" : [ "Enable journaling before switching a pool to journal-based mirroring.", "Disable journaling to improve performance once snapshot mode is in use." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "enableJournaling",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose images should be updated.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Pool journaling toggle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "postprocessing_hint" : "Review the task log for per-image errors and request a resync if needed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers" : {
      "post" : {
        "summary" : "Add a pool peer using the bootstrap token from a remote cluster.",
        "operationId" : "RbdMirrorResource_addPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Import an RBD mirroring peer into the pool using a bootstrap token.",
          "usage" : [ "Set up bi-directional mirroring between clusters by applying the remote token.", "Re-add a peer after cleaning up mismatched keys or changing site names." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "direction",
            "in" : "body",
            "description" : "Direction parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "localSiteName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "peerToken",
            "in" : "body",
            "description" : "PeerToken parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "siteName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool that should mirror to the remote peer.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Peer onboarding"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers/{id}", "/pools/{pool}/rbd-mirror/token" ],
          "postprocessing_hint" : "Restart rbd-mirror daemons if necessary and verify the peer appears in GET /pools/{pool}/rbd-mirror.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers/{id}" : {
      "patch" : {
        "summary" : "Change pool peer settings. These changes only take effect after restarting the rbd-mirror daemon service.",
        "operationId" : "RbdMirrorResource_updatePoolPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RBD mirroring peer configuration for a pool",
          "usage" : [ "Modify peer connection settings after initial setup", "Change mirroring direction (rx-only/tx-only/rx-tx)", "Update peer authentication credentials" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify peer exists and Octopus+ for direction changes",
            "post_action" : "Restart rbd-mirror daemon service for changes to take effect"
          },
          "request_parameters" : [ {
            "name" : "client",
            "in" : "body",
            "description" : "Client parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "direction",
            "in" : "body",
            "description" : "Direction parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "monHosts",
            "in" : "body",
            "description" : "MonHosts parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "siteName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name with the peer",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Peer global UUID",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Restart rbd-mirror daemon after changes",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a specific peer mirroring cluster from a pool.",
        "operationId" : "RbdMirrorResource_deletePoolMirrorPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool containing the peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a configured RBD mirroring peer from a pool.",
          "usage" : [ "Call when retiring a remote cluster from mirroring.", "Clean up misconfigured peers before adding correct settings." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose peer should be removed.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Global peer UUID to delete.",
            "required" : true,
            "example" : "3cf9834e-9d34-4e3e-8b39-4bbdcf3c4a59"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror peer management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers", "/pools/{pool}/rbd-mirror/peers (POST)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/token" : {
      "patch" : {
        "summary" : "Change the site name of the pool.",
        "operationId" : "RbdMirrorResource_updatePoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to set the site name.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Site name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSiteNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update the site name identifier for RBD mirroring pool",
          "usage" : [ "Set meaningful site name for cluster identification in mirroring", "Update site name when cluster role or location changes" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "siteName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to update site name for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/token" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the bootstrap token to set up a peer for the pool. This token can be imported on a peer cluster to automatically set up a connection between the two clusters to mirror the pool. Note that the token contains sensitive information about your cluster!\n\nWill return null if anything fails while trying to create the token (e.g. mirroring is not enabled on the pool).",
        "operationId" : "RbdMirrorResource_getPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to generate a token for.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate bootstrap token for setting up RBD mirroring peer connection",
          "usage" : [ "Exchange tokens between clusters to establish mirroring", "Initial setup of cross-cluster replication", "Provide to remote cluster administrators" ],
          "response_shape" : "String?",
          "workflow_guidance" : {
            "pre_check" : "Pool exists; Mirroring enabled; Admin permissions confirmed",
            "post_action" : "Token generated containing cluster connection details; Share securely with peer administrator"
          },
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to generate token for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Token generation for peer setup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "postprocessing_hint" : "Token contains sensitive information; transmit securely to peer cluster administrator.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Token contains sensitive cluster information and should be handled securely"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-namespaces" : {
      "get" : {
        "summary" : "List all existing RBD namespaces",
        "operationId" : "RbdNamespaceResource_listRbdNamespaces",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNamespace"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List namespaces available within an RBD pool.",
          "usage" : [ "Discover namespaces before provisioning images for a tenant.", "Refresh after creating or deleting namespaces to update UI selections." ],
          "response_shape" : "array<RbdNamespace>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose namespaces should be listed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Namespace discovery"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces/{namespace}", "/pools/{pool}/rbds" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{pool}/rbd-namespaces/{namespace}" : {
      "delete" : {
        "summary" : "Delete a RBD namespace",
        "operationId" : "RbdNamespaceResource_deleteRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an empty RBD namespace from the pool.",
          "usage" : [ "Clean up deprecated namespaces after migrating images to a new structure.", "Delete temporary namespaces once automation has drained them." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "namespace parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to remove.",
            "required" : true,
            "example" : "vm"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Namespace cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbd-namespaces to confirm the namespace disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new RBD namespace",
        "operationId" : "RbdNamespaceResource_createRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a dedicated namespace within a pool to group related RBD images.",
          "usage" : [ "Call during tenant onboarding to isolate their images.", "Create staging namespaces before cloning golden images for tests." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "namespace parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool that will contain the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to create.",
            "required" : true,
            "example" : "tenant-a"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Namespace creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Immediately refresh the namespace list or create initial images within the new namespace.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds" : {
      "get" : {
        "summary" : "List all RBDs including their details in a pool",
        "operationId" : "PoolRbdResource_listRbdImages",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images in a pool (optionally including details) for inventory or UI browsing.",
          "usage" : [ "Populate pool detail views before selecting an image to manage.", "Page through RBDs when auditing capacity or identifying stale images." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Name of the pool containing the images.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "RBD inventory"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new RBD",
        "operationId" : "PoolRbdResource_createRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdImageCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new RBD image within the selected pool (optionally creating the namespace).",
          "usage" : [ "Provision a backing volume for a VM or application before mapping it to clients.", "Bootstrap automation that prepares RBDs for NVMe-oF or iSCSI exports." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "erasureCodedPool",
            "in" : "body",
            "description" : "ErasureCodedPool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "features",
            "in" : "body",
            "description" : "Features parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Target pool for the image.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "Trigger GET /pools/{pool}/rbds with details=true to confirm the image appears with correct features.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}" : {
      "patch" : {
        "summary" : "Change properties of an existing RBD image.",
        "operationId" : "PoolRbdResource_updateRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Details to be changed",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust metadata of an existing RBD image (rename, grow, or toggle features).",
          "usage" : [ "Increase image size after storage expansion.", "Rename an image before migrating clients to a new naming scheme.", "Enable features such as object-map or fast-diff after ensuring client compatibility." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "features",
            "in" : "body",
            "description" : "Features parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Current image name.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "RBD metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Force an RBD cache refresh for the image and notify dependent services of name changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get details of a specific RBD image (not cached)",
        "operationId" : "PoolRbdResource_rbdDetails",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve up-to-date details for a specific RBD image, bypassing caches when necessary.",
          "usage" : [ "Inspect features, mirroring status, and snapshots before performing maintenance.", "Verify image metadata immediately after updates to confirm changes took effect." ],
          "response_shape" : "RbdImageResponse",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to retrieve.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Image detail lookup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an existing RBD image",
        "operationId" : "PoolRbdResource_rbdDelete",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the RBD to delete",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD deletion request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RBD image after validating confirmations and dependencies.",
          "usage" : [ "Remove retired images once snapshots are purged and consumers are detached.", "Automate cleanup workflows after migrating workloads to a new pool." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "ThisWillDeleteData parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name to delete.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RBD deletions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Stream the ManagedTask output to the UI and refresh GET /pools/{pool}/rbds once it finishes.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting an RBD image permanently removes all data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a single RBD image.",
        "operationId" : "PoolRbdResource_forceCacheUpdateRbd",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate cached metadata for a single RBD image.",
          "usage" : [ "Clear stale size or feature info after manual rbd CLI operations.", "Use during troubleshooting when the UI shows outdated data for one image." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name being refreshed.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 3600,
            "note" : "Image cache invalidation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Next GET request will reconstruct the cache entry; avoid back-to-back invalidations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/flatten" : {
      "post" : {
        "summary" : "Flatten a clone, making it independent of its parent. Flattening happens in the background and may take hours to complete.",
        "operationId" : "PoolRbdResource_flattenRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a background flattening job to detach a clone from its parent snapshot.",
          "usage" : [ "Run before deleting or expiring the parent snapshot chain.", "Reduce read amplification on steady-state clones kept long term." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the clone.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Clone image name to flatten.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Clone flatten operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Wait for the ManagedTask to complete and then verify the parent snapshot can be safely removed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/qos" : {
      "post" : {
        "summary" : "Set qos limits of an image.",
        "operationId" : "QosRbdSettingResources_setRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure QoS limits on a specific RBD image, optionally overriding pool defaults.",
          "usage" : [ "Throttle noisy tenants by applying per-image IOPS/BPS caps.", "Remove overrides by sending commands with null/0 limit values." ],
          "response_shape" : "array<QosCommandAppliedResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to configure.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos", "/pools/{pool}/qos" ],
          "postprocessing_hint" : "Call GET /pools/{pool}/rbds/{rbd}/qos to confirm applied limits and inherited values.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of an image.",
        "operationId" : "QosRbdSettingResources_listRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve QoS limits configured for a specific RBD image",
          "usage" : [ "Display per-image IOPS and bandwidth limits", "Compare image QoS settings with pool defaults" ],
          "response_shape" : "List<QosCommandsResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-001"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "QoS query"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos (POST)", "/pools/{pool}/rbds/{rbd}/qos (DELETE)", "/pools/{pool}/qos" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limit of an image.",
        "operationId" : "QosRbdSettingResources_deleteRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific QoS limit from an RBD image (optionally scoped by namespace).",
          "usage" : [ "Clear overrides before inheriting pool-wide QoS policies.", "Reset an image to unlimited IOPS/BPS after finishing migration tests." ],
          "response_shape" : "QosCommandAppliedResponse",
          "request_parameters" : [ {
            "name" : "command",
            "in" : "body",
            "description" : "Command parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "limit",
            "in" : "body",
            "description" : "Limit parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name whose QoS is being cleared.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos", "/pools/{pool}/qos" ],
          "postprocessing_hint" : "Re-run GET /pools/{pool}/rbds/{rbd}/qos to verify the command is absent.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update RBD mirroring settings for the image.",
        "operationId" : "RbdMirrorResource_updateImageMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to update.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Image mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorImageUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure RBD image-level mirroring settings",
          "usage" : [ "Enable/disable mirroring for specific RBD images", "Switch between journal and snapshot mirroring modes", "Configure mirroring schedule for snapshot mode" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify pool mirror mode, image features, and Ceph version compatibility",
            "post_action" : "Monitor task for feature enablement and mode changes"
          },
          "request_parameters" : [ {
            "name" : "imageMirrorMode",
            "in" : "body",
            "description" : "ImageMirrorMode parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "journaling",
            "in" : "body",
            "description" : "Journaling parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "primary",
            "in" : "body",
            "description" : "Primary parameter",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-001"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changes affect image replication behavior"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/resync" : {
      "post" : {
        "summary" : "Force a RBD mirroring resync on the image. Note that this only flags the image, it's up to the rbd-mirror daemon to execute the resync.",
        "operationId" : "RbdMirrorResource_resyncImage",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to resync.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request a re-synchronization of a mirrored RBD image with its remote peer.",
          "usage" : [ "Trigger after recovering from divergence on a secondary image.", "Flag an image for resync when the remote copy may be stale." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to resync.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror maintenance"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror", "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots" : {
      "get" : {
        "summary" : "Get mirror snapshots of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getImageSnapshots",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshot"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List mirror snapshots for a specific RBD image configured for snapshot-based mirroring",
          "usage" : [ "Review available recovery points for mirrored images", "Audit snapshot history for specific images", "Check mirroring progress" ],
          "response_shape" : "List<RbdMirrorSnapshot>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the RBD image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-01"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Image snapshot listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Snapshots are ordered by creation time; use for point-in-time recovery planning.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a mirror snapshot of the image",
        "operationId" : "RbdMirrorResource_createImageSnapshot",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a mirroring snapshot for an image configured in snapshot mode.",
          "usage" : [ "Generate an on-demand snapshot to seed mirroring prior to scheduled runs.", "Create recovery points before maintenance on mirrored workloads." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to snapshot.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Mirror snapshot operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror", "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}" : {
      "patch" : {
        "summary" : "Update an existing snapshot of an image.",
        "operationId" : "PoolRbdResource_updateRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to update",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to update",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rename or change protection status for an existing RBD snapshot.",
          "usage" : [ "Protect snapshots before exposing clones to prevent accidental deletion.", "Rename snapshots to follow retention policies after automation triggers." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "protect",
            "in" : "body",
            "description" : "Protect parameter",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "snap parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Current snapshot name.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Re-fetch snapshot details to confirm the new name or protection status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a snapshot of an image.",
        "operationId" : "PoolRbdResource_deleteRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to delete",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RBD snapshot to free storage or allow subsequent image deletion.",
          "usage" : [ "Clean up snapshots after confirming they are no longer needed for rollback.", "Run before deleting the parent image, because deletions require all snapshots to be gone." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "snap parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to delete.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Snapshot deletions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbds/{rbd} to verify the snapshot list updated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new snapshot of an image.",
        "operationId" : "PoolRbdResource_createRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to snapshot",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the new snapshot",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a point-in-time snapshot for an RBD image.",
          "usage" : [ "Take an application-consistent snapshot prior to maintenance or upgrade steps.", "Capture a base image before cloning it to new environments." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "snap parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the source image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to snapshot.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to create.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "List snapshots to confirm creation and consider protecting it if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" : {
      "post" : {
        "summary" : "Create a clone of a snapshot on an existing image.",
        "operationId" : "PoolRbdResource_createRbdClone",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to clone",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot to clone",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Clone creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloneRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clone an RBD snapshot into a writable image, optionally in another pool or namespace.",
          "usage" : [ "Provision a new VM from a golden snapshot without copying data.", "Create point-in-time test environments while keeping linkage to the parent image." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "pool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "rbd parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "snap parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Source pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Source image name.",
            "required" : true,
            "example" : "golden-template"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to clone.",
            "required" : true,
            "example" : "2024-01-01"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD clone operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "List the destination pool to confirm the clone appears and schedule flattening if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/rbds" : {
      "get" : {
        "summary" : "List all RBD details in all pools",
        "operationId" : "RbdResource_listAllRbds",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images with size, mirroring, and feature details across all pools/namespaces.",
          "usage" : [ "Call to populate RBD inventory tables in the UI.", "Refresh after provisioning or deleting RBDs to ensure cached details are current." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "common_parameters" : {
            "pagination.limit" : "Set limit <=100 to avoid large ceph-volume dumps.",
            "pagination.where.namespace" : "Filter by namespace when browsing multi-tenant pools."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "RBD inventory refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds/rbd-names", "/rbds/rbd-infos", "/rbds/rbd-pools" ],
          "postprocessing_hint" : "If withDetails=false, schedule detail fetches for visible rows before rendering.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-infos" : {
      "get" : {
        "summary" : "Get RBD details (size, features, parent, data-pool) for a list of images.",
        "operationId" : "RbdResource_rbdDetailsMultiple",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "Images to query, syntax is pool/image or pool/namespace/image.",
          "name" : "image",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/RbdImageResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch detailed metadata for specific RBD images in bulk.",
          "usage" : [ "Call when an operator selects multiple images to inspect mirroring, parent, or feature flags.", "Use after provisioning to confirm images picked up expected settings." ],
          "response_shape" : "map<string,RbdImageResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "Detailed RBD metadata"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "Warn users when map entries are null (images unavailable) and suggest refreshing the cache.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-names" : {
      "get" : {
        "summary" : "List all RBD names in all pools",
        "operationId" : "RbdResource_listAllRbdNames",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNameResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Lightweight fallback for RBD listing when GET /rbds fails - return basic RBD identifiers only.",
          "usage" : [ "Use as primary RBD discovery when full details not needed.", "Fallback when GET /rbds returns 500 errors.", "Populate dropdowns when prompting the user to select an image.", "Call before issuing detailed queries to avoid loading full image metadata." ],
          "response_shape" : "array<RbdNameResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD name lookup"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-pools", "/rbds/rbd-infos" ],
          "postprocessing_hint" : "Sort results alphabetically and group by pool for UI widgets. FALLBACK ENDPOINT: Use when /rbds fails. Follow with /rbds/rbd-infos for detailed information.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-pools" : {
      "get" : {
        "summary" : "List all RBD pools and namespaces",
        "operationId" : "RbdResource_listAllRbdPools",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "First step in RBD discovery - find which pools contain RBDs before listing images.",
          "usage" : [ "Check if RBD pools exist before listing RBDs.", "Diagnose empty RBD responses.", "Call prior to presenting pool/namespace selectors in the UI.", "Use to validate that a target pool is active before provisioning RBDs." ],
          "response_shape" : "array<RbdPoolInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD pool listing"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "PRE-CHECK for /rbds: Non-empty list indicates RBDs should be available. Highlight pools with active=false to signal decommissioned namespaces. Use before /rbds to understand which pools contain RBD images.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/used-size" : {
      "get" : {
        "summary" : "Returns RBD pool/namespace/image used size",
        "operationId" : "RbdResource_rbdUsedSize",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The namespace to query. If omitted or set to null, the default namespace will be used.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "description" : "The pool to query (required).",
          "name" : "pool",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "The rbd to query. If omitted or set to null,the size of the entire namespace will be returned, otherwise only the size of this rbd.",
          "name" : "rbd",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdUsedSizeResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate provisioned and used size for a pool, namespace, or specific RBD image.",
          "usage" : [ "Display usage data before reclaiming space or deleting snapshots.", "Assess capacity distribution across namespaces for reporting." ],
          "response_shape" : "RbdUsedSizeResponse",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Usage reporting"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets" : {
      "get" : {
        "summary" : "List of all buckets.",
        "operationId" : "RgwResource_getRgwBuckets",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with usage, owner and placement details.",
          "usage" : [ "Render the bucket inventory view", "Filter via pagination when exporting bucket data" ],
          "response_shape" : "OptionalPaginationResponse<RgwBucketResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/policy" ],
          "postprocessing_hint" : "Aggregate usageSum across zones for dashboard totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}" : {
      "patch" : {
        "summary" : "Update RGW bucket",
        "operationId" : "RgwResource_updateRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update S3 bucket ownership, ACLs, or versioning configuration.",
          "usage" : [ "Call when transferring bucket ownership between users or tenants.", "Use to modify bucket versioning settings or access controls post-creation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; New owner user exists if changing ownership; ACL entries valid",
            "post_action" : "Bucket configuration updated; Ownership transferred if requested; Versioning state changed"
          },
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "owner",
            "in" : "body",
            "description" : "Owner parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "versioning",
            "in" : "body",
            "description" : "Versioning parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to update.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "S3 bucket updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/users" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName} to confirm updated settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW bucket details",
        "operationId" : "RgwResource_getRgwBucketDetails",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BucketDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return ACL, CORS and versioning information for a bucket via RGW.",
          "usage" : [ "Open before editing bucket access settings", "Refresh after applying policy or versioning changes to confirm state" ],
          "response_shape" : "BucketDetails",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (with tenant prefix if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket detail inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/buckets/{bucketName}/policy", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Mask sensitive ACL entries when presenting to non-admin viewers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete RGW bucket",
        "operationId" : "RgwResource_deleteRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketDeletionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RGW bucket, optionally purging all objects first.",
          "usage" : [ "Call with deleteData=true to purge objects for large cleanup operations (returns a ManagedTask).", "Use deleteData=false to remove an empty bucket immediately." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "DeleteData parameter",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "ThisWillDeleteData parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (without tenant prefix).",
            "required" : true,
            "example" : "logs-prod"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Bucket lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects", "/tasks/{id}" ],
          "postprocessing_hint" : "If a ManagedTask is returned, monitor it for WARN logs when objects fail to delete.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting buckets (especially with deleteData=true) permanently removes stored objects."
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new S3 bucket.",
        "operationId" : "RgwResource_createBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new S3 bucket with optional versioning, placement, and ACL configuration.",
          "usage" : [ "Call when provisioning new buckets for applications or user storage.", "Use after setting up placement policies to create buckets with specific storage requirements." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Bucket name is unique; Owner user exists; Placement policy valid if specified",
            "post_action" : "Bucket created with specified configuration; ACLs applied; Versioning enabled if requested"
          },
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "Acl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "endpoint",
            "in" : "body",
            "description" : "Endpoint parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "expectedNumberOfObjects",
            "in" : "body",
            "description" : "ExpectedNumberOfObjects parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "owner",
            "in" : "body",
            "description" : "Owner parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "placement",
            "in" : "body",
            "description" : "Placement parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "versioning",
            "in" : "body",
            "description" : "Versioning parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to create.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "S3 bucket creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets", "/s3/buckets/{bucketName}", "/s3/placements" ],
          "postprocessing_hint" : "Poll GET /s3/buckets to confirm the bucket appears with correct ownership and settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/download" : {
      "get" : {
        "summary" : "Download an object.",
        "operationId" : "RgwResource_downloadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stream a single S3 object through croit with presigned token handling.",
          "usage" : [ "Allow administrators to download objects directly from the UI", "Use for one-off retrievals; do not poll" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Object downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Trigger the download immediately; do not attempt resumable transfers via this endpoint.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. API params are identical to object listing.",
        "operationId" : "RgwResource_listMultipartUploads",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MultipartUploadListing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect ongoing multipart uploads for a bucket using native S3 markers.",
          "usage" : [ "Display uploads that may require cleanup", "Use before deciding to abort stalled uploads" ],
          "response_shape" : "MultipartUploadListing",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to list.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads-paginated", "/s3/buckets/{bucketName}/multipart-uploads" ],
          "postprocessing_hint" : "Sort by initiated time to highlight oldest uploads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Cancel an active or abandoned multi-part upload.",
        "operationId" : "RgwResource_cancelMultipartUpload",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "uploadId",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Abort an in-progress S3 multipart upload",
          "usage" : [ "Clean up incomplete uploads to free storage", "Cancel failed or abandoned upload sessions" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 60,
            "note" : "Upload management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads-paginated" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. Uses croit's pagination.",
        "operationId" : "RgwResource_listMultipartUploadsPaginated",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3MultipartUploadResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate multipart uploads with server-side filtering and caching of continuation tokens.",
          "usage" : [ "Use in admin UIs where consistent paging is required", "Prefer when sorting/filtering uploads by metadata" ],
          "response_shape" : "S3MultipartUploadResponse",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to page through.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads", "/s3/buckets/{bucketName}/objects-paginated" ],
          "postprocessing_hint" : "Reuse the pagination.after and returned next markers to continue the listing without re-querying earlier data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects" : {
      "get" : {
        "summary" : "List objects in a bucket. Refer to S3 documentation for listing details",
        "operationId" : "RgwResource_listBucketObjects",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Listing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform an S3 object listing with optional prefix and pagination markers.",
          "usage" : [ "Use for browsing objects in classic delimiter-based mode", "When more control is needed, prefer the paginated variant" ],
          "response_shape" : "S3Listing",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to list objects from.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Interactive bucket browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects-paginated", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Combine prefixes and objects to render directory-style listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an object by name.",
        "operationId" : "RgwResource_deleteS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a specific S3 object from a bucket",
          "usage" : [ "Remove individual files from storage", "Clean up obsolete or temporary objects" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 1000,
            "window_seconds" : 60,
            "note" : "Object operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects (GET)", "/s3/buckets/{bucketName}/objects (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Object deletion is permanent and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects-paginated" : {
      "get" : {
        "summary" : "List objects and prefixes in a bucket. Uses croit's pagination.",
        "operationId" : "RgwResource_listBucketObjectsAndPrefixes",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "description" : "Maximum number of S3 objects queried for filtering.",
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3ObjectsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide consistent server-side pagination over bucket contents with filtering and sorting support.",
          "usage" : [ "Use in UI tables that need deterministic paging and sorting", "Cache continuation tokens returned via pagination.after for subsequent calls" ],
          "response_shape" : "S3ObjectsResponse",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to enumerate.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Paginated object browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Merge prefixes with objects when presenting a tree view; use nextMarker caching to avoid re-querying prior pages.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/acl" : {
      "put" : {
        "summary" : "Override an object's ACL.",
        "operationId" : "RgwResource_setObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Object ACL",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/AclEntry"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update access control list for a specific S3 object.",
          "usage" : [ "Call when modifying object permissions for users or groups.", "Use to grant or revoke access to specific objects without affecting bucket ACLs." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Object exists; ACL entries are valid; User has permission to modify ACLs",
            "post_action" : "Object ACL updated with new permissions; Previous ACL entries replaced"
          },
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket containing the object.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Object ACL updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName}/objects/acl to confirm updated permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current ACL of an object.",
        "operationId" : "RgwResource_getObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the ACL grants for a specific object.",
          "usage" : [ "Display permissions before editing", "Audit who has access to sensitive objects" ],
          "response_shape" : "array<AclEntry>",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object ACL inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Highlight grants that provide public access or wildcard permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/copy" : {
      "put" : {
        "summary" : "Copy an object.",
        "operationId" : "RgwResource_copyS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Copy an S3 object to another location within the same or different bucket.",
          "usage" : [ "Call when duplicating objects for backup or organizing data.", "Use to copy objects between buckets with different storage policies." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Source object exists; Destination bucket accessible; Source and destination differ",
            "post_action" : "Object copied with original ACLs preserved; Destination object created"
          },
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Source bucket containing the object to copy.",
            "required" : true,
            "example" : "source-bucket"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Object copy operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/move" ],
          "postprocessing_hint" : "Verify copy with GET /s3/buckets/{dstBucketName}/objects to confirm object appears at destination.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/metadata" : {
      "put" : {
        "summary" : "Override object metadata.",
        "operationId" : "RgwResource_putS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "S3 metadata",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/S3Metadata"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update metadata headers for a specific S3 object without changing the object content.",
          "usage" : [ "Call when modifying object content-type, cache-control, or custom metadata.", "Use to update metadata without requiring object re-upload or version change." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Object exists; New metadata is valid; User has write permissions",
            "post_action" : "Object metadata updated; ACLs preserved; Object content unchanged"
          },
          "request_parameters" : [ {
            "name" : "cacheControl",
            "in" : "body",
            "description" : "CacheControl parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "contentDisposition",
            "in" : "body",
            "description" : "ContentDisposition parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "contentEncoding",
            "in" : "body",
            "description" : "ContentEncoding parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "contentLanguage",
            "in" : "body",
            "description" : "ContentLanguage parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "contentMD5",
            "in" : "body",
            "description" : "ContentMD5 parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "contentType",
            "in" : "body",
            "description" : "ContentType parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "etag",
            "in" : "body",
            "description" : "Etag parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "expirationTime",
            "in" : "body",
            "description" : "ExpirationTime parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "expirationTimeRuleId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "httpExpiresDate",
            "in" : "body",
            "description" : "HttpExpiresDate parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "lastModified",
            "in" : "body",
            "description" : "LastModified parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "raw",
            "in" : "body",
            "description" : "Raw parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "s3Type",
            "in" : "body",
            "description" : "S3Type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "userMetadata",
            "in" : "body",
            "description" : "UserMetadata parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "versionId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket containing the object.",
            "required" : true,
            "example" : "my-app-data"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Object metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName}/objects/metadata to confirm updated headers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get metadata of an object.",
        "operationId" : "RgwResource_getS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Metadata"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch S3 object metadata (size, content type, custom headers) without downloading the object.",
          "usage" : [ "Inspect metadata prior to downloads", "Verify custom metadata set by clients" ],
          "response_shape" : "S3Metadata",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object metadata inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Expose both standard headers and user metadata distinctly in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/move" : {
      "put" : {
        "summary" : "Move an object.",
        "operationId" : "RgwResource_moveS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Move an S3 object to a different location or bucket",
          "usage" : [ "Reorganize object storage", "Rename objects", "Move objects between buckets" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Source object exists; Destination bucket accessible; Source and destination differ",
            "post_action" : "Object moved to new location; Original object removed from source"
          },
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Source bucket name",
            "required" : true
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Object move operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/copy" ],
          "postprocessing_hint" : "Verify move with GET /s3/buckets/{dstBucketName}/objects to confirm object at destination and original location is empty.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/policy" : {
      "post" : {
        "summary" : "Create or update a bucket policy. See the ceph documentation for the list of currently supported actions.",
        "operationId" : "RgwResource_setPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Bucket policy in JSON format",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update S3 bucket access policy",
          "usage" : [ "Set bucket permissions", "Configure cross-account access", "Apply security policies" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Policy JSON is valid; Actions are Ceph-supported",
            "post_action" : "Policy applied to bucket; Access permissions updated"
          },
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to apply policy to",
            "required" : true
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Policy management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/policy", "/s3/buckets/{bucketName}" ],
          "postprocessing_hint" : "Verify policy with GET /s3/buckets/{bucketName}/policy to confirm applied settings.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Policy changes affect bucket access permissions for all users"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a bucket policy.",
        "operationId" : "RgwResource_getPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the JSON policy attached to an S3 bucket.",
          "usage" : [ "Display the existing policy before editing", "Export policies for compliance reviews" ],
          "response_shape" : "BucketPolicy",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (may include tenant prefix).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Policy inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Pretty-print the JSON before displaying to administrators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a bucket policy.",
        "operationId" : "RgwResource_deletePolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove the access policy from an S3 bucket",
          "usage" : [ "Reset bucket permissions to default", "Remove custom access policies before reconfiguration" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Policy management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/policy (GET)", "/s3/buckets/{bucketName}/policy (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing bucket policy may affect access for existing users"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/quota" : {
      "put" : {
        "summary" : "Set a quota for this bucket.",
        "operationId" : "RgwResource_setBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set storage quota limits for an S3 bucket",
          "usage" : [ "Limit bucket storage consumption", "Prevent bucket from growing beyond specified limits", "Enforce storage policies" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Quota values are valid; Admin permissions confirmed",
            "post_action" : "Quota limits applied; Future uploads will be checked against limits"
          },
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "maxObjects",
            "in" : "body",
            "description" : "MaxObjects parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsNew",
            "in" : "body",
            "description" : "MaxObjectsNew parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsOld",
            "in" : "body",
            "description" : "MaxObjectsOld parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "maxSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          }, {
            "name" : "maxSizeKiBOld",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "maxSizeNew",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to set quota for",
            "required" : true
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Quota management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/users/{uid}/bucket-quota" ],
          "postprocessing_hint" : "Monitor bucket usage to ensure quota limits are appropriate for use case.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Quota changes may prevent future uploads if current usage exceeds new limits"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/upload" : {
      "put" : {
        "summary" : "Upload an object.",
        "operationId" : "RgwResource_uploadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UploadS3ObjectRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Upload a file to an S3 bucket",
          "usage" : [ "Store files in object storage", "Upload documents or media", "Backup files to S3" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Sufficient quota available; File size within limits",
            "post_action" : "Object stored in bucket; Metadata indexed; File accessible via S3 API"
          },
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to upload to",
            "required" : true
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 3600,
            "note" : "File upload operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/multipart-uploads" ],
          "postprocessing_hint" : "For large files consider using multipart upload for better reliability and progress tracking.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/default-placement" : {
      "put" : {
        "summary" : "Set the default placement rule. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setDefaultPlacement",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "Default placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwDefaultPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the default S3 placement rule for new buckets",
          "usage" : [ "Configure default storage location", "Set cluster-wide bucket placement policy", "Manage storage tier defaults" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Placement rule exists; Not in multi-site configuration; Admin permissions confirmed",
            "post_action" : "Default placement updated; New buckets will use this placement rule"
          },
          "request_parameters" : [ {
            "name" : "placementRule",
            "in" : "body",
            "description" : "PlacementRule parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "storageClass",
            "in" : "body",
            "description" : "StorageClass parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Placement configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/placements", "/s3/placements/{name}" ],
          "postprocessing_hint" : "Verify change with GET /s3/placements to confirm new default is applied.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing default placement affects all future bucket creation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements" : {
      "get" : {
        "summary" : "List all available placement policies in all zones.",
        "operationId" : "RgwResource_getPlacements",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwPlacementResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose RGW placement policies and the default placement for configuration UIs.",
          "usage" : [ "Load when editing bucket placement settings", "Refresh after creating or deleting placements" ],
          "response_shape" : "RgwPlacementResponse",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Placement configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/buckets", "/s3/default-placement" ],
          "postprocessing_hint" : "Prefer the field data when pagination is used; fallback to placements otherwise.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/placements/{name}" : {
      "put" : {
        "summary" : "Create a new placement policy in the default zonegroup in the default zone. This API does not support multi-site setups.",
        "operationId" : "RgwResource_addPlacement",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name for the policy, each zone within a zonegroup must have a policy with the same name.",
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new S3 placement policy for bucket storage configuration",
          "usage" : [ "Define custom storage locations", "Create tiered storage policies", "Configure pool assignments for buckets" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Pools exist and are accessible; Placement name is unique; Not in multi-site setup",
            "post_action" : "Placement policy created; Available for bucket assignment"
          },
          "request_parameters" : [ {
            "name" : "dataExtraPool",
            "in" : "body",
            "description" : "DataExtraPool parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "dataPool",
            "in" : "body",
            "description" : "DataPool parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "indexPool",
            "in" : "body",
            "description" : "IndexPool parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Name for the placement policy",
            "required" : true,
            "example" : "ssd-placement"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Placement policy creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/placements", "/s3/default-placement" ],
          "postprocessing_hint" : "Verify creation with GET /s3/placements and consider setting as default if appropriate.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating placement policies affects storage architecture"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements/{placementRule}/storage-classes/{storageClass}" : {
      "put" : {
        "summary" : "Set storage classes on placement rules. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to add or edit.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Storage class configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwStorageClassRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage class for a placement rule",
          "usage" : [ "Define tiered storage options", "Configure performance vs cost storage classes", "Set up storage class hierarchy" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Placement rule exists; Data pool is valid; Not in multi-site setup",
            "post_action" : "Storage class configured; Available for bucket use"
          },
          "request_parameters" : [ {
            "name" : "dataPool",
            "in" : "body",
            "description" : "DataPool parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "placementRule",
            "in" : "path",
            "description" : "placementRule parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "storageClass parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "placementRule",
            "in" : "path",
            "description" : "Name of existing placement rule",
            "required" : true,
            "example" : "ssd-placement"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "Storage class name to add or modify",
            "required" : true,
            "example" : "STANDARD_IA"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Storage class configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/placements", "/s3/placements/{placementRule}/storage-classes/{storageClass}" ],
          "postprocessing_hint" : "Test storage class by creating a bucket with the new placement rule and storage class.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Storage class changes affect data placement and performance characteristics"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a storage class on a placement rule. Deletes the entire placement rule when specifying the STANDARD storage class. This API does not support multi-site setups.",
        "operationId" : "RgwResource_deleteStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to remove, or STANDARD to remove the entire placement rule.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a storage class from a placement rule",
          "usage" : [ "Remove unused storage classes", "Clean up placement configuration", "Remove entire placement rule (STANDARD class)" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Storage class exists; No buckets using this placement; Not in multi-site setup",
            "post_action" : "Storage class deleted; Placement rule removed if STANDARD class deleted"
          },
          "path_parameters" : [ {
            "name" : "placementRule",
            "in" : "path",
            "description" : "placementRule parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "storageClass parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "placementRule",
            "in" : "path",
            "description" : "Name of the placement rule",
            "required" : true,
            "example" : "ssd-placement"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "Storage class to delete (STANDARD deletes entire placement rule)",
            "required" : true,
            "example" : "STANDARD_IA"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Storage class deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/placements", "/s3/buckets" ],
          "postprocessing_hint" : "Verify deletion with GET /s3/placements and check no buckets are using removed placement.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting storage classes affects bucket placement options; STANDARD deletion removes entire rule"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/usage/by-bucket/{bucketName}" : {
      "get" : {
        "summary" : "Retrieve latest usage statistics for a given S3 bucket.",
        "description" : "Return results aggregated into 1 hour intervals for all users that accessed the bucket.\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForBucketByUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Aggregate hourly RGW usage for a bucket across all users.",
          "usage" : [ "Feed billing reports or compliance exports", "Schedule periodic runs; avoid interactive polling" ],
          "response_shape" : "S3UsageForBucketByUserResponse",
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "bucketName parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to analyze (with tenant if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-user/{uid}", "/stats" ],
          "postprocessing_hint" : "Group the returned per-user lists before persisting to accounting systems; trimming is triggered automatically.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/usage/by-user/{uid}" : {
      "get" : {
        "summary" : "Retrieve usage statistics for a given S3 user.",
        "description" : "Return results aggregated into 1 hour intervals for all buckets the user accessed. Caution: this cannot be used for the anonymous user\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForUserByBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Collect hourly RGW usage metrics for a specific user to feed billing or analytics.",
          "usage" : [ "Trigger on-demand reports and persist results externally", "Avoid frequent polling; schedule periodic exports instead" ],
          "response_shape" : "S3UsageForUserByBucketResponse",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to report on.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-bucket/{bucketName}", "/stats" ],
          "postprocessing_hint" : "Aggregate returned hourly buckets before billing; consider trimming data once exported.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/user-names" : {
      "get" : {
        "summary" : "Get list of RGW user names",
        "operationId" : "RgwResource_getRgwUsers",
        "tags" : [ "s3" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide a lightweight list of RGW user IDs for selectors or autocomplete.",
          "usage" : [ "Populate dropdowns when selecting a user", "Refresh occasionally to pick up new accounts" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Sort user IDs alphabetically before display.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users" : {
      "get" : {
        "summary" : "List of S3 users.",
        "operationId" : "RgwResource_getRgwUserInfo",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "uid",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW users with metadata for management or dashboards.",
          "usage" : [ "Render the S3 user inventory table", "Filter by uid to fetch specific users before editing" ],
          "response_shape" : "OptionalPaginationResponse<RgwUserResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "User inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/user-names", "/s3/users/{uid}/keys" ],
          "postprocessing_hint" : "Merge cached data to avoid hitting RGW for every refresh.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create RGW user",
        "operationId" : "RgwResource_createRgwUser",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "New RGW user creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new RGW user account for S3 access.",
          "usage" : [ "Call before generating access keys via /s3/users/{uid}/keys.", "Provide tenant when working in multi-tenant deployments to segregate users." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "defaultPlacement",
            "in" : "body",
            "description" : "DefaultPlacement parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "defaultStorageClass",
            "in" : "body",
            "description" : "DefaultStorageClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "email",
            "in" : "body",
            "description" : "Email parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "tenant",
            "in" : "body",
            "description" : "Tenant parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "RGW user provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/keys", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Immediately request credentials via /s3/users/{uid}/keys to complete onboarding.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}" : {
      "patch" : {
        "summary" : "Update RGW user",
        "operationId" : "RgwResource_updateRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW user account properties and settings",
          "usage" : [ "Modify user metadata", "Update placement or storage class defaults", "Change user display name or email" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Placement/storage class valid if specified; Admin permissions confirmed",
            "post_action" : "User metadata updated; New defaults apply to future buckets"
          },
          "request_parameters" : [ {
            "name" : "defaultPlacement",
            "in" : "body",
            "description" : "DefaultPlacement parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "defaultStorageClass",
            "in" : "body",
            "description" : "DefaultStorageClass parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "email",
            "in" : "body",
            "description" : "Email parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "suspended",
            "in" : "body",
            "description" : "Suspended parameter",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to update",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User account modifications"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Changes affect future bucket creation; existing buckets retain current settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW user",
        "operationId" : "RgwResource_deleteRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RGW user account and invalidate its credentials cache.",
          "usage" : [ "Call after migrating data away from the user or revoking access.", "Remove all keys and subusers beforehand to avoid orphaned credentials." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user id to remove.",
            "required" : true,
            "example" : "app-backups"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User deprovisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Invalidate any UI caches and update IAM dashboards to reflect the removal.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create RGW subuser",
        "operationId" : "RgwResource_createRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a subuser under an existing RGW user account",
          "usage" : [ "Add Swift API access for applications", "Create compartmentalized access within user account", "Set up limited-permission subusers" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Parent user exists; Subuser name is unique; Access level is valid",
            "post_action" : "Subuser created with specified permissions; Keys generated if requested"
          },
          "request_parameters" : [ {
            "name" : "permissions",
            "in" : "body",
            "description" : "Permissions parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "subuser",
            "in" : "body",
            "description" : "Subuser parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID to create subuser under",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Subuser creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}/keys" ],
          "postprocessing_hint" : "Monitor returned task; generate keys after creation if needed.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/bucket-quota" : {
      "put" : {
        "summary" : "Set a quota for all buckets owned by this user.",
        "operationId" : "RgwResource_setUserBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User bucket quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set quota limits for all buckets owned by a user",
          "usage" : [ "Control bucket storage per user", "Apply bucket-level limits across user's buckets", "Prevent individual bucket bloat" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Quota values valid; Admin permissions confirmed",
            "post_action" : "Per-bucket quota applied to all user's buckets; Future uploads checked per bucket"
          },
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "maxObjects",
            "in" : "body",
            "description" : "MaxObjects parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsNew",
            "in" : "body",
            "description" : "MaxObjectsNew parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsOld",
            "in" : "body",
            "description" : "MaxObjectsOld parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "maxSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          }, {
            "name" : "maxSizeKiBOld",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "maxSizeNew",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to set bucket quota for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Bucket quota management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/quota", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Monitor individual bucket usage to ensure per-bucket limits are appropriate.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bucket quota changes may prevent uploads to existing buckets if limits are exceeded"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/buckets" : {
      "get" : {
        "summary" : "List all buckets owner by the user.",
        "operationId" : "RgwResource_getRgwBucketsForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwBucketResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List buckets owned by a specific RGW user, including usage and quotas.",
          "usage" : [ "Display per-user bucket inventory", "Validate bucket ownership before applying user-level policies" ],
          "response_shape" : "array<RgwBucketResponse>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID whose buckets to list.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory by user"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/users" ],
          "postprocessing_hint" : "Sum usage across buckets to show per-user totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file",
        "operationId" : "RgwResource_getS3CfgFile",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file containing credentials and endpoint info for an RGW user.",
          "usage" : [ "Offer the config download after creating or rotating credentials", "Avoid repeated downloads; regenerate when IPs or keys change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user or subuser ID (user or user:subuser).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" ],
          "postprocessing_hint" : "Serve the download immediately; tokens are short-lived.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/key" : {
      "get" : {
        "summary" : "Get RGW user key",
        "operationId" : "RgwResource_getRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwUserKey"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the credentials for a specific S3 subuser or main user.",
          "usage" : [ "Display access/secret keys when downloading configuration files", "Call after key rotation to show the new credentials" ],
          "response_shape" : "RgwUserKey",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (format user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users" ],
          "postprocessing_hint" : "Redact secretKey in logs and restrict exposure to admins.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys" : {
      "put" : {
        "summary" : "Update RGW keys",
        "operationId" : "RgwResource_updateRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW keys update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateKeysRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update or regenerate access keys for an RGW user",
          "usage" : [ "Rotate compromised credentials", "Update multiple keys at once", "Generate new access/secret key pairs" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "User exists; Key configurations are valid; No duplicate access keys",
            "post_action" : "Keys updated; Old keys invalidated; New keys ready for use"
          },
          "request_parameters" : [ {
            "name" : "keys",
            "in" : "body",
            "description" : "Keys parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to update keys for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Key management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}/cfg-file/download" ],
          "postprocessing_hint" : "Monitor returned task; distribute new credentials to applications; test access before confirming.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Key updates invalidate existing credentials and may break active applications"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW user keys",
        "operationId" : "RgwResource_getRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all access keys belonging to a user or subuser.",
          "usage" : [ "Show existing keys before rotating or deleting", "Audit which subusers have credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/key" ],
          "postprocessing_hint" : "Mask secretKey values unless explicitly requested by an admin.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW user key",
        "operationId" : "RgwResource_removeRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an S3 access key from a RGW user",
          "usage" : [ "Revoke compromised or unused access keys", "Rotate credentials by removing old keys" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "accessKey parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Access key to delete",
            "required" : true,
            "example" : "AKIAIOSFODNN7EXAMPLE"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys (POST)", "/s3/users/{uid}/keys (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW user key",
        "operationId" : "RgwResource_createRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new access key with specified access key ID and secret for an RGW user.",
          "usage" : [ "Call when generating custom access keys for applications or users.", "Use to create keys with specific access key IDs for integration requirements." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Access key ID is unique; Valid key formats; RGW service running",
            "post_action" : "Access key created; Available for S3 authentication; Secret stored securely"
          },
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "accessKey parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID to create the access key for.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Specific access key ID to create.",
            "required" : true,
            "example" : "ABCDEFGHIJKLMNOPQRST"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Access key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}" ],
          "postprocessing_hint" : "Access key immediately active for S3 operations; store secret key securely; test authentication after creation.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/quota" : {
      "put" : {
        "summary" : "Set a quota for this user.",
        "operationId" : "RgwResource_setUserQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set storage quota limits for an RGW user account",
          "usage" : [ "Limit user's total storage consumption", "Enforce storage policies per user", "Prevent runaway storage usage" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Quota values are valid; Admin permissions confirmed",
            "post_action" : "User quota applied; Future uploads checked against limits"
          },
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "maxObjects",
            "in" : "body",
            "description" : "MaxObjects parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsNew",
            "in" : "body",
            "description" : "MaxObjectsNew parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxObjectsOld",
            "in" : "body",
            "description" : "MaxObjectsOld parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "maxSize",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          }, {
            "name" : "maxSizeKiBOld",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "maxSizeNew",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to set quota for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User quota management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}", "/s3/users/{uid}/bucket-quota" ],
          "postprocessing_hint" : "Monitor user storage to ensure quota limits are appropriate for use case.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Quota changes may prevent future uploads if current usage exceeds new limits"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers" : {
      "put" : {
        "summary" : "Update RGW subusers",
        "operationId" : "RgwResource_updateRgwSubusers",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subusers update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateSubusersRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update multiple subusers for an RGW user account",
          "usage" : [ "Batch update subuser permissions", "Modify multiple subuser access levels", "Update subuser configurations in bulk" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Parent user exists; Subuser configurations valid; Admin permissions confirmed",
            "post_action" : "Subusers updated with new permissions; Keys generated if requested"
          },
          "request_parameters" : [ {
            "name" : "subusers",
            "in" : "body",
            "description" : "Subusers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Subuser batch operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}" ],
          "postprocessing_hint" : "Monitor returned task; verify subuser access after changes; update application configurations.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Subuser permission changes affect application access patterns"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW subusers for user",
        "operationId" : "RgwResource_getRgwSubusersForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwSubUser"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List subusers belonging to an RGW account, including their permissions.",
          "usage" : [ "Load subusers before editing their keys or ACLs", "Display subuser information in account dashboards" ],
          "response_shape" : "array<RgwSubUser>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subuser inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/subusers/{subuser}/keys" ],
          "postprocessing_hint" : "Group results by permissions to highlight read-only subusers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}" : {
      "patch" : {
        "summary" : "Update RGW subuser",
        "operationId" : "RgwResource_updateRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW subuser permissions and configuration without recreating the subuser.",
          "usage" : [ "Call when modifying subuser access permissions or settings.", "Use to update subuser permissions without disrupting existing access keys." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "User and subuser exist; Valid permission level; RGW service running",
            "post_action" : "Subuser permissions updated; Access control changes effective immediately; Keys preserved unless regenerated"
          },
          "request_parameters" : [ {
            "name" : "permissions",
            "in" : "body",
            "description" : "Permissions parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID that owns the subuser.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to update.",
            "required" : true,
            "example" : "appuser"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Subuser configuration updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Monitor task progress for permission updates; existing access keys remain valid unless explicitly regenerated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW subuser",
        "operationId" : "RgwResource_deleteRgwSubser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a RGW subuser from a parent user account",
          "usage" : [ "Clean up unused subusers", "Revoke Swift API access for specific subusers" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify subuser exists and is not in use",
            "post_action" : "Monitor task completion and verify removal"
          },
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to delete",
            "required" : true,
            "example" : "swift-user"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 60,
            "note" : "Subuser management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers (POST)", "/s3/users/{uid}/subusers (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting subuser removes all access for that identity"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file for subuser",
        "operationId" : "RgwResource_getS3CfgFileForsubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file scoped to a specific subuser.",
          "usage" : [ "Offer immediately after creating a subuser", "Reuse only until credentials or endpoints change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "backup"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/cfg-file/download", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Download immediately; tokens expire quickly.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys" : {
      "get" : {
        "summary" : "Get RGW keys for subuser",
        "operationId" : "RgwResource_getRgwKeysForSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List credentials for a specific RGW subuser.",
          "usage" : [ "Review keys before regenerating or deleting", "Audit which subusers have active credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "alice:tenant"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" ],
          "postprocessing_hint" : "Mask secret keys in UI unless explicitly requested.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW key for subuser",
        "operationId" : "RgwResource_removeSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an S3 access key from a RGW subuser",
          "usage" : [ "Revoke subuser access without deleting the subuser", "Rotate subuser credentials" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "accessKey parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name",
            "required" : true,
            "example" : "swift-user"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Access key to delete",
            "required" : true,
            "example" : "AKIAIOSFODNN7EXAMPLE"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Subuser key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}/keys (PUT)", "/s3/users/{uid}/subusers/{subuser}/keys (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW key for subuser",
        "operationId" : "RgwResource_createSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new access key with specified access key ID and secret for an RGW subuser.",
          "usage" : [ "Call when generating custom access keys for subuser applications.", "Use to create keys with specific access key IDs for subuser integration requirements." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User and subuser exist; Access key ID is unique; Valid key formats; RGW service running",
            "post_action" : "Subuser access key created; Available for S3 authentication; Secret stored securely"
          },
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "uid parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "subuser parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "accessKey parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID that owns the subuser.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to create the access key for.",
            "required" : true,
            "example" : "appuser"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Specific access key ID to create for the subuser.",
            "required" : true,
            "example" : "SUBUSER123ACCESSKEY"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Subuser access key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}/keys", "/s3/users/{uid}/subusers/{subuser}" ],
          "postprocessing_hint" : "Subuser access key immediately active for S3 operations; store secret key securely; test authentication after creation.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/server-access/host-keys" : {
      "get" : {
        "summary" : "Get the SSH host keys configured on the servers as pairs of key type, public key.",
        "operationId" : "SshKeyResource_getHostKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve SSH host public keys for server identity verification during SSH connections.",
          "usage" : [ "Call when setting up SSH client configurations to verify server identities.", "Use to populate known_hosts files for automated SSH connections to cluster servers." ],
          "response_shape" : "Map<String, String?>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Host key retrieval"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/server-access/keys", "/servers" ],
          "postprocessing_hint" : "Add non-null keys to SSH known_hosts files; keys remain constant unless servers are rebuilt.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/keys" : {
      "put" : {
        "summary" : "Replace all SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_replaceSshKeys",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/KeyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the complete list of SSH public keys authorized for server access.",
          "usage" : [ "Call when updating team member SSH access or rotating keys for security.", "Use to synchronize authorized keys with external identity management systems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All SSH keys are valid public keys; Team member access requirements confirmed",
            "post_action" : "All server authorized_keys files updated; Old keys revoked; New keys immediately active"
          },
          "request_parameters" : [ {
            "name" : "keys",
            "in" : "body",
            "description" : "Keys parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "SSH key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/server-access/keys" ],
          "postprocessing_hint" : "Verify SSH access works with new keys before removing backup access methods; key changes are immediate.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This replaces all SSH keys and may lock out users with keys not in the new list"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_getSshKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all SSH public keys currently authorized for server access.",
          "usage" : [ "Call when auditing SSH access permissions or preparing key rotation.", "Use to verify which team members have SSH access to cluster servers." ],
          "response_shape" : "List<String>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "SSH key listing"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/server-access/keys", "/server-access/passwords" ],
          "postprocessing_hint" : "Display key fingerprints for identification; validate key formats before using for authentication.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/passwords" : {
      "patch" : {
        "summary" : "Set server passwords",
        "operationId" : "SshKeyResource_setServerPasswords",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerAccessPasswords"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update server root and IPMI passwords for physical access and hardware management.",
          "usage" : [ "Call when rotating passwords for security compliance or after suspected compromise.", "Use to set initial passwords during cluster setup or hardware provisioning." ],
          "response_shape" : "ManagedThreadTask or null",
          "workflow_guidance" : {
            "pre_check" : "Passwords meet complexity requirements; IPMI interfaces accessible; Root access confirmed",
            "post_action" : "Passwords updated on all accessible servers; IPMI admin credentials changed; Root password available for console access"
          },
          "request_parameters" : [ {
            "name" : "ipmiPassword",
            "in" : "body",
            "description" : "IpmiPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "rootPassword",
            "in" : "body",
            "description" : "RootPassword parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Password management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/server-access/passwords", "/ipmi" ],
          "postprocessing_hint" : "Test access with new passwords; IPMI changes may take time to propagate; monitor task for per-server results.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Password changes affect server access and may require physical intervention if SSH keys fail"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get server passwords.",
        "operationId" : "SshKeyResource_getServerPasswords",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ServerAccessPasswords"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current server root and IPMI passwords for emergency access and hardware management.",
          "usage" : [ "Call when administrators need access credentials for console login or IPMI management.", "Use during disaster recovery when SSH key access is unavailable." ],
          "response_shape" : "ServerAccessPasswords",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Password retrieval"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/server-access/passwords", "/ipmi" ],
          "postprocessing_hint" : "Handle passwords securely; use for emergency access only; SSH keys are preferred for regular operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers" : {
      "get" : {
        "summary" : "List all servers.",
        "operationId" : "ServerResource_getServers",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all managed servers including hardware, health and service metadata.",
          "usage" : [ "Populate inventory or overview tables before drilling into per-server details", "Refresh every 30 seconds at most when tracking cluster health in dashboards" ],
          "response_shape" : "OptionalPaginationResponse<ServerResponse>",
          "common_parameters" : {
            "pagination.limit" : "Cap list size to avoid fetching every server on large clusters.",
            "pagination.where" : "Filter by hostname, roles or states before requesting details."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared viewer polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/services", "/servers/ips" ],
          "postprocessing_hint" : "Derive UI aggregates (e.g. running service counts) from the response before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIps",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a simple list of free IP addresses within a subnet for quick selection.",
          "usage" : [ "Use in auto-complete inputs when assigning new IPs", "Run immediately before reserving an address to avoid stale results" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips-obj", "/servers/ips" ],
          "postprocessing_hint" : "Display the results in ascending order and avoid caching them beyond the current form interaction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips-obj" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIpsObjects",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseFreeIp"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate a list of free IP addresses within a subnet, returning structured records.",
          "usage" : [ "Call before provisioning new services to reserve free management IPs", "Use in UI workflows that require both IP and subnet context" ],
          "response_shape" : "OptionalPaginationResponse<FreeIp>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips", "/servers/ips", "/servers/ips-with-subnet" ],
          "postprocessing_hint" : "Hold the response only transiently; recalculate before committing allocations to avoid races.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ha-groups" : {
      "get" : {
        "summary" : "List of all configured HA groups.",
        "operationId" : "HaGroupResource_getHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHaGroupResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured HA groups with associated VIP and members.",
          "usage" : [ "Render the HA groups overview table.", "Check current failover configuration before editing or deleting a group." ],
          "response_shape" : "OptionalPaginationResponse<HaGroupResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "HA group listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create HA group",
        "operationId" : "HaGroupResource_createHagroup",
        "tags" : [ "ha-groups" ],
        "requestBody" : {
          "description" : "HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new HA group with failover policies and member servers.",
          "usage" : [ "Provision HA for RGW/NFS services during initial setup.", "Automate HA group creation as part of cluster expansion workflows." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify license validity and ensure selected servers share matching RGW zones/DNS and unique VIPs.",
            "post_action" : "Monitor the task for provisioning errors; run health checks once created."
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "evictNfsClientsOnFailback",
            "in" : "body",
            "description" : "EvictNfsClientsOnFailback parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "failback",
            "in" : "body",
            "description" : "Failback parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "failbackTime",
            "in" : "body",
            "description" : "FailbackTime parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "failoverTime",
            "in" : "body",
            "description" : "FailoverTime parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "service",
            "in" : "body",
            "description" : "Service parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "virtualIp",
            "in" : "body",
            "description" : "VirtualIp parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "HA group provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ha-groups/{id}" : {
      "put" : {
        "summary" : "Update HA group",
        "operationId" : "HaGroupResource_updateHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update HA group configuration including VIP, membership, and timings.",
          "usage" : [ "Adjust failover timings based on operational feedback.", "Replace servers in the HA set during maintenance swaps." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Validate RGW constraints and confirm the HA group ID matches the payload.",
            "post_action" : "Monitor the update task; notify clients if the VIP or membership changes."
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "evictNfsClientsOnFailback",
            "in" : "body",
            "description" : "EvictNfsClientsOnFailback parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "failback",
            "in" : "body",
            "description" : "Failback parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "failbackTime",
            "in" : "body",
            "description" : "FailbackTime parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "failoverTime",
            "in" : "body",
            "description" : "FailoverTime parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "service",
            "in" : "body",
            "description" : "Service parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "virtualIp",
            "in" : "body",
            "description" : "VirtualIp parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Existing HA group ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "HA group updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete HA group",
        "operationId" : "HaGroupResource_deleteHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an HA group definition and release its virtual IP.",
          "usage" : [ "Decommission HA for a service that has been migrated or disabled.", "Clean stale entries before recreating with different parameters." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "HA group ID to delete.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "HA group deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting the HA group immediately removes the floating IP and failover policy."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ips" : {
      "get" : {
        "summary" : "List all IP addresses in use.",
        "operationId" : "ServerResource_listIps",
        "tags" : [ "servers" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpAddressInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return all IP addresses in use across NICs, VLANs, HA groups and SMB services.",
          "usage" : [ "Generate concise IP usage summaries before assigning new addresses", "Cross-check address ownership during troubleshooting sessions" ],
          "response_shape" : "IpAddressInfo",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "IP usage overview requests"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips-with-subnet", "/servers/free-ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Deduplicate IPv4/IPv6 entries before presenting, since some addresses appear in multiple categories.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ips-with-subnet" : {
      "get" : {
        "summary" : "List all used IP addresses with their subnet.",
        "operationId" : "ServerResource_listIpsWithSubnet",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpGeneralInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate IP addresses with subnet metadata for capacity analysis.",
          "usage" : [ "Run before allocating new addresses to ensure subnet availability", "Filter by subnet to produce reports for network teams" ],
          "response_shape" : "OptionalPaginationResponse<IpGeneralInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subnet utilisation lookups"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Group results by subnetShort to highlight utilisation hotspots.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/nics" : {
      "get" : {
        "summary" : "List all nics.",
        "operationId" : "ServerResource_getAllNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NICs across all servers with bond and VLAN metadata.",
          "usage" : [ "Build global network inventory views or export NIC data", "Filter for unused interfaces before provisioning new services" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Cluster-wide NIC inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Aggregate by bond or NUMA node if needed in dashboards.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/reboot" : {
      "post" : {
        "summary" : "Reboot multiple servers",
        "operationId" : "ServerResource_rebootServers",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerRebootRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule reboots for multiple servers in one request.",
          "usage" : [ "Roll dozens of hosts after applying kernel or firmware patches.", "Automate controlled restarts during maintenance windows." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Bulk reboot scheduling"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/shutdown", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/update-grub" : {
      "post" : {
        "summary" : "Update GRUB on all boot disks of the given servers.",
        "operationId" : "ServerResource_updateGrub",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateGrubRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Regenerate GRUB configurations on the selected servers' boot disks.",
          "usage" : [ "Run after modifying kernel parameters or reinstalling bootloaders.", "Execute during recovery workflows to ensure the correct boot image is selected." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Bootloader maintenance"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/reboot", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}" : {
      "patch" : {
        "summary" : "Update server",
        "operationId" : "ServerResource_updateServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update server metadata and optionally queue background tasks for image changes or hugepage reconfiguration.",
          "usage" : [ "Rename a server or adjust its management IP after hardware changes.", "Switch the boot image or adjust hugepage reservations prior to deploying NVMe-oF/DAOS services." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "hostname",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "image",
            "in" : "body",
            "description" : "Image parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Notes parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "NrHugepages parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server configuration updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}", "/servers/{id}/reboot", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask and reboot the server if the image was changed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete server",
        "operationId" : "ServerResource_deleteServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a server from croit inventory after services and dependencies are cleared.",
          "usage" : [ "Retire hardware that has been physically removed from the cluster.", "Clean up failed installations before re-registering the host." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Server deletions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/services", "/servers/{id}/disks", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Update external inventory systems and reread GET /servers to ensure the host disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks" : {
      "get" : {
        "summary" : "List disks on the server.",
        "operationId" : "ServerResource_getDisks",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List disks attached to a specific server with live utilization details.",
          "usage" : [ "Inspect storage layout before scheduling OSD or service changes", "Refresh after maintenance to verify disk states and statistics" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric server identifier returned by GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Heavy data payload per server"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers", "/disks", "/servers/{id}/services" ],
          "postprocessing_hint" : "Highlight disks with missing stats and merge with smart metrics if available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update disk",
        "operationId" : "ServerResource_updateDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update per-disk metadata, assign roles, or toggle identify LEDs for maintenance workflows.",
          "usage" : [ "Promote an unassigned disk to journal/DB/WAL after validation.", "Locate a disk in the chassis by enabling the identify LED." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "identifyLed",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Notes parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "partitions",
            "in" : "body",
            "description" : "Partitions parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "role",
            "in" : "body",
            "description" : "Role parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Disk metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/wipe" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove disk from inventory",
        "description" : "\n\t\t\tRemoves a disk entry from the inventory database without affecting any cluster operations.\n\t\t\tThis is used for housekeeping when a disk has been physically removed or replaced.\n\t\t\tThe disk will reappear in inventory after the next hardware detection if it's still present.\n\t\t\tFor active OSDs, use the disk wipe endpoint with destroy=true instead.\n\t\t",
        "operationId" : "ServerResource_deleteDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk entry from the inventory database without affecting cluster operations",
          "usage" : [ "Clean up stale disk entries when hardware has been physically removed", "Remove records for failed disks that will not return", "Clean inventory after disk replacement before hardware re-detection" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Disk inventory cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}/smart" ],
          "postprocessing_hint" : "Disk will reappear in inventory after next hardware detection if still physically present",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks/{diskId}/smart" : {
      "post" : {
        "summary" : "Update disk SMART details",
        "operationId" : "ServerResource_updateDiskSmartDetails",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DiskSmartStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an on-demand SMART data refresh for a specific disk.",
          "usage" : [ "Pull the latest health metrics before deciding to replace a disk.", "Validate alerts from monitoring systems with real-time SMART data." ],
          "response_shape" : "DiskSmartStatus",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "diskId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "SMART refresh"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics" : {
      "get" : {
        "summary" : "List nics on the server.",
        "operationId" : "ServerResource_getNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NIC inventory and link status for a specific server.",
          "usage" : [ "Load before rendering network configuration dialogs", "Re-query after applying NIC or VLAN changes to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server NIC inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/nics", "/servers" ],
          "postprocessing_hint" : "Group bonded members and flag stale lastSeen values for manual review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/nics/bonds" : {
      "post" : {
        "summary" : "Create network bond",
        "operationId" : "ServerResource_createBond",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Bond creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BondRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an LACP or active/passive bond on a server and migrate existing IP configuration.",
          "usage" : [ "Call during network onboarding to aggregate multiple NICs under a single bond interface.", "Rebuild bonds after replacing physical adapters while preserving IP assignments." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "activePassive",
            "in" : "body",
            "description" : "ActivePassive parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "nics",
            "in" : "body",
            "description" : "Nics parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "primary",
            "in" : "body",
            "description" : "Primary parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Bond configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Re-run hardware detection or networking checks to verify the bond state on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}" : {
      "patch" : {
        "summary" : "Update network interface",
        "operationId" : "ServerResource_updateNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NIC update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NicUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NIC addressing, notes, MAC address, or adjust bonded NIC membership on a server.",
          "usage" : [ "Reconfigure IPs after a network change.", "Replace a failed NIC while keeping MAC reservations up to date." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "bond",
            "in" : "body",
            "description" : "Bond parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Ip6 parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "mac",
            "in" : "body",
            "description" : "Mac parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Notes parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier from GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "NIC configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/bonds", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Restart DHCP updates and verify network reachability after changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete network interface",
        "operationId" : "ServerResource_deleteNic",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a network interface record from the server inventory (and tear down virtual links).",
          "usage" : [ "Clean up NIC entries after replacing hardware or undoing temporary bonding.", "Delete misconfigured virtual interfaces before reapplying network settings." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "Identifier of the NIC to remove.",
            "required" : true,
            "example" : "58"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NIC deletions"
          },
          "cache_hint" : "no-cache",
          "postprocessing_hint" : "Trigger DHCP regeneration and re-run hardware detection to refresh NIC state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans" : {
      "get" : {
        "summary" : "List vlans configured on the nic.",
        "operationId" : "ServerResource_getVlans",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseVlanInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List VLAN interfaces configured on a specific NIC.",
          "usage" : [ "Inspect VLAN assignments before modifying network topology", "Verify applied VLAN changes after POST/PATCH operations" ],
          "response_shape" : "OptionalPaginationResponse<VlanInfo>",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-NIC VLAN inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/nics" ],
          "postprocessing_hint" : "Present both IPv4 and IPv6 columns and indicate overlapping DHCP pools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add VLAN",
        "operationId" : "ServerResource_addVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewVlanRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Attach a tagged VLAN interface to a specific server NIC, including optional IPv4/IPv6 addresses.",
          "usage" : [ "Provision tenant networks on dedicated NICs.", "Restore VLAN configuration after replacing network hardware." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Ip6 parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "vlan",
            "in" : "body",
            "description" : "Vlan parameter",
            "required" : true,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}/vlans/{vlanId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans/{vlanId}" : {
      "patch" : {
        "summary" : "Update VLAN",
        "operationId" : "ServerResource_updateVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VlanUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update VLAN tag or IP configuration for an existing VLAN interface on a NIC.",
          "usage" : [ "Change addressing after moving the VLAN to a new subnet.", "Adjust tagging when consolidating VLAN numbering." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Ip6 parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "vlan",
            "in" : "body",
            "description" : "Vlan parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "vlanId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier hosting the VLAN.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Validate routing and DHCP settings after modifying VLAN parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete VLAN",
        "operationId" : "ServerResource_deleteVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a VLAN interface from a server NIC and clean up the underlying host link if possible.",
          "usage" : [ "Call after migrating VLAN traffic away from the interface.", "Undo temporary VLAN assignments made for maintenance tasks." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "nicId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "vlanId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier within the server.",
            "required" : true,
            "example" : "58"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "VLAN removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Run hardware re-detect or reapply network configuration to confirm the VLAN disappeared on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/reboot" : {
      "post" : {
        "summary" : "Reboot server",
        "operationId" : "ServerResource_rebootServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule an immediate reboot of the specified server via the croit agent.",
          "usage" : [ "Restart a node after applying configuration changes.", "Recover a machine that requires a manual reboot outside of rolling operations." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server reboot"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/shutdown", "/servers/reboot" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/redetect" : {
      "post" : {
        "summary" : "Redetect hardware",
        "operationId" : "ServerResource_redetectHardware",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger the agent to rescan hardware (NICs, disks, etc.) for the specified server.",
          "usage" : [ "Refresh inventory after physically swapping components.", "Revalidate hardware information when monitoring detects discrepancies." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "Hardware re-detect"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services" : {
      "get" : {
        "summary" : "List services on the server.",
        "operationId" : "ServerResource_getServices",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph and gateway services running on a specific server.",
          "usage" : [ "Audit service placement before scheduling migrations", "Refresh after service start/stop actions to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<ServiceResource.MultiServerServiceResponse>",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server service inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/servers/{id}/disks", "/servers" ],
          "postprocessing_hint" : "Highlight services with WARN/ERROR health before showing to the operator.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services/{serviceId}" : {
      "delete" : {
        "summary" : "Delete service",
        "operationId" : "ServerResource_deleteService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach a service instance from a specific server, optionally triggering managed removal tasks.",
          "usage" : [ "Remove a service from a node prior to decommissioning the server.", "Force-stop a misbehaving service by removing it from the host." ],
          "response_shape" : "ManagedTask?",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID assigned to the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server service removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/start", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/shutdown" : {
      "post" : {
        "summary" : "Shutdown server",
        "operationId" : "ServerResource_shutdownServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Gracefully shut down a server through the croit agent and mark it as shutting down.",
          "usage" : [ "Power off a node before hardware maintenance.", "Prepare servers for planned outages after migrating workloads." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server shutdown"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/reboot" ],
          "postprocessing_hint" : "Update runbooks to reflect that the server is offline and monitor for daemon task completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the server via SSH.",
        "operationId" : "TerminalResource_connectToTerminalProxy",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Establish a secure SSH terminal connection to a server through the croit terminal proxy.",
          "usage" : [ "Call when administrators need direct shell access for troubleshooting or maintenance.", "Use to create secure, audited connections to cluster servers without exposing SSH directly." ],
          "response_shape" : "TerminalConnection",
          "workflow_guidance" : {
            "pre_check" : "Server exists; SSH connectivity verified; Terminal proxy running",
            "post_action" : "Connection established; Session token generated; Connection expires after 1 minute if unused"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID to connect to (use 0 for localhost/manager node).",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Terminal connections"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers", "/servers/{id}" ],
          "postprocessing_hint" : "Connect immediately using returned connection details; session expires quickly; all terminal activity is audited and logged.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Terminal access provides full administrative control over cluster servers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mds" : {
      "post" : {
        "summary" : "Add MDS service",
        "operationId" : "ServerResource_addMdsService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a CephFS metadata server (MDS) on the specified host.",
          "usage" : [ "Scale CephFS metadata capacity by adding another MDS daemon.", "Recreate an MDS after host replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run the MDS daemon.",
            "required" : true,
            "example" : "25"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "MDS provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mon" : {
      "post" : {
        "summary" : "Add monitor service",
        "operationId" : "ServerResource_addMonService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Monitor service creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MonServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a Ceph monitor on the specified server, provisioning keys and optional disk wiping.",
          "usage" : [ "Scale out the monitor quorum when adding new nodes.", "Redeploy a monitor after replacing hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "diskId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that should host the monitor.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Monitor provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rbd-mirror" : {
      "post" : {
        "summary" : "Start a rbd mirror daemon on the server. Only one rbd mirror daemon is allowed to run on each server.",
        "operationId" : "ServerResource_addRbdMirrorService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an rbd-mirror daemon on the specified server, including keyring creation.",
          "usage" : [ "Provision replication capacity between clusters by adding mirror daemons.", "Recreate a mirror daemon after node recovery." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run rbd-mirror.",
            "required" : true,
            "example" : "31"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "rbd-mirror provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rgw" : {
      "post" : {
        "summary" : "Add RGW service",
        "operationId" : "ServerResource_addRgwService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a RADOS Gateway (RGW) instance on the specified server.",
          "usage" : [ "Scale RGW capacity by adding additional gateways.", "Recreate an RGW daemon after server replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will host the RGW service.",
            "required" : true,
            "example" : "28"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RGW provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/servers/{serverId}/services/{serviceId}/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServerResource_restartServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a service instance on a specific server.",
          "usage" : [ "Bounce a daemon after applying configuration changes on a single node.", "Recover a service exhibiting issues without affecting other replicas." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServerResource_startServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service instance on a particular server.",
          "usage" : [ "Bring a daemon online on a chosen node without affecting other replicas.", "Recover a service after host maintenance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to start on the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service start"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/stop", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServerResource_stopServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance running on a specific server.",
          "usage" : [ "Drain a daemon prior to host maintenance.", "Temporarily disable a problematic service on one server." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service stop"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServerResource_restartServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "description" : "",
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Bounce a daemon after applying configuration updates.", "Recover an OSD exhibiting issues on a particular node." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServerResource_startServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service or OSD on a given server, disambiguating by type.",
          "usage" : [ "Start an OSD process on its host after maintenance.", "Bring a specific service replica online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD start"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/stop", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServerResource_stopServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Drain an OSD or service prior to maintenance.", "Temporarily disable a daemon causing issues." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service or OSD ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD stop"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "ServerResource_testSshConnection",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Use SSH with retries.",
          "name" : "retry",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Run a simple SSH connectivity test against the specified server (optionally with retries).",
          "usage" : [ "Diagnose SSH access issues before scheduling tasks that require remote commands.", "Measure whether retry logic is needed for unstable connections." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "SSH diagnostics"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/redetect" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services" : {
      "get" : {
        "summary" : "List of all services across all servers.",
        "operationId" : "ServiceResource_getAllServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph and croit services with health, state, and placement details.",
          "usage" : [ "Call to render the service inventory dashboard with pagination support.", "Refresh after starting/stopping services or during maintenance to monitor state transitions." ],
          "response_shape" : "OptionalPaginationResponse<MultiServerServiceResponse>",
          "common_parameters" : {
            "pagination.where.type" : "Filter to service types like mon/mds/nfs before bulk actions.",
            "pagination.where.running" : "Focus on stopped services when triaging issues."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Service monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/{serviceId}", "/services/restart" ],
          "postprocessing_hint" : "Group services by type and highlight entries with health.uptime=null to indicate unseen daemons.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi" : {
      "post" : {
        "summary" : "Create a new iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addIscsiGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "iSCSI gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision the single supported iSCSI gateway cluster and deploy ceph-iscsi gateways on selected servers.",
          "usage" : [ "Call during initial setup to instantiate the iSCSI control plane.", "Use after wiping an old deployment (servers rebooted) to recreate the gateway." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "iSCSI cluster provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "Monitor the ManagedTask output; once complete, verify gateway health via GET /services/iscsi.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}" : {
      "patch" : {
        "summary" : "Update an iSCSI gateway.",
        "operationId" : "IscsiServiceResource_updateIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable metadata on the iSCSI gateway service (currently the description).",
          "usage" : [ "Rename the gateway in the UI after reassigning responsibilities.", "Clarify the service description following infrastructure changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID to update.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI metadata update"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Inspect the ceph-iscsi gateway configuration.",
        "operationId" : "IscsiServiceResource_getIscsiGatewayConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiGatewayConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the ceph-iscsi configuration snapshot for the selected gateway.",
          "usage" : [ "Load the gateway detail view before presenting targets and clients.", "Refresh after finishing gateway maintenance or changing the active target." ],
          "response_shape" : "IscsiGatewayConfig",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Gateway configuration refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI service.",
        "operationId" : "IscsiServiceResource_deleteIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down the iSCSI gateway service and purge its Ceph-side configuration.",
          "usage" : [ "Invoke when decommissioning the iSCSI deployment or migrating to new hardware.", "Use before recreating the gateway to ensure no residual configuration remains." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier as returned by GET /services/iscsi.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Inform operators that affected servers must be rebooted before provisioning a new gateway.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a server to an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addServerToIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayServer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale out the iSCSI gateway by adding another server with its client-facing IP.",
          "usage" : [ "Use when onboarding a new gateway node to increase throughput.", "Call after replacing hardware to reinstate the node into the gateway cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serverId",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Existing iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway scaling"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "After success, run GET /services/iscsi/{serviceId} to confirm the new server appears and is healthy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}" : {
      "delete" : {
        "summary" : "Delete an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an iSCSI client definition and revoke its access credentials.",
          "usage" : [ "Call when retiring a host that should no longer access exported LUNs.", "Use before recreating the client with new CHAP secrets to avoid duplicates." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN as shown in the gateway configuration.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI client removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Re-run GET /services/iscsi/{serviceId} to confirm the client entry is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Configure a new iSCSI client",
        "operationId" : "IscsiServiceResource_createIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI client entry (CHAP credentials plus optional host group assignment).",
          "usage" : [ "Add a new initiator to access exported LUNs.", "Recreate a client with fresh credentials during onboarding." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "group",
            "in" : "body",
            "description" : "Group parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "username",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Desired client name or IQN.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newhost"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI client creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "patch" : {
        "summary" : "Change a client's username/password",
        "operationId" : "IscsiServiceResource_changeIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate CHAP credentials for an existing iSCSI client.",
          "usage" : [ "Update secrets after a credential leak or scheduled rotation.", "Rename the client user while preserving existing LUN mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "username",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Existing client name/IQN to update.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI credential rotation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}/disks" : {
      "delete" : {
        "summary" : "Unmap a disk from an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteLunFromIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an exported RBD image (LUN) from an iSCSI client without deleting the data.",
          "usage" : [ "Invoke when revoking a client's access to a specific disk before remapping it elsewhere.", "Use during maintenance to unmap volumes ahead of storage reconfiguration." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN whose mapping should be removed.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI LUN detach"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "postprocessing_hint" : "After success, refresh the client's disk list to verify the mapping is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add new disk(s) to an iSCSI client",
        "operationId" : "IscsiServiceResource_addLunToIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image will be created if it doesn't exist yet",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map existing or newly created RBD images to an iSCSI client.",
          "usage" : [ "Provision LUNs for a host by creating and exporting images in one call.", "Re-attach disks to a client after recreating credentials." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN receiving the disks.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk mapping"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/disks" : {
      "get" : {
        "summary" : "List iSCSI RBD exports for a gateway.",
        "operationId" : "IscsiServiceResource_getImages",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Include image details",
          "name" : "details",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiImagesResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images exported by the iSCSI gateway, optionally with metadata.",
          "usage" : [ "Populate the disks tab for an iSCSI gateway detail view.", "Refresh after adding, deleting or resizing LUNs." ],
          "response_shape" : "IscsiImagesResponse",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi/{serviceId}/disks/{wwn}" : {
      "patch" : {
        "summary" : "Update parameters for an exported RBD image.",
        "operationId" : "IscsiServiceResource_updateDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Image change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiImageChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an exported iSCSI disk without removing it from clients.",
          "usage" : [ "Grow a LUN after expanding underlying storage.", "Adjust disk size during maintenance while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "sizeString",
            "in" : "body",
            "description" : "Size in bytes",
            "required" : true,
            "example" : "1024"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "wwn parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID owning the disk.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "Disk WWN identifier as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI disk resize"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI-managed disk",
        "operationId" : "IscsiServiceResource_deleteIscsiImage",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an exported iSCSI disk and optionally remove the backing RBD image.",
          "usage" : [ "Call when retiring a LUN after data migration.", "Use to free capacity once a client no longer needs the associated disk." ],
          "response_shape" : "ManagedTask?",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "DeleteData parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "image",
            "in" : "body",
            "description" : "Image parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "wwn parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "World Wide Name of the disk as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI disk deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "If deleteData=true, wait for the ManagedTask to finish before reusing the pool/image name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}" : {
      "delete" : {
        "summary" : "Delete a host group.",
        "operationId" : "IscsiServiceResource_deleteHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an iSCSI host group after unmapping its members.",
          "usage" : [ "Call once all hosts and disks have been reassigned and the group is no longer needed.", "Use prior to recreating the group with a different membership or policy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name as displayed by the gateway.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "postprocessing_hint" : "Warn operators that mapped images stay attached until explicitly unmapped.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new host group.",
        "operationId" : "IscsiServiceResource_createHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI host group to manage access for multiple clients.",
          "usage" : [ "Organize initiators before mapping disks in bulk.", "Prepare a group for automated provisioning workflows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Name of the host group to create.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/disks" : {
      "delete" : {
        "summary" : "Remove a disk from a host group.",
        "operationId" : "IscsiServiceResource_deleteDiskFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach RBD disks from an iSCSI host group without deleting the images.",
          "usage" : [ "Trim group access before assigning disks to a different client or group.", "Use as part of group decommissioning to clear remaining disk mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk unmapping"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Verify the host group’s access list in GET /services/iscsi/{serviceId} to confirm removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add disks to a host group.",
        "operationId" : "IscsiServiceResource_addDiskToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of disks to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map one or more RBD images to every client in a host group.",
          "usage" : [ "Grant a fleet of initiators access to new storage in a single call.", "Pre-provision LUNs before adding hosts to the group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Target host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group disk mapping"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts" : {
      "delete" : {
        "summary" : "Remove hosts from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostsFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove multiple hosts from an iSCSI host group in a single call.",
          "usage" : [ "Call when bulk decommissioning initiators or moving them to another group.", "Use before deleting the host group to ensure no members remain." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk iSCSI host unassign"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "postprocessing_hint" : "Confirm that remaining hosts are correct before assigning new disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add hosts to a host group.",
        "operationId" : "IscsiServiceResource_addHostsToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of hosts to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bulk add multiple initiator IQNs to an iSCSI host group.",
          "usage" : [ "Onboard a batch of servers that should share the same LUN set.", "Restore group membership after recreating host entries." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk host enrollment"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" : {
      "delete" : {
        "summary" : "Remove a host from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single host from an iSCSI host group while leaving its disk mappings intact.",
          "usage" : [ "Call when revoking a specific initiator’s access to the group.", "Use ahead of moving the host into a different group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "host parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to remove.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:node01"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host unassign"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add a host to a host group.",
        "operationId" : "IscsiServiceResource_addHostToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add a single initiator IQN to an existing iSCSI host group.",
          "usage" : [ "Grant an additional server access to the group's mapped LUNs.", "Re-enroll a host that was previously removed from the group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "group parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "host parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to add.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newnode"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host enrollment"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/servers/{hostname}" : {
      "delete" : {
        "summary" : "Remove a server from an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_removeServerFromIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostname",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach one gateway server from the iSCSI cluster, stopping its service and cleaning ceph-iscsi config entries.",
          "usage" : [ "Call during node maintenance or decommission to drain a specific server from the gateway.", "Use before deleting the entire gateway to remove surplus servers cleanly." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "hostname",
            "in" : "path",
            "description" : "hostname parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier (see GET /services/iscsi).",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "hostname",
            "in" : "path",
            "description" : "Server hostname/FQDN exactly as registered with the gateway.",
            "required" : true,
            "example" : "gw1.example.com"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway node removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion before reusing the server for other roles.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/target" : {
      "put" : {
        "summary" : "Set iSCSI target to be used in other endpoints",
        "operationId" : "IscsiServiceResource_setIscsiTarget",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Target IQN string",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "string"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set or override the global target IQN used for a specific iSCSI service.",
          "usage" : [ "Adjust target IQN after importing an existing configuration.", "Correct the target identifier when recovering from configuration drift." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI target IQN update"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the ceph-iscsi config shell",
        "operationId" : "IscsiServiceResource_connectToIscsiTerminal",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Open an authenticated shell session on the active iSCSI gateway server for manual iscsi-config commands.",
          "usage" : [ "Use for troubleshooting ceph-iscsi configuration without SSHing manually.", "Call to automate scripted adjustments via the exposed terminal stream." ],
          "response_shape" : "TerminalConnection",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID whose active node should be targeted.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "iSCSI management shell"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Close the terminal when finished; state changes may require subsequent API calls to refresh cached data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways" : {
      "post" : {
        "summary" : "Create a new NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "NFS gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NFS cluster backed by CephFS across the selected servers.",
          "usage" : [ "Run during initial setup to expose CephFS over NFS.", "Recreate the cluster after a teardown to restore service." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "exports",
            "in" : "body",
            "description" : "Exports parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "NFS cluster provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "postprocessing_hint" : "Monitor the task until completion and confirm cluster health via GET /services/nfs-gateways/{serviceId}.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}" : {
      "patch" : {
        "summary" : "Update an NFS cluster.",
        "operationId" : "NfsServiceResource_patchNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NfsGatewayServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NFS cluster metadata and server membership.",
          "usage" : [ "Adjust the cluster description or server list after hardware changes.", "Swap out nodes while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS cluster updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Retrieve the NFS cluster configuration snapshot.",
        "operationId" : "NfsServiceResource_getNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayService"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve servers and exports configured for the NFS gateway cluster.",
          "usage" : [ "Load the NFS cluster detail view for administrators.", "Refresh after modifying servers or exports to confirm the applied state." ],
          "response_shape" : "NfsGatewayService",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS cluster detail refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports" : {
      "get" : {
        "summary" : "List exports belonging to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/NfsGatewayExport"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List exports defined for the NFS gateway cluster.",
          "usage" : [ "Populate the exports tab in the NFS cluster view.", "Refresh after creating, updating or deleting an export." ],
          "response_shape" : "array<NfsGatewayExport>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS export list polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add an export to the NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayExport"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NFS export and trigger the ganesha daemons to apply it.",
          "usage" : [ "Expose new CephFS directories over NFS.", "Call after preparing data that should be served to clients." ],
          "response_shape" : "NfsGatewayExport",
          "request_parameters" : [ {
            "name" : "access",
            "in" : "body",
            "description" : "Access parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "filesystem",
            "in" : "body",
            "description" : "Filesystem parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "NfsPath parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "Path parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "protocols",
            "in" : "body",
            "description" : "Protocols parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports/{exportId}", "/services/nfs-gateways/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports/{exportId}" : {
      "put" : {
        "summary" : "Replace an export entry on the NFS cluster.",
        "operationId" : "NfsServiceResource_replaceNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing NFS export definition with new parameters.",
          "usage" : [ "Adjust export paths or permissions after reorganizing data.", "Update squash or client access settings without recreating the export." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "access",
            "in" : "body",
            "description" : "Access parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "filesystem",
            "in" : "body",
            "description" : "Filesystem parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "NfsPath parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "Path parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "protocols",
            "in" : "body",
            "description" : "Protocols parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "exportId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Existing export identifier.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an export entry from the NFS cluster.",
        "operationId" : "NfsServiceResource_deleteNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NFS export from the gateway and propagate the deletion to all servers.",
          "usage" : [ "Invoke after decommissioning a dataset so clients lose access.", "Use prior to redefining the export with new parameters to avoid duplicate entries." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "exportId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS gateway service ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Numeric export identifier from GET /services/nfs-gateways/{serviceId}/exports.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS export removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/servers" : {
      "get" : {
        "summary" : "List server IDs assigned to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int32"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server IDs participating in the NFS gateway cluster.",
          "usage" : [ "Populate the servers tab in the NFS cluster detail view.", "Refresh after adding or removing nodes from the cluster." ],
          "response_shape" : "array<int>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS server membership polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/restart" : {
      "post" : {
        "summary" : "Restart services or OSDs.",
        "operationId" : "ServiceResource_restartMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart multiple services or OSDs immediately without waiting for long-running tasks.",
          "usage" : [ "Batch restart selected daemons after applying configuration changes.", "Prefer POST /services/rolling-restart for critical services that require sequential safety." ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered restarts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/rolling-restart", "/tasks" ],
          "postprocessing_hint" : "Refresh GET /services to confirm the new state; consider monitoring /tasks if follow-up jobs were triggered.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/rolling-restart" : {
      "post" : {
        "summary" : "Performs a rolling restart on the provided services or OSDs.",
        "description" : "Each service is restarted one after another. Should one of the services fail to restart, the rolling restart will be stopped.\nOnly one rolling restart will run at a time, i.e.multiple calls to this endpoint won't run in parallel.",
        "operationId" : "ServiceResource_restartMultipleServicesRolling",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a sequential restart of multiple services/OSDs, enforcing cluster health checks between steps.",
          "usage" : [ "Use for critical daemons where concurrency would cause downtime (monitors, managers, SMB servers, etc.).", "Trigger after rolling out configuration or package updates when a safe restart cadence is required." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Rolling restart orchestration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/restart", "/tasks" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask; if it stops on a failure, address the reported service before retrying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb" : {
      "post" : {
        "summary" : "Create a new simple SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a simple SMB cluster backed by CephFS across the specified servers.",
          "usage" : [ "Call during initial SMB setup once CephFS and required networks are configured.", "Recreate the cluster after teardown when migrating to new hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "adminPassword",
            "in" : "body",
            "description" : "AdminPassword parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "readonlyPassword",
            "in" : "body",
            "description" : "ReadonlyPassword parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "shares",
            "in" : "body",
            "description" : "Shares parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "virtualIps",
            "in" : "body",
            "description" : "VirtualIps parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB cluster provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Wait for the ManagedTask to finish, then verify CTDB health and share accessibility.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/active-directory-authentication" : {
      "post" : {
        "summary" : "Create a new SMB cluster using Active Directory for authentication.",
        "operationId" : "SmbServiceResource_addActiveDirectorySmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Active Directory SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ActiveDirectorySmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an Active Directory-integrated SMB cluster with CTDB high availability.",
          "usage" : [ "Use when administrators need domain-joined SMB access to CephFS shares.", "Recreate the cluster on new hardware while keeping AD as the identity provider." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "dnsServers",
            "in" : "body",
            "description" : "DnsServers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "domain",
            "in" : "body",
            "description" : "Domain parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "domainController",
            "in" : "body",
            "description" : "DomainController parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "joinWithSssd",
            "in" : "body",
            "description" : "JoinWithSssd parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "netbiosDomainName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Servers parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "shares",
            "in" : "body",
            "description" : "Shares parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "virtualIps",
            "in" : "body",
            "description" : "VirtualIps parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB+AD cluster provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Once the task completes, verify CTDB health and domain membership before exposing shares.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}" : {
      "patch" : {
        "summary" : "Update an SMB cluster.",
        "operationId" : "SmbServiceResource_updateSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update SMB cluster metadata, virtual IPs, or credentials.",
          "usage" : [ "Adjust virtual IP assignments after changing network topology.", "Rotate admin/readonly passwords following security policies." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "adminPassword",
            "in" : "body",
            "description" : "AdminPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "dnsServers",
            "in" : "body",
            "description" : "DnsServers parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "domainController",
            "in" : "body",
            "description" : "DomainController parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "readonlyPassword",
            "in" : "body",
            "description" : "ReadonlyPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "virtualIps",
            "in" : "body",
            "description" : "VirtualIps parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "SMB cluster updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name" ],
          "postprocessing_hint" : "Monitor the ManagedThreadTask until completion and verify CTDB status afterward.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get SMB cluster config and state.",
        "operationId" : "SmbServiceResource_getSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SmbGatewayServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve full configuration and runtime state for a specific SMB gateway cluster.",
          "usage" : [ "Call when opening the SMB cluster detail view to display servers, shares, and AD metadata.", "Re-query after updating share configuration or joining/leaving AD to verify the applied settings." ],
          "response_shape" : "SmbGatewayServiceResponse",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Identifier of the SMB service returned by GET /services.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB cluster detail"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Surface healthy=false servers and missing virtual IPs prominently to prompt operator remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down an SMB cluster, removing all servers and shares managed by croit.",
          "usage" : [ "Call when decommissioning the SMB service or migrating to a fresh deployment.", "Use after draining shares and clients to ensure the cluster is fully removed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "SMB cluster removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers" : {
      "post" : {
        "summary" : "Add a server to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale an SMB cluster by onboarding a new node with Samba and CTDB services.",
          "usage" : [ "Add capacity after provisioning additional servers.", "Re-add a node following maintenance once it is ready to rejoin the cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "DomainAdminPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "DomainAdminUser parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "nic",
            "in" : "body",
            "description" : "Nic parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "server",
            "in" : "body",
            "description" : "Server parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "vlan",
            "in" : "body",
            "description" : "Vlan parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node onboarding"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/service-dns-name" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single server from the SMB cluster while keeping the cluster online.",
          "usage" : [ "Call before draining a node for maintenance or replacement.", "Use to rebalance the cluster after reducing capacity requirements." ],
          "response_shape" : "ManagedThreadTask?",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "serverId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID as returned by GET /services/smb/{serviceId}.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/service-dns-name" : {
      "post" : {
        "summary" : "Change the service DNS name of an SMB cluster.",
        "operationId" : "SmbServiceResource_changeServiceDnsName",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DNS name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceDNSNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update the shared DNS name under which an AD-integrated SMB cluster registers.",
          "usage" : [ "Call after receiving a new service DNS entry or correcting a previous configuration.", "Rejoin the cluster to AD with a fresh name following recovery exercises." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "DomainAdminPassword parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "DomainAdminUser parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "joinServer",
            "in" : "body",
            "description" : "JoinServer parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB DNS updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/active-directory-authentication" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares" : {
      "post" : {
        "summary" : "Add a share to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Samba share backed by CephFS within the cluster.",
          "usage" : [ "Expose additional datasets to SMB clients without restarting services.", "Provision temporary maintenance shares for support operations." ],
          "response_shape" : "GeneratedId",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "body",
            "description" : "Path parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "share",
            "in" : "body",
            "description" : "Share parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "SMB share creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}/shares/{shareId}", "/services/smb/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares/{shareId}" : {
      "put" : {
        "summary" : "Replace a share on an SMB cluster.",
        "operationId" : "SmbServiceResource_replaceSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing SMB share definition with new parameters.",
          "usage" : [ "Update share paths or permissions without deleting and recreating the share.", "Align share configuration with policy changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "body",
            "description" : "Path parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "share",
            "in" : "body",
            "description" : "Share parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "shareId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share identifier to replace.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share update"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a share from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an SMB share definition from the cluster configuration.",
          "usage" : [ "Call when retiring a dataset or before recreating the share with new settings.", "Use to revoke access quickly while leaving the cluster online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "shareId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share ID from GET /services/smb/{serviceId}/shares.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/start" : {
      "post" : {
        "summary" : "Start services or OSDs.",
        "operationId" : "ServiceResource_startMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start multiple services or OSD daemons in parallel via the service manager.",
          "usage" : [ "Bring a set of daemons online after maintenance windows.", "Automate recovery workflows that re-enable services across nodes." ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service starts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/stop", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Poll GET /services to confirm each entry reports a running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/stop" : {
      "post" : {
        "summary" : "Stop services or OSDs.",
        "operationId" : "ServiceResource_stopMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop multiple services or OSD daemons in one request.",
          "usage" : [ "Gracefully shut down daemons prior to maintenance windows.", "Evacuate services from a node before hardware work." ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stops"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/start", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services to ensure the daemons report a stopped state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServiceResource_restartService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service instance, optionally targeting a specific server.",
          "usage" : [ "Apply configuration changes that require a daemon restart.", "Recover a misbehaving service without touching others." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services/rolling-restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServiceResource_startService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service on its assigned server (or a specific server for multi-instance services).",
          "usage" : [ "Bring a daemon back online after targeted maintenance.", "Recover a service that was previously stopped by operators." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to start.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service start"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/restart", "/services/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServiceResource_stopService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance on demand.",
          "usage" : [ "Quiesce a daemon before performing host maintenance.", "Temporarily disable a service causing issues without touching others." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stop"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/services/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a service.",
        "operationId" : "ServiceResource_updateService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable properties of a service (description, ports, DNS, etc.).",
          "usage" : [ "Adjust RGW service ports or DNS after network changes.", "Revise the display description for operators." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Description parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "Port parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "rgwDnsName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "rgwZone",
            "in" : "body",
            "description" : "RgwZone parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "sslPort",
            "in" : "body",
            "description" : "SslPort parameter",
            "required" : false,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to update.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Service metadata update"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a service.",
        "operationId" : "ServiceResource_deleteServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a service (or remove a server from a multi-server service).",
          "usage" : [ "Invoke when decomissioning daemons or shrinking multi-server services.", "If the service spans multiple servers, provide the server query parameter to detach only that node." ],
          "response_shape" : "ManagedTask?",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "serviceId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier from GET /services.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Service lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/{id}/stop", "/services/restart" ],
          "postprocessing_hint" : "If a ManagedTask is returned, stream /tasks/{id} until completion.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServiceResource_restartServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service or OSD daemon, optionally targeting a specific server instance.",
          "usage" : [ "Bounce an unhealthy daemon without impacting peers.", "Restart an OSD after storage maintenance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain of the target (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/start", "/services/stop", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services/{type}/{id} or monitor tasks to confirm the daemon returns to running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServiceResource_startServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service or OSD daemon, specifying whether the ID refers to a service or an OSD.",
          "usage" : [ "Bring an individual daemon online after maintenance.", "Start an OSD process once its device is available." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD start"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{type}/{id}/stop", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServiceResource_stopServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service or OSD daemon designated by type and ID.",
          "usage" : [ "Suspend a daemon before performing maintenance on its host or storage.", "Temporarily disable an OSD without affecting others." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "type parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD stop"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services/{type}/{id}/start", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/available-ceph-versions" : {
      "get" : {
        "summary" : "Get a list of supported Ceph releases.",
        "operationId" : "SetupResource_getAvailableCephVersions",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephRelease"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover all Ceph release versions supported by this croit installation for version planning.",
          "usage" : [ "Call to view supported Ceph versions before configuring cluster version.", "Use to understand upgrade path options for Ceph cluster management." ],
          "response_shape" : "Array<CephRelease>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Supported versions listing"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/ceph-default" ],
          "postprocessing_hint" : "Use version names from response for Ceph version configuration; some versions may require container switching.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/ceph-default" : {
      "get" : {
        "summary" : "Get the default ceph release for this container as a lowercase string.",
        "operationId" : "SetupResource_getCephDefaultRelease",
        "tags" : [ "setup" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the default Ceph release version built into this croit container.",
          "usage" : [ "Call to determine the container's native Ceph version for compatibility planning.", "Use to understand container switching requirements for different Ceph versions." ],
          "response_shape" : "String (lowercase release name)",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Container information"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/setup/available-ceph-versions", "/setup/ceph-version" ],
          "postprocessing_hint" : "Returns lowercase version name (e.g., 'reef'); this is the version optimized for this container.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/setup/ceph-version" : {
      "post" : {
        "summary" : "Set the Ceph version for a fresh deployment or import.",
        "operationId" : "SetupResource_setCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Ceph version configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephVersionConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the Ceph version that croit expects the cluster to be running, enabling version-specific features and compatibility.",
          "usage" : [ "Call during initial setup to set expected Ceph version before cluster creation.", "Use to update backend expectations when Ceph cluster version has been manually changed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "No cluster operations in progress; Valid Ceph version specified; Container switching possible if needed",
            "post_action" : "Ceph version configured; Container switched if required; Images updated; Task advisor refreshed"
          },
          "request_parameters" : [ {
            "name" : "cephVersion",
            "in" : "body",
            "description" : "CephVersion parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Ceph version configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/available-ceph-versions" ],
          "postprocessing_hint" : "Version change may trigger container switch; monitor task progress; warns about functionality risks if cluster version differs.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing Ceph version may require container switch and can affect functionality if cluster version differs"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the currently configured Ceph version.",
        "operationId" : "SetupResource_getCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephVersionConfiguration"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the currently configured Ceph version that croit expects the cluster to be running.",
          "usage" : [ "Call to verify current Ceph version configuration before making changes.", "Use to check version compatibility for cluster operations." ],
          "response_shape" : "CephVersionConfiguration",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Version information retrieval"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/available-ceph-versions" ],
          "postprocessing_hint" : "Response includes currently configured Ceph release; may differ from actual cluster version if manually changed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/import-cluster" : {
      "post" : {
        "summary" : "Imports an existing Ceph cluster.",
        "operationId" : "SetupResource_importCluster",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Cluster import request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterImportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Import an existing Ceph cluster by connecting to monitors and retrieving cluster configuration.",
          "usage" : [ "Call during initial setup to connect croit to an existing Ceph cluster.", "Use when integrating croit management with a manually deployed Ceph cluster." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Ceph cluster is running; Admin key has full permissions; Monitor addresses are reachable; Croit not yet initialized",
            "post_action" : "Cluster FSID retrieved; Monitor list updated; Admin key stored; Essential keyrings created; Crush rules checked"
          },
          "request_parameters" : [ {
            "name" : "adminKey",
            "in" : "body",
            "description" : "AdminKey parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "mons",
            "in" : "body",
            "description" : "Mons parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Cluster import operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/ceph-version" ],
          "postprocessing_hint" : "Import process validates connectivity, retrieves cluster metadata, creates essential keyrings, and updates images; cluster becomes manageable through croit.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Importing will permanently configure croit for this specific Ceph cluster"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/list-interfaces" : {
      "get" : {
        "summary" : "List all interfaces on the management node.",
        "operationId" : "SetupResource_getManagementInterfaceCandidates",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/InterfaceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover available network interfaces on the management node for PXE and management traffic configuration.",
          "usage" : [ "Call during initial setup to view available network interfaces before selecting management interface.", "Use to verify current network configuration and available interface options." ],
          "response_shape" : "InterfaceResponse",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Interface discovery"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/setup/main-ip" ],
          "postprocessing_hint" : "Use interfaceName from response for management interface configuration; currentInterface shows active management interface.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/main-ip" : {
      "post" : {
        "summary" : "Set's the interface used for PXE booting.",
        "operationId" : "SetupResource_setMainIp",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Main IP configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MainIpRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the primary network interface and IP address used for PXE booting and server management.",
          "usage" : [ "Call during initial cluster setup to define the management network interface.", "Use to update the management IP when network configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Interface exists on system; IP is valid IPv4; Network configuration is ready for change",
            "post_action" : "Management IP updated; Network services restarted; Task advisor checks network configuration"
          },
          "request_parameters" : [ {
            "name" : "interfaceName",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Ip parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Management IP configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/list-interfaces" ],
          "postprocessing_hint" : "Management interface change triggers network service restart; new IP becomes active for PXE and management traffic.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-backup" : {
      "post" : {
        "summary" : "Restore from an encrypted cloud backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Backup restore request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BackupRestoreRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restore croit configuration from an encrypted cloud backup stored on portal.croit.io during initial setup.",
          "usage" : [ "Call during disaster recovery to restore cluster configuration from cloud backup.", "Use when setting up a replacement management node with existing cluster data." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Internet connectivity available; Valid API token; Encryption key available; Backup exists on portal",
            "post_action" : "Backup downloaded; Configuration decrypted and restored; Database imported; Services restarted"
          },
          "request_parameters" : [ {
            "name" : "backupUuid",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          }, {
            "name" : "croitApiToken",
            "in" : "body",
            "description" : "CroitApiToken parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "encryptionKey",
            "in" : "body",
            "description" : "EncryptionKey parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 7200,
            "note" : "Cloud backup restoration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/restore-unencrypted-backup" ],
          "postprocessing_hint" : "Restoration runs as managed task; monitor progress in task manager; restart may be required after completion.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Backup restoration will overwrite current configuration and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-unencrypted-backup" : {
      "post" : {
        "summary" : "Restore from an unencrypted backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromUnencryptedBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UnencryptedBackupRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restore croit configuration from an unencrypted backup file uploaded during initial setup.",
          "usage" : [ "Call during disaster recovery to restore from local backup file.", "Use when cloud backup is unavailable or when working with legacy backup formats." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid backup ZIP file uploaded; File contains database.sql; Sufficient disk space available",
            "post_action" : "Backup file buffered; Database restored; Configuration imported; Services restarted"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 7200,
            "note" : "Backup file restoration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/restore-backup" ],
          "postprocessing_hint" : "File is buffered completely before restoration starts; restoration runs as managed task; monitor progress in task manager.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Backup restoration will overwrite current configuration and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs" : {
      "get" : {
        "summary" : "Get all CephFS snapshot jobs.",
        "operationId" : "CephFsSnapshotResource_getCephFsSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephFSSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List scheduled CephFS snapshot jobs and their status for monitoring or editing.",
          "usage" : [ "Render the snapshot schedule table in the UI", "Refresh after creating or updating snapshot jobs" ],
          "response_shape" : "OptionalPaginationResponse<CephFSSnapshotSchedule>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Snapshot schedule polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs/{id}", "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Display failedSnapshots prominently if present for active schedules.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_addCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new automated CephFS snapshot schedule to protect filesystem data.",
          "usage" : [ "Call when setting up backup schedules for critical CephFS data.", "Use to establish periodic snapshot retention policies for disaster recovery." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "CephFS snapshots enabled; Cron expression valid; Path exists and accessible",
            "post_action" : "Snapshot schedule created and activated; Retention policy applied"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "maxSnapshots",
            "in" : "body",
            "description" : "MaxSnapshots parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "Paths parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "SnapshotPrefix parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/cephfs", "/snapshot-schedule/cephfs/{id}" ],
          "postprocessing_hint" : "Verify schedule appears in GET /snapshot-schedule/cephfs with correct configuration.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_updateCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Modify settings of an existing CephFS snapshot schedule without recreating it.",
          "usage" : [ "Call when adjusting snapshot timing, retention, or target paths for an existing schedule.", "Use to enable/disable schedules temporarily without losing configuration." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; New values pass validation; CephFS snapshots enabled",
            "post_action" : "Schedule updated with new settings; Changes take effect on next scheduled run"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "maxSnapshots",
            "in" : "body",
            "description" : "MaxSnapshots parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "Paths parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "SnapshotPrefix parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to update.",
            "required" : true,
            "example" : "15"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/cephfs", "/snapshot-schedule/cephfs/{id}" ],
          "postprocessing_hint" : "Verify changes with GET /snapshot-schedule/cephfs; disabled schedules stop creating new snapshots but retain existing ones.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_removeCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an automated CephFS snapshot schedule to stop future snapshot creation.",
          "usage" : [ "Call when decommissioning snapshot schedules that are no longer needed.", "Use to clean up schedules for paths that have been deleted or moved." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; No critical snapshots in progress",
            "post_action" : "Schedule removed; Future snapshots cancelled; Existing snapshots preserved"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to remove.",
            "required" : true,
            "example" : "15"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/cephfs" ],
          "postprocessing_hint" : "Confirm removal with GET /snapshot-schedule/cephfs to verify schedule no longer appears.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd" : {
      "get" : {
        "summary" : "Get all RBD snapshot jobs.",
        "operationId" : "RbdSnapshotResource_getRbdSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRbdSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all configured RBD snapshot schedules with their current status and configuration details.",
          "usage" : [ "Call to display snapshot schedule dashboard and monitor automated backup jobs.", "Use to review retention policies and verify snapshot schedule coverage across RBD images." ],
          "response_shape" : "OptionalPaginationResponse<RbdSnapshotSchedule>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Snapshot schedule queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/snapshot-schedule/rbd/{id}", "/rbd" ],
          "postprocessing_hint" : "Group schedules by pool; highlight disabled or failing schedules; show next scheduled run times; display retention policy summaries.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_addRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "RBD snapshot schedule creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a scheduled RBD snapshot job with automatic retention management for data protection.",
          "usage" : [ "Call to establish regular backup schedules for RBD images in specified pools.", "Use to implement data protection policies with automated snapshot lifecycle management." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid cron expression; Snapshot prefix format correct; Target pools/images exist; Scheduler service available",
            "post_action" : "Snapshot schedule created; Cron job registered; Retention policy active; First snapshot scheduled"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "disableRbdCheck",
            "in" : "body",
            "description" : "DisableRbdCheck parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "maxSnapshots",
            "in" : "body",
            "description" : "MaxSnapshots parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "Paths parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "SnapshotPrefix parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule becomes active immediately; first snapshot created according to cron schedule; retention policy applies to future snapshots.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_updateRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot schedule update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update configuration of an existing RBD snapshot schedule including timing, retention, and target paths.",
          "usage" : [ "Call when snapshot schedule requirements change and need adjustment without recreating.", "Use to modify retention policies, timing, or target images while preserving schedule history." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; Valid cron expression; Snapshot prefix format correct; Target paths exist",
            "post_action" : "Schedule configuration updated; Next snapshots use new settings; Retention policy applies to future snapshots"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "disableRbdCheck",
            "in" : "body",
            "description" : "DisableRbdCheck parameter",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "maxSnapshots",
            "in" : "body",
            "description" : "MaxSnapshots parameter",
            "required" : false,
            "example" : "42"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "Paths parameter",
            "required" : false,
            "example" : "example-value"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "SnapshotPrefix parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to update.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule changes take effect for next scheduled run; existing snapshots unaffected; verify new schedule timing is correct.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_removeRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete an RBD snapshot schedule and stop all future automated snapshots for the configured paths.",
          "usage" : [ "Call when snapshot schedule is no longer needed and automated backups should cease.", "Use to clean up obsolete schedules when backup strategies change or RBD images are decommissioned." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; No active snapshot operations depend on this schedule; Admin permissions verified",
            "post_action" : "Schedule deleted; Future snapshots cancelled; Existing snapshots preserved; Scheduler updated"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to delete.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule removal is immediate; existing snapshots remain untouched; verify no dependent backup strategies rely on this schedule.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting snapshot schedules stops all future automated backups for configured RBD images"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats" : {
      "get" : {
        "summary" : "Get a graph by name.",
        "description" : "\n\t\t\tSee resources/statistics/graphite-queries.yml for available graphs.\n\n\t\t\tSome queries like server-specific stats expect template parameter which are passed with\n\t\t\t<code>template-{name}</code> query parameters. Example:\n\n\t\t\t<code>/stats?graph=server-disk-load&startTime=-600&maxDataPoints=50&template-server-id=1</code>\n\n\t\t\tstartTime and endTime should be in the same format, i.e., either both > 0 or both <= 0\n\t\t\t",
        "operationId" : "StatsResource_getStatsAuthed",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "description" : "End time of the graph, default = 0. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "The graph to query.",
          "name" : "graph",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "Maximum number of data points to return to thin out graphs over long time ranges. Default = 500",
          "name" : "maxDataPoints",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "Start time of the graph. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GraphResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve time-series metrics for dashboards using predefined graphite graph IDs.",
          "usage" : [ "Call when rendering monitoring charts; reuse cached data between dashboards if time range unchanged", "Limit polling to no more than once per refresh interval configured for the graph" ],
          "response_shape" : "GraphResponse",
          "common_parameters" : {
            "template-*" : "Supply graph-specific template variables like template-server-id=1."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/stats/server-names", "/stats/pool-names", "/stats/s3-user-names" ],
          "postprocessing_hint" : "Downsample or merge series client-side if visualization cannot display all datapoints.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/cephfs-monitored-dirs" : {
      "put" : {
        "summary" : "Set the CephFS directories that are monitored for statistics.",
        "description" : "Replaces the currently configured set of directories.",
        "operationId" : "StatsResource_updateCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "CephFS directories to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the list of CephFS directories being tracked for utilization statistics.",
          "usage" : [ "Update monitored directories when onboarding new projects or retiring old ones.", "Automate stats configuration during environment provisioning." ],
          "response_shape" : "void",
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "CephFS monitor reconfiguration"
          },
          "cache_hint" : "no-cache",
          "postprocessing_hint" : "Refresh GET /stats/cephfs-monitored-dirs to confirm the new directory list.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get CephFS directories that are monitored for statistics.",
        "operationId" : "StatsResource_getCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsMonitoredDir"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose the list of CephFS directories currently tracked by utilization metrics.",
          "usage" : [ "Show monitored directories in the CephFS stats configuration UI", "Verify directory watch list after administrators update it" ],
          "response_shape" : "array<CephFsMonitoredDir>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Sort directories alphabetically and ensure '/' appears first.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/monitored-rbds" : {
      "put" : {
        "summary" : "Set the Rbd images that are monitored for statistics.",
        "description" : "Replaces the currently configured set of Rbd images.",
        "operationId" : "StatsResource_updateRbdMonitoredImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire list of RBD images being monitored for I/O statistics.",
          "usage" : [ "Call when performing bulk reconfiguration of RBD monitoring.", "Use to synchronize monitoring configuration with external management systems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All specified RBD images exist; Statistics collection service available",
            "post_action" : "Monitoring list completely replaced; I/O collection starts for new images and stops for removed ones"
          },
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Bulk RBD monitoring reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Verify new configuration with GET /stats/monitored-rbds; previously monitored images not in the new list will stop being tracked.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This operation replaces the entire monitoring list and may stop collection for currently monitored images"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the Rbd images that are monitored for statistics.",
        "operationId" : "StatsResource_getMonitoredRbds",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/MonitoredRbd"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images currently tracked for RBD I/O statistics.",
          "usage" : [ "Display the monitored RBD list in the stats configuration UI", "Confirm that requested images are being collected" ],
          "response_shape" : "array<String>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats", "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Display items sorted and grouped by pool for readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Remove images from the set of monitored Rbds.",
        "operationId" : "StatsResource_deleteMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove RBD images from monitoring to stop I/O statistics collection.",
          "usage" : [ "Call when decommissioning RBD images or reducing monitoring overhead.", "Use to selectively remove images while preserving monitoring for others." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Images are currently being monitored; Request format is valid",
            "post_action" : "Images removed from monitoring; I/O statistics collection stops for specified images"
          },
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "RBD monitoring changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Confirm removal by checking GET /stats/monitored-rbds; historical data is preserved.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add images to the set of monitored Rbds.",
        "operationId" : "StatsResource_addMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Additional Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add RBD images to the monitoring list for I/O statistics collection.",
          "usage" : [ "Call when new critical RBD images need performance tracking.", "Use to incrementally expand monitoring without affecting existing tracked images." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "RBD images exist; Pool names are valid; Statistics collection is enabled",
            "post_action" : "Images added to monitoring; I/O statistics collection begins for new images"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "RBD monitoring changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/stats/monitored-rbds", "/stats" ],
          "postprocessing_hint" : "Verify new images appear in GET /stats/monitored-rbds; I/O data collection starts immediately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats/pool-names" : {
      "get" : {
        "summary" : "Get available Ceph pools for statistics.",
        "operationId" : "StatsResource_getPoolNames",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponsePoolStatsInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide pool identifiers and metadata for stats template selection.",
          "usage" : [ "Populate pool selection widgets before querying pool graphs", "Use quota fields to pre-select pools nearing limits" ],
          "response_shape" : "OptionalPaginationResponse<PoolStatsInfo>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/pools", "/stats" ],
          "postprocessing_hint" : "Map queryName to `template-pool-name` parameter values in stats calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-bucket-names" : {
      "get" : {
        "summary" : "Get available S3 buckets for statistics.",
        "operationId" : "StatsResource_getS3BucketNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3BucketName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with quotas for use as template parameters in S3 graphs.",
          "usage" : [ "Populate S3 bucket selectors before requesting usage charts", "Refresh after new buckets are created or quotas change" ],
          "response_shape" : "array<S3BucketName>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "S3 selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-user-names", "/stats" ],
          "postprocessing_hint" : "Use queryName when calling /stats?graph=... with template-s3-bucket-name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-user-names" : {
      "get" : {
        "summary" : "Get available S3 users for statistics.",
        "description" : "This API is somewhat expensive if there are a lot of S3 users, don't call this too often.",
        "operationId" : "StatsResource_getS3UserNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3UserName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return RGW user identifiers for stats templates (e.g. bandwidth per user).",
          "usage" : [ "Populate user pickers in S3 usage dashboards", "Request sparingly on large clusters due to cost" ],
          "response_shape" : "array<S3UserName>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Expensive RGW user listing"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-bucket-names", "/stats" ],
          "postprocessing_hint" : "Normalize queryName by substituting '.' and '@' when building template parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/server-names" : {
      "get" : {
        "summary" : "Get available server names for statistics.",
        "operationId" : "StatsResource_getServerNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ServerNameAndId"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server identifiers used as template parameters for stats queries.",
          "usage" : [ "Populate server selectors before fetching graphs", "Refresh when the hardware inventory changes" ],
          "response_shape" : "array<ServerNameAndId>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/servers", "/stats" ],
          "postprocessing_hint" : "Sort by hostname before presenting in dropdowns.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/status" : {
      "get" : {
        "summary" : "Backend status and health check.",
        "description" : "Returns aggregated health data that indicates whether the croit backend is operational.",
        "operationId" : "BackendStatusResource_getBackendStatus",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BackendStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Check whether the croit backend is healthy before executing workflows.",
          "usage" : [ "Call before write operations or when rendering global status widgets", "Treat non-OK health results as degraded service" ],
          "response_shape" : "BackendStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure caller is authenticated with at least viewer privileges.",
            "post_action" : "Escalate alerts to the UI if status.health != 'OK'."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Shared global polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status" ],
          "postprocessing_hint" : "Highlight health warnings prominently; avoid storing raw payload in logs.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/status/croit-version" : {
      "get" : {
        "summary" : "Get croit version.",
        "description" : "Retrieves the currently running croit software version as a semantic version string.",
        "operationId" : "BackendStatusResource_getCroitVersionParsed",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Determine the running croit software version for diagnostics and support.",
          "usage" : [ "Fetch once when composing system diagnostics or about dialogs", "Attach version metadata to support bundles" ],
          "response_shape" : "string",
          "workflow_guidance" : {
            "pre_check" : "Ensure viewer-level access.",
            "post_action" : "Cache version in session or telemetry payload."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Version rarely changes"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/status" ],
          "postprocessing_hint" : "Store value client-side to avoid repeated calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/supervisor" : {
      "get" : {
        "summary" : "Inspect supervised services status.",
        "operationId" : "SupervisorResource_listProcesses",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseSupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve status and health information for all supervised services managed by the supervisor system.",
          "usage" : [ "Call to monitor overall system health and identify services requiring attention.", "Use to display service dashboard and track service uptime across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<SupervisorModuleJson>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Service status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/supervisor/{name}" ],
          "postprocessing_hint" : "Highlight failed or stopped services; group by service type; show restart counts and last activity timestamps.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}" : {
      "get" : {
        "summary" : "Get details of a specific supervised service.",
        "operationId" : "SupervisorResource_getProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed status, configuration, and operational metrics for a specific supervised service.",
          "usage" : [ "Call when investigating service issues or monitoring specific service performance.", "Use to get detailed logs, process information, and configuration details for troubleshooting." ],
          "response_shape" : "SupervisorModuleJson",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to inspect (e.g., 'dhcp', 'tftp', 'ipmi', 'mariadb').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Individual service queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}/start", "/supervisor/{name}/stop", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Display process ID, uptime, memory usage, and recent log entries; highlight error conditions and configuration issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}/restart" : {
      "post" : {
        "summary" : "Restart a specific supervised service.",
        "operationId" : "SupervisorResource_restartProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a supervised service to apply configuration changes or recover from service issues.",
          "usage" : [ "Call after configuration changes that require service restart.", "Use to recover from service hangs or memory leaks without manual stop/start sequence." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Admin confirms restart impact",
            "post_action" : "Service stopped gracefully; New process started; Service reloads configuration; Status updated"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to restart (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 8,
            "window_seconds" : 300,
            "note" : "Service restart operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/start", "/supervisor/{name}/stop" ],
          "postprocessing_hint" : "Restart combines stop and start operations; monitor service status for successful restart; configuration changes take effect immediately.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Restarting services may cause temporary service interruption; MariaDB restart requires special confirmation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/start" : {
      "post" : {
        "summary" : "Start a supervised service.",
        "operationId" : "SupervisorResource_startProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a stopped or failed supervised service to restore its functionality.",
          "usage" : [ "Call when a service is stopped and needs to be brought back online.", "Use to recover from service failures or after maintenance operations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Service is currently stopped",
            "post_action" : "Service start initiated; Process spawned; Service status changes to running"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to start (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Service management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/stop", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Service starts asynchronously; check service status to confirm successful startup; logs available in service details.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/stop" : {
      "post" : {
        "summary" : "Stop a supervised service.",
        "operationId" : "SupervisorResource_stopProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a running supervised service for maintenance, troubleshooting, or resource management.",
          "usage" : [ "Call when service needs maintenance or is consuming excessive resources.", "Use to temporarily disable services during troubleshooting or configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Service is currently running; Service is not critical system service",
            "post_action" : "Service stop initiated; Process terminated gracefully; Service status changes to stopped"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "name parameter",
            "required" : true,
            "example" : "example-name"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to stop (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Service management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/start", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Service stops gracefully with timeout; check service status to confirm shutdown; dependent services may be affected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/info" : {
      "get" : {
        "summary" : "Collect some support info for debugging purposes.",
        "operationId" : "SupportResource_getSupportInfo",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate comprehensive diagnostic package containing cluster logs, configuration, and system state for support analysis.",
          "usage" : [ "Call when preparing to contact support or when detailed system analysis is needed.", "Use to create diagnostic archive before making configuration changes or troubleshooting complex issues." ],
          "response_shape" : "application/octet-stream (zip file)",
          "workflow_guidance" : {
            "pre_check" : "Sufficient disk space; Cluster components accessible; Admin permissions verified",
            "post_action" : "Diagnostic package created; Logs collected; Configuration captured; Archive ready for analysis"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 1800,
            "note" : "Support info generation (resource intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn" ],
          "postprocessing_hint" : "Archive contains logs, configuration files, and cluster state; download completes when generation finishes; share with support team for analysis.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Support info collection is resource intensive and may contain sensitive cluster information"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn" : {
      "get" : {
        "summary" : "Check if connected to croit VPN.",
        "operationId" : "SupportResource_getVPNConnection",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/VPNConnectionInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Check current VPN connection status and configuration for croit support infrastructure.",
          "usage" : [ "Call to verify if support VPN is active and accessible for remote assistance.", "Use to display VPN dashboard and monitor connection health before support sessions." ],
          "response_shape" : "VPNConnectionInfo",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "VPN status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/support/vpn/connect", "/support/vpn/disconnect" ],
          "postprocessing_hint" : "Display connection status prominently; show hostname configuration; highlight when VPN is active to indicate remote access is enabled.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/support/vpn/connect" : {
      "post" : {
        "summary" : "Connect to the croit VPN.",
        "operationId" : "SupportResource_connectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VPNConnectionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Establish secure VPN connection to croit support infrastructure for remote assistance and debugging.",
          "usage" : [ "Call when remote support is needed for troubleshooting complex cluster issues.", "Use to enable croit support team access for emergency assistance or advanced configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster registered; Internet connectivity; No concurrent VPN operations; Valid hostname if provided",
            "post_action" : "VPN container started; Connection established; API notified; Support team can access cluster"
          },
          "request_parameters" : [ {
            "name" : "hostname",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : false,
            "example" : "example-name"
          }, {
            "name" : "info",
            "in" : "body",
            "description" : "Info parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 1800,
            "note" : "VPN connection attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn", "/support/vpn/disconnect" ],
          "postprocessing_hint" : "Connection runs as managed task; monitor task progress; VPN status visible via GET /support/vpn; disconnect when support session ends.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "VPN connection enables remote access by croit support team"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn/disconnect" : {
      "post" : {
        "summary" : "Disconnect to the croit VPN.",
        "operationId" : "SupportResource_disconnectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Terminate VPN connection to croit support infrastructure and revoke remote access permissions.",
          "usage" : [ "Call when support session is complete to ensure security by closing remote access.", "Use to immediately disconnect support team access if no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "VPN connection exists; No concurrent VPN operations; Container runtime accessible",
            "post_action" : "VPN container stopped; Connection terminated; API notified; Remote access revoked"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 900,
            "note" : "VPN disconnection attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn", "/support/vpn/connect" ],
          "postprocessing_hint" : "Disconnection runs as managed task; monitor task progress; VPN status updated via GET /support/vpn; security restored.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/survey" : {
      "patch" : {
        "summary" : "Enable or disable the croit hardware survey.",
        "operationId" : "SurveyResource_updateSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Survey configuration update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SurveyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable participation in the croit hardware survey for anonymous cluster statistics collection.",
          "usage" : [ "Call when changing privacy preferences for cluster data sharing with croit.io.", "Use to opt in or out of anonymous hardware and configuration reporting for product improvement." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid enabled value provided; Admin permissions verified",
            "post_action" : "Survey participation setting updated; Next survey cycles use new preference"
          },
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable this feature",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Survey preference updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/survey", "/survey/preview" ],
          "postprocessing_hint" : "Setting change is immediate; survey data transmission starts/stops with next scheduled collection; preview what data is shared via GET /survey/preview.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get survey configuration",
        "operationId" : "SurveyResource_getSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current configuration status for croit hardware survey participation.",
          "usage" : [ "Call to display survey participation status in privacy settings or administration dashboard.", "Use to check if cluster is sharing anonymous hardware data with croit.io for product improvement." ],
          "response_shape" : "SurveyConfigResponse",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Survey configuration queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/survey/preview", "/survey" ],
          "postprocessing_hint" : "Display survey participation status prominently; link to privacy policy; show data preview option if enabled.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/feedback" : {
      "post" : {
        "summary" : "Report feedback to croit.io.",
        "operationId" : "SurveyResource_postFeedback",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Feedback data",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Send user feedback, bug reports, or support requests to croit.io with optional cluster diagnostics.",
          "usage" : [ "Call when users encounter issues and want to report them to croit support.", "Use to send feature requests or general feedback about the croit platform." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster is registered; Internet connectivity available; Not in offline mode",
            "post_action" : "Feedback submitted to croit.io; Support info collected if requested; Task tracks upload progress"
          },
          "request_parameters" : [ {
            "name" : "_children",
            "in" : "body",
            "description" : "_children parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "_nodeFactory",
            "in" : "body",
            "description" : "_nodeFactory parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Feedback submissions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/survey", "/support/info" ],
          "postprocessing_hint" : "Feedback submission runs as managed task; support info collection may take several minutes; cancellation prompts for feedback-only submission.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/preview" : {
      "get" : {
        "summary" : "Preview what is sent to croit.io if survey is enabled.",
        "operationId" : "SurveyResource_previewSurveyData",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyReport"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Preview anonymous hardware and configuration data that would be shared with croit.io through the survey program.",
          "usage" : [ "Call to show users exactly what data is collected before enabling survey participation.", "Use for transparency in privacy settings to build trust in data sharing practices." ],
          "response_shape" : "SurveyReport",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Survey data preview"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/survey" ],
          "postprocessing_hint" : "Present data in readable format; highlight anonymization; explain what information helps improve croit products; emphasize no sensitive data included.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor" : {
      "post" : {
        "summary" : "Force a refresh of the recommendation list",
        "operationId" : "TaskAdvisorResource_refreshTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force immediate refresh of task advisor recommendations by running all health checks and analysis.",
          "usage" : [ "Call when cluster configuration has changed and fresh recommendations are needed.", "Use after resolving issues to validate that warnings have been cleared." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; Health checks can be performed",
            "post_action" : "All advisor checks run; Recommendations updated; Obsolete warnings cleared"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Manual advisor refresh"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor" ],
          "postprocessing_hint" : "Refresh runs synchronously; new recommendations available immediately; re-fetch advisor list to see updated results.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "get" : {
        "summary" : "Get a list of all recommendation tasks",
        "operationId" : "TaskAdvisorResource_getTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RecommendationResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current task-advisor recommendations for administrators.",
          "usage" : [ "Call to populate the task-advisor dashboard when the page loads.", "Poll periodically (e.g. every 60s) to surface new findings or auto-mitigations." ],
          "response_shape" : "array<RecommendationResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Advisor dashboard refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/task-advisor", "/task-advisor/suggestions/{suggestionId}", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Sort recommendations by updatedAt descending and badge muted entries so operators can restore them.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor/retry-backup" : {
      "post" : {
        "summary" : "Retry the backup on mon disks.",
        "operationId" : "TaskAdvisorResource_retryBackupOnMonDisk",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retry failed backup operation on monitor disks to resolve backup-related advisor warnings.",
          "usage" : [ "Call when task advisor shows backup failure warnings that need immediate resolution.", "Use to manually trigger backup retry after resolving disk space or connectivity issues." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Previous backup failure detected; Disk space available; Backup destination accessible",
            "post_action" : "Backup operation retried; Advisor recommendations updated; Backup failure warning cleared if successful"
          },
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Backup retry operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor" ],
          "postprocessing_hint" : "Retry executes immediately; backup success clears related advisor warnings; refresh advisor to see updated status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/suggestions/{suggestionId}" : {
      "post" : {
        "summary" : "Apply a suggestion from an advisor recommendation",
        "operationId" : "TaskAdvisorResource_applySuggestion",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "suggestionId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a specific automated fix suggestion from task advisor to resolve cluster issues or warnings.",
          "usage" : [ "Call to apply automatic remediation for advisor recommendations with available fixes.", "Use when manual resolution is complex and advisor provides automated solution." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Suggestion exists; Cluster state allows automated fix; Required permissions available",
            "post_action" : "Automated fix executed; Task tracks progress; Recommendation cleared if successful; Cluster state updated"
          },
          "path_parameters" : [ {
            "name" : "suggestionId",
            "in" : "path",
            "description" : "suggestionId parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "suggestionId",
            "in" : "path",
            "description" : "UUID of the suggestion to apply from advisor recommendation.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 1800,
            "note" : "Automated fix execution"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/tasks/{id}" ],
          "postprocessing_hint" : "Fix runs as managed task; monitor task progress; recommendation removed if successful; cluster changes take effect immediately.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/{taskUuid}" : {
      "patch" : {
        "summary" : "Hide a task from the recommendation list",
        "operationId" : "TaskAdvisorResource_patchTask",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskAdvisorUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Hide or show task advisor recommendations to control which warnings are displayed to administrators.",
          "usage" : [ "Call when specific recommendations are not relevant to current operations and should be hidden.", "Use to manage recommendation visibility without deleting the underlying issue detection." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task recommendation exists; Valid hide value provided; Admin permissions verified",
            "post_action" : "Recommendation visibility updated; UI reflects new display state; Underlying issue detection continues"
          },
          "request_parameters" : [ {
            "name" : "hide",
            "in" : "body",
            "description" : "Unique identifier",
            "required" : true,
            "example" : "42"
          } ],
          "path_parameters" : [ {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "taskUuid parameter",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          }, {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "UUID of the task advisor recommendation to update.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Advisor recommendation updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Visibility change is immediate; hidden recommendations can be shown again later; underlying checks continue regardless of visibility.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a task identified by UUID",
        "operationId" : "TaskAdvisorResource_deleteTaskByUuid",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently remove a task advisor recommendation to stop it from appearing in future scans.",
          "usage" : [ "Call when a recommendation is no longer applicable due to architectural or policy changes.", "Use to clean up obsolete recommendations that cannot be resolved through normal means." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "taskUuid parameter",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          }, {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "Task advisor recommendation UUID to permanently delete.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Recommendation cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Recommendation removed permanently; refresh task advisor dashboard to confirm removal.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting recommendations permanently removes them from future advisor scans"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks" : {
      "get" : {
        "summary" : "Fetch a list of tasks.",
        "operationId" : "TaskResource_getAllTasks",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseTaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate through historical and active tasks with optional filtering and sorting.",
          "usage" : [ "Load the task history view with pagination controls.", "Filter tasks by state or name when auditing recent maintenance operations." ],
          "response_shape" : "PaginationResponse<TaskResponse>",
          "common_parameters" : {
            "pagination.where.state" : "Filter to RUNNING/FAILED to focus on tasks needing action.",
            "pagination.order.startedAt" : "Sort descending to view the newest tasks first."
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Task history pagination"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Use `total` and `limit` to drive pagination UI; hide sensitive task names from non-admin users as returned.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/active" : {
      "get" : {
        "summary" : "Get all currently active tasks (running or waiting).",
        "operationId" : "TaskResource_getAllActiveTasks",
        "tags" : [ "tasks" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all tasks that are currently RUNNING or WAITING.",
          "usage" : [ "Drive dashboards that show live operational activity.", "Poll after submitting work to present users with any tasks that still require monitoring or interaction." ],
          "response_shape" : "array<TaskResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Active task overview"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 5,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks", "/tasks/status", "/tasks/{id}" ],
          "postprocessing_hint" : "Sort by startedAt descending and flag WAITING tasks that might require manual approval (question != null).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/status" : {
      "get" : {
        "summary" : "Get tasks with status.",
        "operationId" : "TaskResource_getTaskStatuses",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch status snapshots for multiple tasks in one request.",
          "usage" : [ "Poll in bulk when coordinating several concurrent background jobs.", "Use after starting a batch of tasks to detect which ones still require attention." ],
          "response_shape" : "array<TaskResponse>",
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Batch status polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Map responses by id; treat missing entries as completed, purged, or permission filtered tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}" : {
      "get" : {
        "summary" : "Get task.",
        "operationId" : "TaskResource_getTaskStatus",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the latest status snapshot for a single long-running task.",
          "usage" : [ "Call immediately after an endpoint returns a ManagedTask to track its execution until completion.", "Use while showing a task detail drawer to stream progress, log output, and pending questions." ],
          "response_shape" : "TaskResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier returned when the task was started.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Task detail polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/status", "/tasks/{id}/cancel", "/tasks/{id}/answer" ],
          "postprocessing_hint" : "Stop polling once done=true; treat statusCode 0 as success, -256 as user cancel, others as failure, and surface question tokens when present.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}/answer" : {
      "post" : {
        "summary" : "Answer task question.",
        "operationId" : "TaskResource_answerQuestion",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Task question answer",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskQuestionAnswer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide an answer to a task question to allow the task to continue execution.",
          "usage" : [ "Call when a task is waiting for user input and shows a question in its status.", "Use to respond to confirmation prompts or provide configuration choices for running tasks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task exists; Task has pending question; Answer token is current; Response is valid option",
            "post_action" : "Answer recorded; Task resumes execution; Question cleared from task status"
          },
          "request_parameters" : [ {
            "name" : "response",
            "in" : "body",
            "description" : "Response parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "token",
            "in" : "body",
            "description" : "Token parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier that has a pending question.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Task question responses"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Answer submission immediately unblocks task execution; monitor task status for progress continuation; question disappears after answer.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks/{id}/cancel" : {
      "post" : {
        "summary" : "Cancel task.",
        "operationId" : "TaskResource_cancelTask",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Cancel a running or waiting task to stop its execution and free system resources.",
          "usage" : [ "Call when a long-running task needs to be stopped due to changed requirements or errors.", "Use to abort tasks that are stuck waiting for user input or taking too long to complete." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task exists; Task is running or waiting; User has admin permissions",
            "post_action" : "Cancellation signal sent; Task will terminate gracefully; Status becomes cancelled"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier to cancel.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Task cancellation requests"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Task cancellation is asynchronous; monitor task status to confirm termination; cancelled tasks show statusCode -256.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users" : {
      "get" : {
        "summary" : "List all known users (local, LDAP and OIDC included).",
        "operationId" : "UserResource_getUsers",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseAccount"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all user accounts from local database, LDAP, and OIDC providers.",
          "usage" : [ "Call to display user management dashboards and overview screens.", "Use for audit purposes to see all users with access to the system." ],
          "response_shape" : "OptionalPaginationResponse<Account>",
          "workflow_guidance" : {
            "pre_check" : "Authentication providers (LDAP/OIDC) are accessible if configured",
            "post_action" : "Filter or paginate results for display; differentiate local vs external users"
          },
          "failure_modes" : [ "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource identifier and check if the resource exists."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "User listing operations"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/users/{id}", "/users/{id}/password" ],
          "postprocessing_hint" : "Combines local accounts with external provider data; excludes API tokens; accounts from external providers have negative IDs; pagination applies to merged results.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new croit user. Returns the ID of the new user.",
        "operationId" : "UserResource_createUser",
        "tags" : [ "users" ],
        "requestBody" : {
          "description" : "User creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/AccountRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new local croit user account with specified username and role permissions.",
          "usage" : [ "Call when adding new users to the local authentication system.", "Use to provision user accounts with appropriate viewer or admin access levels." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Username is unique; Valid role configuration; Not using API token authentication",
            "post_action" : "User account created; Username and roles stored; Account ID returned for reference"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "Roles parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "username",
            "in" : "body",
            "description" : "Name of the resource",
            "required" : true,
            "example" : "example-name"
          } ],
          "failure_modes" : [ "400 if request body is invalid or missing required fields", "409 if resource already exists", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and ensure all required fields are provided."
          }, {
            "code" : "409",
            "action" : "Check if resource already exists; use PUT to update existing resource."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User account creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Account creation is immediate; new user can log in with generated credentials; admin users require both ADMIN and VIEWER roles.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/oidc/{id}/users/{subject}" : {
      "patch" : {
        "summary" : "Update roles of an OIDC user.",
        "operationId" : "UserResource_updateOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for an OIDC user account without affecting their identity provider authentication.",
          "usage" : [ "Call when OIDC user responsibilities change and need different access levels in croit.", "Use to manage role assignments for users authenticated through external identity providers." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "OIDC provider exists; User subject exists; Valid role configuration; Interactive session used",
            "post_action" : "OIDC user roles updated; Changes effective immediately; Identity provider authentication unchanged"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "Roles parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "subject parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "OIDC provider ID that authenticates this user.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "User subject identifier from the OIDC provider.",
            "required" : true,
            "example" : "user@company.com"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "OIDC user role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/oidc/{id}/users/{subject}" ],
          "postprocessing_hint" : "Role changes are immediate; affects croit permissions only; OIDC authentication and identity remain unchanged.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an OIDC user.",
        "operationId" : "UserResource_deleteOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an OIDC user and immediately invalidate all their active sessions.",
          "usage" : [ "Call when removing OIDC users who no longer need access to the system.", "Use to clean up user accounts when users are removed from the identity provider." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "OIDC user exists; Provider configuration is valid; Admin has interactive session",
            "post_action" : "OIDC user deleted; All user sessions immediately invalidated; User cannot authenticate via OIDC"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "subject parameter",
            "required" : true,
            "example" : "example-value"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "OIDC provider ID that manages this user.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "Unique subject identifier from the OIDC provider.",
            "required" : true,
            "example" : "user123@company.com"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "OIDC user management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/oidc/{id}/users/{subject}" ],
          "postprocessing_hint" : "Session invalidation happens immediately; user will be logged out of all active sessions; only affects croit access (OIDC provider unchanged).",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting OIDC users will immediately terminate all their sessions and remove access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}" : {
      "patch" : {
        "summary" : "Update a local croit user.",
        "operationId" : "UserResource_updateUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "User update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for a local croit user account while ensuring at least one admin remains.",
          "usage" : [ "Call when user responsibilities change and need different access levels.", "Use to grant or revoke permissions while maintaining administrative access to the system." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Valid role configuration; Admin safety preserved; Interactive session used",
            "post_action" : "User roles updated; Changes effective immediately; Admin protection maintained"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "Roles parameter",
            "required" : false,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "User account ID to update.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if patch format is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate patch format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to patch."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Role changes are immediate; user may lose current access; system ensures at least one admin remains active.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Role changes affect user permissions immediately and must preserve admin access"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a local croit user account.",
        "operationId" : "UserResource_deleteUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a local croit user account while ensuring at least one admin user remains.",
          "usage" : [ "Call when removing users who no longer need access to the system.", "Use for cleanup when decommissioning user accounts from local authentication." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; At least one other local admin account exists if deleting admin; Interactive session required",
            "post_action" : "User account deleted; User sessions invalidated; User cannot log in with local credentials"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "User ID to delete from the local database.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if resource does not exist", "409 if resource is in use and cannot be deleted", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to delete."
          }, {
            "code" : "409",
            "action" : "Remove dependencies or references to this resource before deletion."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Account deletion is immediate; existing sessions remain valid until expiry; only affects local accounts (LDAP/OIDC users managed externally).",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting user accounts will permanently remove their access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}/password" : {
      "put" : {
        "summary" : "Change the password of a local croit user.",
        "operationId" : "UserResource_setPassword",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Password change request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PasswordChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the password for a local croit user account with appropriate authorization checks.",
          "usage" : [ "Call when users need to update their passwords or admins need to reset user passwords.", "Use for password security maintenance allowing self-service password changes and admin resets." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Account is local (not LDAP); Interactive session; Admin permissions for other users",
            "post_action" : "Password updated securely; User can login with new password; Password change logged"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "Password parameter",
            "required" : true,
            "example" : "example-value"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "id parameter",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "User account ID for password change.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if request body is invalid", "404 if resource does not exist", "403 if user lacks required permissions" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate request body format and field values."
          }, {
            "code" : "404",
            "action" : "Verify the resource exists before attempting to update."
          }, {
            "code" : "403",
            "action" : "Ensure user has appropriate role and permissions for this operation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Password change operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Password change is immediate; user must use new password for next login; password is securely hashed and stored; operation is audited.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    }
  },
  "info" : {
    "title" : "Croit platform API",
    "version" : "1.0",
    "description" : "API documentation for the croit platform."
  }
}