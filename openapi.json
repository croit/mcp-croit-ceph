{
  "openapi" : "3.1.0",
  "components" : {
    "schemas" : {
      "Account" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "authScheme" : {
            "$ref" : "#/components/schemas/AccountAuthScheme"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "managedByLdap" : {
            "type" : "boolean"
          },
          "fullName" : {
            "type" : [ "string", "null" ],
            "description" : "Full name of LDAP/OIDC users"
          },
          "distinguishedName" : {
            "type" : [ "string", "null" ],
            "description" : "Distinguished name (DN) of LDAP users"
          },
          "managedByOidcProvider" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/AccountOidcInfo"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "username", "roles", "authScheme" ]
      },
      "AccountAuthScheme" : {
        "type" : "string",
        "enum" : [ "password", "ldap", "oidc", "api_token" ]
      },
      "AccountOidcInfo" : {
        "type" : "object",
        "properties" : {
          "oidcRefreshTokenPresent" : {
            "type" : "boolean"
          },
          "oidcRefreshExpiry" : {
            "type" : [ "string", "null" ]
          },
          "oidcUpdateExpiry" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AccountRequest" : {
        "description" : "Request to create a new croit user.",
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Login name of the user."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "AclEntry" : {
        "type" : "object",
        "description" : "An ACL entry for a bucket, see S3 documentation for details.",
        "required" : [ "grantee", "permission" ],
        "properties" : {
          "grantee" : {
            "$ref" : "#/components/schemas/AclEntryGrantee"
          },
          "userId" : {
            "type" : [ "string", "null" ],
            "description" : "Only meaningful if grantee == SINGLE_USER."
          },
          "displayName" : {
            "type" : [ "string", "null" ],
            "description" : "Informational. Not used when setting ACLs."
          },
          "permission" : {
            "type" : "object"
          }
        }
      },
      "AclEntryGrantee" : {
        "type" : "string",
        "enum" : [ "ALL_USERS", "AUTHENTICATED_USERS", "SINGLE_USER", "LOG_DELIVERY" ]
      },
      "ActiveDirectorySmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "domain", "netbiosDomainName", "serviceDnsName", "domainController", "dnsServers", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : "string",
            "description" : "Active Directory domain/realm, e.g., MY-ORG.LOCAL"
          },
          "netbiosDomainName" : {
            "type" : "string",
            "description" : "NetBIOS domain name, e.g., MY-ORG"
          },
          "serviceDnsName" : {
            "type" : "string",
            "description" : "Service DNS name which will be used as NetBIOS name by which an SMB server is known."
          },
          "domainController" : {
            "type" : "string",
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Try to join with adcli+sssd. The image running on the server needs to support this."
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "AdminCephPermissions" : {
        "type" : "object"
      },
      "ApiTokenInfo" : {
        "description" : "Information about an API token.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Account ID of the API token."
          },
          "name" : {
            "type" : "string",
            "description" : "Descriptive name of the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Roles for the API token."
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry time of the API token (optional, if omitted, the token doesn't expire)."
          }
        },
        "required" : [ "name", "roles" ]
      },
      "ApiTokenRequest" : {
        "description" : "Request to create a new API token.",
        "type" : "object",
        "required" : [ "name", "roles" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Descriptive name for the API token."
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Time when api token is supposed to expire (optional)."
          }
        }
      },
      "ApiTokenUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin role also needs viewer role."
          }
        }
      },
      "ApiWarning" : {
        "type" : "object",
        "required" : [ "id", "message" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "message" : {
            "type" : "string"
          }
        }
      },
      "ArchConfig" : {
        "type" : "object",
        "properties" : {
          "x86_64" : {
            "type" : "boolean",
            "description" : "Whether x86_64 images are enabled."
          },
          "arm64" : {
            "type" : "boolean",
            "description" : "Whether arm64 images are enabled."
          }
        }
      },
      "AuditInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "category" : {
            "type" : "string"
          },
          "operation" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "method" : {
            "$ref" : "#/components/schemas/AuditLogMethod"
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "endpoint" : {
            "type" : "string"
          },
          "queryParams" : {
            "type" : "string"
          },
          "body" : {
            "type" : "string"
          }
        },
        "required" : [ "time", "category", "operation", "username", "ip", "method", "endpoint", "queryParams", "body" ]
      },
      "AuditLogMethod" : {
        "type" : "string",
        "enum" : [ "POST", "GET", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS" ]
      },
      "AvailableConfigTemplate" : {
        "type" : "object",
        "required" : [ "name", "template" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "template" : {
            "type" : "string"
          }
        }
      },
      "AvailableMigrationTasks" : {
        "type" : "object",
        "properties" : {
          "mimic" : {
            "type" : "boolean"
          },
          "nautilus" : {
            "type" : "boolean"
          },
          "octopus" : {
            "type" : "boolean"
          },
          "pacific" : {
            "type" : "boolean"
          },
          "quincy" : {
            "type" : "boolean"
          },
          "reef" : {
            "type" : "boolean"
          },
          "switchTarget" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BackendStatus" : {
        "description" : "Status overview of the croit backend. Does not contain Ceph information.",
        "type" : "object",
        "properties" : {
          "doSetup" : {
            "type" : "boolean",
            "description" : "Cluster setup required"
          },
          "cephConfigured" : {
            "type" : "boolean",
            "description" : "True if Ceph is configured and ceph status can be queried"
          },
          "daosConfigured" : {
            "type" : "boolean",
            "description" : "True if DAOS is configured"
          },
          "status" : {
            "description" : "Croit health check",
            "type" : "string",
            "$ref" : "#/components/schemas/CroitHealthStatus"
          },
          "oktaOAuth" : {
            "type" : "boolean",
            "description" : "Auth via Okta available"
          },
          "versions" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitApiVersion"
            },
            "description" : "Available croit versions"
          },
          "currentVersion" : {
            "type" : "string",
            "description" : "Running croit version"
          },
          "currentVersionParsed" : {
            "description" : "Running croit version (parsed)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "useCustomLogo" : {
            "type" : "boolean",
            "description" : "Custom logo available at /api/extra-files/logo[-small].svg"
          },
          "backends" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CroitBackendConfiguration"
            },
            "description" : "Manage multiple croit clusters that share a centralized login system. This list may or may not contain the current cluster"
          },
          "multiMdsEnabled" : {
            "type" : "boolean",
            "description" : "Multi MDS is enabled"
          },
          "multiRgwEnabled" : {
            "type" : "boolean",
            "description" : "Multi RGW is enabled"
          },
          "error" : {
            "type" : [ "string", "null" ],
            "description" : "Error message to display in case there are critical errors in croit."
          },
          "errorLong" : {
            "type" : [ "string", "null" ],
            "description" : "Longer error message to display in case there are critical errors in croit."
          }
        },
        "required" : [ "status", "versions", "currentVersion" ]
      },
      "BackupRestoreRequest" : {
        "type" : "object",
        "required" : [ "encryptionKey", "croitApiToken", "backupUuid" ],
        "properties" : {
          "encryptionKey" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "croitApiToken" : {
            "type" : "string"
          },
          "backupUuid" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "BondRequest" : {
        "type" : "object",
        "required" : [ "name", "nics" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "activePassive" : {
            "type" : "boolean"
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BondUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "activePassive" : {
            "type" : [ "boolean", "null" ]
          },
          "primary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "BootDiskRequest" : {
        "type" : "object",
        "properties" : {
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to install croit on."
          },
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that the disk is on. Used as a sanity check that the correct disk is selected."
          }
        }
      },
      "BucketCreationRequest" : {
        "description" : "Create an S3 bucket.",
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "User id of the owner"
          },
          "placement" : {
            "type" : [ "string", "null" ],
            "description" : "Name of a placement policy as returned by /placements"
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "expectedNumberOfObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Expected number of objects to pre-shard the bucket. If in doubt: don't set this as setting a too large value will degrade performance."
          },
          "endpoint" : {
            "type" : [ "string", "null" ],
            "description" : "The S3 endpoint (full URL) used to create this bucket, this effectively controls the zonegroup in which the bucket is created."
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "BucketDeletionRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "deleteData" : {
            "type" : [ "boolean", "null" ]
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "BucketDetails" : {
        "type" : "object",
        "required" : [ "cors", "acl", "versioning" ],
        "properties" : {
          "cors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CORSRuleResponse"
            }
          },
          "acl" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
          }
        }
      },
      "BucketUpdateRequest" : {
        "description" : "Update an S3 bucket.",
        "type" : "object",
        "properties" : {
          "owner" : {
            "type" : [ "string", "null" ],
            "description" : "Change owner to this uid."
          },
          "acl" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/AclEntry"
            }
          },
          "versioning" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/S3BucketVersioningConfiguration"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CORSRuleResponse" : {
        "description" : "S3 CORS rule",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "string", "null" ],
            "description" : "Unique identifier for the rule"
          },
          "allowedMethods" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed HTTP methods"
          },
          "allowedOrigins" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed origins"
          },
          "allowedHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Allowed headers"
          },
          "exposeHeaders" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Exposed headers"
          },
          "maxAgeSeconds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max age in seconds for preflight requests"
          }
        },
        "required" : [ "allowedMethods", "allowedOrigins", "allowedHeaders", "exposeHeaders" ]
      },
      "Category" : {
        "type" : "string",
        "enum" : [ "CEPH", "BACKUP", "CRUSH", "MON", "MGR", "OSD", "PG", "RGW", "NFS", "ISCSI", "SMB", "OS", "CROIT", "RBD_MIRROR", "MDS", "NVMEOF" ]
      },
      "CephConfChangeRequest" : {
        "type" : "object",
        "properties" : {
          "value" : { },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CephConfDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "CephConfigDumpLevel" : {
        "type" : "string",
        "enum" : [ "BASIC", "ADVANCED", "DEV", "UNKNOWN" ]
      },
      "CephConfigResponse" : {
        "type" : "object",
        "required" : [ "name", "value", "description", "default", "level", "seeAlso" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "value" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "description" : {
            "type" : "string"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephConfigUnit"
            }, {
              "type" : "null"
            } ]
          },
          "default" : {
            "$ref" : "#/components/schemas/CephConfigValueReply"
          },
          "level" : {
            "$ref" : "#/components/schemas/CephConfigDumpLevel"
          },
          "seeAlso" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "canUpdateAtRuntime" : {
            "type" : [ "boolean", "null" ]
          },
          "currentValue" : { },
          "currentValueFormatted" : { },
          "defaultValue" : { },
          "defaultValueFormatted" : { }
        }
      },
      "CephConfigType" : {
        "type" : "string",
        "enum" : [ "STRING", "INT", "DOUBLE", "BOOL", "TEXT_FILE" ]
      },
      "CephConfigUnit" : {
        "type" : "string",
        "enum" : [ "BYTES", "SECONDS" ]
      },
      "CephConfigValueReply" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CephConfigType"
          },
          "value" : { }
        }
      },
      "CephDashboardRole" : {
        "type" : "object",
        "required" : [ "scopes_permissions", "name" ],
        "properties" : {
          "scopes_permissions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephDashboardUser" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "integer",
            "format" : "int64"
          },
          "name" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "croitImport" : {
            "type" : "boolean"
          },
          "roles" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFSSnapshotSchedule" : {
        "description" : "Object containing all information for an CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a millisecond-precision timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "Comma-separated string of CephFS directories to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "pathsFormatted", "failedSnapshots" ]
      },
      "CephFlagReponse" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "recommendedState" : {
            "type" : "boolean"
          },
          "currentState" : {
            "type" : "boolean"
          }
        }
      },
      "CephFsDirectoryEntries" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephFsDirectoryEntriesWithStats" : {
        "type" : "object",
        "required" : [ "stats", "entries" ],
        "properties" : {
          "stats" : {
            "$ref" : "#/components/schemas/CephFsResponse"
          },
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            }
          }
        }
      },
      "CephFsFileType" : {
        "type" : "string",
        "enum" : [ "FILE", "DIR", "SYMLINK", "UNKNOWN" ]
      },
      "CephFsFileUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "absolutePath" : {
            "type" : [ "string", "null" ],
            "description" : "New absolute path of the file to rename or move the file."
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Permissions in Unix notation."
          }
        }
      },
      "CephFsLayout" : {
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsMonitoredDir" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-cephfs-dir-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of bytes. Deprecated, use value returned by /stats API."
          },
          "quotaFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Maximum number of files. Deprecated, use value returned by /stats API"
          }
        }
      },
      "CephFsNewDirectoryRequest" : {
        "type" : "object",
        "required" : [ "dir" ],
        "properties" : {
          "dir" : {
            "type" : "string"
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "null to use the default pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephFsPathPermission" : {
        "type" : "object",
        "required" : [ "path", "permissions" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephfsPathPermissionType"
          }
        }
      },
      "CephFsQuota" : {
        "type" : "object",
        "properties" : {
          "maxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephFsResponse" : {
        "type" : "object",
        "required" : [ "path", "sizeFormatted", "dirFilesFormatted", "modeFormatted", "quotaMaxBytesFormatted" ],
        "properties" : {
          "path" : {
            "type" : "string"
          },
          "fullPath" : {
            "type" : [ "string", "null" ]
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "uid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "gid" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "mode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephFsFileType"
            }, {
              "type" : "null"
            } ]
          },
          "dirBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dirSubdirs" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxFiles" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "symlinkPath" : {
            "type" : [ "string", "null" ]
          },
          "isDir" : {
            "type" : [ "boolean", "null" ]
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "dirFilesFormatted" : {
            "type" : "string"
          },
          "modeFormatted" : {
            "type" : "string"
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string"
          }
        }
      },
      "CephFsSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a CephFS snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\".",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot.",
            "minItems" : 1
          }
        }
      },
      "CephFsSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a CephFS snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of CephFS directories to be snapshot."
          }
        }
      },
      "CephFsUploadRequest" : {
        "type" : "object",
        "required" : [ "file", "path" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "path" : {
            "type" : "string"
          }
        }
      },
      "CephHealth" : {
        "type" : "string",
        "enum" : [ "HEALTH_OK", "HEALTH_WARN", "HEALTH_ERR", "HEALTH_UNKNOWN" ]
      },
      "CephHealthCheckDetailMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          }
        }
      },
      "CephHealthCheckSummaryMessage" : {
        "type" : "object",
        "required" : [ "message" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephModule" : {
        "type" : "object",
        "required" : [ "name", "error_string", "module_options" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "can_run" : {
            "type" : "boolean"
          },
          "error_string" : {
            "type" : "string"
          },
          "module_options" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephModuleOption"
            }
          }
        }
      },
      "CephModuleOption" : {
        "type" : "object",
        "required" : [ "name", "type", "level", "default_value", "min", "max", "enum_allowed", "desc", "long_desc", "tags", "see_also" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string"
          },
          "level" : {
            "type" : "string"
          },
          "flags" : {
            "type" : "integer",
            "format" : "int32"
          },
          "default_value" : {
            "type" : "string"
          },
          "min" : {
            "type" : "string"
          },
          "max" : {
            "type" : "string"
          },
          "enum_allowed" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "desc" : {
            "type" : "string"
          },
          "long_desc" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "see_also" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "CephModuleStatus" : {
        "type" : "object",
        "required" : [ "enabled_modules", "disabled_modules" ],
        "properties" : {
          "enabled_modules" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "disabled_modules" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephModule"
            }
          }
        }
      },
      "CephMutedStatusCheck" : {
        "type" : "object",
        "required" : [ "code", "summary" ],
        "properties" : {
          "code" : {
            "type" : "string",
            "description" : "Name of the muted status check.",
            "examples" : [ "SLOW_OPS" ]
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Indicates whether this check will stay muted once it's resolved."
          },
          "summary" : {
            "type" : "string"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPermissions" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "raw" : "#/components/schemas/RawCephPermissions",
            "admin" : "#/components/schemas/AdminCephPermissions",
            "rbd" : "#/components/schemas/RbdCephPermissions",
            "cephfs" : "#/components/schemas/CephfsCephPermissions"
          }
        },
        "type" : "object"
      },
      "CephPgStat" : {
        "type" : "object",
        "required" : [ "pgid", "state", "acting", "up" ],
        "properties" : {
          "pgid" : {
            "type" : "string"
          },
          "state" : {
            "type" : "string"
          },
          "last_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "last_deep_scrub_stamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "acting" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "up_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "acting_primary" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephPoolDeleteRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "stats", "hints", "redundancy", "unprotectedUntilFormatted", "quotaMaxBytesFormatted", "quotaMaxObjectsFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "pgpNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "crushRule" : {
            "type" : "integer",
            "format" : "int32"
          },
          "stats" : {
            "$ref" : "#/components/schemas/PoolStatsResponse"
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "erasureCodingOverwriteSupportMissing" : {
            "type" : "boolean",
            "description" : "Indicates whether this pool is missing the ec_overwrites flag."
          },
          "fastRead" : {
            "type" : "boolean",
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "unprotectedUntil" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Time until the no_delete flag on the pool will be set again if it was temporarily disabled. null if pool is currently protected."
          },
          "deleteProtected" : {
            "type" : "boolean",
            "description" : "True if pool is currently protected from deletion."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to display in the UI."
          },
          "redundancy" : {
            "type" : "string"
          },
          "unprotectedUntilFormatted" : {
            "type" : "string",
            "description" : "Like unprotectedUntil, but formatted into a human-readable string."
          },
          "quotaMaxBytesFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxBytes formatted to be human-readable and to show usage percentage"
          },
          "quotaMaxObjectsFormatted" : {
            "type" : "string",
            "description" : "QuotaMaxObjects formatted to be more easily readable and to show usage percentage"
          }
        }
      },
      "CephPoolSurvey" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : "boolean"
          },
          "pgNum" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "application" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "CephPoolUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "pgNum" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "minSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          },
          "dataChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "parityChunks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "quotaMaxBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "quotaMaxObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "crushRule" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "unprotect" : {
            "type" : [ "boolean", "null" ]
          },
          "application" : {
            "type" : [ "string", "null" ],
            "description" : "Application using the pool, default ceph applications are \"rbd\", \"cephfs\", and \"rgw\"."
          },
          "fastRead" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enables parallel reading of all k+m shards for erasure coded pools."
          },
          "compression" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionSettings"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephRelease" : {
        "type" : "string",
        "enum" : [ "luminous", "mimic", "nautilus", "octopus", "pacific", "quincy", "reef" ]
      },
      "CephReleaseCount" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "$ref" : "#/components/schemas/CephRelease"
          },
          "count" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephReleases" : {
        "type" : "object",
        "required" : [ "mon", "mgr", "osd", "mds", "overall", "other" ],
        "properties" : {
          "mon" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mgr" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "osd" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "mds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "overall" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephReleaseCount"
            }
          },
          "other" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/CephReleaseCount"
              }
            }
          }
        }
      },
      "CephStatus" : {
        "type" : "object",
        "required" : [ "fsid", "health" ],
        "properties" : {
          "fsid" : {
            "type" : "string"
          },
          "quorumNamesCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "health" : {
            "$ref" : "#/components/schemas/CephStatusHealth"
          },
          "osdMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusOsdmap"
            }, {
              "type" : "null"
            } ]
          },
          "mgrMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusMgrMap"
            }, {
              "type" : "null"
            } ]
          },
          "pgMap" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusPgMap"
            }, {
              "type" : "null"
            } ]
          },
          "numOfMons" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusCheck" : {
        "type" : "object",
        "required" : [ "severity", "summary" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "summary" : {
            "$ref" : "#/components/schemas/CephHealthCheckSummaryMessage"
          },
          "detail" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephHealthCheckDetailMessage"
            }
          },
          "muted" : {
            "type" : "boolean",
            "description" : "Indicates whether this check is muted."
          }
        }
      },
      "CephStatusHealth" : {
        "type" : "object",
        "required" : [ "status", "checks" ],
        "properties" : {
          "status" : {
            "$ref" : "#/components/schemas/CephHealth"
          },
          "checks" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/CephStatusCheck"
            }
          },
          "mutes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/CephMutedStatusCheck"
            },
            "description" : "List of muted status checks. null indicates that the current ceph version doesn't support muting status checks."
          }
        }
      },
      "CephStatusMgrMap" : {
        "type" : "object",
        "properties" : {
          "available" : {
            "type" : [ "boolean", "null" ]
          },
          "standbysCount" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusOsdmap" : {
        "type" : "object",
        "properties" : {
          "numUpOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "CephStatusPgMap" : {
        "type" : "object",
        "properties" : {
          "bytesUsed" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "bytesTotal" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeBytesSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringBytesPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "readOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "writeOpPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "recoveringObjectsPerSec" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "dataBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "CephUserRequest" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions" ],
        "properties" : {
          "user" : {
            "type" : "string",
            "description" : "A fully qualified Ceph user name, i.e., usually client.XYZ"
          },
          "comment" : {
            "type" : "string",
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "Permissions for this keyring",
            "type" : "object",
            "$ref" : "#/components/schemas/CephPermissions"
          }
        }
      },
      "CephUserResponse" : {
        "type" : "object",
        "required" : [ "user", "comment", "permissions", "rawPermissions" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "comment" : {
            "type" : "string"
          },
          "permissions" : {
            "$ref" : "#/components/schemas/CephPermissions"
          },
          "rawPermissions" : {
            "$ref" : "#/components/schemas/RawCephPermissions"
          }
        }
      },
      "CephUserUpdate" : {
        "type" : "object",
        "properties" : {
          "comment" : {
            "type" : [ "string", "null" ],
            "description" : "Optional comment that will be stored by croit"
          },
          "permissions" : {
            "description" : "New permissions for this keyring",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephPermissions"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "CephVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "CephVersionConfiguration" : {
        "type" : "object",
        "required" : [ "cephVersion" ],
        "properties" : {
          "cephVersion" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "CephfsCephPermissions" : {
        "type" : "object",
        "required" : [ "pools", "paths" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            }
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsPathPermission"
            }
          }
        }
      },
      "CephfsClientInfo" : {
        "description" : "A Ceph client connected to CephFS, can be either a Kernel or libcephfs client.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numLeases" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of open files"
          },
          "numCaps" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of CephFS caps"
          },
          "state" : {
            "type" : "string",
            "description" : "Connection state"
          },
          "requestLoadAverage" : {
            "type" : "number",
            "format" : "double",
            "description" : "Load caused by this client's requests"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP the client is connecting from"
          },
          "cephUser" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph user name used by this client"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname reported by the client"
          },
          "mountpoint" : {
            "type" : [ "string", "null" ],
            "description" : "Subtree mounted by the client"
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Client Ceph or kernel version"
          }
        },
        "required" : [ "state", "ip" ]
      },
      "CephfsPathPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE", "READ_WRITE_PLACEMENT", "READ_WRITE_SNAPSHOT", "READ_WRITE_PLACEMENT_SNAPSHOT" ]
      },
      "CephfsSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "files" : {
            "type" : "integer",
            "format" : "int64"
          },
          "dirs" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "ChangeRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "createdBy" : {
            "$ref" : "#/components/schemas/ChangeRequestUser"
          },
          "affectedObject" : {
            "type" : "string"
          },
          "changes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ChangeRequestItem"
            }
          },
          "state" : {
            "$ref" : "#/components/schemas/ChangeRequestStatus"
          }
        },
        "required" : [ "description", "createdBy", "affectedObject", "changes", "state" ]
      },
      "ChangeRequestItem" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "type" : "string"
          }
        }
      },
      "ChangeRequestStatus" : {
        "type" : "string",
        "enum" : [ "PENDING", "APPROVED", "REJECTED" ]
      },
      "ChangeRequestUser" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "CloneRequest" : {
        "description" : "Details for a clone creation request",
        "type" : "object",
        "required" : [ "pool", "name" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool in which to store the clone (can be different from the parent image)"
          },
          "name" : {
            "type" : "string",
            "description" : "The name of the new clone"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace for the new clone. Requires v2 cloning, i.e., all clients must be at least Mimic or kernel 4.19"
          }
        }
      },
      "CloudConfigBackupConfig" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "CloudConfigBackupStatus" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "lastBackupTimestamp" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp of the last backup, null if never backed up."
          },
          "lastBackupSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the last backup in byte, null if never backed up."
          },
          "lastBackupChecksum" : {
            "type" : [ "string", "null" ],
            "description" : "SHA256 checksum of the encrypted data of the last backup, null if never backed up."
          },
          "clusterId" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "backupEncryptionKey" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "cephFsid" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "ClusterCreationRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "ClusterDeployRequest" : {
        "type" : "object",
        "required" : [ "mons" ],
        "properties" : {
          "mons" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MonitorRequest"
            }
          }
        }
      },
      "ClusterImportRequest" : {
        "type" : "object",
        "required" : [ "adminKey", "mons" ],
        "properties" : {
          "adminKey" : {
            "type" : "string"
          },
          "mons" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "minItems" : 1
          }
        }
      },
      "ClusterStatus" : {
        "description" : "A croit cluster status report consisting of two parts: information about croit-related services and general Ceph services. Both states are gathered independently so you still get information about croit services if your Ceph cluster is down.",
        "type" : "object",
        "required" : [ "timestamp", "cephLastUpdated", "placementGroups", "servers", "mds", "utilizationByDeviceClass", "radosgws", "iscsi", "nfsGateways", "smbGateways", "nvmeofGateways", "licenseValidUntil", "croitUptime" ],
        "properties" : {
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "The timestamp at which this status report was created. Note that the Ceph state can be up to 30 seconds older if Ceph is slow to respond."
          },
          "cephLastUpdated" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Age of the Ceph status in seconds (relative to `timestamp`). Note that this can be negative, i.e., fresher than the other data."
          },
          "cephStatus" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "healthDetails" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephStatusHealth"
            }, {
              "type" : "null"
            } ]
          },
          "placementGroups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PlacementGroupOverview"
            }
          },
          "recoveryTimeRemaining" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "servers" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "mds" : {
            "$ref" : "#/components/schemas/MdsOnlineStatus"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/DeviceClassUtilization"
            }
          },
          "radosgws" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nfsGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "smbGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "nvmeofGateways" : {
            "$ref" : "#/components/schemas/OnlineStatus"
          },
          "licenseActive" : {
            "type" : "boolean"
          },
          "licenseValidUntil" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "croitUptime" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "ConfigTemplateRequest" : {
        "type" : "object",
        "properties" : {
          "predefinedTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Use a pre-defined template. Either this or customTemplate must be set."
          },
          "customTemplate" : {
            "type" : [ "string", "null" ],
            "description" : "Set a completely custom template. Either this or customTemplate must be set."
          }
        }
      },
      "ConfigTemplateResponse" : {
        "type" : "object",
        "required" : [ "id", "description", "currentTemplateName", "currentTemplate", "availableTemplates" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "currentTemplateName" : {
            "type" : "string"
          },
          "currentTemplate" : {
            "type" : "string"
          },
          "availableTemplates" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/AvailableConfigTemplate"
            }
          }
        }
      },
      "CpuArchitecture" : {
        "type" : "string",
        "enum" : [ "AMD64", "ARM64" ]
      },
      "CreateDaosContainerRequest" : {
        "type" : "object",
        "required" : [ "name", "type", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the container. Allowed are alphanumeric characters (a-z, A-Z, 0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "type" : {
            "description" : "Type of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Chunk size for the container."
          },
          "objectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default object class for the container."
          },
          "directoryObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default directory object class for the container."
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default file object class for the container."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on container creation. Some properties can only be set when creating a container."
          }
        }
      },
      "CreateDaosPoolRequest" : {
        "type" : "object",
        "required" : [ "name", "properties" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the pool. Allowed are alphanumeric characters (a-zA-Z0-9), colon (:), period (.), hyphen (-) or underscore (_)."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the pool in bytes."
          },
          "scmPerc" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Percentage of SCM as percent points. NVMes will thereby get 100 minus this value as percentage."
          },
          "nranks" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of ranks to use (which are then chosen automatically). Cannot be used together with ranks."
          },
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ranks to use. Cannot be used together with nranks."
          },
          "properties" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Properties to set on pool creation. Some properties can only be set when creating a pool."
          }
        }
      },
      "CroitApiVersion" : {
        "type" : "object",
        "required" : [ "version", "releaseDate", "infoUrl" ],
        "properties" : {
          "version" : {
            "type" : "string"
          },
          "releaseDate" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "infoUrl" : {
            "type" : "string"
          }
        }
      },
      "CroitAutoUpdateConfigRequest" : {
        "description" : "Schedule the automatic update of the croit docker image.",
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "custom" : {
            "type" : "boolean",
            "description" : "If true, customized docker registry and docker image settings are used, otherwise the croit defaults."
          },
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryUsername" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry username. Ignored for PUT requests if \"custom\" is set to true."
          },
          "registryPassword" : {
            "type" : [ "string", "null" ],
            "description" : "The docker registry password. Ignored for PUT requests if \"custom\" is set to true."
          },
          "imageName" : {
            "type" : "string",
            "description" : "The name of the docker image. Ignored for PUT requests if \"custom\" is set to true."
          },
          "croitTag" : {
            "type" : "string",
            "description" : "The docker image tag. Ignored for PUT requests if \"custom\" is set to true."
          }
        },
        "required" : [ "imageName", "croitTag" ]
      },
      "CroitBackendConfiguration" : {
        "description" : "A croit backend configured in the config file.",
        "type" : "object",
        "required" : [ "name", "url" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Display name of the croit cluster"
          },
          "url" : {
            "type" : "string",
            "description" : "API endpoint"
          }
        }
      },
      "CroitDependency" : {
        "type" : "object",
        "required" : [ "id", "dependency", "link", "license", "text" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "dependency" : {
            "type" : "string"
          },
          "link" : {
            "type" : "string"
          },
          "license" : {
            "type" : "string"
          },
          "text" : {
            "type" : "string"
          }
        }
      },
      "CroitHealthStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DB_ERROR", "INTERNAL_ERROR" ]
      },
      "CroitServiceType" : {
        "type" : "string",
        "enum" : [ "osd", "mon", "mgr", "radosgw", "mds", "nfs_gateway", "iscsi", "smb", "rbd_mirror", "daos_server", "daos_agent", "nvmf_tgt", "unknown" ]
      },
      "CroitUser" : {
        "type" : "object",
        "required" : [ "userName", "roles", "providerName", "idString", "name" ],
        "properties" : {
          "userName" : {
            "type" : "string"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean"
          },
          "isApiToken" : {
            "type" : "boolean"
          },
          "expiresBy" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "providerName" : {
            "type" : "string"
          },
          "idString" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          }
        }
      },
      "CroitVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "patch" : {
            "type" : "string"
          },
          "cephRelease" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephRelease"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "patch" ]
      },
      "CrushBucketType" : {
        "type" : "string",
        "enum" : [ "OSD", "HOST", "CHASSIS", "RACK", "ROW", "PDU", "POD", "ROOM", "DATACENTER", "ZONE", "REGION", "ROOT", "UNKNOWN" ]
      },
      "CrushNode" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OsdStatus"
            }, {
              "type" : "null"
            } ]
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushBucketType"
          },
          "children" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "used" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "reweight" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "diskId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalGuid" : {
            "type" : [ "string", "null" ]
          },
          "pgs" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "CrushRuleOp" : {
        "type" : "string",
        "enum" : [ "TAKE", "CHOOSE", "CHOOSE_INDEP", "CHOOSELEAF", "CHOOSELEAF_INDEP", "EMIT", "NOOP", "UNKNOWN", "TUNING" ]
      },
      "CrushRuleResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/CrushRuleType"
          },
          "minSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int32"
          },
          "steps" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleStep"
            }
          },
          "typeLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "type", "steps", "typeLabel" ]
      },
      "CrushRuleStep" : {
        "type" : "object",
        "required" : [ "op", "crushMapTextFormat" ],
        "properties" : {
          "op" : {
            "$ref" : "#/components/schemas/CrushRuleOp"
          },
          "crushMapTextFormat" : {
            "type" : "string"
          }
        }
      },
      "CrushRuleType" : {
        "type" : "string",
        "enum" : [ "REPLICATED", "ERASURE" ]
      },
      "CrushTree" : {
        "type" : "object",
        "required" : [ "nodes", "stray" ],
        "properties" : {
          "nodes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          },
          "stray" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushNode"
            }
          }
        }
      },
      "DaosAclEntry" : {
        "discriminator" : {
          "propertyName" : "kind",
          "mapping" : {
            "raw" : "#/components/schemas/RawDaosAcl",
            "parsed" : "#/components/schemas/ParsedDaosAcl"
          }
        },
        "type" : "object"
      },
      "DaosAclFlag" : {
        "type" : "string",
        "enum" : [ "G" ]
      },
      "DaosAclPermission" : {
        "type" : "string",
        "enum" : [ "r", "w", "c", "d", "t", "T", "a", "A", "o" ]
      },
      "DaosAclPrincipalType" : {
        "type" : "string",
        "enum" : [ "PosixUser", "PosixGroup", "PosixOther", "User", "Group" ]
      },
      "DaosAclResponse" : {
        "type" : "object",
        "required" : [ "entries", "entriesRaw", "ownerUser", "ownerGroup" ],
        "properties" : {
          "entries" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries parsed into structured JSON. If the ACL failed to be parsed, it's mapped into an entry of kind \"RawDaosAcl\"."
          },
          "entriesRaw" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "ACL entries how they are reported by DAOS, without any parsing done to them."
          },
          "ownerUser" : {
            "type" : "string",
            "description" : "User that owns the pool."
          },
          "ownerGroup" : {
            "type" : "string",
            "description" : "Group that owns the pool."
          }
        }
      },
      "DaosAclType" : {
        "type" : "string",
        "enum" : [ "A" ]
      },
      "DaosCapacity" : {
        "type" : "object",
        "properties" : {
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total NVMe capacity in GB."
          },
          "scm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total SCM capacity in GB."
          }
        }
      },
      "DaosCertificateCreationRequest" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosCertificateResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the certificate, or -1 if it's a DAOS system certificate."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the certificate."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the certificate."
          },
          "expiry" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Expiry of the certificate. If possible, check the CRT file instead."
          },
          "type" : {
            "description" : "Type of certificate.",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosCertificateType"
          }
        },
        "required" : [ "name", "description", "expiry", "type" ]
      },
      "DaosCertificateType" : {
        "type" : "string",
        "enum" : [ "CA", "SERVER", "ADMIN", "AGENT", "CLIENT" ]
      },
      "DaosCertificateUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DaosClientCreationServerRequest" : {
        "description" : "Server to add as a client to a DAOS cluster.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. Can be left empty for clients."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of targets. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of threads. Only relevant when also specifying nics. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "version" : {
            "$ref" : "#/components/schemas/DaosVersion"
          },
          "upgradeVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "provider" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32"
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosServerConfig"
            }
          }
        },
        "required" : [ "clusterName", "name", "description", "version", "provider", "servers" ]
      },
      "DaosContainerDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          },
          "pool" : {
            "description" : "UUID of the pool the container resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "type" : {
            "description" : "Container type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosContainerType"
          },
          "typeRaw" : {
            "type" : "string",
            "description" : "Container type, as reported by DAOS directly."
          },
          "latestSnapshot" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "redundancyFactor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Redundancy factor of the container."
          },
          "numHandles" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "openTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "closeModifyTime" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "objectClass" : {
            "type" : [ "string", "null" ]
          },
          "dirObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "fileObjectClass" : {
            "type" : [ "string", "null" ]
          },
          "hints" : {
            "type" : [ "string", "null" ]
          },
          "chunkSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        },
        "required" : [ "name", "pool", "uuid", "type", "typeRaw" ]
      },
      "DaosContainerListResponse" : {
        "type" : "object",
        "required" : [ "uuid", "name" ],
        "properties" : {
          "uuid" : {
            "description" : "UUID of the container.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name/label of the container."
          }
        }
      },
      "DaosContainerType" : {
        "type" : "string",
        "enum" : [ "POSIX", "HDF5", "PYTHON", "SPARK", "DATABASE", "ROOT", "SEISMIC", "METEO", "UNKNOWN" ]
      },
      "DaosCreationRequest" : {
        "description" : "Request to create a new DAOS cluster.",
        "type" : "object",
        "required" : [ "clusterName", "name", "description", "provider", "servers" ],
        "properties" : {
          "clusterName" : {
            "type" : "string",
            "description" : "Name of the DAOS cluster."
          },
          "name" : {
            "type" : "string",
            "description" : "Optional human-readable name for the cluster."
          },
          "description" : {
            "type" : "string",
            "description" : "Optional description for the cluster."
          },
          "provider" : {
            "type" : "string",
            "description" : "Interface provider."
          },
          "targets" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of targets for this engine."
          },
          "threads" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of threads (typically targets divided by 4)"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCreationServerRequest"
            },
            "description" : "List of servers to use for DAOS."
          }
        }
      },
      "DaosCreationServerRequest" : {
        "type" : "object",
        "description" : "Server to add as part of the new DAOS cluster",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port to use for DAOS."
          },
          "isAccessPoint" : {
            "type" : "boolean",
            "description" : "Whether this is an access point."
          },
          "nics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of nics to use. If empty, 1 nics per NUMA node will be automatically selected."
          },
          "scms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of SCMs/PMEMs to use. If not provided, all available will be used."
          },
          "nvmes" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of NVMe to use. If not provided, all available will be used."
          },
          "provider" : {
            "type" : [ "string", "null" ],
            "description" : "Override for interface provider of this server. If not provided, the cluster-wide default will be used."
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of targets. If not provided, the cluster-wide default will be used."
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Override for the number of threads. If not provided, the cluster-wide default will be used."
          }
        }
      },
      "DaosDiskCreationRequest" : {
        "type" : "object",
        "required" : [ "name", "pool", "container" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the new DAOS disk in croit."
          },
          "pool" : {
            "description" : "UUID of the DAOS pool that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container that the disk should reside in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes for the disk."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DAOS object class to use for the disk."
          }
        }
      },
      "DaosDiskInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "path" : {
            "type" : "string"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "path" ]
      },
      "DaosEngineConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "numaNode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "targets" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "threads" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nic" : {
            "$ref" : "#/components/schemas/DaosNic"
          },
          "scms" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          },
          "nvmes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosDiskInfo"
            }
          }
        },
        "required" : [ "nic", "scms", "nvmes" ]
      },
      "DaosMemberState" : {
        "type" : "string",
        "enum" : [ "AwaitFormat", "Starting", "Ready", "Joined", "Stopping", "Stopped", "Excluded", "AdminExcluded", "Errored", "Unresponsive", "Unknown" ]
      },
      "DaosNic" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "mac" ]
      },
      "DaosPoolDetails" : {
        "type" : "object",
        "properties" : {
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS cluster ID in croit."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "state" : {
            "description" : "Pool state parsed as an enum. Unrecognized values are mapped to \"Unknown\"",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "Pool state, as reported by DAOS directly."
          },
          "status" : {
            "type" : "integer",
            "format" : "int32"
          },
          "leader" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rebuild" : {
            "description" : "Rebuild status of the pool, if available.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPoolRebuildResponse"
            }, {
              "type" : "null"
            } ]
          },
          "targetsTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total targets."
          },
          "targetsActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active targets."
          },
          "targetsDisabled" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of disabled targets."
          },
          "enginesTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of engines that manage the pool."
          },
          "version" : {
            "type" : "integer",
            "format" : "int32"
          },
          "upgradeLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "poolLayoutVersion" : {
            "type" : "integer",
            "format" : "int32"
          },
          "tierStats" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolTierStatsResponse"
            },
            "description" : "Data usage per storage tier."
          }
        },
        "required" : [ "uuid", "name", "state", "stateRaw", "tierStats" ]
      },
      "DaosPoolRebuildResponse" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "DAOS pool rebuild status."
          },
          "state" : {
            "description" : "DAOS pool rebuild state, parsed into an enum. Unrecognized values are mapped to \"UNKNOWN\".",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolRebuildState"
          },
          "stateRaw" : {
            "type" : "string",
            "description" : "DAOS pool rebuild state, as reported directly from DAOS."
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "record" : {
            "type" : "integer",
            "format" : "int64"
          }
        },
        "required" : [ "state", "stateRaw" ]
      },
      "DaosPoolRebuildState" : {
        "type" : "string",
        "enum" : [ "IDLE", "DONE", "BUSY", "UNKNOWN" ]
      },
      "DaosPoolResponse" : {
        "type" : "object",
        "required" : [ "name", "uuid" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name/label of the pool."
          },
          "uuid" : {
            "description" : "UUID of the pool.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          }
        }
      },
      "DaosPoolStorageMediaType" : {
        "type" : "string",
        "enum" : [ "SCM", "NVME", "UNKNOWN" ]
      },
      "DaosPoolTierStatsResponse" : {
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Total space available, in bytes."
          },
          "free" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Free space available, in bytes."
          },
          "min" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Minimum space used across NVMes, in bytes."
          },
          "max" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Maximum space used across NVMes, in bytes."
          },
          "mean" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Mean space used across NVMes, in bytes."
          },
          "mediaType" : {
            "description" : "Storage media type parsed as an enum. Unrecognized values are mapped to \"UNKNOWN\"",
            "type" : "string",
            "$ref" : "#/components/schemas/DaosPoolStorageMediaType"
          },
          "mediaTypeRaw" : {
            "type" : "string",
            "description" : "Storage media type, as reported by DAOS directly."
          }
        },
        "required" : [ "mediaType", "mediaTypeRaw" ]
      },
      "DaosPosixDiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the DAOS disk."
          },
          "daosId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in."
          },
          "pool" : {
            "description" : "Label of the DAOS pool where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "container" : {
            "description" : "UUID of the DAOS container where this disk resides in.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "poolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in."
          },
          "containerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in."
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class."
          },
          "nvmeofDisks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF disks that use this disk."
          },
          "nvmeofGateways" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs of NVMe-oF clusters that use this disk."
          },
          "nvmeofGatewayLabels" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of names of NVMe-oF clusters that use this disk."
          },
          "error" : {
            "description" : "Configuration errors for this cluster, if any.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HintResponse"
            }, {
              "type" : "null"
            } ]
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          },
          "usedByNvmeof" : {
            "type" : "boolean",
            "description" : "True if this disk is currently being used in a NVMe-oF cluster."
          }
        },
        "required" : [ "name", "pool", "container", "poolLabel", "containerLabel", "nvmeofDisks", "nvmeofGateways", "nvmeofGatewayLabels", "sizeFormatted" ]
      },
      "DaosProperty" : {
        "type" : "object",
        "required" : [ "name", "description", "type", "allowed" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "editable" : {
            "type" : "boolean"
          },
          "type" : {
            "$ref" : "#/components/schemas/DaosPropertyType"
          },
          "unit" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosPropertyUnit"
            }, {
              "type" : "null"
            } ]
          },
          "allowed" : {
            "type" : "array",
            "items" : { }
          }
        }
      },
      "DaosPropertyResponse" : {
        "type" : "object",
        "required" : [ "name", "description", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property."
          },
          "description" : {
            "type" : "string",
            "description" : "Description for the property as reported by DAOS."
          },
          "value" : {
            "type" : "array",
            "description" : "Value of the property, may be arbitrary JSON."
          }
        }
      },
      "DaosPropertyType" : {
        "type" : "string",
        "enum" : [ "String", "Enum", "EnumList", "Int", "IntList" ]
      },
      "DaosPropertyUnit" : {
        "type" : "string",
        "enum" : [ "Percentage", "Bytes", "Seconds" ]
      },
      "DaosRanksRequest" : {
        "type" : "object",
        "properties" : {
          "ranks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "The list of ranks to work on. If empty or omitted, all ranks are used."
          }
        }
      },
      "DaosServerConfig" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "port" : {
            "type" : "integer",
            "format" : "int32"
          },
          "provider" : {
            "type" : [ "string", "null" ]
          },
          "isAccessPoint" : {
            "type" : "boolean"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "engines" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosEngineConfig"
            }
          },
          "isClientNode" : {
            "type" : "boolean"
          }
        },
        "required" : [ "engines" ]
      },
      "DaosSystemMemberResponse" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the server"
          },
          "addr" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/DaosMemberState"
          },
          "stateRaw" : {
            "type" : "string"
          },
          "faultDomain" : {
            "type" : "string"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "incarnation" : {
            "type" : "integer",
            "format" : "int64"
          },
          "uuid" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "fabricUri" : {
            "type" : "string"
          },
          "fabricContexts" : {
            "type" : "integer",
            "format" : "int32"
          },
          "info" : {
            "type" : "string"
          },
          "lastUpdate" : {
            "type" : "string"
          }
        },
        "required" : [ "addr", "state", "stateRaw", "faultDomain", "uuid", "fabricUri", "info", "lastUpdate" ]
      },
      "DaosVerificationError" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationErrorOrWarning" : {
        "type" : "object",
        "required" : [ "message", "id" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "DaosVerificationResult" : {
        "type" : "object",
        "required" : [ "warnings", "errors", "daosConfig" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationErrorOrWarning"
            }
          },
          "errors" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosVerificationError"
            }
          },
          "daosConfig" : {
            "$ref" : "#/components/schemas/DaosConfig"
          }
        }
      },
      "DaosVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "DashboardRoleCreateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ]
          },
          "permissions" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          }
        }
      },
      "DashboardRolePermission" : {
        "type" : "string",
        "enum" : [ "read", "create", "update", "delete" ]
      },
      "DashboardRoleUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "addPerms" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/DashboardRolePermission"
              }
            }
          },
          "delPerms" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DashboardUserCreateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DashboardUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "password" : {
            "type" : [ "string", "null" ]
          },
          "passwordHash" : {
            "type" : [ "string", "null" ]
          },
          "setRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "addRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "delRoles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "DataPoint" : {
        "description" : "One point in a plot",
        "type" : "object",
        "properties" : {
          "v" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Value, see unit property of the axis"
          },
          "t" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Unix timestamp in seconds"
          }
        }
      },
      "DefaultImageRequest" : {
        "type" : "object",
        "properties" : {
          "overrideServers" : {
            "type" : "boolean"
          },
          "default" : {
            "$ref" : "#/components/schemas/UUID"
          }
        },
        "required" : [ "default" ]
      },
      "DefaultImageResponse" : {
        "type" : "object",
        "required" : [ "uuid" ],
        "properties" : {
          "uuid" : {
            "type" : "string"
          }
        }
      },
      "DeleteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "acl" : {
            "description" : "ACL to delete. May be provided instead of the principal, the principal of this ACL will then be used.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosAclEntry"
            }, {
              "type" : "null"
            } ]
          },
          "principal" : {
            "type" : [ "string", "null" ],
            "description" : "Principal whose ACL is to be removed. May be provided as alternative to the ACL."
          },
          "isGroup" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether the principal is a group or user. Only needs to be provided when providing the principal name instead of the entire ACL."
          }
        }
      },
      "DeleteDiskRequest" : {
        "type" : "object",
        "properties" : {
          "deleteData" : {
            "type" : "boolean",
            "description" : "Delete RBD image in Ceph"
          }
        }
      },
      "DestroyedOsdId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "host" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "DestroyedOsdIds" : {
        "type" : "object",
        "required" : [ "destroyedOsds" ],
        "properties" : {
          "destroyedOsds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DestroyedOsdId"
            }
          }
        }
      },
      "DeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "DiskDeleteRequest" : {
        "description" : "Request to wipe a disk",
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server containing the disk"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk"
          },
          "serial" : {
            "type" : "string",
            "description" : "Serial of the disk (confirmation to prevent wiping the wrong disk by mistake)"
          },
          "destroy" : {
            "type" : "boolean",
            "description" : "Whether to destroy the corresponding OSD in the CRUSH map. Defaults to false."
          }
        },
        "required" : [ "serial" ]
      },
      "DiskDeleteRequestWrapper" : {
        "description" : "Request to wipe several disks",
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskDeleteRequest"
            }
          }
        }
      },
      "DiskDeviceClass" : {
        "type" : "string",
        "enum" : [ "hdd", "ssd", "nvme", "pmem" ]
      },
      "DiskPathResponse" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk that this path belongs to."
          },
          "devName" : {
            "type" : "string",
            "description" : "Name of the kernel device that represents this path."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the path is active."
          },
          "state" : {
            "type" : "string",
            "description" : "State of the path. Typically only useful for non-active paths."
          }
        },
        "required" : [ "devName", "state" ]
      },
      "DiskResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "type" : {
            "description" : "Type of disk. Doesn't refer to the disk's model or device class, but if it's a multipath disk or not.",
            "type" : "string",
            "$ref" : "#/components/schemas/DiskType"
          },
          "serial" : {
            "type" : "string"
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "serials" : {
            "type" : "object"
          },
          "wwns" : {
            "type" : "object"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size of the disk in bytes. See \"sizeFormatted\" for a human-readable string."
          },
          "name" : {
            "type" : "string",
            "description" : "Model name of the disk."
          },
          "pathRaw" : {
            "type" : "string",
            "description" : "Path of the disk. Will be outdated/invalid in case the disk is missing."
          },
          "info" : {
            "type" : [ "string", "null" ]
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "dbPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "walPartition" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "osdFragmentation" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bootedFrom" : {
            "type" : "boolean"
          },
          "daemonRunning" : {
            "type" : [ "boolean", "null" ]
          },
          "serviceHealth" : {
            "description" : "Current service health of the service associated (if any) with the disk if it is running;can be null if the service or server was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "identifyLed" : {
            "type" : "boolean"
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          },
          "pciAddress" : {
            "type" : [ "string", "null" ],
            "description" : "PCI address for NVMe disks"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this disk belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this disk belongs to one"
          },
          "mpathInfo" : {
            "description" : "Multipath information, if this is a multipath disk.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MultipathInfoResponse"
            }, {
              "type" : "null"
            } ]
          },
          "stats" : {
            "description" : "Disk statistics (when requested)",
            "type" : "object",
            "$ref" : "#/components/schemas/DiskStatsResponse"
          },
          "bootable" : {
            "type" : "boolean",
            "description" : "If this disk has croit isntalled on it and can be booted from"
          },
          "status" : {
            "type" : "string",
            "description" : "Disk role with some extra information related to the role."
          },
          "capacity" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Deprecated, use \"size\" instead. Capacity of the disk rounded to GB."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk as a human-readable string."
          },
          "roleLabel" : {
            "type" : "string",
            "description" : "Pretty name for the disk role."
          },
          "isMultipathed" : {
            "type" : "boolean",
            "description" : "True if this is a multipathed disks."
          },
          "path" : {
            "type" : [ "string", "null" ],
            "description" : "Path of the disk or null if the disk is missing."
          },
          "pathFormatted" : {
            "type" : "string",
            "description" : "Path of the disk, or an info string in case the disk is missing."
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the disk belongs to."
          }
        },
        "required" : [ "hostname", "role", "type", "serial", "serials", "wwns", "name", "pathRaw", "deviceClass", "lastSeen", "serverLastSeen", "smart", "stats", "status", "sizeFormatted", "roleLabel", "pathFormatted", "numaNodeFormatted" ]
      },
      "DiskRole" : {
        "type" : "string",
        "enum" : [ "unassigned", "mon", "osd", "journal", "other", "raid", "deleting", "updating", "mon_unused", "old_osd", "old_mon", "daos_nvme", "daos_scm", "boot" ]
      },
      "DiskSmartStatus" : {
        "type" : "object",
        "required" : [ "status" ],
        "properties" : {
          "status" : {
            "type" : "string",
            "description" : "SMART health status extracted from the SMART health details."
          },
          "temperature" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Temperature extracted from the SMART health details, in Celsius."
          },
          "details" : {
            "type" : [ "string", "null" ],
            "description" : "SMART health details."
          }
        }
      },
      "DiskStatsResponse" : {
        "type" : "object",
        "properties" : {
          "read" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Reads measured in bytes per second"
          },
          "write" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Writes measured in bytes per second"
          },
          "iopsRead" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Read IOPS"
          },
          "iopsWrite" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Write IOPS"
          },
          "ioLoad" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Overall IO load as percentage"
          },
          "readFormatted" : {
            "type" : "string"
          },
          "writeFormatted" : {
            "type" : "string"
          },
          "iopsReadFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "iopsWriteFormatted" : {
            "type" : "integer",
            "format" : "int64"
          },
          "ioLoadFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "readFormatted", "writeFormatted", "ioLoadFormatted" ]
      },
      "DiskType" : {
        "type" : "string",
        "enum" : [ "normal", "mpath" ]
      },
      "DiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "role" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DiskRole"
            }, {
              "type" : "null"
            } ]
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "identifyLed" : {
            "type" : [ "boolean", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this disk"
          }
        }
      },
      "Distribution" : {
        "type" : "string",
        "enum" : [ "DEBIAN", "SUSE", "SLES", "UNKNOWN" ]
      },
      "DownloadableObject" : {
        "type" : "object",
        "required" : [ "fileName", "data", "url" ],
        "properties" : {
          "fileName" : {
            "type" : "string"
          },
          "data" : {
            "type" : "string",
            "writeOnly" : true
          },
          "url" : {
            "type" : "string",
            "format" : "uri"
          },
          "fileContents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "ErasureCodeProfileDump" : {
        "type" : "object",
        "properties" : {
          "k" : {
            "type" : "integer",
            "format" : "int32"
          },
          "m" : {
            "type" : "integer",
            "format" : "int32"
          },
          "plugin" : {
            "type" : "string"
          },
          "technique" : {
            "type" : "string"
          },
          "crush-device-class" : {
            "type" : [ "string", "null" ]
          },
          "crush-failure-domain" : {
            "type" : [ "string", "null" ]
          },
          "crush-root" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "plugin", "technique" ]
      },
      "EventHookEvent" : {
        "type" : "string",
        "enum" : [ "PreNetworkConfig", "PostNetworkConfig", "PreDaemonStart", "PostDaemonStart", "PreFormatDisk", "PostFormatDisk", "PostCephDaemonStart", "OnHealthDegrade", "OnHealthImprove", "OnHealthRecover", "PreCrushMapChange", "PostCrushMapChange", "PostConfigChanged", "OnDhcpLeaseUpdate", "OnPersistentAvailable", "OnCephFsSnapshotComplete", "OnRbdSnapshotComplete", "OnAudit", "OnCroitStartup", "OnCroitAsyncStartup" ]
      },
      "ExportFormats" : {
        "type" : "string",
        "enum" : [ "raw", "cat", "short", "with-unit" ]
      },
      "FieldCondition" : {
        "description" : "Conditions that can be applied to a specific field.",
        "type" : "object",
        "properties" : {
          "_eq" : {
            "type" : [ "string", "null" ],
            "description" : "Equal to the specified value."
          },
          "_neq" : {
            "type" : [ "string", "null" ],
            "description" : "Not equal to the specified value."
          },
          "_gt" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than the specified value."
          },
          "_gte" : {
            "type" : [ "string", "null" ],
            "description" : "Greater than or equal to the specified value."
          },
          "_lt" : {
            "type" : [ "string", "null" ],
            "description" : "Less than the specified value."
          },
          "_lte" : {
            "type" : [ "string", "null" ],
            "description" : "Less than or equal to the specified value."
          },
          "_regex" : {
            "type" : [ "string", "null" ],
            "description" : "Matches the specified regular expression."
          },
          "_in" : {
            "type" : [ "string", "null" ],
            "description" : "Value is in the specified list or contains the specified substring."
          },
          "_contains" : {
            "type" : [ "string", "null" ],
            "description" : "Value contains the specified item(s)."
          },
          "_nin" : {
            "type" : [ "string", "null" ],
            "description" : "Value is not in the specified list."
          }
        }
      },
      "Finding" : {
        "type" : "object",
        "required" : [ "severity", "category", "shortDescription", "description", "id" ],
        "properties" : {
          "severity" : {
            "$ref" : "#/components/schemas/Severity"
          },
          "category" : {
            "$ref" : "#/components/schemas/Category"
          },
          "shortDescription" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          }
        }
      },
      "FreeIp" : {
        "type" : "object",
        "required" : [ "ip", "subnetShort" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "subnetShort" : {
            "type" : "string"
          }
        }
      },
      "GeneratedId" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "GraphAxisResponse" : {
        "description" : "Collection of plots with the same unit",
        "type" : "object",
        "required" : [ "unit", "graphs" ],
        "properties" : {
          "unit" : {
            "$ref" : "#/components/schemas/StatsUnit"
          },
          "graphs" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Plot"
            }
          }
        }
      },
      "GraphResponse" : {
        "description" : "A single diagram/graph",
        "type" : "object",
        "required" : [ "name", "axis1" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Suggested title for the graph"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Suggested description for the graph"
          },
          "axis1" : {
            "description" : "Data associated with the first y axis",
            "type" : "object",
            "$ref" : "#/components/schemas/GraphAxisResponse"
          },
          "axis2" : {
            "description" : "Optional data associated with the second y axis",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/GraphAxisResponse"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "HaGroup" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServer"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers" ]
      },
      "HaGroupAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "haGroupId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "HaGroupResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "virtualIp" : {
            "type" : "string"
          },
          "service" : {
            "$ref" : "#/components/schemas/HaGroupService"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupServerResponse"
            }
          },
          "failback" : {
            "type" : "boolean",
            "description" : "Switch back to the original server after it recovers."
          },
          "failoverTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until a failover is triggered after a fault state is detected."
          },
          "failbackTime" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time in seconds until the service fails back to the original server after it recovers."
          },
          "evictNfsClientsOnFailback" : {
            "type" : "boolean",
            "description" : "Force disconnect NFS clients from a secondary when failing back to a recovering master server."
          },
          "serversFormatted" : {
            "type" : "string"
          },
          "serviceLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "description", "virtualIp", "service", "servers", "serversFormatted", "serviceLabel" ]
      },
      "HaGroupServer" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupServerResponse" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ]
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "HaGroupService" : {
        "type" : "string",
        "enum" : [ "nfs", "rgw", "smb", "iscsi", "none" ]
      },
      "HardwareResponse" : {
        "type" : "object",
        "properties" : {
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "coresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "cpuFreq" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "mainboardSerial" : {
            "type" : [ "string", "null" ]
          },
          "ipmi" : {
            "type" : [ "object", "null" ]
          },
          "ramFormatted" : {
            "type" : "string"
          },
          "cpuFreqFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "ramFormatted", "cpuFreqFormatted" ]
      },
      "HealthCheckMuteRequest" : {
        "description" : "Request to mute a health check.",
        "type" : "object",
        "properties" : {
          "ttl" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Time in seconds until the health check is unmuted."
          },
          "sticky" : {
            "type" : "boolean",
            "description" : "Whether or not the health check should stay muted even after it is resolved."
          }
        }
      },
      "HintResponse" : {
        "type" : "object",
        "required" : [ "message", "severity" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "severity" : {
            "$ref" : "#/components/schemas/HintSeverity"
          }
        }
      },
      "HintSeverity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARN", "ERROR" ]
      },
      "HookInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "scriptName" : {
            "type" : "string"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "serverNames" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "scriptName", "event", "serverIds", "serverNames" ]
      },
      "HookPointInfo" : {
        "type" : "object",
        "required" : [ "name", "description", "parameters" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "canChooseServer" : {
            "type" : "boolean",
            "description" : "True for hook points running on Ceph nodes. False for hook points running on the management node."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the hook point."
          },
          "parameters" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookScriptParameter"
            },
            "description" : "Information on parameters passed to the script."
          }
        }
      },
      "HookRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        },
        "required" : [ "event", "serverIds" ]
      },
      "HookScriptParameter" : {
        "type" : "object",
        "required" : [ "name", "description" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "HookScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          }
        }
      },
      "HookUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "event" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/EventHookEvent"
            }, {
              "type" : "null"
            } ]
          },
          "allServers" : {
            "type" : [ "boolean", "null" ]
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ImageInfoResponse" : {
        "type" : "object",
        "required" : [ "description" ],
        "properties" : {
          "description" : {
            "type" : "string"
          }
        }
      },
      "ImageListReply" : {
        "type" : "object",
        "properties" : {
          "latestX86" : {
            "description" : "Latest X86_64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "latestArm64" : {
            "description" : "Latest ARM64 image available for this cluster.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultX86" : {
            "description" : "Currently configured default x86_64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "defaultArm64" : {
            "description" : "Currently configured default ARM64 image.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "images" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/ImageResponse"
            },
            "description" : "List of images. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total number of images. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination offset. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Requested pagination limit. Only provided when using pagination."
          }
        }
      },
      "ImagePackage" : {
        "type" : "object",
        "required" : [ "name", "version", "release" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "version" : {
            "type" : "string"
          },
          "release" : {
            "type" : "string"
          }
        }
      },
      "ImageResponse" : {
        "type" : "object",
        "required" : [ "flags", "id", "description", "timestamp", "os", "osVersion", "osName", "osRepoVersion", "cpuArchitecture", "cephVersionShort", "kernelVersion", "sambaVersion", "commit", "ganeshaVersion", "flagsFormatted" ],
        "properties" : {
          "flags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "id" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "os" : {
            "$ref" : "#/components/schemas/Distribution"
          },
          "osVersion" : {
            "type" : "string"
          },
          "osName" : {
            "type" : "string"
          },
          "osRepoVersion" : {
            "type" : "string"
          },
          "cpuArchitecture" : {
            "$ref" : "#/components/schemas/CpuArchitecture"
          },
          "cephVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephVersion"
            }, {
              "type" : "null"
            } ]
          },
          "cephVersionShort" : {
            "type" : "string"
          },
          "kernelVersion" : {
            "type" : "string"
          },
          "sambaVersion" : {
            "type" : "string"
          },
          "commit" : {
            "type" : "string"
          },
          "ganeshaVersion" : {
            "$ref" : "#/components/schemas/SemanticVersion"
          },
          "daosVersion" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/DaosVersion"
            }, {
              "type" : "null"
            } ]
          },
          "isDefault" : {
            "type" : "boolean"
          },
          "isDeprecated" : {
            "type" : "boolean"
          },
          "isNightly" : {
            "type" : "boolean"
          },
          "isExtended" : {
            "type" : "boolean"
          },
          "hasSssd" : {
            "type" : "boolean"
          },
          "supportsBoot" : {
            "type" : "boolean"
          },
          "downloaded" : {
            "type" : "boolean"
          },
          "downloading" : {
            "type" : "boolean"
          },
          "fileSize" : {
            "type" : "integer",
            "format" : "int64"
          },
          "progress" : {
            "type" : "integer",
            "format" : "int64"
          },
          "downloadError" : {
            "type" : [ "string", "null" ]
          },
          "flagsFormatted" : {
            "type" : "string"
          }
        }
      },
      "InitialMonServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "hostname", "ips" ]
      },
      "InstallCroitRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/BootDiskRequest"
            }
          }
        }
      },
      "InterfaceResponse" : {
        "type" : "object",
        "required" : [ "ips", "interfaces" ],
        "properties" : {
          "ips" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpResponse"
            }
          },
          "interfaces" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "currentInterface" : {
            "type" : [ "string", "null" ]
          },
          "currentIp" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IpAddressInfo" : {
        "type" : "object",
        "required" : [ "nic", "vlan", "hagroup", "smb" ],
        "properties" : {
          "nic" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicAddressInfo"
            }
          },
          "vlan" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanAddressInfo"
            }
          },
          "hagroup" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupAddressInfo"
            }
          },
          "smb" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbAddressInfo"
            }
          }
        }
      },
      "IpGeneralInfo" : {
        "description" : "Contains generalized information about an IP address.",
        "type" : "object",
        "required" : [ "ip", "type" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/IpType"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server that this IP is configured for"
          },
          "subnet" : {
            "description" : "The subnet the IP address resides in",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkInfo"
            }, {
              "type" : "null"
            } ]
          },
          "subnetShort" : {
            "type" : [ "string", "null" ],
            "description" : "CIDR notation for the subnet (e.g. 10.0.0.0/24)"
          },
          "inDHCPPool" : {
            "type" : "boolean",
            "description" : "True if this IP is part of a DHCP pool configured in croit"
          }
        }
      },
      "IpResponse" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int16"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "IpType" : {
        "type" : "string",
        "enum" : [ "NIC", "SERVER", "VLAN", "HA_GROUP", "SMB" ]
      },
      "IpmiAccess" : {
        "description" : "Access details for an IPMI device",
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string",
            "description" : "Username to use"
          },
          "password" : {
            "type" : "string",
            "description" : "Password to use"
          },
          "keepAdminPassword" : {
            "type" : "boolean",
            "description" : "Whether to change the password to the croit default"
          }
        }
      },
      "IpmiConfig" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "IpmiDevice" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "server" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServerInfo"
            }, {
              "type" : "null"
            } ]
          },
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "ip", "mac", "warnings" ]
      },
      "IpmiDeviceRequest" : {
        "description" : "Request to add an IPMI device that is not managed by croit's DHCP server",
        "type" : "object",
        "required" : [ "ip", "access" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "IP address of the IPMI device"
          },
          "access" : {
            "description" : "How to access this device",
            "type" : "object",
            "$ref" : "#/components/schemas/IpmiAccess"
          }
        }
      },
      "IpmiDeviceState" : {
        "type" : "object",
        "properties" : {
          "power" : {
            "type" : "boolean"
          },
          "sysTemperature" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpuTemperatures" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          },
          "fanSpeeds" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "cpuTemperatures", "fanSpeeds" ]
      },
      "IpmiDeviceStateWrapper" : {
        "type" : "object",
        "required" : [ "warnings" ],
        "properties" : {
          "warnings" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiWarning"
            }
          },
          "state" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiDeviceState"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IpmiInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "mac" : {
            "type" : "string"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "ip", "mac" ]
      },
      "IscsiAddDiskToClientRequest" : {
        "type" : "object",
        "required" : [ "pool", "name", "backstore" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB if the image does not exist yet, pass null to add an existing image"
          },
          "backstore" : {
            "$ref" : "#/components/schemas/IscsiBackstore"
          }
        }
      },
      "IscsiBackstore" : {
        "type" : "string",
        "enum" : [ "USER", "KERNEL" ]
      },
      "IscsiClientChangeRequest" : {
        "type" : "object",
        "properties" : {
          "username" : {
            "type" : [ "string", "null" ]
          },
          "password" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientCreationRequest" : {
        "type" : "object",
        "required" : [ "username", "password" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "group" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiClientLun" : {
        "type" : "object",
        "required" : [ "pool", "image", "wwn" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "id" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "wwn" : {
            "type" : "string"
          }
        }
      },
      "IscsiClientResponse" : {
        "type" : "object",
        "required" : [ "name", "group", "username", "password", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "group" : {
            "type" : "string"
          },
          "username" : {
            "type" : "string"
          },
          "password" : {
            "type" : "string"
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiGatewayConfig" : {
        "type" : "object",
        "required" : [ "iqn", "gateways", "clients", "groups", "disks", "selectedTarget", "targets" ],
        "properties" : {
          "iqn" : {
            "type" : "string"
          },
          "gateways" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiServerResponse"
            }
          },
          "clients" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientResponse"
            }
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGroupResponse"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          },
          "selectedTarget" : {
            "type" : "string"
          },
          "targets" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "gatewayVersion" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "IscsiGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "IscsiGatewayDisksResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name of the disk."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name where the RBD is located at."
          },
          "wwn" : {
            "type" : "string",
            "description" : "WWN of the disk in iSCSI."
          },
          "lunId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Lun ID of the disk in iSCSI."
          },
          "groups" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Groups that use this disk."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Host IQNs that use this disk."
          }
        },
        "required" : [ "image", "pool", "wwn", "groups", "hosts" ]
      },
      "IscsiGatewayGroupsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "group" : {
            "type" : "string",
            "description" : "Name of the group."
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Hosts in the group."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this group."
          }
        },
        "required" : [ "group", "members", "luns" ]
      },
      "IscsiGatewayHostsResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "iqn" : {
            "type" : "string",
            "description" : "IQN of the host."
          },
          "username" : {
            "type" : "string",
            "description" : "CHAP username."
          },
          "password" : {
            "type" : "string",
            "description" : "CHAP password."
          },
          "group" : {
            "type" : "string",
            "description" : "Group that the host belongs to."
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "Disks attached to this host."
          }
        },
        "required" : [ "iqn", "username", "password", "group", "luns" ]
      },
      "IscsiGatewayServer" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string",
            "description" : "Client-facing IP address of this gateway, must be configured on the server."
          }
        },
        "required" : [ "ip" ]
      },
      "IscsiGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "IP of the server used for iSCSI"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "IscsiGatewayService" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServer"
            },
            "minItems" : 1
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "IscsiGroupResponse" : {
        "type" : "object",
        "required" : [ "name", "members", "luns" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "members" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "luns" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiClientLun"
            }
          }
        }
      },
      "IscsiImageChangeRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Image size in MB"
          }
        }
      },
      "IscsiImageDetails" : {
        "type" : "object",
        "properties" : {
          "image" : {
            "type" : [ "string", "null" ]
          },
          "pool" : {
            "type" : [ "string", "null" ]
          },
          "wwn" : {
            "type" : [ "string", "null" ]
          },
          "backstore" : {
            "type" : [ "string", "null" ]
          },
          "controls" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : { }
          },
          "backstoreParsed" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IscsiBackstore"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "IscsiImagesResponse" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "details" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "$ref" : "#/components/schemas/IscsiImageDetails"
            }
          }
        }
      },
      "IscsiServerResponse" : {
        "type" : "object",
        "required" : [ "name", "ip" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "IscsiServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "KeyUpdateRequest" : {
        "description" : "List of SSH keys allowed to access managed servers.",
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "LicenseCephStatus" : {
        "type" : "object",
        "required" : [ "health", "utilizationByDeviceClass" ],
        "properties" : {
          "health" : {
            "type" : "string"
          },
          "utilizationByDeviceClass" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/LicenseDeviceClassUtilization"
            }
          }
        }
      },
      "LicenseDeviceClassUtilization" : {
        "type" : "object",
        "properties" : {
          "used" : {
            "type" : "integer",
            "format" : "int64"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "usedMax" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeMax" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "LicenseDiskCapacities" : {
        "type" : "object",
        "properties" : {
          "unassigned" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of unassigned disks."
          },
          "osd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of OSD disks (not including separate DB/WAL partitions)."
          },
          "journal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DB/WAL disks."
          },
          "mon" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of mon disks."
          },
          "daosNvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS NVMes."
          },
          "daosScm" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of DAOS SCMs."
          },
          "other" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Raw disk capacity of all other disks."
          }
        }
      },
      "LicenseInfo" : {
        "type" : "object",
        "properties" : {
          "fsid" : {
            "type" : [ "string", "null" ]
          },
          "croitId" : {
            "type" : "string"
          },
          "licenseId" : {
            "type" : "string"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "licenseRestrictions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SignedLicenseData"
            }, {
              "type" : "null"
            } ]
          },
          "registered" : {
            "type" : "boolean"
          },
          "preSetup" : {
            "type" : "boolean"
          }
        },
        "required" : [ "croitId", "licenseId", "validUntil", "nextRefresh" ]
      },
      "LicensePatchRequest" : {
        "type" : "object",
        "properties" : {
          "email" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "LicenseReply" : {
        "description" : "Current license state and usage.",
        "type" : "object",
        "required" : [ "license", "message", "usageFormatted" ],
        "properties" : {
          "license" : {
            "description" : "The currently active license",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseInfo"
          },
          "currentUsage" : {
            "description" : "Cluster usage for licensing purposes",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseUsage"
            }, {
              "type" : "null"
            } ]
          },
          "message" : {
            "type" : "string",
            "description" : "Informational message with license details, e.g., a reason why it is invalid"
          },
          "email" : {
            "type" : [ "string", "null" ],
            "description" : "Configured email address for license notifications."
          },
          "active" : {
            "type" : "boolean",
            "description" : "Whether the license is active"
          },
          "registered" : {
            "type" : "boolean",
            "description" : "Whether the cluster is registered with portal.croit.io"
          },
          "usageFormatted" : {
            "type" : "string",
            "description" : "A string representing current usage and license limits."
          }
        }
      },
      "LicenseUsage" : {
        "description" : "Current cluster usage for licensing purposes.",
        "type" : "object",
        "required" : [ "osds", "rawCapacityGb", "disks", "servers", "rawDaosCapacity" ],
        "properties" : {
          "osds" : {
            "description" : "Number of OSDs by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Raw capacity for ceph by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Used capacity for ceph by device type. (incl. replication overhead)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "netUsageGb" : {
            "description" : "Used capacity for ceph by device type (excl. replication overhead).",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PerOsdLimit"
            }, {
              "type" : "null"
            } ]
          },
          "disks" : {
            "description" : "Raw disk capacity by device type as reported by the nodes, ignoring ceph.",
            "type" : "object",
            "$ref" : "#/components/schemas/LicenseDiskCapacities"
          },
          "cephStatus" : {
            "description" : "Cluster status reported by ceph. Contains similar information to rawCapacityGb and usedCapacityGb, but in raw bytes, and with information on data balance across OSDs.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/LicenseCephStatus"
            }, {
              "type" : "null"
            } ]
          },
          "servers" : {
            "description" : "Number of servers.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "daosClusters" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of DAOS clusters."
          },
          "daosServers" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total number of servers running DAOS."
          },
          "rawDaosCapacity" : {
            "description" : "Raw capacity for DAOS by device type.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosCapacity"
          }
        }
      },
      "LogsQLRequest" : {
        "description" : "VictoriaLogs request that wraps PaginationRequest with additional parameters. Used for both LogViewer Websocket and Log export.",
        "type" : "object",
        "required" : [ "query", "type" ],
        "properties" : {
          "query" : {
            "description" : "Base pagination request for filtering, sorting and limiting",
            "type" : "object",
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "type" : {
            "description" : "Type of logs query - either 'tail' to stream recent logs or 'query' for logs within a time range",
            "type" : "string",
            "$ref" : "#/components/schemas/LogsQLRequestType"
          },
          "start" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Start time for query type requests (required for 'query' type)"
          },
          "end" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "End time for query type requests (required for 'query' type)"
          }
        }
      },
      "LogsQLRequestType" : {
        "type" : "string",
        "enum" : [ "tail", "query" ]
      },
      "MainIpRequest" : {
        "type" : "object",
        "required" : [ "interfaceName", "ip" ],
        "properties" : {
          "interfaceName" : {
            "type" : "string"
          },
          "ip" : {
            "type" : "string"
          }
        }
      },
      "ManagedTask" : {
        "description" : "A long-running task that goes on in the background after this task is completed. See tasks endpoints for details",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "ManagedTaskProgress" : {
        "type" : "object",
        "description" : "Progress indication of a background task.",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "ManagedTaskState" : {
        "type" : "string",
        "enum" : [ "WAITING", "RUNNING", "FINISHED", "FAILED", "CANCELED" ]
      },
      "ManagedThreadTask" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ManagedTaskProgress"
            }, {
              "type" : "null"
            } ]
          },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "done" : {
            "type" : "boolean"
          },
          "result" : { },
          "cancelled" : {
            "type" : "boolean",
            "writeOnly" : true
          },
          "questionLock" : {
            "type" : "object",
            "writeOnly" : true
          },
          "condition" : {
            "type" : "object",
            "writeOnly" : true
          },
          "question" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestion"
            }, {
              "type" : "null"
            } ]
          },
          "thread" : {
            "type" : "object",
            "writeOnly" : true
          },
          "output" : {
            "type" : "string"
          },
          "interactive" : {
            "type" : "boolean"
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "MaxMdsSetting" : {
        "type" : "object",
        "properties" : {
          "maxMds" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Max Mds for CephFS. Shouldn't be higher than the number of servers minus one, to leave at least one standby MDS."
          }
        }
      },
      "MdsOnlineStatus" : {
        "type" : "object",
        "properties" : {
          "active" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standbyReplay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "standby" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MdsRankEntry" : {
        "type" : "object",
        "properties" : {
          "filesystemId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rank" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "status" ]
      },
      "MgrCrashReport" : {
        "description" : "List of Ceph daemon crashes",
        "type" : "object",
        "required" : [ "crashes" ],
        "properties" : {
          "crashes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            }
          }
        }
      },
      "MgrCrashReportEntry" : {
        "type" : "object",
        "description" : "Summarized report of a crashed Ceph daemon",
        "required" : [ "id", "timestamp" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "timestamp" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "process" : {
            "type" : [ "string", "null" ],
            "description" : "ceph process identifier if available, e.g., ceph-osd@123"
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Host on which the process was running"
          },
          "archived" : {
            "type" : "boolean",
            "description" : "Whether this crash is archived; crashes without this flag trigger a Ceph health warning."
          }
        }
      },
      "MinCompatClientVersion" : {
        "type" : "object",
        "required" : [ "release" ],
        "properties" : {
          "release" : {
            "description" : "Ceph release version to set min compat client to.",
            "type" : "string",
            "$ref" : "#/components/schemas/CephRelease"
          }
        }
      },
      "MonServiceRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "MonitorRequest" : {
        "type" : "object",
        "properties" : {
          "diskId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : "string"
          },
          "ipv6" : {
            "type" : "boolean"
          }
        },
        "required" : [ "ip" ]
      },
      "MonitoredRbd" : {
        "type" : "object",
        "required" : [ "poolName", "rbdName", "namespace" ],
        "properties" : {
          "poolName" : {
            "type" : "string",
            "description" : "The pool image"
          },
          "rbdName" : {
            "type" : "string",
            "description" : "The Rbd image"
          },
          "namespace" : {
            "type" : "string",
            "description" : "The pool namespace"
          }
        }
      },
      "MultiServerServiceResponse" : {
        "type" : "object",
        "required" : [ "id", "name", "type", "state", "multiServer", "typeLabel", "status" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used for systemd."
          },
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServiceState"
          },
          "subState" : {
            "description" : "Service-specific sub-state for MGR and MDS services. Indicates active and standby daemons.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceSubState"
            }, {
              "type" : "null"
            } ]
          },
          "mdsInfo" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/MdsRankEntry"
            }, {
              "type" : "null"
            } ]
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "running" : {
            "type" : "boolean"
          },
          "multiServer" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "health" : {
            "description" : "Current service health, can be null if the service was never seen",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceHealthResponse"
            }, {
              "type" : "null"
            } ]
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the DAOS cluster that this service belongs to."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port used by the service. Only available for RGW services."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "TLS/SSL Port used by the service. Only available for RGW services."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "DNS name for an RGW service. Only available for RGW services."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "RGW zone configured for this service. Only available for RGW services."
          },
          "typeLabel" : {
            "type" : "string"
          },
          "status" : {
            "type" : "string",
            "description" : "Extra status information for the service. Only available for MGR, MDS and RGW."
          }
        }
      },
      "MultipartUploadListing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "MultipathInfoResponse" : {
        "type" : "object",
        "required" : [ "paths", "pathsFormatted", "info", "stateLabel" ],
        "properties" : {
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of paths with their information."
          },
          "pathsFormatted" : {
            "type" : "string",
            "description" : "List of paths parsed into a single string."
          },
          "numActive" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of active paths."
          },
          "numTotal" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of total paths."
          },
          "numMax" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "maximum number of paths that croit ever saw for this disk."
          },
          "info" : {
            "type" : "string",
            "description" : "Multipath info summarized as a simple string to display in the UI."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "True if all paths are active."
          },
          "stateLabel" : {
            "type" : "string",
            "description" : "Label containing the states of the paths."
          }
        }
      },
      "NetworkInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this network, generated internally"
          },
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool emd address"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : "string",
            "$ref" : "#/components/schemas/NetworkType"
          },
          "description" : {
            "type" : "string",
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null indicates the default MTU of 1500"
          }
        },
        "required" : [ "ip", "type", "description" ]
      },
      "NetworkType" : {
        "type" : "string",
        "enum" : [ "other", "ceph_public", "ceph_internal", "croit", "ipmi" ]
      },
      "NetworkUpdateRequest" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string",
            "description" : "An IP in this network, does not have to be the first one (network address)"
          },
          "netmask" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "A CIDR prefix length"
          },
          "gateway" : {
            "type" : [ "string", "null" ],
            "description" : "Optional gateway that will be installed as default route on servers with this network"
          },
          "poolStart" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool start address, required if poolEnd is set"
          },
          "poolEnd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional DHCP pool end address, required if poolStart is set"
          },
          "type" : {
            "description" : "Network type, the Ceph network types are configured in Ceph.conf and consumed there. Croit networks are used for booting.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NetworkType"
            }, {
              "type" : "null"
            } ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes"
          },
          "mtu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Custom MTU, null sets the default MTU of 1500"
          }
        }
      },
      "NewActiveDirectorySmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path", "roUsers", "rwUsers" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "roUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          }
        }
      },
      "NewNfsGatewayExport" : {
        "type" : "object",
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ],
        "properties" : {
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        }
      },
      "NewNfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewNfsGatewayExport"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewSimpleSmbGatewayShare" : {
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : "boolean",
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : "boolean",
            "description" : "Enable access for the croit-ro user."
          }
        }
      },
      "NewSmbGatewayShare" : {
        "discriminator" : {
          "propertyName" : "type",
          "mapping" : {
            "simple" : "#/components/schemas/NewSimpleSmbGatewayShare",
            "ad" : "#/components/schemas/NewActiveDirectorySmbGatewayShare"
          }
        },
        "type" : "object",
        "required" : [ "share", "path" ],
        "properties" : {
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          }
        }
      },
      "NewUserRequest" : {
        "type" : "object",
        "required" : [ "uid", "name" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "tenant" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NewVlanRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsExportPermission" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsExportPermissionResponse" : {
        "type" : "object",
        "required" : [ "subnet" ],
        "properties" : {
          "subnet" : {
            "type" : "string",
            "description" : "Subnet for this client entry, e.g. \"10.0.0.0/24\"."
          },
          "rw" : {
            "type" : "boolean",
            "description" : "True if clients in the subnet have read and write access, otherwise clients have only read access."
          }
        }
      },
      "NfsGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "description" ]
      },
      "NfsGatewayExport" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermission"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocols"
          },
          "filesystem" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem" ]
      },
      "NfsGatewayExportResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of the nfs cluster that this export belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Id of this export, assigned by the server on creation."
          },
          "nfsPath" : {
            "type" : "string",
            "description" : "The path on the NFS server at which this export is available."
          },
          "path" : {
            "type" : "string",
            "description" : "The path to export."
          },
          "access" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsExportPermissionResponse"
            },
            "description" : "Clients allowed to access this export."
          },
          "protocols" : {
            "$ref" : "#/components/schemas/NfsProtocolsResponse"
          },
          "filesystem" : {
            "type" : "string"
          },
          "accessJoined" : {
            "type" : "string"
          }
        },
        "required" : [ "nfsPath", "path", "access", "protocols", "filesystem", "accessJoined" ]
      },
      "NfsGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : "string",
            "description" : "Management IP of the server"
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "If the service is healthy on the server."
          }
        },
        "required" : [ "hostname", "ip" ]
      },
      "NfsGatewayService" : {
        "type" : "object",
        "required" : [ "servers", "exports" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "minItems" : 1
          },
          "exports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExport"
            }
          }
        }
      },
      "NfsGatewayServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "servers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "NfsProtocols" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NfsProtocolsResponse" : {
        "type" : "object",
        "properties" : {
          "nfs3" : {
            "type" : "boolean"
          },
          "nfs4" : {
            "type" : "boolean"
          }
        }
      },
      "NicAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "NicBondType" : {
        "type" : "string",
        "enum" : [ "lacp", "active_passive" ]
      },
      "NicResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "mac" : {
            "type" : "string"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "type" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicType"
            }, {
              "type" : "null"
            } ]
          },
          "bondedNics" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NICs that are part of this bond"
          },
          "bond" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Bond this NIC is a part of"
          },
          "bondedNicsFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "NICs that are part of this bond (formatted for the frontend to display in a column"
          },
          "bondFormatted" : {
            "type" : [ "string", "null" ],
            "description" : "Bond this NIC is a part of (formatted for the frontend to display in a column"
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "serverLastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "vlans" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            }
          },
          "linuxName" : {
            "type" : [ "string", "null" ]
          },
          "lldp" : {
            "type" : "array",
            "items" : { }
          },
          "bondType" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/NicBondType"
            }, {
              "type" : "null"
            } ]
          },
          "bondPrimary" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "isVirtual" : {
            "type" : "boolean"
          },
          "infinibandMac" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "numaNode" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "NUMA node that this NIC belongs to"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this NIC belongs to one"
          },
          "ipFormatted" : {
            "type" : "string"
          },
          "ip6Formatted" : {
            "type" : "string"
          },
          "vlansJoined" : {
            "type" : "string"
          },
          "speedFormatted" : {
            "type" : "string"
          },
          "neighbor" : {
            "type" : "string"
          },
          "bondTypeLabel" : {
            "type" : "string"
          },
          "port" : {
            "type" : "string",
            "description" : "Port description from LLDP"
          },
          "numaNodeFormatted" : {
            "type" : "string",
            "description" : "NUMA node the NIC belongs to"
          }
        },
        "required" : [ "mac", "name", "lastSeen", "serverLastSeen", "vlans", "lldp", "ipFormatted", "ip6Formatted", "vlansJoined", "speedFormatted", "neighbor", "bondTypeLabel", "port", "numaNodeFormatted" ]
      },
      "NicType" : {
        "type" : "string",
        "enum" : [ "normal", "bond", "infiniband" ]
      },
      "NicUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this NIC"
          },
          "bond" : {
            "description" : "Updatable bond properties",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/BondUpdateRequest"
            }, {
              "type" : "null"
            } ]
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "Address of the new NIC when replacing NICs. Only applicable for offline servers."
          }
        }
      },
      "NvmeOFBdevType" : {
        "type" : "string",
        "enum" : [ "CEPH", "DAOS" ]
      },
      "NvmeOFCephClusterResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in the NVMe-oF target services."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Client ID to use for this cluster. If null, the croit internal default client for NVMe-oF will be used."
          }
        }
      },
      "NvmeOFDiskCreateRequest" : {
        "type" : "object",
        "required" : [ "type", "subsystems" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the disk to."
          },
          "blockSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "NVMe-oF subsystems to attach this disk to."
          },
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "RBD pool name in ceph (required for ceph disks)."
          },
          "image" : {
            "type" : [ "string", "null" ],
            "description" : "RBD image name in ceph (required for ceph disks)."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace in ceph (currently not supported!)."
          },
          "cluster" : {
            "type" : [ "string", "null" ],
            "description" : "RBD cluster configuration that this disk is configured for. If null, the cluster \"croit_cluster\" will be used."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS disk ID in croit. For DAOS disks, either this ID needs to be specified to choose an existing disk, or all of the other DAOS parameters to create a new disk."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the new DAOS disk in croit (required when creating a new DAOS disk)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster ID in croit (required when creating a new DAOS disk)."
          },
          "daosPool" : {
            "description" : "DAOS pool UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "DAOS container UUID (required when creating a new DAOS disks).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "totalSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total size in bytes for the disk (required and only applicable when creating a new DAOS disks)."
          },
          "oclass" : {
            "type" : [ "string", "null" ],
            "description" : "DAOS object class to use for the disk (optional when creating a new DAOS disks)."
          }
        }
      },
      "NvmeOFDiskResponse" : {
        "type" : "object",
        "required" : [ "type", "bdevNames", "namespaceNGUID", "namespaceEUI64", "namespaceUUID", "hints", "subsystemNqns", "hosts", "pool", "image", "cluster", "daosPoolLabel", "daosContainerLabel", "oclass", "subsystemsFormatted", "blockSizeFormatted", "sizeFormatted" ],
        "properties" : {
          "type" : {
            "description" : "Type of the bdev.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFBdevType"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NVMe-oF disk in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this disk belongs to."
          },
          "bdevNames" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Map of subsystem IDs to the bdev name used for each subsystem in the NVMe-oF target services."
          },
          "namespaceNGUID" : {
            "type" : "string",
            "description" : "NVMe NGUID device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceEUI64" : {
            "type" : "string",
            "description" : "NVMe EUI-64 device identifier that will be used when attaching this disk to a subsystem."
          },
          "namespaceUUID" : {
            "description" : "NVMe UUID device identifier that will be used when attaching this disk to a subsystem.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          },
          "subsystemNqns" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Subsystem NQNs that this disk is attached to."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the same subsystem as this disk."
          },
          "blockSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Block size configured for the disk in bytes."
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Size of the disk in bytes."
          },
          "pool" : {
            "type" : "string",
            "description" : "RBD pool name in ceph (provided if this is a Ceph bdev)."
          },
          "image" : {
            "type" : "string",
            "description" : "RBD image name in ceph (provided if this is a Ceph bdev)."
          },
          "cluster" : {
            "type" : "string",
            "description" : "RBD cluster configuration that this disk is configured for (provided if this is a Ceph bdev)."
          },
          "daosDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosDiskName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the DAOS disk (provided if this is a DAOS bdev)."
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Croit ID of the DAOS cluster where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosPool" : {
            "description" : "UUID of the DAOS pool where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosContainer" : {
            "description" : "UUID of the DAOS container where this disk resides in (provided if this is a DAOS bdev).",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/UUID"
            }, {
              "type" : "null"
            } ]
          },
          "daosPoolLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS pool where this disk resides in (provided if this is a DAOS bdev)."
          },
          "daosContainerLabel" : {
            "type" : "string",
            "description" : "Label of the DAOS container where this disk resides in (provided if this is a DAOS bdev)."
          },
          "oclass" : {
            "type" : "string",
            "description" : "DAOS object class (provided if this is a DAOS bdev)."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this disk is attached to."
          },
          "blockSizeFormatted" : {
            "type" : "string",
            "description" : "Block size configured for the disk."
          },
          "sizeFormatted" : {
            "type" : "string",
            "description" : "Size of the disk."
          }
        }
      },
      "NvmeOFDiskUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New image size for the disk."
          }
        }
      },
      "NvmeOFDisksAttachRequest" : {
        "type" : "object",
        "required" : [ "disks" ],
        "properties" : {
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the NVMe-oF disks in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFGatewayCreateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Optional name for the cluster to display to the user."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional default configurations for transports to use for NVMe-oF target services."
          },
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
            },
            "description" : "NVMe-oF target services to set up for the new cluster."
          }
        },
        "required" : [ "transportDefaults", "services" ]
      },
      "NvmeOFGatewayResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that can be used in other cluster requests."
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the cluster in croit. Only used to display it to the user."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the cluster in croit. Only used to display it to the user."
          },
          "forceSecure" : {
            "type" : "boolean",
            "description" : "Force secure channel for all listeners. \"false\" by default if not specified."
          },
          "transportDefaults" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Default configurations for transports to use for NVMe-oF target services."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this cluster, if any."
          }
        },
        "required" : [ "name", "description", "transportDefaults", "hints" ]
      },
      "NvmeOFGatewayUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "New description for the cluster to display to the user. The name won't be changed if omitted or null."
          },
          "forceSecure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Force secure channel for listeners. Omit if the current setting should not be changed."
          },
          "transportDefaults" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "New default configurations for transports to use for NVMe-oF target services. Overwrites all existing ones if provided."
          }
        }
      },
      "NvmeOFHostCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the host to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host. The NQN has to be unique within a cluster."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Optional shared key to use for authentication. If omitted, the host won't need to authenticate."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Optional list of IDs for subsystems that the host should be attached to."
          }
        },
        "required" : [ "nqn", "subsystems" ]
      },
      "NvmeOFHostResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the host in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the host."
          },
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key that the host will need to authenticate to NVMe-oF target services."
          },
          "subsystems" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for subsystems that this host is attached to."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the same subsystem as this host."
          },
          "subsystemsFormatted" : {
            "type" : "string",
            "description" : "List of subsystems that this host is attached to."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          },
          "hasSharedKey" : {
            "type" : "boolean",
            "description" : "Whether the host has a shared key for authentication with NVMe-oF target services configured."
          }
        },
        "required" : [ "nqn", "subsystems", "disks", "subsystemsFormatted", "disksFormatted" ]
      },
      "NvmeOFHostUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "sharedKey" : {
            "type" : [ "string", "null" ],
            "description" : "Shared key to use for authentication. If omitted, the host won't need to authenticate."
          }
        }
      },
      "NvmeOFHostsAttachRequest" : {
        "type" : "object",
        "required" : [ "hosts" ],
        "properties" : {
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "IDs of the hosts in croit to attach to or detach from the subsystem."
          }
        }
      },
      "NvmeOFListenerConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the listener belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the listener is configured on."
          },
          "listenerId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the listener."
          },
          "type" : {
            "description" : "Transport type for this listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the NIC that this listener is configured to use."
          },
          "nicName" : {
            "type" : "string",
            "description" : "Name of the NIC that this this listener is configured to use."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the VLAN that this listener is configured to use, if at all."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN that this this listener is configured to use, if at all."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port configured for the listener. If null, the cluster's default port will be used."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Secure flag. If true, the listener is configured to use TLS. The cluster's configuration may overwrite this."
          }
        },
        "required" : [ "type", "nicName" ]
      },
      "NvmeOFListenerCreateRequest" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "description" : "Type of the listener.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the nic that this listener is configured on."
          },
          "vlanId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "ID of the vlan that this listener is configured on, if at all."
          },
          "port" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Port that the service should listen on."
          },
          "secure" : {
            "type" : "boolean",
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFListenerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port that the service should listen on (required for TCP and RDMA)."
          },
          "secure" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether this listener should use secure connections (i.e. with TLS). If omitted, the default configuration of the NVMe-oF cluster will be used."
          }
        }
      },
      "NvmeOFServiceCreateRequest" : {
        "type" : "object",
        "properties" : {
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server that this service is to be created on."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Optional description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "Optional transports configurations."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "Optional listeners configurations."
          }
        },
        "required" : [ "transports", "listeners" ]
      },
      "NvmeOFServiceResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the service belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit."
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the server in croit that this service is installed on."
          },
          "serverHostname" : {
            "type" : "string",
            "description" : "Hostname of the server that this service is installed on."
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages configured for the server."
          },
          "anaState" : {
            "description" : "ANA state to set for all listeners in this service.",
            "type" : "string",
            "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the service. Used as systemd name and is automatically generated. Cannot be changed."
          },
          "description" : {
            "type" : "string",
            "description" : "Description of the service in croit. Only used to display it to the user."
          },
          "transports" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfigResponse"
            },
            "description" : "Transport configs specific for this service. Note that the cluster's default configs may extend these."
          },
          "listeners" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "Listener configs for this service."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Configuration errors for this service, if any."
          }
        },
        "required" : [ "serverHostname", "anaState", "name", "description", "transports", "listeners", "hints" ]
      },
      "NvmeOFServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the cluster to display to the user."
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional number of hugepages configuration for the server. Will overwrite the current hugepages configuration."
          },
          "anaState" : {
            "description" : "Optional ANA state to set for all listeners in this service.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/ServiceNvmeofAnaState"
            }, {
              "type" : "null"
            } ]
          },
          "transports" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFTransportConfig"
            },
            "description" : "List of transport configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          },
          "listeners" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
            },
            "description" : "List of listeners configs to overwrite the existing ones with. If omitted, the listeners won't be updated."
          }
        }
      },
      "NvmeOFSubsystemCreateRequest" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit to add the subsystem to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem. The NQN has to be unique within a cluster."
          }
        },
        "required" : [ "nqn" ]
      },
      "NvmeOFSubsystemResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the subsystem in croit that can be used in other requests."
          },
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that this subsystem belongs to."
          },
          "nqn" : {
            "type" : "string",
            "description" : "NQN of the subsystem."
          },
          "serialNumber" : {
            "type" : "string",
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : "string",
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Maximum number of bdevs that can be attached."
          },
          "hosts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for hosts attached to the subsystem."
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of IDs for disks attached to the subsystem."
          },
          "hostsFormatted" : {
            "type" : "string",
            "description" : "List of hosts attached to the subsystem."
          },
          "disksFormatted" : {
            "type" : "string",
            "description" : "List of disks attached to the subsystem."
          }
        },
        "required" : [ "nqn", "serialNumber", "modelNumber", "hosts", "disks", "hostsFormatted", "disksFormatted" ]
      },
      "NvmeOFSubsystemUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "serialNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured serial number for the subsystem."
          },
          "modelNumber" : {
            "type" : [ "string", "null" ],
            "description" : "Configured model name for the subsystem."
          },
          "maxNamespaces" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Maximum number of disks that can be attached."
          }
        }
      },
      "NvmeOFTransportConfig" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "NvmeOFTransportConfigResponse" : {
        "type" : "object",
        "properties" : {
          "gatewayId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the cluster in croit that the transport config belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the service in croit that the transport config belongs to."
          },
          "type" : {
            "description" : "Transport type. The transport config is applied to all listeners of this type.",
            "type" : "string",
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          },
          "ioUnitSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "I/O unit size (bytes)."
          },
          "maxIoQpairsPerCtrlr" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of IO qpairs per controller."
          },
          "inCapsuleDataSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Max number of in-capsule data size."
          },
          "maxIoSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Max I/O size (bytes)."
          }
        },
        "required" : [ "type" ]
      },
      "NvmeOFTransportType" : {
        "type" : "string",
        "enum" : [ "TCP", "RDMA" ]
      },
      "OidcClientAuth" : {
        "type" : "string",
        "enum" : [ "None", "Post", "Basic" ]
      },
      "OidcConfigCreateRequest" : {
        "type" : "object",
        "required" : [ "name", "discoveryUrl", "clientId", "groupPointer", "roleMapping", "defaultRoles", "scope" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/OidcClientAuth"
            }, {
              "type" : "null"
            } ]
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "Scopes for OIDC requests, separated by spaces (default: \"openid profile\")"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          }
        }
      },
      "OidcConfigResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the OIDC config/provider in croit"
          },
          "name" : {
            "type" : "string",
            "description" : "Human-readable name of the OIDC provider"
          },
          "discoveryUrl" : {
            "type" : "string",
            "description" : "Discovery URL for the OIDC provider"
          },
          "clientId" : {
            "type" : "string",
            "description" : "Client ID for croit"
          },
          "clientSecret" : {
            "type" : [ "string", "null" ],
            "description" : "Client secret for croit (optional, in case no secret is configured/expected)"
          },
          "clientAuth" : {
            "description" : "Client authentication method (None - no client secret, Basic - HTTP Basic Auth, Post - secret encoded in form body)",
            "type" : "string",
            "$ref" : "#/components/schemas/OidcClientAuth"
          },
          "manualRoles" : {
            "type" : "boolean",
            "description" : "If true, user roles are to be configured manually per used, otherwise the role pointer/claim is used"
          },
          "groupPointer" : {
            "type" : "string",
            "description" : "Role claim or JSON pointer to look for in the claims to get a list of roles that the user belongs to"
          },
          "roleMapping" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Mapping of role names in the claims to their croit role"
          },
          "defaultRoles" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "List of default roles every user from this OIDC will have"
          },
          "scope" : {
            "type" : "string",
            "description" : "OIDC scope to query for"
          },
          "callbackBaseUri" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the callback base URI (for debugging purposes)"
          },
          "issuerUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the issuer URI (for debugging purposes)"
          },
          "authorizeUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the authorize endpoint URI (for debugging purposes)"
          },
          "tokenUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the token endpoint URI (for debugging purposes)"
          },
          "userinfoUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the userinfo endpoint URI (for debugging purposes)"
          },
          "jwksUrl" : {
            "type" : [ "string", "null" ],
            "description" : "May be set to override the JWKS URI (for debugging purposes)"
          },
          "defaultMaxExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "defaultMinExpiry" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "providerName" : {
            "type" : "string"
          },
          "roleMappingFormatted" : {
            "type" : "string"
          },
          "clientAuthLabel" : {
            "type" : "string"
          }
        },
        "required" : [ "name", "discoveryUrl", "clientId", "clientAuth", "groupPointer", "roleMapping", "defaultRoles", "scope", "defaultMaxExpiry", "defaultMinExpiry", "providerName", "roleMappingFormatted", "clientAuthLabel" ]
      },
      "OidcProvider" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "OktaLoginRequest" : {
        "type" : "object",
        "required" : [ "idToken" ],
        "properties" : {
          "idToken" : {
            "type" : "string"
          }
        }
      },
      "OktaOAuthConfig" : {
        "type" : "object",
        "required" : [ "baseUrl", "clientId", "issuer", "mapRoles" ],
        "properties" : {
          "baseUrl" : {
            "type" : "string"
          },
          "clientId" : {
            "type" : "string"
          },
          "issuer" : {
            "type" : "string"
          },
          "audience" : {
            "type" : [ "string", "null" ]
          },
          "mapRoles" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          }
        }
      },
      "OnlineStatus" : {
        "type" : "object",
        "properties" : {
          "online" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "healthy" : {
            "type" : "boolean"
          }
        }
      },
      "OptionalPaginationResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseObject"
        }, {
          "type" : "array",
          "items" : { },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseAccount" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseAccount"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/Account"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseApiTokenInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseApiTokenInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ApiTokenInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephFSSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephFSSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephPoolResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephPoolResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephPoolResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCephfsClientInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCephfsClientInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CephfsClientInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseConfigTemplateResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseConfigTemplateResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ConfigTemplateResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseCrushRuleResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseCrushRuleResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/CrushRuleResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseDiskResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseDiskResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/DiskResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseFreeIp" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseFreeIp"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/FreeIp"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHaGroupResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHaGroupResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HaGroupResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseHookInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseHookInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/HookInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpGeneralInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpGeneralInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpGeneralInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseIpmiDevice" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseIpmiDevice"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/IpmiDevice"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMgrCrashReportEntry" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMgrCrashReportEntry"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MgrCrashReportEntry"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseMultiServerServiceResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseMultiServerServiceResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/MultiServerServiceResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNetworkInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNetworkInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NetworkInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseNicResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseNicResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/NicResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseOidcConfigResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseOidcConfigResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/OidcConfigResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponsePoolStatsInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponsePoolStatsInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/PoolStatsInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRbdSnapshotSchedule" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRbdSnapshotSchedule"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RbdSnapshotSchedule"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwBucketResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwBucketResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwBucketResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseRgwUserResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseRgwUserResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/RgwUserResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseScriptIdentifier" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseScriptIdentifier"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ScriptIdentifier"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseServerResponse" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseServerResponse"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/ServerResponse"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseSupervisorModuleJson" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseSupervisorModuleJson"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/SupervisorModuleJson"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OptionalPaginationResponseVlanInfo" : {
        "description" : "A response that can be either paginated or a raw list (depending on the presence of the pagination query parameter).",
        "oneOf" : [ {
          "$ref" : "#/components/schemas/PaginationResponseVlanInfo"
        }, {
          "type" : "array",
          "items" : {
            "$ref" : "#/components/schemas/VlanInfo"
          },
          "description" : "The raw list of items, if no pagination was requested"
        } ]
      },
      "OsdCreationRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OsdCreationRequestEntry"
            }
          }
        }
      },
      "OsdCreationRequestEntry" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32"
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for DB or DB/WAL (if walDisk is null)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Disk that will be used for WAL."
          },
          "encrypted" : {
            "type" : "boolean"
          },
          "reuseOsdId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "crushDeviceClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "OsdFullRatios" : {
        "type" : "object",
        "properties" : {
          "nearfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "backfillfull" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "full" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "OsdStatus" : {
        "type" : "string",
        "enum" : [ "UP", "DOWN", "DESTROYED", "UNKNOWN" ]
      },
      "OverwriteDaosAclRequest" : {
        "type" : "object",
        "properties" : {
          "entries" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/DaosAclEntry"
            },
            "description" : "ACL entries to overwrite the existing ones with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "aclFile" : {
            "type" : [ "string", "null" ],
            "description" : "ACL file to overwrite the existing one with, if provided. Either entries or aclFile can be provided, but not both."
          },
          "ownerUser" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (user), if provided. Only possible with containers."
          },
          "ownerGroup" : {
            "type" : [ "string", "null" ],
            "description" : "New owner (group), if provided. Only possible with containers."
          }
        }
      },
      "PaginationRequest" : {
        "type" : "object",
        "description" : "Pagination request. When supplied, the result will be filtered, sorted and limited according to this request object.",
        "properties" : {
          "sortBy" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SortBy"
            },
            "description" : "Optional sorting rules for the items. Items are sorted before the limit is applied."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Optional maximum number of items to return. If omitted, all items are returned."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of items, defaults to 0."
          },
          "where" : {
            "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/FieldCondition"
            },
            "type" : [ "object", "null" ],
            "properties" : {
              "_and" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical AND operator. All conditions must be satisfied."
              },
              "_or" : {
                "type" : [ "array", "null" ],
                "items" : {
                  "$ref" : "#/components/schemas/WhereCondition"
                },
                "description" : "Logical OR operator. At least one condition must be satisfied."
              },
              "_not" : {
                "description" : "Logical NOT operator. The condition must not be satisfied.",
                "type" : [ "object", "null", "null" ],
                "anyOf" : [ {
                  "$ref" : "#/components/schemas/WhereCondition"
                }, {
                  "type" : "null"
                } ]
              },
              "_search" : {
                "type" : [ "string", "null" ],
                "description" : "Full-text search across all searchable fields."
              }
            }
          }
        }
      },
      "PaginationResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseAccount" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/Account"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseApiTokenInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ApiTokenInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFSSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFSSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephFsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephFsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPgStat" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPgStat"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephPoolResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCephfsClientInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephfsClientInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseConfigTemplateResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ConfigTemplateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCroitDependency" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CroitDependency"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseCrushRuleResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CrushRuleResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosCertificateResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosCertificateResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosContainerListResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosContainerListResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPoolDetails" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPoolDetails"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPosixDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPosixDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosPropertyResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosPropertyResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDaosSystemMemberResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DaosSystemMemberResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskPathResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskPathResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseDiskResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseFreeIp" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/FreeIp"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHaGroupResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HaGroupResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseHookInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HookInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpGeneralInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpGeneralInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIpmiDevice" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IpmiDevice"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayDisksResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayDisksResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayGroupsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayGroupsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayHostsResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayHostsResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseIscsiGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/IscsiGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMgrCrashReportEntry" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MgrCrashReportEntry"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseMultiServerServiceResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/MultiServerServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNetworkInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NetworkInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayExportResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayExportResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNfsGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NfsGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNicResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NicResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFCephClusterResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFDiskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFDiskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFGatewayResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFGatewayResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFHostResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFHostResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFListenerConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFListenerConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFServiceResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFServiceResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseNvmeOFSubsystemResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NvmeOFSubsystemResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseObject" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : { },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseOidcConfigResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/OidcConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponsePoolStatsInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolStatsInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdImageResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdImageResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRbdSnapshotSchedule" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotSchedule"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwBucketResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseRgwUserResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwUserResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptIdentifier" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptIdentifier"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseScriptInfo" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ScriptInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseServerResponse" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayConfigResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayConfigResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayServerResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSmbGatewayShareResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseSupervisorModuleJson" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SupervisorModuleJson"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseTaskResponse" : {
        "description" : "A paginated result.",
        "type" : "object",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/TaskResponse"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "PaginationResponseVlanInfo" : {
        "type" : "object",
        "description" : "A paginated result.",
        "required" : [ "data" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/VlanInfo"
            },
            "description" : "List of items on this page. May be less than the requested limit if not enough items are available."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Total items available under the requested filter."
          },
          "after" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Offset in the list of total items that was requested."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of items requested."
          }
        }
      },
      "ParsedDaosAcl" : {
        "type" : "object",
        "required" : [ "type", "flags", "principal", "permissions", "principalType", "raw" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/DaosAclType"
          },
          "flags" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclFlag"
            }
          },
          "principal" : {
            "type" : "string"
          },
          "permissions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "$ref" : "#/components/schemas/DaosAclPermission"
            }
          },
          "isGroup" : {
            "type" : "boolean"
          },
          "principalType" : {
            "$ref" : "#/components/schemas/DaosAclPrincipalType"
          },
          "raw" : {
            "type" : "string"
          }
        }
      },
      "PasswordChangeRequest" : {
        "type" : "object",
        "required" : [ "password" ],
        "properties" : {
          "password" : {
            "type" : "string"
          }
        }
      },
      "PerOsdLimit" : {
        "description" : "Limit OSD number or usage by device class, -1 means unlimited",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs."
          },
          "hdd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as HDD."
          },
          "ssd" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as SSD."
          },
          "nvme" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs identified as NVMe."
          },
          "unknown" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Sum over all OSDs that couldn't be identified (for net usage: also crush rules not matching a device class)."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more OSDs/storage"
          }
        }
      },
      "PingMetricsConfiguration" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean"
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PingMetricsSummary" : {
        "type" : "object",
        "properties" : {
          "fromId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "toId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "median" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "dropPercent" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          }
        }
      },
      "PingParameters" : {
        "type" : "object",
        "properties" : {
          "count" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of ICMP echo requests sent to each host."
          },
          "period" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Time between consecutive packets to a single host in milliseconds."
          },
          "fromId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Server ID of the requesting host. 0 for management host."
          },
          "toIds" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "Server IDs of the responding hosts. 0 for management host."
          },
          "network" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Network ID of the network within which the packets should be sent."
          }
        },
        "required" : [ "toIds" ]
      },
      "PingResult" : {
        "type" : "object",
        "properties" : {
          "xmt" : {
            "type" : "integer",
            "format" : "int32"
          },
          "rcv" : {
            "type" : "integer",
            "format" : "int32"
          },
          "lossPercent" : {
            "type" : "number",
            "format" : "double"
          },
          "min" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "max" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "avg" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "results" : {
            "type" : "array",
            "items" : {
              "type" : "number",
              "format" : "double"
            }
          }
        },
        "required" : [ "results" ]
      },
      "PlacementGroupOverview" : {
        "type" : "object",
        "required" : [ "poolName" ],
        "properties" : {
          "poolName" : {
            "type" : "string"
          },
          "poolId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "okay" : {
            "type" : "integer",
            "format" : "int32"
          },
          "warn" : {
            "type" : "integer",
            "format" : "int32"
          },
          "error" : {
            "type" : "integer",
            "format" : "int32"
          },
          "inactive" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "Plot" : {
        "type" : "object",
        "description" : "A single plot/line for a diagram",
        "required" : [ "datapoints", "name", "tags" ],
        "properties" : {
          "datapoints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/DataPoint"
            }
          },
          "name" : {
            "type" : "string"
          },
          "tags" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Tags (e.g., server id, osd id, ...) associated with this graph"
          }
        }
      },
      "PoolCompressionAlgorithm" : {
        "type" : "string",
        "enum" : [ "LZ4", "Snappy", "Zlib", "Zstd", "None" ]
      },
      "PoolCompressionMode" : {
        "type" : "string",
        "enum" : [ "None", "Passive", "Aggressive", "Force" ]
      },
      "PoolCompressionSettings" : {
        "type" : "object",
        "properties" : {
          "algorithm" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionAlgorithm"
            }, {
              "type" : "null"
            } ]
          },
          "mode" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PoolCompressionMode"
            }, {
              "type" : "null"
            } ]
          },
          "requiredRatio" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "minBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "maxBlobSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "PoolPermission" : {
        "type" : "object",
        "description" : "A pool-specific permission, optionally restricted to a namespace within the pool.",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, either this or wildcardPoolPermissions must be set"
          },
          "wildcardPoolPermissions" : {
            "description" : "Grant a wildcard pool permission, either this or pool must be set",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WildcardPoolPermission"
            }, {
              "type" : "null"
            } ]
          },
          "permissions" : {
            "description" : "Permissions to grant on the pool",
            "type" : "string",
            "$ref" : "#/components/schemas/PoolPermissionType"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Only allow access to a specific namespace within this pool"
          }
        },
        "required" : [ "permissions" ]
      },
      "PoolPermissionType" : {
        "type" : "string",
        "enum" : [ "READ", "READ_WRITE" ]
      },
      "PoolState" : {
        "type" : "string",
        "enum" : [ "Creating", "Ready", "Destroying", "Degraded", "Unknown" ]
      },
      "PoolStatsInfo" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-pool-name query parameter"
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description of the pool"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the pool if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the pool if configured"
          }
        }
      },
      "PoolStatsResponse" : {
        "type" : "object",
        "properties" : {
          "bytes" : {
            "type" : "integer",
            "format" : "int64"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          },
          "readIops" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIops" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "writeBytesPerSec" : {
            "type" : "number",
            "format" : "double"
          },
          "bytesFormatted" : {
            "type" : "string"
          },
          "readIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "writeIopsFormatted" : {
            "type" : "number",
            "format" : "double"
          },
          "readBytesPerSecFormatted" : {
            "type" : "string"
          },
          "writeBytesPerSecFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "bytesFormatted", "readBytesPerSecFormatted", "writeBytesPerSecFormatted" ]
      },
      "QOSSettingsCommandSchema" : {
        "description" : "Ceph QOS Settings Command",
        "type" : "object",
        "required" : [ "command", "displayName", "description" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        }
      },
      "QOSSettingsCommands" : {
        "description" : "List of ceph commands available to define QOS SETTINGS limits (nautilus and above).",
        "type" : "string",
        "enum" : [ "RBD_QOS_IOPS_LIMIT", "RBD_QOS_BPS_LIMIT", "RBD_QOS_READ_IOPS_LIMIT", "RBD_QOS_WRITE_IOPS_LIMIT", "RBD_QOS_READ_BPS_LIMIT", "RBD_QOS_WRITE_BPS_LIMIT", "RBD_QOS_BPS_BURST", "RBD_QOS_IOPS_BURST", "RBD_QOS_READ_BPS_BURST", "RBD_QOS_READ_IOPS_BURST", "RBD_QOS_WRITE_BPS_BURST", "RBD_QOS_WRITE_IOPS_BURST" ]
      },
      "QosCommandAppliedResponse" : {
        "type" : "object",
        "required" : [ "command", "errorMessage" ],
        "properties" : {
          "command" : {
            "type" : "string"
          },
          "success" : {
            "type" : "boolean"
          },
          "errorMessage" : {
            "type" : "string"
          }
        }
      },
      "QosCommandLimit" : {
        "description" : "The Qos command to be executed.",
        "type" : "object",
        "required" : [ "command" ],
        "properties" : {
          "command" : {
            "type" : "string",
            "description" : "The command to be executed.",
            "pattern" : "\\S"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit to be set as an unsigned integer (0 means no limit).",
            "minimum" : 0
          }
        }
      },
      "QosCommandsResponse" : {
        "description" : "The Qos setting as defined in the doc.",
        "type" : "object",
        "required" : [ "setting" ],
        "properties" : {
          "setting" : {
            "description" : "Detail of the command.",
            "type" : "object",
            "required" : [ "command", "displayName", "description" ],
            "properties" : {
              "command" : {
                "type" : "string"
              },
              "displayName" : {
                "type" : "string"
              },
              "description" : {
                "type" : "string"
              }
            }
          },
          "value" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The current limit."
          },
          "inherited" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "The limit inherited from pool settings, if there is any."
          }
        }
      },
      "QueryOrder" : {
        "type" : "string",
        "enum" : [ "ASC", "DESC" ]
      },
      "RankReintegrateRequest" : {
        "type" : "object",
        "properties" : {
          "rank" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Rank to reintegrate. If omitted, all ranks will be attempted."
          }
        }
      },
      "RawCephPermissions" : {
        "type" : "object",
        "properties" : {
          "mon" : {
            "type" : [ "string", "null" ]
          },
          "mgr" : {
            "type" : [ "string", "null" ]
          },
          "osd" : {
            "type" : [ "string", "null" ]
          },
          "mds" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RawDaosAcl" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "type" : "string"
          }
        }
      },
      "RbdCephPermissions" : {
        "description" : "Ceph permissions for RBD clients",
        "type" : "object",
        "required" : [ "pools" ],
        "properties" : {
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/PoolPermission"
            },
            "description" : "List of pools or wildcard specs this key has access to"
          }
        }
      },
      "RbdDeleteRequest" : {
        "description" : "Details for an RBD deletion request",
        "type" : "object",
        "required" : [ "pool", "rbd" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "The pool to operate on, repeated for safety"
          },
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD to delete, repeated for safety"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "The namespace to operate on, optional, default is the default namespace, repeated for safety"
          },
          "thisWillDeleteData" : {
            "type" : [ "string", "null" ],
            "description" : "Must be set to \"I'm really sure that I want to delete this\""
          }
        }
      },
      "RbdFeature" : {
        "type" : "string",
        "enum" : [ "LAYERING", "EXCLUSIVE_LOCK", "OBJECT_MAP", "FAST_DIFF", "DEEP_FLATTEN", "JOURNALING" ]
      },
      "RbdImageCreationRequest" : {
        "description" : "Details of an RBD image that is to be created",
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Store actual data in a separate erasure-coded pool. The main pool will only store metadata."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace (omit/null for the default namespace)"
          }
        }
      },
      "RbdImageMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "journal", "snapshot" ]
      },
      "RbdImageMirrorState" : {
        "type" : "string",
        "enum" : [ "disabled", "primary", "mirror" ]
      },
      "RbdImageResponse" : {
        "type" : "object",
        "required" : [ "name", "pool", "features", "mirrorInfo", "hints", "sizeFormatted" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where this image resides in"
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace if this image is not in the default namespace"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Size in bytes"
          },
          "features" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "Enabled RBD features"
          },
          "parent" : {
            "description" : "Parent image if this is a linked clone (not for creating images, use clone endpoint)",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdParentDump"
            }, {
              "type" : "null"
            } ]
          },
          "erasureCodedPool" : {
            "type" : [ "string", "null" ],
            "description" : "Separate erasure-coded pool in which the image data is stored. The main pool will only store metadata."
          },
          "mirrorInfo" : {
            "description" : "RBD mirror information for this RBD image.",
            "type" : "object",
            "$ref" : "#/components/schemas/RbdMirrorImageInfo"
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the pool/namespace of this image.",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "snaps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageSnapshot"
            },
            "description" : "Snapshots of this image (not for creating images), default = default Ceph features"
          },
          "withDetails" : {
            "type" : "boolean",
            "description" : "Whether or not image details are included"
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "Hints to be displayed in the UI, such as errors that happened while fetching RBD details."
          },
          "sizeFormatted" : {
            "type" : "string"
          }
        }
      },
      "RbdImageSnapshot" : {
        "description" : "Details of an RBD image snapshot",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot"
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot"
          },
          "protect" : {
            "type" : "boolean",
            "description" : "True if this snapshot is protected"
          }
        },
        "required" : [ "name" ]
      },
      "RbdImageUsedSizeResponse" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the RBD"
          },
          "snapshot" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the snapshot if this entry is an RBD snapshot, otherwise null"
          },
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the RBD has in total (in bytes)"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used on the RBD (in bytes)"
          }
        }
      },
      "RbdJournalingUpdateRequest" : {
        "description" : "Request to enable/disable journaling on all images",
        "type" : "object",
        "properties" : {
          "enableJournaling" : {
            "type" : "boolean",
            "description" : "Enable/Disable journaling on all images."
          }
        }
      },
      "RbdMirrorDirection" : {
        "type" : "string",
        "enum" : [ "rx_tx", "rx_only", "tx_only" ]
      },
      "RbdMirrorImageInfo" : {
        "description" : "RBD mirroring details and status of an RBD image.",
        "type" : "object",
        "required" : [ "imageMirrorMode", "mirrorState" ],
        "properties" : {
          "imageMirrorMode" : {
            "description" : "Mirror mode set for the image (disabled, journal or snapshot, snapshot is only supported in octopus or later).",
            "type" : "string",
            "examples" : [ "journal" ],
            "$ref" : "#/components/schemas/RbdImageMirrorMode"
          },
          "mirrorState" : {
            "description" : "State describing if the image is mirrored as primary, mirrored as non-primary, or has mirroring disabled.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdImageMirrorState"
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this image is primary, or null if mirroring is disabled."
          },
          "globalId" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "RBD mirroring global ID (if mirroring is enabled on this image). This ID isn't used by croit."
          },
          "state" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring state (if mirroring is enabled on this image).",
            "examples" : [ "up+replaying" ]
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirroring status description (if mirroring is enabled on this image).",
            "examples" : [ "replaying, master_position=[object_number=3, tag_tid=1, entry_tid=3], mirror_position=[object_number=3, tag_tid=1, entry_tid=3], entries_behind_master=0" ]
          },
          "lastUpdate" : {
            "type" : [ "string", "null" ],
            "description" : "Time of the latest RBD mirroring update (if mirroring is enabled on this image).",
            "examples" : [ "2020-08-06 10:32:34" ]
          },
          "daemonHost" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the server on which the rbd-mirror daemon is running.",
            "examples" : [ "croit-host01" ]
          },
          "peerSites" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Peer sites which this image is mirrored from or mirrored to."
          }
        }
      },
      "RbdMirrorImageUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD image",
        "type" : "object",
        "properties" : {
          "journaling" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable/disable journaling."
          },
          "imageMirrorMode" : {
            "description" : "Mirror mode (disable, journaling or snapshot), enabling mirroring is only possible if the pool is in image mirror mode, and snapshot is only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdImageMirrorMode"
            }, {
              "type" : "null"
            } ]
          },
          "primary" : {
            "type" : [ "boolean", "null" ],
            "description" : "Make image primary/non-primary, only possible if mirroring is enabled on the image."
          }
        }
      },
      "RbdMirrorPeer" : {
        "description" : "RBD mirroring peer details.",
        "type" : "object",
        "required" : [ "id", "siteName", "clientName" ],
        "properties" : {
          "id" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Global ID of the peer (generated separately from the cluster IDs).",
            "examples" : [ "268847dc-e379-462b-901b-298260b7b7c6" ]
          },
          "siteName" : {
            "type" : "string",
            "description" : "Name of the peer cluster, by default its cluster ID.",
            "examples" : [ "ad5a99dd-4a08-41c3-bafa-d0ea8f5ced18" ]
          },
          "clientName" : {
            "type" : "string",
            "description" : "Name of the ceph key on the peer cluster, this ceph user is used by the rbd-mirror daemon to connect to the peer cluster. Croit uses the default from the bootstrap token (client.rbd-mirror-peer).",
            "examples" : [ "client.rbd-mirror-peer" ]
          },
          "direction" : {
            "description" : "Mirror direction, rx-tx, rx-only or tx-only. Only available with Ceph Octopus or later. Croit uses the default of the bootstrap method: rx-tx. Should this still be set to tx-only, try removing the peers from the pool on both clusters and reimport the bootstrap token.",
            "type" : [ "string", "null" ],
            "examples" : [ "client.rbd-mirror-peer" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorPeerCreateRequest" : {
        "description" : "Request to create a new peer using a bootstrap token",
        "type" : "object",
        "required" : [ "peerToken", "direction" ],
        "properties" : {
          "peerToken" : {
            "type" : "string",
            "description" : "Bootstrap token obtained from the peer cluster.",
            "examples" : [ "eyJmc2lkIjoiYmYzNTQ4MzAtZjBmZi00ZGRkLWEwNzUtMjRjNjZlNjVjODdlIiwiY2xpZW50X2lkIjoicmJkLW1pcnJvci1wZWVyIiwia2V5IjoiQVFDdUlYTmZEeS8yS2hBQUEwMnFISm5mWDdkWSthR2l5bzRQRXc9PSIsIm1vbl9ob3N0IjoiMTcyLjMxLjExMS4xMjQ6Njc4OSwgMTcyLjMxLjExMS4xMzY6Njc4OSwgMTcyLjMxLjExMS4xMjE6Njc4OSJ9" ]
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "localSiteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of this cluster that will be displayed on the peer cluster.",
            "examples" : [ "clusterB" ]
          },
          "direction" : {
            "description" : "Direction setting for the peer, rx-tx (default), rx-only or (starting with octopus) tx-only.",
            "type" : "string",
            "$ref" : "#/components/schemas/RbdMirrorDirection"
          }
        }
      },
      "RbdMirrorPeerUpdateRequest" : {
        "description" : "Request to update mirroring settings of a mirror peer",
        "type" : "object",
        "properties" : {
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the peer cluster. Doesn't affect the peer connection, and can be used for organizational purposes.",
            "examples" : [ "clusterA" ]
          },
          "monHosts" : {
            "type" : [ "string", "null" ],
            "description" : "Mon hosts of the peer cluster. Changing this can break the peer connection."
          },
          "direction" : {
            "description" : "New direction setting for the peer (rx-tx, rx-only or tx-only). Changing this can break the peer connection. Only available with Ceph Octopus or later.",
            "type" : [ "string", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdMirrorDirection"
            }, {
              "type" : "null"
            } ]
          },
          "client" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the remote client with read-access for RBD pools. Changing this can break the peer connection."
          }
        }
      },
      "RbdMirrorPoolInfo" : {
        "description" : "RBD mirroring details and status of an RBD pool+namespace.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace, will be null when referring to the pool only without namespace.",
            "examples" : [ "ns1" ]
          },
          "poolMirrorMode" : {
            "description" : "Mirror mode set for the RBD pool (disabled, pool or image).",
            "type" : "string",
            "examples" : [ "pool" ],
            "$ref" : "#/components/schemas/RbdPoolMirrorMode"
          },
          "siteName" : {
            "type" : [ "string", "null" ],
            "description" : "Site name of the pool.",
            "examples" : [ "clusterA" ]
          },
          "peers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdMirrorPeer"
            },
            "description" : "List of peers setup for RBD mirroring, currently only one peer is supported and returned."
          },
          "statusHealth" : {
            "type" : [ "string", "null" ],
            "description" : "RBD mirror status (if mirroring is enabled on this pool).",
            "examples" : [ "OK" ]
          },
          "statusStates" : {
            "type" : [ "object", "null" ],
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "RBD mirror status states (if mirroring is enabled on this pool).",
            "examples" : [ {
              "replaying" : 2,
              "stopped" : 1
            } ]
          }
        },
        "required" : [ "poolMirrorMode", "peers" ]
      },
      "RbdMirrorPoolUpdateRequest" : {
        "description" : "Request to update mirroring settings of an RBD pool",
        "type" : "object",
        "properties" : {
          "poolMirrorMode" : {
            "description" : "Rbd mirror mode (pool, image, disabled).",
            "type" : [ "string", "null" ],
            "examples" : [ "image" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RbdPoolMirrorMode"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RbdMirrorSiteNameUpdateRequest" : {
        "description" : "Request to update the site name of a pool.",
        "type" : "object",
        "required" : [ "siteName" ],
        "properties" : {
          "siteName" : {
            "type" : "string",
            "description" : "Site name for the pool.",
            "examples" : [ "clusterA" ]
          }
        }
      },
      "RbdMirrorSnapshot" : {
        "description" : "Mirror snapshot information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the snapshot.",
            "examples" : [ 10 ]
          },
          "name" : {
            "type" : "string",
            "description" : "Name of the snapshot.",
            "examples" : [ ".mirror.primary.4fe60c6d-bafc-4399-850f-d43783af38dc.95e9cd1b-f327-4c21-9cbe-7b2e3a575885" ]
          }
        },
        "required" : [ "name" ]
      },
      "RbdMirrorSnapshotSchedule" : {
        "description" : "Mirror snapshot schedule information for RBD images in snapshot mode.",
        "type" : "object",
        "properties" : {
          "pool" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the pool, or \"-\"/null if the schedule affects all pools.",
            "examples" : [ "poolName" ]
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace with in the pool, or \"-\"/null if the schedule affects all namespaces.",
            "examples" : [ "-" ]
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Name of the RBD image, or \"-\"/null if the schedule affects all images.",
            "examples" : [ "-" ]
          },
          "interval" : {
            "type" : "string",
            "description" : "Interval time of the schedule specified as time in days, hours or minutes (with suffixes d/h/m, e.g. 7d, 12h or 30m).",
            "examples" : [ "10h" ]
          },
          "startTime" : {
            "type" : [ "string", "null" ],
            "description" : "Optional start time of the schedule specified in the ISO 8601 time format.",
            "examples" : [ "14:00:00" ]
          }
        },
        "required" : [ "interval" ]
      },
      "RbdNameResponse" : {
        "description" : "An RBD name including pool and namespace.",
        "type" : "object",
        "required" : [ "rbd", "pool" ],
        "properties" : {
          "rbd" : {
            "type" : "string",
            "description" : "Name of the RBD."
          },
          "pool" : {
            "type" : "string",
            "description" : "Pool where the RBD resides in."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace used for the RBD, or null for the default namespace of the pool."
          }
        }
      },
      "RbdNamespace" : {
        "type" : "object",
        "required" : [ "name" ],
        "properties" : {
          "name" : {
            "type" : "string"
          }
        }
      },
      "RbdParentDump" : {
        "type" : "object",
        "required" : [ "pool", "image", "snapshot" ],
        "properties" : {
          "pool" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "snapshot" : {
            "type" : "string"
          }
        }
      },
      "RbdPoolInfo" : {
        "description" : "Contains basic information on an RBD pool with namespace.",
        "type" : "object",
        "required" : [ "pool", "hints" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "Namespace or null for the default namespace."
          },
          "ec" : {
            "type" : "boolean",
            "description" : "Whether or not the pool is an erasure-coded pool."
          },
          "active" : {
            "type" : "boolean",
            "description" : "True if the pool's PGs are all active or peering."
          },
          "hints" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/HintResponse"
            },
            "description" : "List of hints to display in the UI, e.g. errors that happened while this pool."
          }
        }
      },
      "RbdPoolMirrorMode" : {
        "type" : "string",
        "enum" : [ "disabled", "pool", "image" ]
      },
      "RbdSnapshotPath" : {
        "description" : "Name of an RBD image or pool.",
        "type" : "object",
        "required" : [ "pool" ],
        "properties" : {
          "pool" : {
            "type" : "string",
            "description" : "Name of the RBD pool."
          },
          "namespace" : {
            "type" : [ "string", "null" ],
            "description" : "RBD namespace."
          },
          "rbd" : {
            "type" : [ "string", "null" ],
            "description" : "Optional RBD image, if omitted, the entire pool is used."
          }
        }
      },
      "RbdSnapshotSchedule" : {
        "description" : "Information for an RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The ID of the snapshot schedule."
          },
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : "boolean",
            "description" : "True if this schedule is enabled."
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"."
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered."
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "failedSnapshots" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of snapshots that couldn't be created."
          },
          "pathsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "cron", "snapshotPrefix", "paths", "failedSnapshots", "pathsFormatted" ]
      },
      "RbdSnapshotScheduleCreateRequest" : {
        "description" : "Request to create a RBD snapshot schedule.",
        "type" : "object",
        "required" : [ "cron", "snapshotPrefix", "paths" ],
        "properties" : {
          "cron" : {
            "type" : "string",
            "description" : "Cron string for the schedule.",
            "pattern" : "\\S"
          },
          "snapshotPrefix" : {
            "type" : "string",
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\"",
            "pattern" : "\\S"
          },
          "maxSnapshots" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot.",
            "minItems" : 1
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotScheduleUpdateRequest" : {
        "description" : "Request to update the settings of a RBD snapshot schedule.",
        "type" : "object",
        "properties" : {
          "cron" : {
            "type" : [ "string", "null" ],
            "description" : "Cron string for the schedule."
          },
          "enabled" : {
            "type" : [ "boolean", "null" ],
            "description" : "True if this schedule should be enabled."
          },
          "snapshotPrefix" : {
            "type" : [ "string", "null" ],
            "description" : "Prefix for the snapshots. The snapshots will be formatted using a timestamp as \"prefix-yyyy-MM-dd.HH:mm:ss.SSS\""
          },
          "maxSnapshots" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of snapshots to be kept. Older snapshots exceeding this limit will be deleted. All snapshots fitting into the naming format will be considered.",
            "maximum" : 100,
            "minimum" : 1
          },
          "paths" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdSnapshotPath"
            },
            "description" : "List of RBD pools and images to be snapshot."
          },
          "disableRbdCheck" : {
            "type" : "boolean",
            "description" : "Disable checking if all rbds/pools are valid."
          }
        }
      },
      "RbdSnapshotUpdateRequest" : {
        "description" : "Details for an snapshot update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "Rename the snapshot to this new name"
          },
          "protect" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable or disable snapshot protection"
          }
        }
      },
      "RbdUpdateRequest" : {
        "description" : "Details for a RBD update request",
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ],
            "description" : "New name of the image"
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "New size of the image in bytes, sizes can only increase"
          },
          "features" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdFeature"
            },
            "description" : "New list of features to be enabled"
          }
        }
      },
      "RbdUsedSizeResponse" : {
        "type" : "object",
        "properties" : {
          "provisionedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage the namespace (or the single RBD specified in the request) has in total in bytes"
          },
          "usedSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Amount of storage currently being used in the namespace (or the single RBD specified in the request) in bytes"
          },
          "rbds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RbdImageUsedSizeResponse"
            }
          }
        }
      },
      "RecommendationResponse" : {
        "type" : "object",
        "required" : [ "taskUuid", "finding", "suggestions", "links", "updatedAt" ],
        "properties" : {
          "taskUuid" : {
            "description" : "A UUID to identify this recommendation by in other requests.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "finding" : {
            "description" : "Information on this recommendation, including what should be shown in the UI.",
            "type" : "object",
            "$ref" : "#/components/schemas/Finding"
          },
          "suggestions" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Suggestions that can be applied to fix or execute this advisor recommendation. Maps suggestion ID to a human-readable string."
          },
          "links" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            },
            "description" : "Links to display for more info."
          },
          "hide" : {
            "type" : "boolean",
            "description" : "If true, this recommendation was muted by the user and should be hidden in the UI."
          },
          "affected" : {
            "description" : "The object affected by this recommendation. Used for linking in the UI."
          },
          "updatedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "Timestamp when this recommendation was last added or updated."
          }
        }
      },
      "RecoverySpeed" : {
        "type" : "object",
        "properties" : {
          "speed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Recovery speed setting from 1 (slowest) to 10 (fastest). Set to <= 0 to restore the default configured in ceph.conf."
          }
        }
      },
      "ReplaceOsdRequest" : {
        "type" : "object",
        "properties" : {
          "osd" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "OSD ID to replace."
          },
          "disk" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the disk to use for the replacement, meaning the OSD will be put on this disk."
          },
          "encrypted" : {
            "type" : [ "boolean", "null" ],
            "description" : "If true, the newly created OSD will be encrypted. If null, the setting of the old OSD (if available) will be used."
          },
          "keepDbWal" : {
            "type" : "boolean",
            "description" : "If true, the newly created OSD will use the same DB/WAL as the replaced disk."
          },
          "dbDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the DB partition (if at all)."
          },
          "walDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "If keepDbWal is false, this is the ID of the disk to be used for the WAL partition (if at all)."
          },
          "resizeOsd" : {
            "type" : "boolean",
            "description" : "If true, the OSD will be resized to match the new disk."
          }
        }
      },
      "ReplaceOsdsRequest" : {
        "type" : "object",
        "required" : [ "osds" ],
        "properties" : {
          "osds" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/ReplaceOsdRequest"
            }
          }
        }
      },
      "RestartPolicy" : {
        "type" : "string",
        "enum" : [ "NEVER", "ON_FAILURE", "ALWAYS" ]
      },
      "RgwBucketResponse" : {
        "type" : "object",
        "required" : [ "bucket", "placement_rule", "id", "owner", "usage", "bucket_quota", "tenant", "usageSum" ],
        "properties" : {
          "bucket" : {
            "type" : "string"
          },
          "placement_rule" : {
            "type" : "string"
          },
          "id" : {
            "type" : "string"
          },
          "owner" : {
            "type" : "string"
          },
          "zonegroup" : {
            "type" : [ "string", "null" ]
          },
          "mtime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "usage" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/RgwBucketUsageResponse"
            },
            "description" : "Data usage by zone."
          },
          "bucket_quota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "tenant" : {
            "type" : "string"
          },
          "usageSum" : {
            "$ref" : "#/components/schemas/RgwBucketUsageResponse"
          }
        }
      },
      "RgwBucketSurvey" : {
        "type" : "object",
        "properties" : {
          "sizeGB" : {
            "type" : "number",
            "format" : "double"
          },
          "objects" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwBucketUsageResponse" : {
        "type" : "object",
        "properties" : {
          "sizeKiB" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeKiBActual" : {
            "type" : "integer",
            "format" : "int64"
          },
          "numObjects" : {
            "type" : "number",
            "format" : "double"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiB instead."
          },
          "size_kb_actual" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use sizeKiBActual instead."
          },
          "num_objects" : {
            "type" : "number",
            "format" : "double",
            "description" : "Deprecated, use numObjects instead."
          }
        },
        "required" : [ "sizeFormatted" ]
      },
      "RgwDefaultPlacementRequest" : {
        "type" : "object",
        "required" : [ "placementRule" ],
        "properties" : {
          "placementRule" : {
            "type" : "string",
            "description" : "The name of the placement rule to set as default."
          },
          "storageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Optional storage class for the placement rule to use as default."
          }
        }
      },
      "RgwDetailedUsage" : {
        "type" : "object",
        "required" : [ "bucketName", "bucketOwner", "time" ],
        "properties" : {
          "bucketName" : {
            "type" : "string"
          },
          "bucketOwner" : {
            "type" : "string"
          },
          "time" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "bytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bytesUploaded" : {
            "type" : "integer",
            "format" : "int64"
          },
          "successfulOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "failedOperations" : {
            "type" : "integer",
            "format" : "int64"
          },
          "metadataBytesDownloaded" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "RgwKeyRequest" : {
        "type" : "object",
        "required" : [ "user", "access_key", "secret_key" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : "string"
          },
          "secret_key" : {
            "type" : "string"
          }
        }
      },
      "RgwPlacementPolicyResponse" : {
        "type" : "object",
        "required" : [ "name", "storageClass", "dataPool", "indexPool", "dataExtraPool" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "The unique name of the placement policy."
          },
          "storageClass" : {
            "type" : "string",
            "description" : "Name of the storage class used for this placement policy."
          },
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data for the placement + storage class."
          },
          "indexPool" : {
            "type" : "string",
            "description" : "The pool used to store the bucket index"
          },
          "dataExtraPool" : {
            "type" : "string",
            "description" : "The pool used to store extra metadata."
          },
          "isDefault" : {
            "type" : "boolean"
          }
        }
      },
      "RgwPlacementRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          },
          "indexPool" : {
            "type" : [ "string", "null" ],
            "description" : "The pool used as an index for buckets. Can't be erasure coded."
          },
          "dataExtraPool" : {
            "type" : [ "string", "null" ],
            "description" : "An extra data pool for metadata. Can't be erasure coded."
          }
        }
      },
      "RgwPlacementResponse" : {
        "type" : "object",
        "properties" : {
          "defaultPlacementRule" : {
            "type" : [ "string", "null" ],
            "description" : "Default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ],
            "description" : "Default storage class of the default placement of the default zone. If no default is set (or parsing failed), this will be null."
          },
          "placements" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when not using pagination."
          },
          "data" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RgwPlacementPolicyResponse"
            },
            "description" : "A list of placement rules. Only provided when using pagination."
          },
          "total" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Total placements available under the requested filter. Only provided when using pagination."
          },
          "after" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Offset in the list of total placements that was requested. Only provided when using pagination."
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of placements requested. Only provided when using pagination."
          }
        }
      },
      "RgwQuotaRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size. Use a negative number to disable the size quota."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects. Use a negative number to disable the objects quota."
          },
          "max_size_kb" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes). Use a negative number to disable the size quota."
          },
          "max_objects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects. Use a negative number to disable the objects quota."
          }
        }
      },
      "RgwQuotaResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "maxSize" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max size in bytes."
          },
          "maxObjects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Max number of objects."
          },
          "max_size_kb" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxSize instead. Max size in KiB (kibibytes)."
          },
          "max_objects" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Deprecated, use maxObjects instead. Max number of objects."
          },
          "maxSizeFormatted" : {
            "type" : "string"
          },
          "maxObjectsFormatted" : {
            "type" : "string"
          }
        },
        "required" : [ "maxSizeFormatted", "maxObjectsFormatted" ]
      },
      "RgwSslCertChangeRequest" : {
        "type" : "object",
        "properties" : {
          "certificate" : {
            "type" : [ "string", "null" ]
          },
          "doRollingRestart" : {
            "type" : "boolean"
          }
        }
      },
      "RgwStorageClassRequest" : {
        "type" : "object",
        "required" : [ "dataPool" ],
        "properties" : {
          "dataPool" : {
            "type" : "string",
            "description" : "The pool used to store the data. All metadata will still be stored in the default pools."
          }
        }
      },
      "RgwSubUser" : {
        "type" : "object",
        "required" : [ "id" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubUserPermission" : {
        "type" : "string",
        "enum" : [ "full-control", "read-write", "read", "write", "NONE" ]
      },
      "RgwSubuserRequest" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserResponse" : {
        "type" : "object",
        "required" : [ "subuser" ],
        "properties" : {
          "subuser" : {
            "type" : "string"
          },
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwSubuserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "permissions" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/RgwSubUserPermission"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "RgwUpdateKeysRequest" : {
        "type" : "object",
        "required" : [ "keys" ],
        "properties" : {
          "keys" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwKeyRequest"
            }
          }
        }
      },
      "RgwUpdateSubusersRequest" : {
        "type" : "object",
        "required" : [ "subusers" ],
        "properties" : {
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserRequest"
            }
          }
        }
      },
      "RgwUserKey" : {
        "type" : "object",
        "required" : [ "user" ],
        "properties" : {
          "user" : {
            "type" : "string"
          },
          "access_key" : {
            "type" : [ "string", "null" ]
          },
          "secret_key" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RgwUserResponse" : {
        "type" : "object",
        "required" : [ "uid", "name", "email", "subusers", "bucketQuota", "userQuota", "subusersFormatted" ],
        "properties" : {
          "uid" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "email" : {
            "type" : "string"
          },
          "suspended" : {
            "type" : "boolean"
          },
          "subusers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwSubuserResponse"
            }
          },
          "bucketQuota" : {
            "description" : "This quota is applied to all buckets owned by this user.",
            "type" : "object",
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "userQuota" : {
            "$ref" : "#/components/schemas/RgwQuotaResponse"
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          },
          "subusersFormatted" : {
            "type" : "string"
          }
        }
      },
      "RgwUserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "email" : {
            "type" : [ "string", "null" ]
          },
          "suspended" : {
            "type" : [ "boolean", "null" ]
          },
          "defaultPlacement" : {
            "type" : [ "string", "null" ]
          },
          "defaultStorageClass" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "RoleEnum" : {
        "type" : "string",
        "enum" : [ "admin", "viewer", "securefolder" ]
      },
      "RunScriptRequest" : {
        "type" : "object",
        "properties" : {
          "scriptId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Execute previously uploaded script by id, mutually exclusive with script"
          },
          "script" : {
            "type" : [ "string", "null" ],
            "description" : "Execute verbatim script, mutually exclusive with scriptId"
          },
          "args" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "List of parameters passed to the script"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of servers the script will be run on"
          }
        },
        "required" : [ "args", "servers" ]
      },
      "S3BucketName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-bucket-name query parameter"
          },
          "quotaBytes" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Data quota of the bucket if configured"
          },
          "quotaObjects" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Object quota of the bucket if configured"
          }
        }
      },
      "S3BucketVersioningConfiguration" : {
        "type" : "string",
        "enum" : [ "OFF", "ENABLED", "SUSPENDED", "UNKNOWN" ]
      },
      "S3Listing" : {
        "type" : "object",
        "required" : [ "prefixes", "objects" ],
        "properties" : {
          "prefixes" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3PrefixDetail"
            }
          },
          "objects" : {
            "type" : "array",
            "items" : { }
          },
          "continuationToken" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "S3Metadata" : {
        "type" : "object",
        "properties" : {
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "contentType" : {
            "type" : "string"
          },
          "etag" : {
            "type" : [ "string", "null" ]
          },
          "size" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "userMetadata" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "string"
            }
          },
          "versionId" : {
            "type" : [ "string", "null" ]
          },
          "contentDisposition" : {
            "type" : [ "string", "null" ]
          },
          "cacheControl" : {
            "type" : [ "string", "null" ]
          },
          "expirationTime" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "expirationTimeRuleId" : {
            "type" : [ "string", "null" ]
          },
          "contentEncoding" : {
            "type" : [ "string", "null" ]
          },
          "contentLanguage" : {
            "type" : [ "string", "null" ]
          },
          "contentMD5" : {
            "type" : [ "string", "null" ]
          },
          "httpExpiresDate" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "raw" : {
            "type" : "object",
            "additionalProperties" : { }
          }
        },
        "required" : [ "contentType", "userMetadata", "raw" ]
      },
      "S3MultipartUpload" : {
        "type" : "object",
        "required" : [ "key", "uploadId", "owner", "initiator", "storageClass", "initiated", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "uploadId" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "initiator" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "storageClass" : {
            "type" : "string"
          },
          "initiated" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3MultipartUploadResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3MultipartUpload"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3ObjectResponse" : {
        "type" : "object",
        "required" : [ "key", "bucketName", "owner", "eTag", "lastModified", "storageClass", "sizeFormatted", "keyWithoutPrefix" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "bucketName" : {
            "type" : "string"
          },
          "owner" : {
            "$ref" : "#/components/schemas/S3Owner"
          },
          "eTag" : {
            "type" : "string"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          },
          "lastModified" : {
            "type" : "string",
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          },
          "storageClass" : {
            "type" : "string"
          },
          "sizeFormatted" : {
            "type" : "string"
          },
          "keyWithoutPrefix" : {
            "type" : "string"
          }
        }
      },
      "S3ObjectsResponse" : {
        "type" : "object",
        "required" : [ "data", "prefixes" ],
        "properties" : {
          "data" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/S3ObjectResponse"
            }
          },
          "total" : {
            "type" : "integer",
            "format" : "int32"
          },
          "after" : {
            "type" : "integer",
            "format" : "int32"
          },
          "limit" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "prefixes" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "S3Owner" : {
        "type" : "object",
        "required" : [ "id", "displayName" ],
        "properties" : {
          "id" : {
            "type" : "string"
          },
          "displayName" : {
            "type" : "string"
          }
        }
      },
      "S3PrefixDetail" : {
        "type" : "object",
        "required" : [ "prefix" ],
        "properties" : {
          "prefix" : {
            "type" : "string"
          },
          "lastModified" : {
            "type" : [ "string", "null" ],
            "format" : "date",
            "examples" : [ "2022-03-10" ]
          }
        }
      },
      "S3UsageForBucketByUserResponse" : {
        "description" : "Usage data for a bucket, split by user performing the operation.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All users (unauthenticated access is mapped to \"anonymous\") accessing this bucket, entries are split into 1 hour intervals."
          }
        }
      },
      "S3UsageForUserByBucketResponse" : {
        "description" : "Usage data for a user, split by bucket.",
        "type" : "object",
        "required" : [ "buckets" ],
        "properties" : {
          "buckets" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/components/schemas/RgwDetailedUsage"
              }
            },
            "description" : "All buckets accessed by this user, entries are split into 1 hour intervals"
          }
        }
      },
      "S3UserName" : {
        "type" : "object",
        "required" : [ "displayName", "queryName" ],
        "properties" : {
          "displayName" : {
            "type" : "string",
            "description" : "Name for users"
          },
          "queryName" : {
            "type" : "string",
            "description" : "Name for the template-s3-user-name query parameter"
          }
        }
      },
      "SambaServiceDNSNameUpdateRequest" : {
        "type" : "object",
        "required" : [ "serviceDnsName" ],
        "properties" : {
          "serviceDnsName" : {
            "type" : "string",
            "description" : "The new DNS name for the SMB cluster"
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          },
          "joinServer" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Server to use when joining the new DNS name. Optional, if not supplied, the first server from the database is used."
          }
        }
      },
      "SambaServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "virtualIps" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password of the croit-read read-only user."
          },
          "domainController" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname of the domain controller, e.g., dc01."
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Optional list of DNS servers to resolve names, default DNS servers distributed via DHCP are configured in /config/config.yml."
          },
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          }
        }
      },
      "SambaShareType" : {
        "type" : "string",
        "enum" : [ "SIMPLE", "ADS" ]
      },
      "SchedulingSettings" : {
        "type" : "object",
        "required" : [ "timezone" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          }
        }
      },
      "ScriptIdentifier" : {
        "type" : "object",
        "deprecated" : true,
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          }
        },
        "required" : [ "name" ]
      },
      "ScriptInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "hooks" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/SimpleHookInfo"
            }
          },
          "hookNames" : {
            "type" : [ "string", "null" ]
          }
        },
        "required" : [ "name" ]
      },
      "ScriptRequest" : {
        "type" : "object",
        "properties" : {
          "name" : {
            "type" : [ "string", "null" ]
          },
          "contents" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SemanticVersion" : {
        "type" : "object",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32"
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32"
          },
          "revision" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "ServerAccessPasswords" : {
        "description" : "Passwords to access servers.",
        "type" : "object",
        "properties" : {
          "rootPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password for (physical) shell access as root user, password login for SSH is disabled."
          },
          "ipmiPassword" : {
            "type" : [ "string", "null" ],
            "description" : "IPMI password for the ADMIN user of IPMI interfaces managed by croit."
          }
        }
      },
      "ServerHealth" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double"
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean"
          }
        }
      },
      "ServerHealthResponse" : {
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "hwDetectTime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "cephDiskProcs" : {
            "type" : "integer",
            "format" : "int32"
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "clockDrift" : {
            "type" : "number",
            "format" : "double",
            "description" : "Approximate time difference between this server and the management server, negative values indicate the server is behind."
          },
          "freeRam" : {
            "type" : "integer",
            "format" : "int64"
          },
          "bootedFromDisk" : {
            "type" : "boolean",
            "description" : "True if this server was booted from disk instead of PXE."
          },
          "uptimeFormatted" : {
            "type" : "string"
          },
          "freeRamFormatted" : {
            "type" : "string"
          },
          "bootSource" : {
            "type" : "string",
            "description" : "What the server used to boot, either 'Disk' or 'PXE'"
          }
        },
        "required" : [ "uptimeFormatted", "freeRamFormatted", "bootSource" ]
      },
      "ServerInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "type" : [ "object", "null" ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "services" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "servicesRunning" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "osds" : {
            "type" : "integer",
            "format" : "int32"
          },
          "osdsRunning" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealth"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ]
          },
          "hasSambaSssd" : {
            "type" : "boolean"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32"
          },
          "machineId" : {
            "type" : "string"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "services", "servicesRunning", "usedPorts", "ips", "health", "machineId" ]
      },
      "ServerLimit" : {
        "description" : "Limit number of servers",
        "type" : "object",
        "properties" : {
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Number of servers allowed (0 or a negative number means no limit)."
          },
          "gracePercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Grace in percent for having servers above the limit."
          },
          "graceValue" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Grace in number of servers for having servers above the limit. Overrides gracePercent when provided."
          }
        }
      },
      "ServerNameAndId" : {
        "description" : "Server id/hostname pairs for querying the stats APIs.",
        "type" : "object",
        "required" : [ "hostname" ],
        "properties" : {
          "hostname" : {
            "type" : "string",
            "description" : "The hostname"
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Use this id as template parameter."
          }
        }
      },
      "ServerRebootRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "ServerResponse" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ServerState"
          },
          "macs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "ip" : {
            "type" : "string"
          },
          "image" : {
            "type" : "string"
          },
          "hardware" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/HardwareResponse"
            }, {
              "type" : "null"
            } ]
          },
          "lastSeen" : {
            "type" : "string",
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "daemonVersion" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPorts" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            },
            "description" : "List of ports used by this server's services."
          },
          "ips" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "IPs configured on all NICs, only these are valid for the main IP."
          },
          "health" : {
            "$ref" : "#/components/schemas/ServerHealthResponse"
          },
          "ipmi" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/IpmiInfo"
            }, {
              "type" : "null"
            } ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "hasSambaSssd" : {
            "type" : "boolean",
            "description" : "True if the server is running Samba with sssd"
          },
          "daosId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "DAOS cluster id, if this server belongs to one"
          },
          "imageDescription" : {
            "type" : "string",
            "description" : "Description for the image that is configured on the server"
          },
          "nrHugepages" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) configured for the server when using it for DAOS or NVMe-oF."
          },
          "machineId" : {
            "type" : "string",
            "description" : "Machine ID"
          },
          "services" : {
            "$ref" : "#/components/schemas/ServerServicesResponse"
          },
          "ramUsageFormatted" : {
            "type" : "string"
          },
          "stateLabel" : {
            "type" : "string"
          },
          "macsFormatted" : {
            "type" : "string",
            "description" : "MAC addresses if the management interface as a comma-separated string (there are multiple if it's a bond)"
          }
        },
        "required" : [ "hostname", "state", "macs", "ip", "image", "lastSeen", "usedPorts", "ips", "health", "imageDescription", "machineId", "services", "ramUsageFormatted", "stateLabel", "macsFormatted" ]
      },
      "ServerServicesResponse" : {
        "type" : "object",
        "required" : [ "osd", "mon", "mgr", "smb", "nfs", "mds", "iscsi", "rgw", "rbdMirror", "nvmfTgt", "daosServer", "daosAgent" ],
        "properties" : {
          "osd" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mon" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mgr" : {
            "$ref" : "#/components/schemas/Service"
          },
          "smb" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nfs" : {
            "$ref" : "#/components/schemas/Service"
          },
          "mds" : {
            "$ref" : "#/components/schemas/Service"
          },
          "iscsi" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rgw" : {
            "$ref" : "#/components/schemas/Service"
          },
          "rbdMirror" : {
            "$ref" : "#/components/schemas/Service"
          },
          "nvmfTgt" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosServer" : {
            "$ref" : "#/components/schemas/Service"
          },
          "daosAgent" : {
            "$ref" : "#/components/schemas/Service"
          }
        }
      },
      "ServerState" : {
        "type" : "string",
        "enum" : [ "booting", "running", "offline", "rebooting", "shutting_down" ]
      },
      "ServerUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ]
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "image" : {
            "type" : [ "string", "null" ]
          },
          "notes" : {
            "type" : [ "string", "null" ],
            "description" : "User-defined notes for this server"
          },
          "nrHugepages" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Number of hugepages (2MiB) to configure for services that require it."
          }
        }
      },
      "Service" : {
        "type" : "object",
        "properties" : {
          "deployed" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of deployed instances of this services."
          },
          "running" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Number of running instances of this services."
          },
          "isDeployed" : {
            "type" : "boolean",
            "description" : "Whether an instance of this service is deployed."
          },
          "isRunning" : {
            "type" : [ "boolean", "null" ],
            "description" : "Whether an instance of this service is running."
          }
        }
      },
      "ServiceControlRequest" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The service ID, or in case of an OSD the daemon ID."
          },
          "server" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Required for multi-server services"
          },
          "isOsd" : {
            "type" : "boolean",
            "description" : "If this service is an OSD."
          }
        }
      },
      "ServiceHealthResponse" : {
        "description" : "Health information about a running service",
        "type" : "object",
        "properties" : {
          "uptime" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Uptime in seconds"
          },
          "memory" : {
            "type" : [ "number", "null" ],
            "format" : "double",
            "description" : "Memory usage (RSS) in GiB"
          },
          "uptimeFormatted" : {
            "type" : "string",
            "description" : "Uptime in seconds"
          },
          "memoryFormatted" : {
            "type" : "string",
            "description" : "Memory usage (RSS) in GiB"
          }
        },
        "required" : [ "uptimeFormatted", "memoryFormatted" ]
      },
      "ServiceNvmeofAnaState" : {
        "type" : "string",
        "enum" : [ "optimized", "non_optimized", "inaccessible" ]
      },
      "ServiceState" : {
        "type" : "string",
        "enum" : [ "creating", "enabled", "disabled", "creation_failed" ]
      },
      "ServiceSubState" : {
        "type" : "string",
        "enum" : [ "ACTIVE", "STANDBY" ]
      },
      "ServiceTypePath" : {
        "type" : "string",
        "enum" : [ "osds", "mons", "radosgws", "mds", "mgrs", "nfs_gateways", "iscsis", "smbs", "rbd_mirrors", "daos_server", "daos_agent", "nvmf_tgts" ]
      },
      "ServiceUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "description" : {
            "type" : [ "string", "null" ],
            "description" : "Description for the service."
          },
          "port" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Port for the service. Only relevant for RGW."
          },
          "sslPort" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "SSL/TLS port for the service. Only relevant for RGW."
          },
          "rgwDnsName" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW DNS name to use for this service. Only relevant for RGW."
          },
          "rgwZone" : {
            "type" : [ "string", "null" ],
            "description" : "New RGW zone to use for this service. Only relevant for RGW."
          }
        }
      },
      "SetDaosAclRequest" : {
        "type" : "object",
        "required" : [ "acl" ],
        "properties" : {
          "acl" : {
            "description" : "ACL entry to update. If it doesn't exist, it will be created.",
            "type" : "object",
            "$ref" : "#/components/schemas/DaosAclEntry"
          }
        }
      },
      "SetDaosContainerOwnerRequest" : {
        "type" : "object",
        "required" : [ "owner" ],
        "properties" : {
          "owner" : {
            "type" : "string",
            "description" : "The new owner."
          },
          "isGroup" : {
            "type" : "boolean",
            "description" : "Whether the owner is a group instead of a user."
          }
        }
      },
      "SetDaosPropertyRequest" : {
        "type" : "object",
        "required" : [ "name", "value" ],
        "properties" : {
          "name" : {
            "type" : "string",
            "description" : "Name of the property to set."
          },
          "value" : {
            "type" : "string",
            "description" : "Value that the property should be set to."
          }
        }
      },
      "Severity" : {
        "type" : "string",
        "enum" : [ "INFO", "WARNING", "CRITICAL" ]
      },
      "SignedLicenseData" : {
        "description" : "Signed license information as received from https://api.croit.io.",
        "type" : "object",
        "required" : [ "nextRefresh", "features", "osds", "rawCapacityGb", "usedCapacityGb", "netCapacityGb", "storage", "servers", "croitVersions" ],
        "properties" : {
          "nextRefresh" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "License server needs to be contacted by this time."
          },
          "cephUuid" : {
            "type" : [ "string", "null" ],
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Ceph FSID"
          },
          "gracePeriodDays" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace period when the license or nextRefresh was exceeded."
          },
          "features" : {
            "type" : "object",
            "additionalProperties" : {
              "type" : "boolean"
            },
            "description" : "Limit features explicitly, setting a feature to false here disables it explicitly. Features missing here use the default setting."
          },
          "osds" : {
            "description" : "Limit the number of OSDs that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "rawCapacityGb" : {
            "description" : "Limit the raw available capacity of the cluster.",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "usedCapacityGb" : {
            "description" : "Limit the used capacity of the cluster (incl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "netCapacityGb" : {
            "description" : "Limit the net data stored by this cluster (excl. replication overhead).",
            "type" : "object",
            "$ref" : "#/components/schemas/PerOsdLimit"
          },
          "storage" : {
            "description" : "Limit the available hardware storage.",
            "type" : "object",
            "$ref" : "#/components/schemas/StorageLimit"
          },
          "servers" : {
            "description" : "Limit the number of nodes that can be used with this license.",
            "type" : "object",
            "$ref" : "#/components/schemas/ServerLimit"
          },
          "croitVersions" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "Set of croit versions this license is valid for. Empty set means all versions."
          },
          "offline" : {
            "type" : "boolean",
            "description" : "License is applicable to offline croit instances."
          },
          "free" : {
            "type" : "boolean",
            "description" : "License is a free license (not paid for, but community edition or trial)"
          }
        }
      },
      "SimpleDaosConfig" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "clusterName" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "description" : {
            "type" : "string"
          }
        },
        "required" : [ "clusterName", "name", "description" ]
      },
      "SimpleHookInfo" : {
        "type" : "object",
        "required" : [ "event" ],
        "properties" : {
          "event" : {
            "$ref" : "#/components/schemas/EventHookEvent"
          },
          "allServers" : {
            "type" : "boolean"
          },
          "serverIds" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "SimpleRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "startBucket", "independent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "startBucket" : {
            "type" : "string"
          },
          "independent" : {
            "type" : "string"
          },
          "deviceClass" : {
            "type" : [ "string", "null" ]
          },
          "erasureCoding" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "SmbAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SmbGatewayConfigResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "description" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean"
          }
        },
        "required" : [ "description", "type", "virtualIps" ]
      },
      "SmbGatewayServerRequest" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "domainAdminUser" : {
            "type" : [ "string", "null" ],
            "description" : "User name to join an Active Directory domain."
          },
          "domainAdminPassword" : {
            "type" : [ "string", "null" ],
            "description" : "Password to join an Active Directory domain. Password will not be stored by croit."
          }
        }
      },
      "SmbGatewayServerResponse" : {
        "type" : "object",
        "properties" : {
          "serviceId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname of the server"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "hostname", "virtualIps" ]
      },
      "SmbGatewayServerResponse1" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : [ "string", "null" ],
            "description" : "Interface on which HA virtual IPs will be bound."
          },
          "mac" : {
            "type" : [ "string", "null" ],
            "description" : "MAC address of current interface"
          },
          "ip" : {
            "type" : [ "string", "null" ],
            "description" : "IP of the server"
          },
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "description" : "VLAN tag on the selected interface."
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IPs currently bound on the server."
          },
          "healthy" : {
            "type" : "boolean",
            "description" : "true if all health checks succeeded."
          }
        },
        "required" : [ "virtualIps" ]
      },
      "SmbGatewayServiceRequest" : {
        "type" : "object",
        "required" : [ "servers", "virtualIps", "adminPassword", "readonlyPassword", "shares" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerRequest"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "adminPassword" : {
            "type" : "string",
            "description" : "Password of the croit admin user."
          },
          "readonlyPassword" : {
            "type" : "string",
            "description" : "Password of the croit-read read-only user."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/NewSimpleSmbGatewayShare"
            }
          },
          "description" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SmbGatewayServiceResponse" : {
        "type" : "object",
        "required" : [ "type", "servers", "virtualIps", "shares" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/SambaShareType"
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayServerResponse1"
            },
            "minItems" : 1
          },
          "virtualIps" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Virtual IP addresses to be distributed evenly across all healthy servers."
          },
          "shares" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SmbGatewayShareResponse"
            },
            "minItems" : 1
          },
          "domain" : {
            "type" : [ "string", "null" ]
          },
          "netbiosDomainName" : {
            "type" : [ "string", "null" ]
          },
          "serviceDnsName" : {
            "type" : [ "string", "null" ]
          },
          "domainController" : {
            "type" : [ "string", "null" ]
          },
          "dnsServers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            }
          },
          "joinWithSssd" : {
            "type" : "boolean",
            "description" : "Joined with adcli+sssd."
          }
        }
      },
      "SmbGatewayShareResponse" : {
        "type" : "object",
        "required" : [ "type", "share", "path" ],
        "properties" : {
          "type" : {
            "type" : "string",
            "description" : "Type of the SMB cluster that this share belongs to."
          },
          "serviceId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of the SMB cluster that this share belongs to."
          },
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID of this share."
          },
          "share" : {
            "type" : "string",
            "description" : "Name of the SMB share."
          },
          "path" : {
            "type" : "string",
            "description" : "Path in CephFS to export."
          },
          "guest" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the guest user."
          },
          "rw" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the admin/croit user."
          },
          "ro" : {
            "type" : [ "boolean", "null" ],
            "description" : "Enable access for the croit-ro user."
          },
          "roUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read-only access. Prefix groups with @."
          },
          "rwUsers" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "Users/groups with read/write access. Prefix groups with @."
          },
          "roUsersFormatted" : {
            "type" : [ "string", "null" ]
          },
          "rwUsersFormatted" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "SortBy" : {
        "type" : "object",
        "required" : [ "column", "order" ],
        "properties" : {
          "column" : {
            "type" : "string",
            "description" : "Which column to sort by."
          },
          "order" : {
            "description" : "Whether to sort ascending or descending.",
            "type" : "string",
            "$ref" : "#/components/schemas/QueryOrder"
          }
        }
      },
      "SsdPrimaryRuleRequest" : {
        "type" : "object",
        "required" : [ "name", "ssdStartBucket", "ssdIndependent", "hddStartBucket", "hddIndependent" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "ssdStartBucket" : {
            "type" : "string"
          },
          "ssdIndependent" : {
            "type" : "string"
          },
          "ssdDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "hddStartBucket" : {
            "type" : "string"
          },
          "hddIndependent" : {
            "type" : "string"
          },
          "hddDeviceClass" : {
            "type" : [ "string", "null" ]
          },
          "ssdCopies" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }
      },
      "StandbyReplaySetting" : {
        "type" : "object",
        "properties" : {
          "allowStandbyReplay" : {
            "type" : "boolean"
          },
          "cephFsName" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "StatsUnit" : {
        "type" : "string",
        "enum" : [ "IOPS", "BYTES_PER_SECOND", "BITS_PER_SECOND", "OBJECTS_PER_SECOND", "OBJECTS", "BYTES", "SECONDS", "MILLISECONDS", "MICROSECONDS", "PERCENT", "COUNT", "NONE" ]
      },
      "StorageLimit" : {
        "type" : "object",
        "description" : "Limit available hardware storage",
        "properties" : {
          "osds" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, excluding DB/WAL (negative number means no limit)."
          },
          "osdsWithJournal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL (negative number means no limit)."
          },
          "osdsTotal" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for OSDs, including DB/WAL and not yet used disks."
          },
          "total" : {
            "type" : "integer",
            "format" : "int64",
            "description" : "Storage in raw bytes allowed for all disks."
          },
          "gracePercent" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Grace in percent for having more storage"
          }
        }
      },
      "SupervisorModuleJson" : {
        "type" : "object",
        "required" : [ "name", "command", "restartPolicy" ],
        "properties" : {
          "name" : {
            "type" : "string"
          },
          "healthy" : {
            "type" : "boolean"
          },
          "disabled" : {
            "type" : "boolean"
          },
          "command" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "restartPolicy" : {
            "$ref" : "#/components/schemas/RestartPolicy"
          },
          "running" : {
            "type" : "boolean"
          },
          "pid" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          }
        }
      },
      "SurveyCeph" : {
        "type" : "object",
        "properties" : {
          "numOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numInOsds" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "sizeGB" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "rawCapacityGB" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "fullPercent" : {
            "type" : [ "integer", "null" ],
            "format" : "int64"
          },
          "pools" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/CephPoolSurvey"
            }
          },
          "rgwBuckets" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/RgwBucketSurvey"
            }
          },
          "cephFsStats" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/CephfsSurvey"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "pools", "rgwBuckets" ]
      },
      "SurveyConfigResponse" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          }
        }
      },
      "SurveyDisk" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "role" : {
            "$ref" : "#/components/schemas/DiskRole"
          },
          "sizeGB" : {
            "type" : "integer",
            "format" : "int32"
          },
          "name" : {
            "type" : "string"
          },
          "deviceClass" : {
            "$ref" : "#/components/schemas/DiskDeviceClass"
          },
          "partitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "usedPartitions" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "journalDisk" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "smart" : {
            "$ref" : "#/components/schemas/DiskSmartStatus"
          },
          "missing" : {
            "type" : "boolean"
          },
          "bluestore" : {
            "type" : [ "boolean", "null" ]
          },
          "type" : {
            "$ref" : "#/components/schemas/DiskType"
          },
          "numPaths" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        },
        "required" : [ "role", "name", "deviceClass", "smart", "type" ]
      },
      "SurveyNic" : {
        "type" : "object",
        "properties" : {
          "server" : {
            "type" : "integer",
            "format" : "int32"
          },
          "speed" : {
            "type" : "number",
            "format" : "double"
          },
          "name" : {
            "type" : "string"
          },
          "type" : {
            "$ref" : "#/components/schemas/NicType"
          },
          "bondSize" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "numVlans" : {
            "type" : "integer",
            "format" : "int32"
          }
        },
        "required" : [ "name", "type" ]
      },
      "SurveyReport" : {
        "type" : "object",
        "required" : [ "services", "disks", "servers", "nics" ],
        "properties" : {
          "services" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyService"
            }
          },
          "disks" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyDisk"
            }
          },
          "servers" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyServer"
            }
          },
          "nics" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/components/schemas/SurveyNic"
            }
          },
          "ceph" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/SurveyCeph"
            }, {
              "type" : "null"
            } ]
          }
        }
      },
      "SurveyServer" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ram" : {
            "type" : [ "number", "null" ],
            "format" : "double"
          },
          "cpu" : {
            "type" : [ "string", "null" ]
          },
          "cpuArch" : {
            "type" : [ "string", "null" ]
          },
          "cpus" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "totalCores" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "virtualCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "physicalCoresPerCpu" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "mainboard" : {
            "type" : [ "string", "null" ]
          },
          "runningImage" : {
            "type" : [ "string", "null" ]
          },
          "uptime" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "SurveyService" : {
        "type" : "object",
        "required" : [ "type" ],
        "properties" : {
          "type" : {
            "$ref" : "#/components/schemas/CroitServiceType"
          },
          "server" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "SurveyUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : [ "boolean", "null" ]
          }
        }
      },
      "TaskAdvisorUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "hide" : {
            "type" : "boolean"
          }
        }
      },
      "TaskProgressResponse" : {
        "type" : "object",
        "properties" : {
          "complete" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The amount of completed steps."
          },
          "total" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "The total amount of steps to be completed."
          }
        }
      },
      "TaskQuestion" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string"
          },
          "defaultResponse" : {
            "type" : "string"
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "priority" : {
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "timeout" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
          },
          "response" : {
            "type" : "string",
            "writeOnly" : true
          },
          "timeLeft" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ]
          }
        }
      },
      "TaskQuestionAnswer" : {
        "type" : "object",
        "required" : [ "token", "response" ],
        "properties" : {
          "token" : {
            "$ref" : "#/components/schemas/UUID"
          },
          "response" : {
            "type" : "string"
          }
        }
      },
      "TaskQuestionPriority" : {
        "type" : "string",
        "enum" : [ "Standard", "Urgent" ]
      },
      "TaskQuestionResponse" : {
        "type" : "object",
        "required" : [ "message", "defaultResponse", "responseOptions", "priority", "token" ],
        "properties" : {
          "message" : {
            "type" : "string",
            "description" : "Task question message to display to the user."
          },
          "defaultResponse" : {
            "type" : "string",
            "description" : "Default response if user doesn't answer in time."
          },
          "responseOptions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Response options to offer to the user."
          },
          "priority" : {
            "description" : "Priority for this question.",
            "type" : "string",
            "$ref" : "#/components/schemas/TaskQuestionPriority"
          },
          "token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Token used for the reply request."
          },
          "timeout" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Total time to respond to the question (in milliseconds)."
          },
          "timeLeft" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "Time left to respond to the question (in milliseconds)."
          }
        }
      },
      "TaskResponse" : {
        "description" : "A long running tasks.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "done" : {
            "type" : "boolean"
          },
          "statusCode" : {
            "type" : "integer",
            "format" : "int32"
          },
          "startedAt" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "startedBy" : {
            "type" : "string"
          },
          "name" : {
            "type" : "string"
          },
          "state" : {
            "$ref" : "#/components/schemas/ManagedTaskState"
          },
          "progress" : {
            "description" : "Progress indication of a background task.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskProgressResponse"
            }, {
              "type" : "null"
            } ]
          },
          "result" : { },
          "object" : {
            "type" : [ "string", "null" ]
          },
          "output" : {
            "type" : "string"
          },
          "cancelled" : {
            "type" : "boolean"
          },
          "question" : {
            "description" : "Question that a task might prompt for.",
            "type" : [ "object", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/TaskQuestionResponse"
            }, {
              "type" : "null"
            } ]
          }
        },
        "required" : [ "startedAt", "startedBy", "name", "state", "output" ]
      },
      "TemplateObject" : {
        "type" : "object",
        "required" : [ "content", "type" ],
        "properties" : {
          "content" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/components/schemas/TemplateVariable"
            }
          },
          "nullable" : {
            "type" : "boolean"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          }
        }
      },
      "TemplateVariable" : {
        "type" : "object",
        "properties" : {
          "nullable" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string"
          },
          "description" : {
            "type" : [ "string", "null" ]
          },
          "deprecated" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      },
      "TerminalConnection" : {
        "type" : "object",
        "required" : [ "path", "authToken", "validUntil" ],
        "properties" : {
          "path" : {
            "type" : "string",
            "description" : "Connect here."
          },
          "tlsPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for TLS."
          },
          "plaintextPort" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Connect to this port for an unencrypted connection."
          },
          "authToken" : {
            "description" : "Pass as Authorization header.",
            "type" : "string",
            "$ref" : "#/components/schemas/UUID"
          },
          "validUntil" : {
            "type" : "string",
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ],
            "description" : "URL is valid until this time, existing connections stay connected afterwards."
          },
          "iscsi" : {
            "type" : "boolean",
            "description" : "Whether this is a connection to an iSCSI gateway."
          }
        }
      },
      "TimezoneSettings" : {
        "type" : "object",
        "required" : [ "timezone", "options" ],
        "properties" : {
          "timezone" : {
            "type" : "string"
          },
          "options" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        }
      },
      "Token" : {
        "description" : "Token Response",
        "type" : "object",
        "required" : [ "access_token", "token_type", "roles" ],
        "properties" : {
          "access_token" : {
            "type" : "string",
            "format" : "uuid",
            "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
            "description" : "Access token, should be handled as an opaque value as the format may change in the future."
          },
          "token_type" : {
            "type" : "string",
            "description" : "OAuth2 token type, always \"bearer\"."
          },
          "expires_in" : {
            "type" : [ "string", "null" ],
            "format" : "duration",
            "examples" : [ "P1D" ],
            "description" : "Remaining validity."
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            },
            "description" : "All roles of the user the token is associated with."
          },
          "userId" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Internal id of the user this token is associated with."
          },
          "passwordWasNeverChanged" : {
            "type" : "boolean",
            "description" : "Set if the user never changed their password."
          }
        }
      },
      "TokenInfoReply" : {
        "type" : "object",
        "required" : [ "username", "roles" ],
        "properties" : {
          "username" : {
            "type" : "string"
          },
          "roles" : {
            "type" : "array",
            "uniqueItems" : true,
            "items" : {
              "type" : "string"
            }
          },
          "expiry" : {
            "type" : [ "string", "null" ],
            "format" : "date-time",
            "examples" : [ "2022-03-10T16:15:50Z" ]
          },
          "oidcId" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "oidcSubject" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "UUID" : {
        "type" : "string",
        "format" : "uuid",
        "pattern" : "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}"
      },
      "UnencryptedBackupRequest" : {
        "type" : "object",
        "required" : [ "file" ],
        "properties" : {
          "file" : {
            "type" : "string",
            "format" : "binary"
          }
        }
      },
      "UpdateGrubRequest" : {
        "type" : "object",
        "required" : [ "servers" ],
        "properties" : {
          "servers" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          }
        }
      },
      "UploadS3ObjectRequest" : {
        "type" : "object",
        "required" : [ "key", "file" ],
        "properties" : {
          "key" : {
            "type" : "string"
          },
          "file" : {
            "type" : "string",
            "format" : "binary"
          },
          "size" : {
            "type" : "integer",
            "format" : "int64"
          }
        }
      },
      "UserUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "roles" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/RoleEnum"
            },
            "description" : "Roles. Admin users also need viewer privileges."
          }
        }
      },
      "VPNConfigRequest" : {
        "description" : "Croit VPN configuartion request to https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "croitVersionString" : {
            "type" : [ "string", "null" ],
            "description" : "Croit version as a string (omitted if unknown)."
          },
          "croitVersion" : {
            "description" : "Croit version (omitted if unknown).",
            "type" : "object",
            "anyOf" : [ {
              "$ref" : "#/components/schemas/VPNCroitVersion"
            }, {
              "type" : "null"
            } ]
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname to use for the croit VPN."
          },
          "extraArgs" : {
            "type" : [ "string", "null" ],
            "description" : "Extra arguments to pass to the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        },
        "required" : [ "hostname" ]
      },
      "VPNConfigResponse" : {
        "description" : "Croit VPN configuartion as received from https://api.croit.io.",
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "ID for the vpn configuration."
          },
          "envs" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "description" : "Environment variables to set for the croit VPN container."
          },
          "image" : {
            "description" : "Image to use for the croit VPN container.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNCroitDockerImage"
          },
          "stateDir" : {
            "type" : "string",
            "description" : "Directory to use for the croit VPN configuration. Should be mounted from a docker volume."
          },
          "resetState" : {
            "type" : "boolean",
            "description" : "If true, the croit client requesting the VPN config needs to reset the VPN state directory."
          },
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          }
        },
        "required" : [ "envs", "image", "stateDir", "reqId" ]
      },
      "VPNConnectInfo" : {
        "description" : "Croit VPN connection confirmation and information on the client.",
        "type" : "object",
        "required" : [ "reqId", "hostname", "fqdn", "ip", "errorMessage", "vpnLogs" ],
        "properties" : {
          "reqId" : {
            "type" : "string",
            "description" : "Connection request ID, to be sent to the connect confirmation endpoint"
          },
          "connected" : {
            "type" : "boolean",
            "description" : "Whether or not connection was successful."
          },
          "hostname" : {
            "type" : "string",
            "description" : "Hostname assigned by the croit VPN."
          },
          "fqdn" : {
            "type" : "string",
            "description" : "FQDN assigned by the croit VPN."
          },
          "ip" : {
            "type" : "string",
            "description" : "IP assigned by the croit VPN."
          },
          "errorMessage" : {
            "type" : "string",
            "description" : "Error message if VPN failed to connect."
          },
          "vpnLogs" : {
            "type" : "string",
            "description" : "VPN logs if VPN failed to connect."
          }
        }
      },
      "VPNConnectionInfo" : {
        "type" : "object",
        "required" : [ "status", "suggestedHostname" ],
        "properties" : {
          "status" : {
            "description" : "Croit VPN connection status.",
            "type" : "object",
            "$ref" : "#/components/schemas/VPNConnectionStatus"
          },
          "configuredHostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to be used in the croit VPN as configured by the user."
          },
          "suggestedHostname" : {
            "type" : "string",
            "description" : "Hostname to be used in the croit VPN as suggested by croit."
          }
        }
      },
      "VPNConnectionRequest" : {
        "type" : "object",
        "properties" : {
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname to use for the croit VPN."
          },
          "info" : {
            "type" : [ "string", "null" ],
            "description" : "Optional extra info for this connection request (e.g. ticket number). Limited to 50 characters."
          }
        }
      },
      "VPNConnectionStatus" : {
        "type" : "object",
        "properties" : {
          "containerRunning" : {
            "type" : "boolean",
            "description" : "True if croit VPN container is running."
          },
          "connected" : {
            "type" : "boolean",
            "description" : "True if connected to the croit VPN."
          },
          "version" : {
            "type" : [ "string", "null" ],
            "description" : "Version of the tailscale client."
          },
          "hostname" : {
            "type" : [ "string", "null" ],
            "description" : "Hostname in the croit VPN."
          },
          "fqdn" : {
            "type" : [ "string", "null" ],
            "description" : "FQDN in the croit VPN."
          },
          "clientId" : {
            "type" : [ "string", "null" ],
            "description" : "Tailscale ID in the croit VPN"
          },
          "userId" : {
            "type" : [ "integer", "null" ],
            "format" : "int64",
            "description" : "User ID in the croit VPN"
          },
          "ips" : {
            "type" : [ "array", "null" ],
            "items" : {
              "type" : "string"
            },
            "description" : "List of IPs of this host in the croit VPN."
          },
          "reason" : {
            "type" : "string",
            "description" : "If disconnected, the reason why croit assumes that the VPN is not connected."
          }
        },
        "required" : [ "reason" ]
      },
      "VPNCroitDockerImage" : {
        "type" : "object",
        "description" : "Docker image specification.",
        "properties" : {
          "registry" : {
            "type" : [ "string", "null" ],
            "description" : "Registry to use. If omitted, the default registry (docker hub) is used."
          },
          "login" : {
            "type" : [ "object", "null" ],
            "description" : "Login to use. If omitted, no login data is provided to the registry (the image needs to be public)."
          },
          "name" : {
            "type" : "string",
            "description" : "Image name."
          },
          "tag" : {
            "type" : "string",
            "description" : "Image tag."
          }
        },
        "required" : [ "name", "tag" ]
      },
      "VPNCroitVersion" : {
        "type" : "object",
        "description" : "Croit version.",
        "properties" : {
          "major" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Major croit release version (e.g. 2303)."
          },
          "minor" : {
            "type" : "integer",
            "format" : "int32",
            "description" : "Minor croit release version (e.g. 1)."
          },
          "patch" : {
            "type" : "string",
            "description" : "Patch version (only relevant for nightly or dev builds)."
          },
          "cephRelease" : {
            "type" : [ "string", "null" ],
            "description" : "Ceph release (e.g. quincy)."
          }
        },
        "required" : [ "patch" ]
      },
      "VlanAddressInfo" : {
        "type" : "object",
        "required" : [ "ip" ],
        "properties" : {
          "ip" : {
            "type" : "string"
          },
          "nicId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlanId" : {
            "type" : "integer",
            "format" : "int32"
          },
          "serverId" : {
            "type" : "integer",
            "format" : "int32"
          }
        }
      },
      "VlanInfo" : {
        "type" : "object",
        "properties" : {
          "id" : {
            "type" : "integer",
            "format" : "int32"
          },
          "nic" : {
            "type" : "integer",
            "format" : "int32"
          },
          "vlan" : {
            "type" : "integer",
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "VlanUpdateRequest" : {
        "type" : "object",
        "properties" : {
          "vlan" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          },
          "ip" : {
            "type" : [ "string", "null" ]
          },
          "ip6" : {
            "type" : [ "string", "null" ]
          }
        }
      },
      "WhereCondition" : {
        "description" : "Filter to apply to the list of items. Items are filtered before the limit is applied.",
        "additionalProperties" : {
          "$ref" : "#/components/schemas/FieldCondition"
        },
        "type" : [ "object", "null" ],
        "properties" : {
          "_and" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical AND operator. All conditions must be satisfied."
          },
          "_or" : {
            "type" : [ "array", "null" ],
            "items" : {
              "$ref" : "#/components/schemas/WhereCondition"
            },
            "description" : "Logical OR operator. At least one condition must be satisfied."
          },
          "_not" : {
            "description" : "Logical NOT operator. The condition must not be satisfied.",
            "type" : [ "object", "null", "null" ],
            "anyOf" : [ {
              "$ref" : "#/components/schemas/WhereCondition"
            }, {
              "type" : "null"
            } ]
          },
          "_search" : {
            "type" : [ "string", "null" ],
            "description" : "Full-text search across all searchable fields."
          }
        }
      },
      "WildcardPoolPermission" : {
        "type" : "string",
        "enum" : [ "ALL_POOLS", "ALL_CEPHFS_POOLS" ]
      }
    }
  },
  "tags" : [ {
    "name" : "api-tokens",
    "description" : "Manage croit API tokens."
  }, {
    "name" : "audit",
    "description" : "Query croit audit logs."
  }, {
    "name" : "authentication",
    "description" : "OAuth2 authentication."
  }, {
    "name" : "ceph-keys",
    "description" : "Manage Ceph access keys."
  }, {
    "name" : "ceph-pools",
    "description" : "Manage ceph pools."
  }, {
    "name" : "cephfs",
    "description" : "CephFS file management."
  }, {
    "name" : "change-requests"
  }, {
    "name" : "cluster"
  }, {
    "name" : "config",
    "description" : "Configure settings for croit and ceph."
  }, {
    "name" : "config-templates",
    "description" : "Manage templates for config files."
  }, {
    "name" : "croit",
    "description" : "Information about the croit application."
  }, {
    "name" : "crush",
    "description" : "CRUSH map and rule management."
  }, {
    "name" : "daos",
    "description" : "Configure and manage DAOS."
  }, {
    "name" : "disks",
    "description" : "Manage server disks."
  }, {
    "name" : "extra-files",
    "description" : "Static web server for files located in /config/extra-files (or in /config/extra-files-secure, requiring authentication), to be downloaded by hook scripts on the servers."
  }, {
    "name" : "ha-groups",
    "description" : "Manage high availability groups and floating IPs."
  }, {
    "name" : "hooks",
    "description" : "Hook scripts for specific events."
  }, {
    "name" : "images",
    "description" : "Manage OS images."
  }, {
    "name" : "ipmi",
    "description" : "Manage IPMI interfaces."
  }, {
    "name" : "license",
    "description" : "croit license information."
  }, {
    "name" : "logs",
    "description" : "Log file API."
  }, {
    "name" : "maintenance",
    "description" : "Cluster maintenance and recovery APIs."
  }, {
    "name" : "networks",
    "description" : "Manage networks."
  }, {
    "name" : "osds",
    "description" : "OSD inventory, status, and topology management."
  }, {
    "name" : "placement-groups",
    "description" : "Manage placement groups."
  }, {
    "name" : "qos-settings",
    "description" : "QOS Settings."
  }, {
    "name" : "rbd-mirror",
    "description" : "Manage RBD mirroring for RBD pools. To configure RBD mirroring, first start an RBD mirror service on the cluster that data should be mirrored to. Then use this API to enable mirroring on pools with the same name on both clusters. To connect the two clusters, generate a bootstrap token on one of the pools, and import the token on the same pool on the other cluster."
  }, {
    "name" : "rbds",
    "description" : "Manage RBD images in pools."
  }, {
    "name" : "s3",
    "description" : "Manage S3 access."
  }, {
    "name" : "servers",
    "description" : "Manage server hardware, configuration, and services."
  }, {
    "name" : "services",
    "description" : "Manage services, this includes both Ceph services and croit-specific services running on both the ceph servers and management node."
  }, {
    "name" : "setup",
    "description" : "Initial setup of croit."
  }, {
    "name" : "snapshot-schedule",
    "description" : "Schedule automatic snapshots for CephFS and RBD."
  }, {
    "name" : "stats",
    "description" : "Get statistics of the cluster and servers."
  }, {
    "name" : "status",
    "description" : "Backend status."
  }, {
    "name" : "supervisor",
    "description" : "Manage supervisor operations."
  }, {
    "name" : "support",
    "description" : "Connect to croit support."
  }, {
    "name" : "survey",
    "description" : "Manage participation in the croit hardware survey."
  }, {
    "name" : "task-advisor",
    "description" : "Admin task advisor."
  }, {
    "name" : "tasks",
    "description" : "Status and overview of long running background tasks."
  }, {
    "name" : "users",
    "description" : "Manage croit users."
  } ],
  "paths" : {
    "/api-tokens" : {
      "get" : {
        "summary" : "List all configured api tokens.",
        "operationId" : "ApiTokenResource_getApiTokens",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseApiTokenInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured API tokens with their names, roles, and expiration status for access management.",
          "usage" : [ "Call when auditing API access permissions or reviewing token lifecycle management.", "Use to identify expired or soon-to-expire tokens requiring renewal or cleanup." ],
          "response_shape" : "OptionalPaginationResponse<ApiTokenInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination request with filtering and sorting capabilities.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"name\":{\"_like\":\"%admin%\"}}]}"
          } ],
          "failure_modes" : [ "403 if called by an API token instead of a user session" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "API tokens cannot list other tokens; use a user session with admin privileges."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "API token management queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/api-tokens", "/auth/whoami" ],
          "postprocessing_hint" : "Highlight expiring tokens; group by role; display creation dates and last-used timestamps if available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a new API token. Returns the secret token (which should only be shown once to the user).",
        "operationId" : "ApiTokenResource_createApiToken",
        "tags" : [ "api-tokens" ],
        "requestBody" : {
          "description" : "API token creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new API token for programmatic access to the croit API with specified roles and expiration.",
          "usage" : [ "Call when setting up new services or automation that needs API access.", "Use to generate tokens for CI/CD pipelines, monitoring systems, or integration tools." ],
          "response_shape" : "String (secret token)",
          "workflow_guidance" : {
            "pre_check" : "Name is unique; Roles are valid; Admin has interactive session",
            "post_action" : "Token created and returned; Secret shown only once; Token immediately usable"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Descriptive name to identify the token's purpose.",
            "required" : true,
            "example" : "monitoring-service"
          }, {
            "name" : "roles",
            "in" : "body",
            "description" : "List of roles to assign (admin users need viewer role too).",
            "required" : true,
            "example" : "[\"viewer\", \"admin\"]"
          }, {
            "name" : "expiry",
            "in" : "body",
            "description" : "Optional expiration timestamp (null for no expiration).",
            "required" : false,
            "example" : "2024-12-31T23:59:59Z"
          } ],
          "failure_modes" : [ "400 if name is already taken or roles are invalid", "403 if called by an API token instead of user session" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose a unique name and validate role assignments are correct."
          }, {
            "code" : "403",
            "action" : "Use an interactive admin session for security when creating API tokens."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "API token creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens", "/api-tokens/{id}" ],
          "postprocessing_hint" : "Store the returned token securely - it cannot be retrieved again; only shown once for security.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "API tokens provide programmatic access and should be created carefully"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/api-tokens/{id}" : {
      "patch" : {
        "summary" : "Update an API token.",
        "operationId" : "ApiTokenResource_updateApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "API token update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ApiTokenUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for an existing API token to adjust access levels without regenerating the token.",
          "usage" : [ "Call when service requirements change and need different permission levels.", "Use to grant or revoke specific access rights while preserving the token secret." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Token exists; Valid role configuration; Admin has interactive session",
            "post_action" : "Token permissions updated; Changes effective immediately; Services continue using same token"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "New list of roles to assign (admin users need both ADMIN and VIEWER roles).",
            "required" : false,
            "example" : "[\"VIEWER\", \"ADMIN\"]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "API token ID to update from GET /api-tokens.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "400 if role configuration is invalid or insufficient", "403 if called by an API token instead of user session", "404 if API token ID does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure admin tokens have both ADMIN and VIEWER roles; validate role assignments."
          }, {
            "code" : "403",
            "action" : "Use an interactive admin session for security when managing API tokens."
          }, {
            "code" : "404",
            "action" : "Verify token ID exists; check if token was deleted; refresh token list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "API token updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens", "/api-tokens/{id}" ],
          "postprocessing_hint" : "Permission changes are immediate; verify services still function correctly with new role assignments.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an API token.",
        "operationId" : "ApiTokenResource_deleteApiToken",
        "tags" : [ "api-tokens" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete an API token to revoke access for automated systems or services.",
          "usage" : [ "Call when decommissioning services or revoking access for compromised tokens.", "Use for cleanup of unused or expired API tokens to maintain security hygiene." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "API token ID to delete from GET /api-tokens.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "403 if called by an API token instead of user session", "404 if API token ID does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when managing API tokens."
          }, {
            "code" : "404",
            "action" : "Token may have already been deleted; refresh token list to verify."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "API token management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/api-tokens" ],
          "postprocessing_hint" : "Token is immediately invalid; update any services that were using this token before deletion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting API tokens will immediately revoke access for any services using this token"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit" : {
      "get" : {
        "summary" : "Get audit logs.",
        "operationId" : "AuditResource_getAuditLogs",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "description" : "Limit number of results returned, max = 100, default = 50.",
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 1
          }
        }, {
          "description" : "Offset for pagination, default = 0.",
          "name" : "offset",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32",
            "minimum" : 0
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AuditInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve audit logs for compliance monitoring and security analysis of system activities.",
          "usage" : [ "Call when investigating security incidents or reviewing user actions for compliance audits.", "Use to monitor administrative changes and track system access patterns." ],
          "response_shape" : "List<AuditInfo>",
          "request_parameters" : [ {
            "name" : "limit",
            "in" : "query",
            "description" : "Maximum number of audit records to return (1-100, default 50).",
            "required" : false,
            "example" : "25"
          }, {
            "name" : "offset",
            "in" : "query",
            "description" : "Number of records to skip for pagination (default 0).",
            "required" : false,
            "example" : "50"
          } ],
          "failure_modes" : [ "400 if limit exceeds 100 or offset/limit are negative" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure limit is between 1-100 and offset is non-negative."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Audit log queries"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/audit/{id}" ],
          "postprocessing_hint" : "Group by action type and timestamp; highlight security-relevant events; show user context for each action.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-ad-logs" : {
      "post" : {
        "summary" : "Fix Samba AD audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaADLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clean up vulnerable Samba Active Directory audit logs containing leaked credentials (CVE-2025-29305).",
          "usage" : [ "Call when security vulnerability scanner identifies exposed AD credentials in audit logs.", "Use as immediate remediation action to remove sensitive authentication data from logs." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Vulnerable AD logs detected; Admin privileges confirmed; Backup considerations reviewed",
            "post_action" : "Vulnerable audit log entries cleaned; Task advisor updated; Security vulnerability resolved"
          },
          "failure_modes" : [ "500 if cleanup task fails to remove vulnerable log entries", "500 if task advisor verification indicates incomplete cleanup" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Review task logs for specific cleanup failures; contact support if cleanup verification fails after completion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Security remediation actions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/audit", "/audit/actions/fix-samba-simple-logs" ],
          "postprocessing_hint" : "Monitor task progress for completion; verify with task advisor that vulnerability is resolved; logs are permanently modified.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This action will permanently remove audit log entries containing AD credentials"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/actions/fix-samba-simple-logs" : {
      "post" : {
        "summary" : "Fix Samba simple audit logs: see CVE-2025-29305",
        "operationId" : "AuditResource_fixSambaSimpleLogs",
        "tags" : [ "audit" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clean up vulnerable Samba simple authentication audit logs containing exposed credentials (CVE-2025-29305).",
          "usage" : [ "Call when security scanner detects exposed simple authentication credentials in audit logs.", "Use for immediate security remediation to remove leaked password data from system logs." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Vulnerable simple auth logs detected; Admin privileges confirmed; Backup considerations reviewed",
            "post_action" : "Vulnerable audit log entries cleaned; Task advisor updated; Security vulnerability resolved"
          },
          "failure_modes" : [ "500 if cleanup task fails to remove vulnerable log entries", "500 if task advisor verification indicates incomplete remediation" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check task logs for specific cleanup errors; contact support if verification fails after remediation completion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Security remediation actions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/audit", "/audit/actions/fix-samba-ad-logs" ],
          "postprocessing_hint" : "Monitor task progress for completion; verify with task advisor that vulnerability is resolved; log modifications are permanent.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This action will permanently remove audit log entries containing simple authentication credentials"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/audit/{id}" : {
      "get" : {
        "summary" : "Get specific audit log by ID.",
        "operationId" : "AuditResource_getAuditLog",
        "tags" : [ "audit" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AuditInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed information for a specific audit log entry by its unique identifier.",
          "usage" : [ "Call when investigating specific security events or analyzing detailed context of an action.", "Use to get complete audit record details including request parameters and response data." ],
          "response_shape" : "AuditInfo",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Unique audit log entry identifier.",
            "required" : true,
            "example" : "12345"
          } ],
          "failure_modes" : [ "400 if audit record with specified ID does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify the audit ID exists by checking recent entries from GET /audit."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Individual audit record queries"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/audit" ],
          "postprocessing_hint" : "Display complete audit context including user, timestamp, action details, and any request/response data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/login" : {
      "post" : {
        "summary" : "OAuth 2 authentication via HTTP basic authentication, see Section 4.4 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginBasic",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform OAuth 2 client credentials authentication using HTTP Basic Auth (RFC 6749 Section 4.4).",
          "usage" : [ "Call from API clients or services that need to authenticate with client credentials.", "Use for machine-to-machine authentication without user interaction." ],
          "response_shape" : "Token",
          "request_parameters" : [ {
            "name" : "grant_type",
            "in" : "form",
            "description" : "OAuth 2 grant type, must be 'client_credentials'.",
            "required" : true,
            "example" : "client_credentials"
          } ],
          "failure_modes" : [ "400 if grant_type is not 'client_credentials'", "401 if HTTP Basic Auth credentials are invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure grant_type parameter is set to 'client_credentials'."
          }, {
            "code" : "401",
            "action" : "Verify username and password are correct and user account is active."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Client credential authentication"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login-form", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; set Cache-Control and Pragma headers prevent caching.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/login-form" : {
      "post" : {
        "summary" : "OAuth 2 authentication with all parameters as url-encoded form, see Section 4.3 of RFC 6749 for details.",
        "operationId" : "AuthResource_loginForm",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "content" : {
            "application/x-www-form-urlencoded" : {
              "schema" : {
                "type" : "object",
                "required" : [ "grant_type", "username", "password" ],
                "properties" : {
                  "grant_type" : {
                    "type" : "string"
                  },
                  "username" : {
                    "type" : "string"
                  },
                  "password" : {
                    "type" : "string"
                  }
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform OAuth 2 password grant authentication using form-encoded credentials (RFC 6749 Section 4.3).",
          "usage" : [ "Call from login forms where users enter username and password directly.", "Use for web applications requiring traditional username/password authentication." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "User account exists and is active; Password is correct; No account lockout in effect",
            "post_action" : "Session token generated; User authenticated; Cache-Control headers set"
          },
          "request_parameters" : [ {
            "name" : "grant_type",
            "in" : "form",
            "description" : "OAuth 2 grant type, must be 'password'.",
            "required" : true,
            "example" : "password"
          }, {
            "name" : "username",
            "in" : "form",
            "description" : "User name of the croit or LDAP user.",
            "required" : true,
            "example" : "admin"
          }, {
            "name" : "password",
            "in" : "form",
            "description" : "Plaintext password for authentication.",
            "required" : true,
            "example" : "password123"
          } ],
          "failure_modes" : [ "400 if grant_type is not 'password'", "403 if username/password combination is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure grant_type parameter is set to 'password'."
          }, {
            "code" : "403",
            "action" : "Verify credentials are correct; check if account is locked or disabled."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Password authentication attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; password field is redacted from audit logs for security.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/logout" : {
      "post" : {
        "summary" : "Log out the current user session",
        "operationId" : "AuthResource_logout",
        "tags" : [ "authentication" ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Terminate the current user session and invalidate the authentication token.",
          "usage" : [ "Call when users explicitly log out or when sessions need to be terminated.", "Use in security flows to ensure clean session termination." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid session token provided; User is authenticated",
            "post_action" : "Session invalidated; Authentication cookies removed; User logged out"
          },
          "failure_modes" : [ "401 if no valid session token is provided" ],
          "error_handling" : [ {
            "code" : "401",
            "action" : "Session was already invalid; proceed with logout flow and clear client-side tokens."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Logout operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/login-form", "/auth/token-info" ],
          "postprocessing_hint" : "Clear all client-side tokens and redirect to login page; session cookies are automatically removed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/auth/oidc" : {
      "get" : {
        "summary" : "List of all OIDC configs.",
        "operationId" : "AuthResource_getOidcConfigs",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseOidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed configuration for every registered OIDC provider.",
          "usage" : [ "Open the identity provider administration view", "Review provider settings before editing or deleting entries" ],
          "response_shape" : "OptionalPaginationResponse<OidcConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit, sort or filter provider records.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"providerName\":{\"_ilike\":\"%prod%\"}}]}"
          } ],
          "failure_modes" : [ "403 if called with an API token session", "200 [] when no providers are configured" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Require an interactive admin session before exposing provider settings."
          }, {
            "code" : "200",
            "action" : "Present an empty state encouraging the creation of a provider."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "OIDC admin view"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc/{id}", "/auth/oidc/providers" ],
          "postprocessing_hint" : "Mask client secrets when rendering and avoid persisting them client-side.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create new OIDC configuration",
        "operationId" : "AuthResource_createOidcConfig",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "OIDC configuration creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new OIDC identity provider configuration for external authentication.",
          "usage" : [ "Call when adding a new identity provider like Auth0, Azure AD, or Google Workspace.", "Use to enable SSO authentication for users from external systems." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "OIDC discovery URL is accessible; Client credentials are valid; Admin has interactive session",
            "post_action" : "Provider configuration saved; OIDC discovery cached; Provider available for user authentication"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Human-readable name for the OIDC provider.",
            "required" : true,
            "example" : "Company Active Directory"
          }, {
            "name" : "discoveryUrl",
            "in" : "body",
            "description" : "OIDC discovery endpoint URL for the provider.",
            "required" : true,
            "example" : "https://login.company.com/.well-known/openid_configuration"
          }, {
            "name" : "clientId",
            "in" : "body",
            "description" : "OAuth client ID for croit application.",
            "required" : true,
            "example" : "croit-app-12345"
          }, {
            "name" : "clientSecret",
            "in" : "body",
            "description" : "OAuth client secret (if required by provider).",
            "required" : false,
            "example" : "secret123"
          } ],
          "failure_modes" : [ "403 if called with an API token instead of user session", "500 if OIDC discovery fails or provider is unreachable" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when adding identity providers."
          }, {
            "code" : "500",
            "action" : "Verify discovery URL is accessible and returns valid OIDC metadata; check network connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}", "/auth/oidc/providers" ],
          "postprocessing_hint" : "Monitor task for completion; test provider with GET /auth/oidc/{id}/login before enabling for users.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Adding OIDC providers affects user authentication and requires network access to external systems"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/callback" : {
      "post" : {
        "summary" : "Handle OIDC callback",
        "operationId" : "AuthResource_oidcCallback",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "code",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "error",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "state",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Process OIDC authorization callback from identity provider and complete user authentication.",
          "usage" : [ "Called automatically by the browser after user completes authentication at identity provider.", "Handles the OAuth 2 authorization code exchange and user session creation." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "Valid authorization code from provider; State parameter matches; Provider configuration exists",
            "post_action" : "User session created; Authentication cookies set; User redirected to application"
          },
          "request_parameters" : [ {
            "name" : "code",
            "in" : "query",
            "description" : "Authorization code from identity provider.",
            "required" : false,
            "example" : "abc123"
          }, {
            "name" : "state",
            "in" : "query",
            "description" : "State parameter for CSRF protection.",
            "required" : false,
            "example" : "state-token-123"
          }, {
            "name" : "error",
            "in" : "query",
            "description" : "Error code if authentication failed.",
            "required" : false,
            "example" : "access_denied"
          } ],
          "failure_modes" : [ "400 if authorization code is invalid or expired", "401 if user has no roles defined after authentication", "500 if token exchange with identity provider fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Authorization failed at provider; redirect user to retry authentication."
          }, {
            "code" : "401",
            "action" : "User authenticated but has no assigned roles; configure user roles in identity provider."
          }, {
            "code" : "500",
            "action" : "Token exchange failed; check provider connectivity and client credentials."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "OIDC callback processing"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/{id}/login", "/auth/token-info" ],
          "postprocessing_hint" : "Automatically called by browser; session token is returned for client-side storage; manual audit logging included.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/oidc/providers" : {
      "get" : {
        "summary" : "Get list of OIDC provider options",
        "operationId" : "AuthResource_getOidcProviders",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/OidcProvider"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured OIDC providers for login selection screens.",
          "usage" : [ "Call on the login page to show available identity providers", "Cache provider names between sessions unless configuration changes" ],
          "response_shape" : "array<OidcProvider>",
          "failure_modes" : [ "200 [] when no OIDC providers are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display a message indicating that no external providers are available."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/oidc/{id}/login", "/auth/oidc" ],
          "postprocessing_hint" : "Sort providers alphabetically before rendering the list.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/oidc/{id}" : {
      "put" : {
        "summary" : "Update OIDC configuration",
        "operationId" : "AuthResource_updateOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC configuration update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/OidcConfigCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing OIDC identity provider configuration and invalidate affected user sessions.",
          "usage" : [ "Call when modifying provider settings like discovery URL, client credentials, or role mappings.", "Use to fix authentication issues or update provider configurations." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; New discovery URL is accessible; Admin has interactive session",
            "post_action" : "Provider configuration updated; Existing user sessions invalidated; Users must re-authenticate"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Updated human-readable name for the provider.",
            "required" : true,
            "example" : "Updated Company AD"
          }, {
            "name" : "discoveryUrl",
            "in" : "body",
            "description" : "Updated OIDC discovery endpoint URL.",
            "required" : true,
            "example" : "https://new-login.company.com/.well-known/openid_configuration"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to update.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "403 if called with an API token instead of user session", "404 if provider ID does not exist", "500 if updated discovery URL is invalid or unreachable" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when modifying identity providers."
          }, {
            "code" : "404",
            "action" : "Provider may have been deleted; refresh provider list and verify ID."
          }, {
            "code" : "500",
            "action" : "Verify new discovery URL is accessible; check provider configuration changes."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}", "/auth/oidc/{id}/invalidate" ],
          "postprocessing_hint" : "Monitor task for completion; affected users will need to re-authenticate; test updated configuration.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Updating OIDC providers will log out all users from this provider and may affect authentication"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get specific OIDC configuration",
        "operationId" : "AuthResource_getOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OidcConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch a single OIDC provider configuration for editing.",
          "usage" : [ "Load details when the admin selects a provider from the list", "Validate configuration values before saving changes" ],
          "response_shape" : "OidcConfigResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "403 if called with an API token session", "404 if the provider does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Require a human admin session before exposing provider secrets."
          }, {
            "code" : "404",
            "action" : "Display a toast that the provider was removed and refresh the list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-provider detail fetch"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Do not log clientSecret fields; redact before telemetry.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete OIDC configuration",
        "operationId" : "AuthResource_deleteOidcConfig",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an OIDC identity provider configuration and invalidate all related user sessions.",
          "usage" : [ "Call when decommissioning an identity provider or migrating to a different provider.", "Use to clean up test providers or providers that are no longer trusted." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; No critical users depend solely on this provider; Admin has interactive session",
            "post_action" : "Provider configuration deleted; All user sessions from this provider invalidated; Users must re-authenticate"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to remove.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "403 if called with an API token session", "404 if the provider doesn't exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Require interactive admin session for security when removing identity providers."
          }, {
            "code" : "404",
            "action" : "Provider may have already been deleted; refresh the provider list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "OIDC provider removal"
          },
          "related_endpoints" : [ "/auth/oidc", "/auth/oidc/{id}/invalidate" ],
          "postprocessing_hint" : "Verify removal with GET /auth/oidc; affected users will need alternative authentication methods configured.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting OIDC providers will immediately log out all users from that provider and prevent future logins"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/invalidate" : {
      "post" : {
        "summary" : "Invalidate all OIDC user sessions",
        "operationId" : "AuthResource_invalidateOidcSessions",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Forcibly invalidate all active user sessions from a specific OIDC identity provider.",
          "usage" : [ "Call when suspecting compromised provider credentials or after security incidents.", "Use to force users to re-authenticate after provider configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Provider exists; Admin has interactive session; Understanding that users will be logged out",
            "post_action" : "All user sessions from this provider invalidated; Users must re-authenticate"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier from GET /auth/oidc to invalidate sessions for.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "403 if called with an API token instead of user session", "404 if provider ID does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when invalidating user sessions."
          }, {
            "code" : "404",
            "action" : "Provider may have been deleted; refresh provider list and verify ID."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Session invalidation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/{id}", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Affected users will need to re-authenticate; consider notifying users before performing this action.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This will immediately log out all users authenticated via this OIDC provider"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/auth/oidc/{id}/login" : {
      "get" : {
        "summary" : "Initiate OIDC login flow",
        "operationId" : "AuthResource_oidcLogin",
        "tags" : [ "authentication" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off the browser-based OIDC authorization flow and obtain a redirect response.",
          "usage" : [ "Invoke when the user selects an external provider on the login screen", "Immediately follow the redirect location to continue the OIDC handshake" ],
          "response_shape" : "HTTP 302 redirect",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Provider identifier returned by GET /auth/oidc/providers",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the provider is unknown", "500 if the OIDC discovery or redirect construction fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Show an error and refresh the provider list before retrying."
          }, {
            "code" : "500",
            "action" : "Log details, alert the user, and offer fallback credentials if available."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "User login attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/oidc/providers", "/auth/oidc/callback", "/auth/token-info" ],
          "postprocessing_hint" : "Persist the generated state token client-side (e.g. in session storage) before following the redirect.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/okta/login" : {
      "post" : {
        "summary" : "Login with Okta ID token",
        "operationId" : "AuthResource_loginWithOktaIdToken",
        "tags" : [ "authentication" ],
        "requestBody" : {
          "description" : "Okta login request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OktaLoginRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/Token"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Authenticate users using Okta ID tokens with role mapping and session creation.",
          "usage" : [ "Call after user completes Okta authentication and obtains an ID token.", "Use for Okta-specific SSO integration with custom role mapping." ],
          "response_shape" : "Token",
          "workflow_guidance" : {
            "pre_check" : "Okta configuration exists; ID token is valid and not expired; User has assigned groups",
            "post_action" : "User session created; Role mapping applied; Authentication cookies set"
          },
          "request_parameters" : [ {
            "name" : "idToken",
            "in" : "body",
            "description" : "JWT ID token from Okta authentication.",
            "required" : true,
            "example" : "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
          } ],
          "failure_modes" : [ "400 if ID token verification fails or is malformed", "500 if Okta integration is not configured" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify ID token is valid and not expired; check Okta configuration."
          }, {
            "code" : "500",
            "action" : "Configure Okta OAuth settings in application configuration."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Okta token authentication"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/okta/signInConfig", "/auth/token-info", "/auth/logout" ],
          "postprocessing_hint" : "Store access_token securely; group claims are mapped to croit roles based on configuration.",
          "idempotent" : false,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/okta/signInConfig" : {
      "get" : {
        "summary" : "Get Okta OAuth configuration",
        "operationId" : "AuthResource_getOktaCfg",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OktaOAuthConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve Okta OAuth metadata required to render the Okta login widget.",
          "usage" : [ "Call once when loading the Okta-based login page", "Refresh only if the frontend detects configuration changes" ],
          "response_shape" : "OktaOAuthConfig",
          "failure_modes" : [ "500 if Okta integration is not configured" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show a maintenance message and fall back to standard credentials."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Login bootstrap"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/auth/okta/login", "/auth/token-info" ],
          "postprocessing_hint" : "Persist issuer and audience client-side for token verification before invoking /auth/okta/login.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/auth/token-info" : {
      "get" : {
        "summary" : "Get auth info for the request bearer token.",
        "operationId" : "AuthResource_tokenInfo",
        "tags" : [ "authentication" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TokenInfoReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the current bearer token to derive username, roles and expiry.",
          "usage" : [ "Call immediately after successful login to cache session metadata", "Re-run when showing account settings to refresh expiry information" ],
          "response_shape" : "TokenInfoReply",
          "failure_modes" : [ "401 if the bearer token is missing or invalid" ],
          "error_handling" : [ {
            "code" : "401",
            "action" : "Trigger a re-login flow and clear stale session cookies."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Session inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/auth/login", "/auth/logout", "/auth/oidc/{id}/login" ],
          "postprocessing_hint" : "Persist expiry and provider IDs locally so subsequent calls are avoided.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients" : {
      "get" : {
        "summary" : "List all currently connected CephFS clients.",
        "operationId" : "CephFsListingResource_listCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephfsClientInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the active CephFS clients reported by the MDS.",
          "usage" : [ "Show currently connected clients in admin dashboards", "Refresh on demand when diagnosing stuck sessions" ],
          "response_shape" : "OptionalPaginationResponse<CephfsClientInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or sort client entries.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "400 if ceph status cannot be fetched" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Display an error banner and recommend checking Ceph health."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Client inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/clients/evict", "/stats" ],
          "postprocessing_hint" : "Highlight clients with stale sessions (zero age) before allowing eviction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/clients/evict" : {
      "post" : {
        "summary" : "Evict (kick) a connected client, the client can reconnect but must do so explicitly.",
        "operationId" : "CephFsListingResource_evictCephfsClients",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "description" : "ID of the client to evict",
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int64"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Forcefully disconnect CephFS clients",
          "usage" : [ "Evict misbehaving or stuck clients", "Force clients to reconnect after configuration changes" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "id",
            "in" : "query",
            "description" : "List of client IDs to evict",
            "required" : true,
            "example" : "[123, 456]"
          } ],
          "failure_modes" : [ "400 if trying to evict client id 0", "404 if no active MDS servers found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Client ID 0 is reserved and cannot be evicted"
          }, {
            "code" : "404",
            "action" : "Ensure CephFS has active MDS servers"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Client management"
          },
          "related_endpoints" : [ "/cephfs/clients" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/copy" : {
      "put" : {
        "summary" : "Copy a file or directory recursively.",
        "operationId" : "CephFsListingResource_copyCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Copy a file or directory recursively while preserving permissions and ownership.",
          "usage" : [ "Create backups of important directories", "Duplicate directory structures for different projects", "Copy files between different CephFS locations" ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "post_action" : "Monitor the returned ManagedTask for progress updates"
          },
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "Source file or directory path to copy from.",
            "required" : true,
            "example" : "/data/source"
          }, {
            "name" : "dstPath",
            "in" : "query",
            "description" : "Destination path where the file or directory will be copied.",
            "required" : true,
            "example" : "/data/backup"
          } ],
          "failure_modes" : [ "404 if source path does not exist", "409 if destination already exists", "500 if insufficient space or permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify source path exists before initiating copy."
          }, {
            "code" : "409",
            "action" : "Choose a different destination path or remove existing files."
          }, {
            "code" : "500",
            "action" : "Check available space and file permissions."
          } ],
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Resource intensive copy operations"
          },
          "related_endpoints" : [ "/cephfs/move", "/cephfs/delete", "/tasks" ],
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Large copy operations can consume significant storage and time"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/create-directory" : {
      "post" : {
        "summary" : "Create a new directory recursively.",
        "operationId" : "CephFsListingResource_createCephFsDirectory",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsNewDirectoryRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new directory recursively with optional pool and namespace layout configuration.",
          "usage" : [ "Create new directories for organizing CephFS data", "Set up directories with specific storage pools for performance optimization" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "request",
            "in" : "body",
            "description" : "CephFsNewDirectoryRequest containing directory path, pool and namespace.",
            "required" : true,
            "example" : "{\"dir\":\"/data/projects\",\"pool\":\"fast-pool\",\"namespace\":null}"
          } ],
          "failure_modes" : [ "400 if directory path contains '.snap' and starts with '_'", "409 if directory already exists", "400 if invalid pool or namespace specified" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate directory path and avoid reserved snapshot naming patterns."
          }, {
            "code" : "409",
            "action" : "Check if directory exists before creation or use existing directory."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Directory creation"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/layout", "/cephfs/quota" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/delete" : {
      "delete" : {
        "summary" : "Delete files or directories recursively.",
        "operationId" : "CephFsListingResource_deleteCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "deleteSnapshots",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete files or directories recursively from CephFS",
          "usage" : [ "Remove unwanted files or entire directories", "Clean up snapshots when deleteSnapshots=true" ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "List of paths to delete",
            "required" : true,
            "example" : "['/data/old-files']"
          }, {
            "name" : "deleteSnapshots",
            "in" : "query",
            "description" : "Also delete snapshots",
            "required" : false,
            "default" : "false"
          } ],
          "failure_modes" : [ "404 if path not found", "403 if insufficient permissions", "409 if directory not empty and recursive not allowed" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify path exists"
          }, {
            "code" : "403",
            "action" : "Check file permissions"
          }, {
            "code" : "409",
            "action" : "Use recursive delete for directories"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "File operations"
          },
          "related_endpoints" : [ "/cephfs/ls", "/cephfs/files" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Recursive deletion is permanent and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/download" : {
      "get" : {
        "summary" : "Download a file.",
        "operationId" : "CephFsListingResource_downloadCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate a download token for a CephFS file and stream its content.",
          "usage" : [ "Invoke when the user requests to download a file", "Do not poll; each request creates a fresh download token" ],
          "response_shape" : "DownloadableObject",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "Absolute CephFS file path to download.",
            "required" : true,
            "example" : "/data/archive.log"
          } ],
          "failure_modes" : [ "400 if the path is not a file", "403 for protected .croit folders", "400 if CephFS is not configured" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Show an error toast and prevent download for directories."
          }, {
            "code" : "403",
            "action" : "Request admin credentials before exposing protected files."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/upload" ],
          "postprocessing_hint" : "Immediately follow the returned download URL; token lifetimes are short.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files" : {
      "patch" : {
        "summary" : "Update or rename a file/directory.",
        "operationId" : "CephFsListingResource_patchCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsFileUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update file or directory metadata including path, permissions, and ownership.",
          "usage" : [ "Rename files or directories to new locations", "Change file permissions (mode) for access control", "Update ownership (uid/gid) for proper access management" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "Current absolute path of the file or directory to update.",
            "required" : true,
            "example" : "/data/oldname.txt"
          }, {
            "name" : "req",
            "in" : "body",
            "description" : "CephFsFileUpdateRequest with new path, uid, gid, and/or mode.",
            "required" : true,
            "example" : "{\"absolutePath\":\"/data/newname.txt\",\"mode\":755}"
          } ],
          "failure_modes" : [ "404 if the source path does not exist", "409 if the target path already exists during rename", "400 if invalid permissions or ownership values" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the source file exists before updating."
          }, {
            "code" : "409",
            "action" : "Choose a different target path for rename operations."
          }, {
            "code" : "400",
            "action" : "Validate permission values (0-777) and user/group IDs."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File metadata updates"
          },
          "related_endpoints" : [ "/cephfs/move", "/cephfs/files", "/cephfs/stats" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List files in a directory.",
        "operationId" : "CephFsListingResource_listCephFsFiles",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntries"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List directory entries (names only) along with directory metadata.",
          "usage" : [ "Load before rendering a CephFS directory tree", "Refresh after uploads or deletions to update the listing" ],
          "response_shape" : "CephFsDirectoryEntries",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Absolute CephFS path to list (e.g. /, /data/projects).",
            "required" : true,
            "example" : "/"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the dir parameter does not point to a directory", "403 if accessing protected .croit folders as non-admin" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Surface the error and prompt the user to select a valid directory."
          }, {
            "code" : "403",
            "action" : "Inform the user that .croit folders require admin privileges."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files-with-stats", "/cephfs/files-paginated", "/cephfs/download" ],
          "postprocessing_hint" : "Sort entries client-side and merge with stats if needed from /files-with-stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-paginated" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesPaginated",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephFsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate CephFS directory entries with full stats to avoid huge payloads.",
          "usage" : [ "Use in UIs with infinite scroll for large directories", "Request subsequent pages by adjusting pagination.after" ],
          "response_shape" : "PaginationResponse<CephFsResponse>",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Directory path to list.",
            "required" : true,
            "example" : "/data/projects"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset and filters.",
            "required" : true,
            "example" : "{\"limit\":200,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Keep limits <= 500 to avoid timeouts."
          },
          "failure_modes" : [ "400 if CephFS is not configured", "400 if dir is not a directory", "403 for protected .croit folders" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fallback to /files when pagination is not required."
          }, {
            "code" : "403",
            "action" : "Show an authorization error and disable listing."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Paginated directory browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-with-stats" ],
          "postprocessing_hint" : "Use pagination.after from response to fetch the next chunk.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/files-with-stats" : {
      "get" : {
        "summary" : "List files with all stats in a directory.",
        "description" : "Avoid calling this too often or on directories with > 10k files.",
        "operationId" : "CephFsListingResource_listCephFsFilesWithStats",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsDirectoryEntriesWithStats"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return directory entries together with full CephFS statistics for each item.",
          "usage" : [ "Use when a UI needs size, permissions or type information per entry", "Prefer /files-paginated for very large directories to avoid heavy payloads" ],
          "response_shape" : "CephFsDirectoryEntriesWithStats",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Absolute CephFS path to inspect.",
            "required" : true,
            "example" : "/data"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the target is not a directory", "403 for protected .croit folders" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Suggest fallback to root or a smaller directory."
          }, {
            "code" : "403",
            "action" : "Prompt for admin privileges when accessing .croit paths."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Heavy directory stats"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-paginated" ],
          "postprocessing_hint" : "Gracefully handle entries disappearing during traversal (nulls are skipped).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout" : {
      "put" : {
        "summary" : "Change the pool a file or directory is stored in.",
        "description" : "Files can only be changed if they are empty. Changing a directory only affects new files and subdirectories.",
        "operationId" : "CephFsListingResource_setCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS layout configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsLayout"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage pool and namespace layout for files and directories.",
          "usage" : [ "Assign directories to specific storage pools for performance optimization", "Configure namespace isolation for multi-tenant scenarios", "Migrate empty files to different storage tiers" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "File or directory path to configure layout for.",
            "required" : true,
            "example" : "/data/fast-access"
          }, {
            "name" : "layout",
            "in" : "body",
            "description" : "CephFsLayout configuration with pool and namespace settings.",
            "required" : true,
            "example" : "{\"pool\":\"ssd-pool\",\"namespace\":\"project-a\"}"
          } ],
          "failure_modes" : [ "400 if target is a symbolic link", "400 if trying to change layout of non-empty files", "404 if specified pool does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure files are empty before changing layout, or use directory layout for new files."
          }, {
            "code" : "404",
            "action" : "Verify pool name exists using /cephfs/layout/pools endpoint."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Layout configuration"
          },
          "related_endpoints" : [ "/cephfs/layout", "/cephfs/layout/pools", "/cephfs/create-directory" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the pool a file or directory is stored in.",
        "operationId" : "CephFsListingResource_getCephFsLayout",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsLayout"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect the pool and namespace layout attributes for a file or directory.",
          "usage" : [ "Call before modifying layout to display current targets", "Use during troubleshooting to confirm where data is stored" ],
          "response_shape" : "CephFsLayout",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "File or directory path to inspect.",
            "required" : true,
            "example" : "/data/logs"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured", "400 if the path is a symbolic link" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Inform the user that symbolic links are not supported and select the target directory instead."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Layout inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cephfs/layout/pools", "/cephfs/layout" ],
          "postprocessing_hint" : "Display null pools as 'default' in UI for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/layout/pools" : {
      "get" : {
        "summary" : "Get pools that are eligible as data storage location in the layout API.",
        "operationId" : "CephFsListingResource_getPoolsForCephfsLayout",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CephFS data pools that can be assigned via the layout API.",
          "usage" : [ "Populate pool dropdowns when editing directory layouts", "Refresh when filesystem topology changes" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "200 [] when CephFS has no data pools or filesystem not found" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Notify that no data pools are available and CephFS may not be configured."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Layout configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cephfs/layout", "/pools" ],
          "postprocessing_hint" : "Display pool names with human-friendly descriptions from /pools if needed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/move" : {
      "put" : {
        "summary" : "Rename a file or directory.",
        "operationId" : "CephFsListingResource_moveCephFsFile",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dstPath",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "path",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rename or move a file or directory to a new location within CephFS.",
          "usage" : [ "Rename files or directories to better organize data", "Move files between different directory structures", "Reorganize CephFS hierarchy for better management" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "path",
            "in" : "query",
            "description" : "Current absolute path of the file or directory.",
            "required" : true,
            "example" : "/data/old-location/file.txt"
          }, {
            "name" : "dstPath",
            "in" : "query",
            "description" : "New absolute path for the file or directory.",
            "required" : true,
            "example" : "/data/new-location/file.txt"
          } ],
          "failure_modes" : [ "404 if source path does not exist", "409 if destination path already exists", "403 if insufficient permissions for source or destination" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify source path exists before attempting move."
          }, {
            "code" : "409",
            "action" : "Choose a different destination path or remove existing file."
          }, {
            "code" : "403",
            "action" : "Check permissions on both source and destination directories."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "File move operations"
          },
          "related_endpoints" : [ "/cephfs/copy", "/cephfs/files", "/cephfs/delete" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/quota" : {
      "put" : {
        "summary" : "Set the quota of a directory.",
        "operationId" : "CephFsListingResource_setCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "description" : "CephFS quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsQuota"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage quotas for CephFS directories to control space and file count usage.",
          "usage" : [ "Set byte limits to prevent directories from consuming too much storage", "Configure file count limits to prevent excessive small file creation", "Remove quotas by setting values to null or zero" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Directory path to configure quota for (cannot be root directory).",
            "required" : true,
            "example" : "/data/projects"
          }, {
            "name" : "quota",
            "in" : "body",
            "description" : "CephFsQuota configuration with maxBytes and maxFiles limits.",
            "required" : true,
            "example" : "{\"maxBytes\":1073741824,\"maxFiles\":10000}"
          } ],
          "failure_modes" : [ "400 if target is not a directory", "400 if trying to set quota on root directory (/)", "400 if negative quota values provided" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure target is a directory and not the root filesystem."
          }, {
            "code" : "400",
            "action" : "Use positive values for quotas or null/zero to disable."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Quota configuration"
          },
          "related_endpoints" : [ "/cephfs/quota", "/cephfs/files", "/cephfs/create-directory" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the quota of a directory.",
        "operationId" : "CephFsListingResource_getCephFsQuota",
        "tags" : [ "cephfs" ],
        "parameters" : [ {
          "name" : "dir",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephFsQuota"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch byte and file quotas applied to a CephFS directory.",
          "usage" : [ "Display current quota before allowing edits", "Check quota status while troubleshooting capacity issues" ],
          "response_shape" : "CephFsQuota",
          "request_parameters" : [ {
            "name" : "dir",
            "in" : "query",
            "description" : "Directory path to inspect.",
            "required" : true,
            "example" : "/home/project"
          } ],
          "failure_modes" : [ "400 if the target is not a directory", "400 if CephFS is not configured" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Suggest selecting a directory (not the filesystem root when forbidden)."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Quota inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cephfs/quota", "/cephfs/files" ],
          "postprocessing_hint" : "Display null values as 'unlimited'.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cephfs/stats" : {
      "post" : {
        "summary" : "Get stats for a list of files.",
        "operationId" : "CephFsListingResource_listCephfsFiles",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "description" : "Absolute paths of the requested files.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch CephFS metadata for a provided list of absolute paths.",
          "usage" : [ "Batch resolve file metadata before rendering mixed selections in the UI.", "Validate existence of specific paths during automation scripts." ],
          "response_shape" : "array<CephFsResponse>",
          "request_parameters" : [ {
            "name" : "paths",
            "in" : "body",
            "description" : "Absolute CephFS paths to inspect.",
            "required" : true,
            "example" : "[\"/data/project/file.txt\"]"
          } ],
          "failure_modes" : [ "200 entries with null stats when a path does not exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Highlight rows with null stats to indicate missing files."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Ad-hoc metadata lookups"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cephfs/files", "/cephfs/files-with-stats" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cephfs/upload" : {
      "put" : {
        "summary" : "Upload a file.",
        "operationId" : "CephFsListingResource_uploadCephFsFile",
        "tags" : [ "cephfs" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsUploadRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Upload a file to CephFS using multipart form data.",
          "usage" : [ "Upload files from client applications to CephFS storage", "Restore backed up files to CephFS", "Transfer files from external sources into the cluster" ],
          "response_shape" : "Response (201 CREATED)",
          "request_parameters" : [ {
            "name" : "file",
            "in" : "form",
            "description" : "File content as InputStream from multipart form.",
            "required" : true,
            "example" : "<binary file data>"
          }, {
            "name" : "path",
            "in" : "form",
            "description" : "Absolute CephFS path where the file will be stored.",
            "required" : true,
            "example" : "/data/uploads/document.pdf"
          } ],
          "failure_modes" : [ "409 if file already exists at the specified path", "500 if upload fails due to storage issues", "413 if file size exceeds limits" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Choose a different file path or remove existing file."
          }, {
            "code" : "500",
            "action" : "Check available storage space and CephFS health."
          }, {
            "code" : "413",
            "action" : "Split large files or increase upload limits."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "File upload operations"
          },
          "related_endpoints" : [ "/cephfs/download", "/cephfs/files", "/cephfs/delete" ],
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests" : {
      "get" : {
        "summary" : "Get all pending change requests.",
        "operationId" : "ChangeRequestResource_getPendingChangeRequests",
        "tags" : [ "change-requests" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ChangeRequest"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all pending change requests awaiting admin approval for CRUSH map modifications.",
          "usage" : [ "Call to review pending infrastructure changes before approving or rejecting them.", "Use to monitor the change approval workflow and track what modifications are queued." ],
          "response_shape" : "List<ChangeRequest>",
          "failure_modes" : [ "200 with empty list if no pending changes exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no pending changes; users can make CRUSH map modifications to generate new requests."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Change request monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/change-requests/{id}/approve", "/change-requests/{id}/reject", "/crush" ],
          "postprocessing_hint" : "Display change details with affected objects; highlight requests by age and impact; show who created each request.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/change-requests/{id}/approve" : {
      "post" : {
        "summary" : "Approve a pending change request.",
        "operationId" : "ChangeRequestResource_approveChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Approve a pending change request to execute CRUSH map modifications with proper validation and safety checks.",
          "usage" : [ "Call after reviewing change request details to execute approved CRUSH map changes.", "Use when ready to apply storage layout modifications that have been validated." ],
          "response_shape" : "ManagedTask (or null if no CRUSH changes)",
          "workflow_guidance" : {
            "pre_check" : "Change request exists; No concurrent CRUSH operations; OSD creation lock available",
            "post_action" : "CRUSH map updated; Change request processed; Task advisor validates changes; Hooks executed"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Change request ID to approve and execute.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if change request ID does not exist", "409 if CRUSH map is currently being updated by another operation", "500 if OSD creation lock cannot be acquired during execution" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify change request exists and has not been processed already."
          }, {
            "code" : "409",
            "action" : "Wait for current CRUSH map operations to complete before retrying approval."
          }, {
            "code" : "500",
            "action" : "Check for concurrent OSD operations; retry after OSD operations complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "CRUSH map modifications"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/change-requests", "/change-requests/{id}/reject", "/crush" ],
          "postprocessing_hint" : "Monitor task progress for CRUSH map updates; default CRUSH rules may be created automatically; task advisor checks map validity.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Approving change requests will modify the CRUSH map and potentially affect data placement"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/change-requests/{id}/reject" : {
      "post" : {
        "summary" : "Reject a pending change request.",
        "operationId" : "ChangeRequestResource_rejectChange",
        "tags" : [ "change-requests" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reject a pending change request to prevent execution of CRUSH map modifications.",
          "usage" : [ "Call when change request review determines that proposed changes should not be applied.", "Use to cancel change requests that are unsafe or no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Change request exists; Not already processed; Admin review completed",
            "post_action" : "Change request rejected; No CRUSH map changes applied; Request removed from pending list"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Change request ID to reject and cancel.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if change request ID does not exist or has already been processed" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify change request exists and has not been approved or rejected already."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Change request management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/change-requests", "/change-requests/{id}/approve" ],
          "postprocessing_hint" : "Rejection is immediate; no CRUSH map changes are applied; audit log records the rejection decision.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Rejecting change requests will permanently cancel proposed CRUSH map modifications"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_createCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bootstrap a brand-new Ceph cluster using the selected MON disk and IP address.",
          "usage" : [ "Invoke immediately after fetching candidates from GET /cluster/create/mons.", "Monitor the returned ManagedTask via /tasks/{id} until the bootstrap completes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "diskId",
            "in" : "body",
            "description" : "Identifier of the MON-formatted disk (from GET /cluster/create/mons)",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "serverId",
            "in" : "body",
            "description" : "Server hosting the MON disk",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Management IP address to bind the initial MON",
            "required" : true,
            "example" : "10.0.0.12"
          }, {
            "name" : "ipv6",
            "in" : "body",
            "description" : "Set true when the provided IP is IPv6",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the cluster is already configured", "400 if the selected disk is missing or not MON-capable", "400 if the IP does not match the ipv6 flag" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate disk/server eligibility via GET /cluster/create/mons and ensure the IP belongs to the server before retrying."
          }, {
            "code" : "409",
            "action" : "If concurrent bootstrap is in progress, wait for the existing ManagedTask to finish."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Cluster bootstrap is a one-time operation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/maintenance/migrations" ],
          "postprocessing_hint" : "Persist the returned task id and stream updates from /tasks/{id} until state=FINISHED.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bootstrapping the cluster is destructive if a cluster already exists."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/create/mons" : {
      "get" : {
        "summary" : "List all servers that have a MON disk.",
        "operationId" : "ClusterResource_getMonCandidates",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/InitialMonServer"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List servers eligible to host the initial Ceph MON during cluster bootstrap.",
          "usage" : [ "Call prior to POST /cluster to populate the MON selection UI.", "Refresh after wiping disks or changing roles to see newly eligible servers." ],
          "response_shape" : "array<InitialMonServer>",
          "failure_modes" : [ "200 [] when no disks with role=mon are detected" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Advise the operator to provision mon-formatted disks or rerun disk discovery."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Cluster bootstrap planning"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster", "/disks/create-osds" ],
          "postprocessing_hint" : "Sort by hostname and display both IPv4/IPv6 entries so the installer can choose the correct address.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/deploy" : {
      "post" : {
        "summary" : "Deploys the cluster with {diskId} as the first MON.",
        "operationId" : "ClusterResource_deployCluster",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterDeployRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy the initial Ceph monitors using multiple preselected MON disks.",
          "usage" : [ "Call once during bootstrap after validating candidates from GET /cluster/create/mons.", "Track the returned ManagedTask via /tasks/{id} to follow wiping and MON provisioning progress." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "mons[].diskId",
            "in" : "body",
            "description" : "Disk identifier for each MON you want to create.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "mons[].serverId",
            "in" : "body",
            "description" : "Server hosting the disk.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "mons[].ip",
            "in" : "body",
            "description" : "IP address for the MON daemon on that server.",
            "required" : true,
            "example" : "10.0.0.15"
          }, {
            "name" : "mons[].ipv6",
            "in" : "body",
            "description" : "Set true when ip is IPv6.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the cluster is already configured", "400 if no monitors are supplied", "400 if validation detects disks that cannot host a MON" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Re-run GET /cluster/create/mons and adjust the selection; wipe flagged disks when prompted."
          }, {
            "code" : "409",
            "action" : "If another deployment is running, monitor the existing ManagedTask instead of retrying immediately."
          } ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 86400,
            "note" : "Initial deployment should run once"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/create/mons", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Store the returned task id and display wiping/installation progress until done.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deploying multiple monitors may wipe disks that contain existing data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/releases" : {
      "get" : {
        "summary" : "Get running Ceph releases",
        "operationId" : "ClusterResource_clusterReleases",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephReleases"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the Ceph release distribution currently running across cluster daemons.",
          "usage" : [ "Call before triggering upgrades to confirm the cluster is homogeneous.", "Poll during migrations to track remaining hosts still on older releases." ],
          "response_shape" : "CephReleases",
          "failure_modes" : [ "500 if Ceph rejected the versions request or returned malformed data" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking Ceph mgr health; include ceph versions stderr in diagnostics if the error persists."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Upgrade monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status", "/maintenance/migrations" ],
          "postprocessing_hint" : "Highlight releases other than the target to communicate remaining upgrade tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status" : {
      "get" : {
        "summary" : "Get croit cluster status",
        "operationId" : "ClusterResource_clusterStatus",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph and croit service health snapshot.",
          "usage" : [ "Call before running Ceph-altering workflows to ensure the cluster is healthy", "Refresh every 10 seconds when rendering live dashboards" ],
          "response_shape" : "ClusterStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure Ceph is configured; if not, expect cephStatus to be null.",
            "post_action" : "Surface warnings or degraded services in the UI."
          },
          "failure_modes" : [ "503 if the croit backend cache is unavailable", "200 with cephStatus=null when Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry with exponential backoff (up to 30s) before alerting operations."
          }, {
            "code" : "200",
            "action" : "Display maintenance banner if cephStatus is null."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared across dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 10,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status/detail", "/status" ],
          "postprocessing_hint" : "Cache the response for <=5s client-side to avoid excess load.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/detail" : {
      "get" : {
        "summary" : "Get Ceph health detail.",
        "operationId" : "ClusterResource_clusterHealthDetail",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephStatusHealth"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect detailed Ceph health checks including summaries and explanations.",
          "usage" : [ "Call after detecting warnings in GET /cluster/status", "Use sparingly for drill-down views to reduce payload size" ],
          "response_shape" : "CephHealthDetail",
          "failure_modes" : [ "503 if the Ceph manager is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry up to 3 times with 5 second backoff; inform the user if still unavailable."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Detail view heavy payload"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/mute/{check}" ],
          "postprocessing_hint" : "Limit the number of displayed checks and truncate long detail strings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history" : {
      "get" : {
        "summary" : "List available past cluster state timestamps.",
        "operationId" : "ClusterResource_clusterStatusHistoryEntries",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int64"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available historical snapshots for later retrieval.",
          "usage" : [ "Fetch once to populate a history selector", "Choose the latest timestamp to investigate recent incidents" ],
          "response_shape" : "array<long>",
          "failure_modes" : [ "200 [] when historical cache is empty" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show message that no history is available yet."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Used sparingly when opening timelines"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history/{timestamp}" ],
          "postprocessing_hint" : "Sort timestamps descending before presenting to users.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/history/{timestamp}" : {
      "get" : {
        "summary" : "Get cluster state as close as possible to a specific timestamp.",
        "operationId" : "ClusterResource_getClusterPastState",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "description" : "Timestamp as returned by /cluster/status/history",
          "name" : "timestamp",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ClusterStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a cached cluster status snapshot close to the requested time.",
          "usage" : [ "Call after selecting a timestamp from GET /cluster/status/history", "Prefer timestamps not older than 15 minutes for accurate diagnostics" ],
          "response_shape" : "ClusterStatus",
          "path_parameters" : [ {
            "name" : "timestamp",
            "in" : "path",
            "description" : "Epoch seconds returned by GET /cluster/status/history",
            "required" : true,
            "example" : "1700000000"
          } ],
          "failure_modes" : [ "404 if no cached status exists for the requested timestamp", "200 with cephStatus=null when Ceph was unreachable at that time" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fallback to the closest earlier timestamp or notify the user."
          }, {
            "code" : "200",
            "action" : "Warn the user that Ceph data was unavailable at that time."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Timeline exploration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/cluster/status/history", "/cluster/status/detail" ],
          "postprocessing_hint" : "Indicate the actual snapshot timestamp compared to the requested value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/mute/{check}" : {
      "post" : {
        "summary" : "Mute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckMute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HealthCheckMuteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Temporarily mute a specific Ceph health check to suppress alerts.",
          "usage" : [ "Call immediately before acknowledging a known issue to keep dashboards quiet.", "Specify ttl when scheduling an automatic unmute; otherwise rely on a manual POST /cluster/status/unmute/{check}." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ttl",
            "in" : "body",
            "description" : "Seconds until the mute automatically expires (0 keeps default behaviour).",
            "required" : false,
            "example" : "3600"
          }, {
            "name" : "sticky",
            "in" : "body",
            "description" : "true to leave the check muted even after Ceph reports it resolved.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check identifier (e.g. OSD_DOWN).",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "400 if ttl is negative", "404 if the health check name is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Clamp ttl to a positive value or set it to 0 to rely on Ceph defaults."
          }, {
            "code" : "404",
            "action" : "List active checks from GET /cluster/status to validate the identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Alert suppression"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status", "/cluster/status/unmute/{check}" ],
          "postprocessing_hint" : "Immediately refresh GET /cluster/status to reflect the muted check.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/cluster/status/nagios" : {
      "get" : {
        "summary" : "Get overall Ceph health status formatted for Nagios.",
        "operationId" : "ClusterResource_clusterHealthSummaryForNagios",
        "tags" : [ "cluster" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose Ceph health in a Nagios-compatible single line format.",
          "usage" : [ "Integrate with external Nagios/icinga style monitors", "Use when plain text status codes are required" ],
          "response_shape" : "text/plain",
          "failure_modes" : [ "200 CEPH CRITICAL - failed to get cluster status when cache missing" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat message containing 'failed to get cluster status' as CRITICAL in the monitoring system."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "External monitoring poll"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios/{check}" ],
          "postprocessing_hint" : "Use first token to determine Nagios state before logging.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/nagios/{check}" : {
      "get" : {
        "summary" : "Get a specific Ceph health check in Nagios text format.",
        "operationId" : "ClusterResource_clusterHealthForNagios",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a Nagios-compatible status line for a specific Ceph health check code.",
          "usage" : [ "Configure Nagios/Icinga service checks for individual Ceph alerts", "Provide targeted status for dashboards that focus on specific health codes" ],
          "response_shape" : "text/plain",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Ceph health check code, e.g. SLOW_OPS",
            "required" : true,
            "example" : "SLOW_OPS"
          } ],
          "failure_modes" : [ "200 <code> UNKNOWN - cannot get ceph status when cache missing" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Interpret UNKNOWN as CRITICAL in monitoring and retry after 30s."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Per-check polling"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster/status/nagios" ],
          "postprocessing_hint" : "Split first word to extract Nagios state before piping to external tools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/cluster/status/unmute/{check}" : {
      "post" : {
        "summary" : "Unmute a Ceph health check",
        "operationId" : "ClusterResource_clusterHealthCheckUnmute",
        "tags" : [ "cluster" ],
        "parameters" : [ {
          "name" : "check",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Re-enable a previously muted Ceph health check.",
          "usage" : [ "Call after resolving the underlying issue so alerts resume.", "Use to cancel a sticky mute created via POST /cluster/status/mute/{check}." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "check",
            "in" : "path",
            "description" : "Health check identifier to unmute.",
            "required" : true,
            "example" : "OSDMAP_FLAGS"
          } ],
          "failure_modes" : [ "404 if the check is not known" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the check is currently muted by inspecting GET /cluster/status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Alert management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/cluster/status/mute/{check}", "/cluster/status" ],
          "postprocessing_hint" : "Trigger a status refresh to confirm the check is now active.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config" : {
      "put" : {
        "summary" : "Set Ceph configuration option",
        "operationId" : "CephConfigResource_setCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update Ceph cluster configuration settings or croit-specific application settings.",
          "usage" : [ "Call when tuning cluster performance parameters or changing service behavior.", "Use to apply configuration changes that require cluster-wide propagation." ],
          "response_shape" : "ManagedThreadTask or null",
          "workflow_guidance" : {
            "pre_check" : "Configuration option exists; Value type matches expected format; Cluster is healthy",
            "post_action" : "Configuration applied cluster-wide; Services restarted if needed; Warning shown for RGW frontend conflicts"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Configuration option name (underscores converted to spaces).",
            "required" : true,
            "example" : "osd_pool_default_size"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "New value for the configuration option.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "301 if trying to change RGW SSL certificate (use /rgw-ssl-cert instead)", "400 if configuration option name or value is invalid", "500 if configuration update fails" ],
          "error_handling" : [ {
            "code" : "301",
            "action" : "Use PUT /config/rgw-ssl-cert for RGW SSL certificate changes."
          }, {
            "code" : "400",
            "action" : "Verify configuration option exists and value type is correct."
          }, {
            "code" : "500",
            "action" : "Check Ceph cluster health and mon service connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Configuration changes"
          },
          "related_endpoints" : [ "/config", "/config/available", "/config/rgw-ssl-cert" ],
          "postprocessing_hint" : "For RGW frontends config, warn about potential port conflicts with existing RGW services that may cause S3 downtime.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all ceph configs.",
        "operationId" : "CephConfigResource_getCephConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph configuration options that have been modified from their defaults.",
          "usage" : [ "Call when reviewing current cluster configuration settings.", "Use before making configuration changes to understand current state." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters to limit results.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "500 if configuration cannot be retrieved from Ceph cluster" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and mon service status."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Configuration inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config/available", "/config/modified" ],
          "postprocessing_hint" : "Display modified values prominently; group by service type for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete Ceph configuration option",
        "operationId" : "CephConfigResource_deleteCephOption",
        "tags" : [ "config" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephConfDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph configuration option to revert to default value",
          "usage" : [ "Remove custom configuration overrides", "Revert settings to Ceph defaults" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Configuration option name to delete",
            "required" : true,
            "example" : "osd_pool_default_size"
          } ],
          "failure_modes" : [ "404 if configuration option doesn't exist", "400 if trying to delete a required option" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify configuration option exists"
          }, {
            "code" : "400",
            "action" : "Some options cannot be deleted"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Config management"
          },
          "related_endpoints" : [ "/config", "/config (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing config options may affect cluster behavior"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates" : {
      "get" : {
        "summary" : "List of all templates.",
        "operationId" : "TemplateResource_getTemplates",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseConfigTemplateResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available configuration templates for system files like GRUB, network setup, and disk configuration.",
          "usage" : [ "Call when loading the template management UI to show available and current templates.", "Use to understand which templates are active and what alternatives are available." ],
          "response_shape" : "OptionalPaginationResponse<ConfigTemplateResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters for template list.",
            "required" : false,
            "example" : "{\"limit\":10}"
          } ],
          "failure_modes" : [ "200 with empty list if no templates are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates no template system is configured."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Template configuration access"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/config-templates/templates/{template}", "/config-templates/helpers" ],
          "postprocessing_hint" : "Display current template prominently; group available templates by category for easy selection.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/helpers" : {
      "get" : {
        "summary" : "Get template helpers",
        "operationId" : "TemplateResource_getHelpers",
        "tags" : [ "config-templates" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available handlebars helper functions for use in custom configuration templates.",
          "usage" : [ "Call when building template editors to show available helper functions.", "Use to understand what processing functions are available for template variables." ],
          "response_shape" : "map<string,string>",
          "failure_modes" : [ "200 with empty map if no helpers are registered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates no custom helpers are available; only basic handlebars syntax is supported."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Template helper discovery"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/config-templates", "/config-templates/templates/{template}/variables" ],
          "postprocessing_hint" : "Use helpers in handlebars syntax like {{helper variable}} when building custom templates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config-templates/templates/{template}" : {
      "put" : {
        "summary" : "Set configuration template",
        "operationId" : "TemplateResource_setTemplate",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Template configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ConfigTemplateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a system configuration template and deploy it across all affected servers.",
          "usage" : [ "Call when customizing GRUB configuration, network setup, or disk templates.", "Use to switch between predefined templates or deploy custom configurations." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Template syntax is valid; Servers are accessible; GRUB/network changes confirmed",
            "post_action" : "Template deployed to all servers; GRUB reconfigured if applicable; Servers may require reboot for changes to take effect"
          },
          "request_parameters" : [ {
            "name" : "predefinedTemplate",
            "in" : "body",
            "description" : "Name of a built-in template to use (mutually exclusive with customTemplate).",
            "required" : false,
            "example" : "default-grub"
          }, {
            "name" : "customTemplate",
            "in" : "body",
            "description" : "Custom template content to deploy (mutually exclusive with predefinedTemplate).",
            "required" : false,
            "example" : "custom handlebars template"
          } ],
          "path_parameters" : [ {
            "name" : "template",
            "in" : "path",
            "description" : "Template identifier (e.g., 'grub-config', 'network-setup', 'cmdline-disk').",
            "required" : true,
            "example" : "grub-config"
          } ],
          "failure_modes" : [ "400 if both or neither predefinedTemplate and customTemplate are provided", "404 if the template identifier doesn't exist", "500 if template deployment fails on any server" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide exactly one of predefinedTemplate or customTemplate in the request."
          }, {
            "code" : "404",
            "action" : "Verify template name with GET /config-templates before attempting to update."
          }, {
            "code" : "500",
            "action" : "Check server connectivity and template syntax; some changes may require manual intervention on failed servers."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "System template updates"
          },
          "related_endpoints" : [ "/config-templates", "/config-templates/templates/{template}/variables" ],
          "postprocessing_hint" : "Monitor task progress carefully; test server boot behavior after GRUB or kernel changes; rollback capability may require manual intervention.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Template changes affect all servers and may cause boot failures if misconfigured"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/config-templates/templates/{template}/variables" : {
      "get" : {
        "summary" : "Get template variables",
        "operationId" : "TemplateResource_getVariables",
        "tags" : [ "config-templates" ],
        "parameters" : [ {
          "name" : "template",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TemplateObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available template variables and context data for a specific configuration template.",
          "usage" : [ "Call when building template editors to show available variables for substitution.", "Use to validate custom templates against available context data." ],
          "response_shape" : "TemplateObject",
          "path_parameters" : [ {
            "name" : "template",
            "in" : "path",
            "description" : "Template identifier to get variables for.",
            "required" : true,
            "example" : "grub-config"
          } ],
          "failure_modes" : [ "404 if the template doesn't exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify template name exists with GET /config-templates before requesting variables."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Template variable access"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/config-templates", "/config-templates/helpers" ],
          "postprocessing_hint" : "Use variable names in handlebars syntax ({{variable}}) when building custom templates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/available" : {
      "get" : {
        "summary" : "Get available Ceph configuration options",
        "operationId" : "CephConfigResource_getAvailableOptions",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/CephConfigResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all available Ceph configuration options including current values, defaults, and metadata.",
          "usage" : [ "Call when building configuration management UI to show all possible settings.", "Use before making configuration changes to understand available options and their defaults." ],
          "response_shape" : "Map<String, CephConfigResponse>",
          "failure_modes" : [ "500 if Ceph configuration cannot be retrieved" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and mon service status."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Configuration metadata retrieval"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config", "/config/availableAsList", "/config/modified" ],
          "postprocessing_hint" : "Exclude DEV-level options from UI; group by category; highlight non-default values.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/availableAsList" : {
      "get" : {
        "summary" : "List available ceph configs.",
        "operationId" : "CephConfigResource_getAvailableOptionsAsList",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all available Ceph configuration options as a paginated list, combining configured and unconfigured options.",
          "usage" : [ "Call when populating configuration dropdown lists or search interfaces.", "Use for comprehensive configuration management where all options need to be browsable." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "request_parameters" : [ {
            "name" : "settingFilter",
            "in" : "query",
            "description" : "Filter to show only 'croit' or 'ceph' settings.",
            "required" : false,
            "example" : "ceph"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Pagination parameters for large configuration lists.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "500 if configuration metadata cannot be retrieved" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and configuration service availability."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "Configuration list retrieval"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config/available", "/config/modified" ],
          "postprocessing_hint" : "Sort by modified status first; exclude DEV-level options unless explicitly requested; provide search functionality.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/client" : {
      "get" : {
        "summary" : "Download client Ceph configuration file",
        "operationId" : "CephConfigResource_getConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate and download a client-specific Ceph configuration file for external access.",
          "usage" : [ "Call when setting up external Ceph clients that need cluster access.", "Use to provide configuration files for applications connecting to the Ceph cluster." ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; Authentication configured properly",
            "post_action" : "Client configuration file generated; Contains only client-relevant settings"
          },
          "failure_modes" : [ "500 if configuration file generation fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and configuration generation service."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Client configuration downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/download/full", "/config" ],
          "postprocessing_hint" : "Downloaded file should be renamed to ceph.conf and placed in /etc/ceph/ on client systems.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/download/full" : {
      "get" : {
        "summary" : "Download full Ceph configuration file",
        "operationId" : "CephConfigResource_getFullConfigFile",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate and download the complete Ceph cluster configuration file including all settings.",
          "usage" : [ "Call when backing up cluster configuration or preparing for cluster migration.", "Use for troubleshooting or when full configuration details are needed for support." ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; All configuration sources available",
            "post_action" : "Complete configuration file generated; Contains all cluster and service settings"
          },
          "failure_modes" : [ "500 if configuration file generation fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and configuration service availability."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 300,
            "note" : "Full configuration downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/download/client", "/config" ],
          "postprocessing_hint" : "Contains sensitive configuration details; secure appropriately when used for backups or migrations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/modified" : {
      "get" : {
        "summary" : "List modified ceph configs.",
        "operationId" : "CephConfigResource_getCephOrCroitConfig",
        "tags" : [ "config" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "settingFilter",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List only Ceph configuration options that have been modified from their default values.",
          "usage" : [ "Call when auditing configuration changes or identifying customized settings.", "Use to understand what has been tuned compared to default Ceph installation." ],
          "response_shape" : "OptionalPaginationResponse<CephConfigResponse>",
          "request_parameters" : [ {
            "name" : "settingFilter",
            "in" : "query",
            "description" : "Filter to show only 'croit' or 'ceph' settings.",
            "required" : false,
            "example" : "ceph"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters.",
            "required" : false,
            "example" : "{\"limit\":20}"
          } ],
          "failure_modes" : [ "200 with empty list if no configurations have been modified" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates cluster is using all default settings."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Modified configuration inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/config", "/config/available" ],
          "postprocessing_hint" : "Display value changes prominently; show impact level for each modified setting.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/config/rgw-ssl-cert" : {
      "put" : {
        "summary" : "Set RGW SSL certificate",
        "operationId" : "CephConfigResource_setRgwSslCert",
        "tags" : [ "config" ],
        "requestBody" : {
          "description" : "RGW SSL certificate configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSslCertChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW SSL certificate and perform rolling restart of RGW services to apply changes.",
          "usage" : [ "Call when replacing expired SSL certificates for S3/Swift endpoints.", "Use to deploy new certificates from a certificate authority or enable custom SSL." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Certificate format valid; SSH access to RGW servers; RGW services healthy",
            "post_action" : "Certificate uploaded to /etc/ceph/rgwcert.pem on all RGW servers; RGW services restarted; New certificate active"
          },
          "request_parameters" : [ {
            "name" : "certificate",
            "in" : "body",
            "description" : "PEM format certificate containing both PRIVATE KEY and CERTIFICATE sections (null generates new cert).",
            "required" : false,
            "example" : "-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----"
          }, {
            "name" : "doRollingRestart",
            "in" : "body",
            "description" : "Whether to perform rolling restart of RGW services after certificate update.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if certificate format is invalid (missing PRIVATE KEY or CERTIFICATE)", "500 if certificate upload to servers fails or rolling restart fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure certificate contains both PRIVATE KEY and CERTIFICATE sections in PEM format."
          }, {
            "code" : "500",
            "action" : "Check SSH connectivity to RGW servers and verify RGW service health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "SSL certificate updates"
          },
          "related_endpoints" : [ "/config/rgw-ssl-cert", "/services" ],
          "postprocessing_hint" : "Verify SSL endpoints work with new certificate; rolling restart prevents S3/Swift downtime during certificate deployment.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW SSL certificate",
        "operationId" : "CephConfigResource_getRgwSslCert",
        "tags" : [ "config" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current RGW SSL certificate content for inspection or backup.",
          "usage" : [ "Call when auditing SSL certificate configuration for S3/Swift endpoints.", "Use to backup current certificate before updating to a new one." ],
          "response_shape" : "String",
          "failure_modes" : [ "200 with empty string if no custom certificate is configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates default generated certificate is in use."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Certificate inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/config/rgw-ssl-cert" ],
          "postprocessing_hint" : "Parse certificate to extract expiration date and issuer for certificate management.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies" : {
      "get" : {
        "summary" : "List croit app dependencies.",
        "operationId" : "CroitAppResource_getAllDependencies",
        "tags" : [ "croit" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCroitDependency"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all third-party dependencies used by the croit application with their licenses and legal information.",
          "usage" : [ "Call when preparing compliance reports or auditing software licenses for legal requirements.", "Use to understand the dependency stack and licensing obligations for croit deployments." ],
          "response_shape" : "PaginationResponse<CroitDependency>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination request with filtering and sorting capabilities.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"license\":{\"_like\":\"%MIT%\"}}]}"
          } ],
          "failure_modes" : [ "500 if dependency file cannot be parsed or is corrupted" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Dependency parsing failed; contact croit support as this indicates application packaging issues."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dependency information queries"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/croit/dependencies/cyclonedx" ],
          "postprocessing_hint" : "Group dependencies by license type; highlight license obligations; show dependency counts per license category.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/croit/dependencies/cyclonedx" : {
      "get" : {
        "summary" : "Download croit app dependencies as CycloneDX SBOM.",
        "operationId" : "CroitAppResource_cyclonedx",
        "tags" : [ "croit" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the complete Software Bill of Materials (SBOM) in CycloneDX format for compliance and security scanning.",
          "usage" : [ "Call when integrating with security scanning tools that require CycloneDX SBOM format.", "Use for automated compliance workflows or vulnerability management systems." ],
          "response_shape" : "DownloadableObject (JSON file)",
          "failure_modes" : [ "500 if SBOM file is missing or corrupted in application resources" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "SBOM file unavailable; contact croit support as this indicates application packaging issues."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "SBOM downloads"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/croit/dependencies" ],
          "postprocessing_hint" : "Save as bom.cyclonedx.json; use with security scanning tools like OWASP Dependency-Check or Snyk.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush" : {
      "post" : {
        "summary" : "Update the current CRUSH map.",
        "operationId" : "CrushResource_setCrushMap",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "CRUSH map update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CrushTree"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ChangeRequest"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Submit CRUSH map topology changes as a change request for review and approval before execution.",
          "usage" : [ "Use when restructuring cluster topology, moving OSDs between buckets, or changing weights.", "Call after planning placement changes to create a reviewable change request." ],
          "response_shape" : "ChangeRequest",
          "request_parameters" : [ {
            "name" : "tree",
            "in" : "body",
            "description" : "Complete CRUSH tree structure with desired bucket hierarchy and OSD assignments.",
            "required" : true,
            "example" : "{\"nodes\": [...], \"buckets\": [...]}"
          } ],
          "failure_modes" : [ "400 if CRUSH tree structure is invalid or inconsistent", "500 if change request creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate CRUSH tree structure; ensure all OSDs are properly assigned and bucket hierarchy is consistent."
          }, {
            "code" : "500",
            "action" : "Check change request system health; retry with simplified topology changes."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "CRUSH map modifications"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush", "/change-requests", "/crush/rules" ],
          "postprocessing_hint" : "Review change request details carefully; CRUSH changes may cause data rebalancing; monitor cluster health during execution.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "CRUSH map changes can trigger significant data movement and affect cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current CRUSH map.",
        "operationId" : "CrushResource_getCrushMap",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CrushTree"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Get complete list of OSDs with their status and location - PRIMARY endpoint for OSD inventory and topology.",
          "usage" : [ "Get complete list of OSDs with their status and location.", "Primary endpoint for OSD inventory and topology.", "Call before planning placement rule changes or visualising data distribution.", "Refresh after running ceph osd crush set commands to verify topology updates." ],
          "response_shape" : "CrushTree",
          "request_parameters" : [ {
            "name" : "crush-tree-extraction",
            "in" : "response-processing",
            "description" : "CRUSH map contains hierarchical OSD data. Extract OSDs from tree.nodes array. Each OSD node has: id (OSD ID), status (up/down/destroyed), weight (capacity), host (parent bucket), device_class (ssd/hdd/nvme). Filter nodes where type='osd' to get all OSDs.",
            "required" : false,
            "example" : "tree.nodes.filter(n => n.type === 'osd')"
          } ],
          "failure_modes" : [ "500 if the Ceph cluster rejects the osd tree command" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking manager health; include Ceph stderr in troubleshooting notes."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "OSD listing and CRUSH inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/disks", "/crush/rules", "/disks/create-osds", "/pools" ],
          "postprocessing_hint" : "PRIMARY OSD listing endpoint. Extract OSDs from tree.nodes where type='osd'. Summarize weight totals per bucket and highlight destroyed OSDs for operators. Group OSDs by host/rack for topology visualization.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/destroyed-osd-ids" : {
      "get" : {
        "summary" : "Get list of destroyed OSD IDs",
        "operationId" : "CrushResource_getDestroyedOsdIds",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DestroyedOsdIds"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List OSDs marked as destroyed to identify failed storage devices requiring replacement.",
          "usage" : [ "Call during maintenance planning to identify hardware failures needing attention.", "Use before OSD cleanup operations to track which devices were previously failed." ],
          "response_shape" : "DestroyedOsdIds",
          "failure_modes" : [ "200 with empty list if no OSDs are destroyed or Ceph query fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list may indicate no destroyed OSDs or Ceph connectivity issues; check cluster health."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Destroyed OSD tracking"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/disks", "/maintenance" ],
          "postprocessing_hint" : "Group destroyed OSDs by host; highlight OSDs ready for physical replacement or purge operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/ec-profiles" : {
      "get" : {
        "summary" : "Get all EC profiles.",
        "operationId" : "CrushResource_getEcProfiles",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/ErasureCodeProfileDump"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve erasure coding profiles with their data/parity configurations for pool planning.",
          "usage" : [ "Call when creating EC pools to select appropriate data protection levels.", "Use to audit existing EC configurations and plan capacity requirements." ],
          "response_shape" : "Map<String, ErasureCodeProfileDump>",
          "failure_modes" : [ "500 if Ceph manager cannot retrieve EC profile information" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Verify Ceph manager health and retry; check ceph osd erasure-code-profile ls manually."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "EC profile queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools", "/crush/rules" ],
          "postprocessing_hint" : "Display k+m ratios prominently; show storage efficiency and minimum cluster size for each profile.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/osd/{osdId}/metadata" : {
      "get" : {
        "summary" : "Retrieve OSD metadata, resulting JSON contains runtime information about the OSD and varies by Ceph version.",
        "operationId" : "CrushResource_getOsdMetaData",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch Ceph-reported metadata for a specific OSD (host, bucket, state, etc.).",
          "usage" : [ "Inspect placement and attributes before migrating or removing an OSD.", "Verify metadata differences after ceph osd metadata commands or crush map edits." ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if the OSD id is unknown", "500 if Ceph rejects the metadata command" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /crush to confirm active OSD ids before retrying."
          }, {
            "code" : "500",
            "action" : "Retry after verifying mgr/osd availability; include command stderr for troubleshooting."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Metadata inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/disks", "/maintenance/osd-full-ratios" ],
          "postprocessing_hint" : "Present key-value pairs grouped by section (e.g., device, network) to improve readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules" : {
      "get" : {
        "summary" : "List CRUSH rules.",
        "operationId" : "CrushResource_getCrushRules",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCrushRuleResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List CRUSH rules with their steps to analyze data placement policies.",
          "usage" : [ "Fetch before assigning rules to pools or creating new ones.", "Compare rules after modifications to ensure parameters match expectations." ],
          "response_shape" : "OptionalPaginationResponse<CrushRuleResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON allowing filtering and sorting by rule name or type.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"type\":{\"_eq\":\"replicated\"}}]}"
          } ],
          "failure_modes" : [ "500 if the Ceph manager rejects the crush rule query" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying Ceph mgr health; include ceph osd crush rule dump output when escalating."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Rule inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/pools", "/crush/rules/simple" ],
          "postprocessing_hint" : "Group replicated vs erasure rules and display chooseleaf steps prominently for operators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/classes" : {
      "get" : {
        "summary" : "List CRUSH device classes.",
        "operationId" : "CrushResource_getCrushRuleClasses",
        "tags" : [ "crush", "osds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available CRUSH device classes to understand storage tiers and constraints for rule creation.",
          "usage" : [ "Call when designing CRUSH rules to target specific device types (ssd, hdd, nvme).", "Use to validate device class names before creating placement rules." ],
          "response_shape" : "List<String>",
          "failure_modes" : [ "200 with empty list if no device classes are configured", "500 if Ceph manager is unavailable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no device classes; assign classes to OSDs via ceph osd crush set-device-class."
          }, {
            "code" : "500",
            "action" : "Verify Ceph manager connectivity and cluster health before retrying."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Device class queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush/rules", "/crush/rules/simple", "/disks" ],
          "postprocessing_hint" : "Display device classes with counts of OSDs in each class; common classes are ssd, hdd, nvme.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/crush/rules/simple" : {
      "post" : {
        "summary" : "Create a simple CRUSH rule.",
        "operationId" : "CrushResource_newSimpleCrushRule",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "Simple CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SimpleRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a basic replicated or erasure-coded CRUSH rule targeting a specific bucket/device class.",
          "usage" : [ "Use when onboarding new pools requiring dedicated placement rules.", "Provide deviceClass to avoid mixing drive types in future expansions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "CRUSH rule name to create.",
            "required" : true,
            "example" : "replicated-ssd"
          }, {
            "name" : "startBucket",
            "in" : "body",
            "description" : "Starting bucket (e.g., default root).",
            "required" : true,
            "example" : "default"
          }, {
            "name" : "deviceClass",
            "in" : "body",
            "description" : "Optional target device class such as ssd or hdd.",
            "required" : false,
            "example" : "ssd"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "true to create an EC rule (requires parity/data parameters).",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if device class is blank", "409 if a rule with the same name already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide a non-empty device class or remove the field entirely."
          }, {
            "code" : "409",
            "action" : "Choose a unique rule name or delete the conflicting rule first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule authoring"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/crush" ],
          "postprocessing_hint" : "After creation, associate the rule with a pool and run ceph osd map to verify placement.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating CRUSH rules affects placement decisions for subsequent pools."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/ssdPrimary" : {
      "post" : {
        "summary" : "Create SSD primary CRUSH rule",
        "operationId" : "CrushResource_newSsdPrimaryCrushRule",
        "tags" : [ "crush", "osds" ],
        "requestBody" : {
          "description" : "SSD primary CRUSH rule creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/SsdPrimaryRuleRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a specialized CRUSH rule that places primary replicas on SSD and secondary replicas on HDD for tiered storage.",
          "usage" : [ "Use when implementing hybrid storage strategies to optimize performance and cost.", "Call to create rules that ensure fast SSD access for primary reads while using cheaper HDD for redundancy." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Unique name for the SSD primary CRUSH rule.",
            "required" : true,
            "example" : "ssd-primary-hdd-secondary"
          }, {
            "name" : "ssdStartBucket",
            "in" : "body",
            "description" : "CRUSH bucket containing SSD devices (e.g., ssd-rack).",
            "required" : true,
            "example" : "ssd-rack"
          }, {
            "name" : "ssdDeviceClass",
            "in" : "body",
            "description" : "Device class for SSD devices.",
            "required" : false,
            "example" : "ssd"
          }, {
            "name" : "ssdCopies",
            "in" : "body",
            "description" : "Number of replicas to place on SSD devices (default 1).",
            "required" : false,
            "example" : "1"
          }, {
            "name" : "hddStartBucket",
            "in" : "body",
            "description" : "CRUSH bucket containing HDD devices for secondary replicas.",
            "required" : true,
            "example" : "hdd-rack"
          }, {
            "name" : "hddDeviceClass",
            "in" : "body",
            "description" : "Device class for HDD devices.",
            "required" : false,
            "example" : "hdd"
          } ],
          "failure_modes" : [ "400 if device class names are blank", "409 if rule name already exists", "500 if CRUSH buckets or device classes don't exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide non-empty device class names or remove the parameters."
          }, {
            "code" : "409",
            "action" : "Choose unique rule name or delete existing rule first."
          }, {
            "code" : "500",
            "action" : "Verify CRUSH bucket topology and device class assignments before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Specialized CRUSH rule creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/crush/rules/simple" ],
          "postprocessing_hint" : "Test with ceph osd map after creation; verify SSD primaries and HDD secondaries placement before assigning to pools.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "SSD primary rules affect data placement and performance characteristics of pools"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/crush/rules/{name}" : {
      "delete" : {
        "summary" : "Delete specified CRUSH rule.",
        "operationId" : "CrushResource_deleteCrushRule",
        "tags" : [ "crush", "osds" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an existing CRUSH rule from the cluster.",
          "usage" : [ "Ensure no pools reference the rule before calling this endpoint.", "Perform after migrating pools to alternate rules to keep the CRUSH map tidy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "CRUSH rule name to delete.",
            "required" : true,
            "example" : "replicated-ssd"
          } ],
          "failure_modes" : [ "404 if the rule name does not exist", "409 if Ceph refuses to remove the rule because it is still referenced" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /crush/rules to verify the list before retrying."
          }, {
            "code" : "409",
            "action" : "Reassign any dependent pools to other rules and retry the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "CRUSH rule lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/crush/rules", "/pools" ],
          "postprocessing_hint" : "Dump the CRUSH map to confirm the rule is gone and no orphaned references remain.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing rules impacting pool placement may lead to data movement if referenced inadvertently."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos" : {
      "get" : {
        "summary" : "Retrieve all DAOS configs.",
        "operationId" : "DaosClusterResource_getDaosClusters",
        "tags" : [ "daos" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/SimpleDaosConfig"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a list of all configured DAOS clusters with basic configuration details.",
          "usage" : [ "Call to display DAOS cluster overview and selection interfaces.", "Use for monitoring dashboards to show all available DAOS storage systems." ],
          "response_shape" : "List<SimpleDaosConfig>",
          "failure_modes" : [ "200 with empty list if no DAOS clusters are configured", "500 if database access fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no DAOS clusters configured; create clusters via DAOS setup endpoints."
          }, {
            "code" : "500",
            "action" : "Database connectivity issue; check system health and retry."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "DAOS cluster listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Display cluster status, server count, and basic health information for each DAOS system.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS cluster.",
        "operationId" : "DaosClusterResource_createDaosCluster",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new DAOS cluster with specified servers and configuration after validation.",
          "usage" : [ "Call after successful verification to create and configure a DAOS storage cluster.", "Use to deploy DAOS infrastructure on validated servers with network configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Servers verified; Network configured; No existing DAOS cluster conflicts; Sufficient resources",
            "post_action" : "DAOS cluster created; Services deployed; Pool and container caches initialized; Cluster ready for use"
          },
          "request_parameters" : [ {
            "name" : "request",
            "in" : "body",
            "description" : "DAOS cluster creation configuration with servers and settings.",
            "required" : true,
            "example" : "{\"clusterName\": \"production\", \"servers\": [1, 2, 3], \"networkId\": 1}"
          } ],
          "failure_modes" : [ "400 if cluster configuration fails validation or has errors", "500 if cluster creation task fails to start or encounters deployment errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review verification errors; ensure all servers meet DAOS requirements before creation."
          }, {
            "code" : "500",
            "action" : "Check server connectivity, network configuration, and DAOS service health; review task logs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 3600,
            "note" : "DAOS cluster creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/verify", "/daos/{daosId}" ],
          "postprocessing_hint" : "Monitor task progress for deployment status; cluster becomes available after successful creation; automatic verification warnings require confirmation.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating DAOS cluster will deploy storage services across multiple servers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/verify" : {
      "post" : {
        "summary" : "Verify if the servers can be used to set up DAOS.",
        "operationId" : "DaosClusterResource_verifyDaosSetup",
        "tags" : [ "daos" ],
        "requestBody" : {
          "description" : "DAOS cluster creation request for verification",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosVerificationResult"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Verify if selected servers meet requirements for DAOS cluster setup without making changes.",
          "usage" : [ "Call before creating DAOS cluster to validate server configuration and compatibility.", "Use to check hardware requirements, network configuration, and software prerequisites." ],
          "response_shape" : "DaosVerificationResult",
          "workflow_guidance" : {
            "pre_check" : "Servers exist; Network configuration valid; DAOS prerequisites available",
            "post_action" : "Verification results returned; No changes made to system; Ready for cluster creation if successful"
          },
          "request_parameters" : [ {
            "name" : "request",
            "in" : "body",
            "description" : "DAOS cluster creation configuration for validation.",
            "required" : true,
            "example" : "{\"servers\": [1, 2, 3], \"networkId\": 1}"
          } ],
          "failure_modes" : [ "400 if server configuration is invalid or incompatible", "404 if specified servers or network do not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review verification results for specific compatibility issues; address hardware or configuration problems."
          }, {
            "code" : "404",
            "action" : "Verify all server IDs and network ID exist in the system."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS verification operations"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/daos", "/daos/{daosId}" ],
          "postprocessing_hint" : "Review verification results for warnings and errors; address any issues before proceeding with cluster creation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}" : {
      "get" : {
        "summary" : "Retrieve a DAOS cluster by ID.",
        "operationId" : "DaosClusterResource_getDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed configuration and status information for a specific DAOS cluster.",
          "usage" : [ "Call when displaying DAOS cluster details, configuration review, or troubleshooting.", "Use to fetch complete cluster setup before making modifications or monitoring health." ],
          "response_shape" : "DaosConfig",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "Unique identifier of the DAOS cluster to retrieve.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the DAOS cluster ID does not exist", "500 if cluster configuration cannot be loaded" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster ID exists; refresh cluster list from GET /daos."
          }, {
            "code" : "500",
            "action" : "Check DAOS service health and configuration storage; retry after verifying cluster state."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "DAOS cluster details"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos", "/daos/{daosId}/members", "/daos/{daosId}/containers" ],
          "postprocessing_hint" : "Display server assignments, engine configurations, and network settings; highlight any configuration warnings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS cluster.",
        "operationId" : "DaosClusterResource_deleteDaosCluster",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete a DAOS cluster and all associated data, pools, and containers.",
          "usage" : [ "Call when decommissioning DAOS storage systems or removing failed cluster configurations.", "Use to clean up test or development DAOS clusters that are no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to delete permanently.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if cluster deletion process fails during service removal" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Cluster may already be deleted; verify current cluster list."
          }, {
            "code" : "500",
            "action" : "Check server connectivity and DAOS service status; manual cleanup may be required."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "DAOS cluster deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos", "/daos/{daosId}" ],
          "postprocessing_hint" : "Monitor task progress for deletion status; services are removed from all cluster servers; pool and container caches are cleared; operation cannot be undone.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting DAOS cluster will permanently destroy all data, pools, and containers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs" : {
      "get" : {
        "summary" : "Retrieve a list of certificates for the DAOS cluster.",
        "operationId" : "DaosCertificateResource_getDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosCertificateResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all certificates (system and client) for a DAOS cluster.",
          "usage" : [ "Call to display certificate management interface and monitor certificate expiration dates.", "Use for security audits and certificate lifecycle management in DAOS clusters." ],
          "response_shape" : "PaginationResponse<DaosCertificateResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large certificate lists.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to list certificates for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if certificate information cannot be retrieved" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster ID exists and is properly configured."
          }, {
            "code" : "500",
            "action" : "Check certificate storage and DAOS cluster configuration health."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Certificate listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/certs/{certId}/crtFile", "/daos/{daosId}/certs/{certId}/keyFile" ],
          "postprocessing_hint" : "Highlight expiring certificates; group by type (CA, server, admin, agent, client); show expiry dates prominently.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new client certificate to the DAOS cluster.",
        "operationId" : "DaosCertificateResource_createDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new client certificate for secure DAOS cluster access with specified name and description.",
          "usage" : [ "Call when setting up new clients that need authenticated access to DAOS cluster.", "Use to generate client certificates for applications or users requiring DAOS connectivity." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate name is unique; CA is operational",
            "post_action" : "Client certificate created; Certificate files available for download; Client can authenticate to cluster"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Unique name for the client certificate.",
            "required" : true,
            "example" : "app-client-01"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description for the certificate purpose.",
            "required" : false,
            "example" : "Application client certificate for data access"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID where the certificate will be created.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "400 if certificate name already exists or is invalid", "500 if certificate generation fails due to CA or system issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and is properly configured."
          }, {
            "code" : "400",
            "action" : "Choose a unique certificate name; ensure name follows naming conventions."
          }, {
            "code" : "500",
            "action" : "Check DAOS CA health, certificate storage, and cluster connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Certificate creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}" ],
          "postprocessing_hint" : "Monitor task for certificate generation; download certificate files after creation; distribute securely to client applications.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/reparse-expiries" : {
      "post" : {
        "summary" : "Reparse all expiries from the CRT files.",
        "operationId" : "DaosCertificateResource_reparseDaosCertsExpiries",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reparse certificate expiration dates from CRT files to update database with current expiry information.",
          "usage" : [ "Call when certificate expiry information appears outdated or inconsistent.", "Use after manual certificate updates or when expiry warnings seem incorrect." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate files accessible; Database writable",
            "post_action" : "Certificate expiry dates updated; Database synchronized with file system; Expiry warnings accurate"
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing certificates to reparse.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if certificate file reading fails or parsing encounters errors" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and certificate storage is accessible."
          }, {
            "code" : "500",
            "action" : "Check certificate file permissions, format validity, and storage connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 1800,
            "note" : "Certificate parsing operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs" ],
          "postprocessing_hint" : "Monitor task for parsing progress; expiry information will be updated in database; certificate warnings will reflect current file contents.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}" : {
      "patch" : {
        "summary" : "Update a client certificate's name or description.",
        "operationId" : "DaosCertificateResource_updateDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS certificate update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosCertificateUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update metadata for a DAOS client certificate including display name and description.",
          "usage" : [ "Call when certificate labeling needs to be updated for better organization.", "Use to add or modify descriptive information without regenerating the certificate." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Certificate is client type; Valid metadata provided",
            "post_action" : "Certificate metadata updated; Display information refreshed; Certificate remains functional"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New display name for the certificate.",
            "required" : false,
            "example" : "web-service-cert"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "New description explaining certificate purpose.",
            "required" : false,
            "example" : "Certificate for web service authentication"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID to update (must be a client certificate).",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "400 if certificate is not a client certificate (server certs cannot be updated)", "404 if DAOS cluster or certificate ID does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Only client certificates can be updated; server and admin certificates are read-only."
          }, {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and certificate ID is valid; check certificate list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Certificate metadata updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}" ],
          "postprocessing_hint" : "Metadata changes are immediate; certificate functionality and security remain unchanged; only display information updated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a client certificate from the DAOS cluster. The admin/agent/server and CA certificates cannot be deleted.",
        "operationId" : "DaosCertificateResource_deleteDaosClientCerts",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a client certificate from the DAOS cluster to revoke access for specific clients.",
          "usage" : [ "Call when revoking access for DAOS clients or cleaning up unused certificates.", "Use for security management to remove certificates that should no longer have cluster access." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate to delete.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Client certificate ID to delete (must be >0; system certificates cannot be deleted).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if attempting to delete system certificates (CA, server, admin, agent)", "404 if DAOS cluster or client certificate does not exist", "500 if certificate removal task fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Only client certificates can be deleted; system certificates are protected."
          }, {
            "code" : "404",
            "action" : "Verify cluster and certificate ID exist; check if certificate was already deleted."
          }, {
            "code" : "500",
            "action" : "Check DAOS cluster connectivity and certificate management system health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Certificate deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/create" ],
          "postprocessing_hint" : "Monitor task progress; certificate removal is immediate; revoked clients lose access; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting certificates immediately revokes client access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/crtFile" : {
      "get" : {
        "summary" : "Download the crt file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCrtFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the certificate (.crt) file for a specific DAOS certificate for client authentication.",
          "usage" : [ "Call to obtain certificate files needed for DAOS client connections and authentication.", "Use when setting up new clients or troubleshooting authentication issues." ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID (-1: CA, -2: Server, -3: Admin, -4: Agent, >0: Client).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if DAOS cluster or certificate does not exist", "500 if certificate file cannot be retrieved or prepared for download" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster and certificate ID exist; check certificate list first."
          }, {
            "code" : "500",
            "action" : "Check certificate storage integrity and file system access."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Certificate downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}/keyFile" ],
          "postprocessing_hint" : "File expires after 15 minutes; use with corresponding key file for complete authentication setup.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/certs/{certId}/daos-configs.{type}" : {
      "get" : {
        "summary" : "Download a tar package containing all necessary files to connect to DAOS with the chosen certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosCertPackage",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Download as tar or as zip file.",
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : "zip|tar"
          }
        }, {
          "description" : "Include admin config and certificate files.",
          "name" : "withAdmin",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        }
      }
    },
    "/daos/{daosId}/certs/{certId}/keyFile" : {
      "get" : {
        "summary" : "Download the key file of the given certificate.",
        "operationId" : "DaosCertificateResource_downloadDaosKeyFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Certificate ID in croit.",
          "name" : "certId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the private key (.key) file for a specific DAOS certificate for client authentication.",
          "usage" : [ "Call to obtain private key files required for DAOS client authentication and secure connections.", "Use when configuring DAOS clients or troubleshooting authentication setup." ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier containing the certificate.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "certId",
            "in" : "path",
            "description" : "Certificate ID (-1: CA, -2: Server, -3: Admin, -4: Agent, >0: Client).",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if DAOS cluster or certificate does not exist", "500 if private key file cannot be retrieved or prepared for download" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster and certificate ID exist; check certificate list first."
          }, {
            "code" : "500",
            "action" : "Check certificate storage integrity and private key accessibility."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Private key downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs", "/daos/{daosId}/certs/{certId}/crtFile" ],
          "postprocessing_hint" : "File expires after 15 minutes; secure key storage required; combine with certificate file for authentication.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Private key files contain sensitive cryptographic material that must be handled securely"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/container-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available container properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosContainerProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available container properties supported by the DAOS cluster version for container configuration.",
          "usage" : [ "Call before creating or modifying DAOS containers to understand supported configuration options.", "Use to validate container property names and value ranges when building container creation requests." ],
          "response_shape" : "List<DaosProperty>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to get version-specific container properties for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if property metadata cannot be retrieved for the cluster version" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and is properly configured."
          }, {
            "code" : "500",
            "action" : "Check DAOS version compatibility and property schema availability."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Property schema queries"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 3600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/containers", "/daos/{daosId}/pool-props" ],
          "postprocessing_hint" : "Group properties by category; show data types and validation rules; cache for container creation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/containers" : {
      "get" : {
        "summary" : "Retrieve all DAOS containers in the cluster.",
        "operationId" : "DaosClusterResource_getAllDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all DAOS containers across all pools in the cluster.",
          "usage" : [ "Call to display container management interfaces and monitor data distribution.", "Use for capacity planning and tracking container usage across the entire DAOS cluster." ],
          "response_shape" : "PaginationResponse<DaosContainerDetails>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large container lists.",
            "required" : false,
            "example" : "{\"limit\": 100, \"offset\": 0}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to list containers from.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if container discovery fails across pools" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster ID exists and is configured."
          }, {
            "code" : "500",
            "action" : "Check DAOS pool health and container service availability."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Container listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{poolId}/containers" ],
          "postprocessing_hint" : "Aggregate containers by pool; show storage usage and health status; schedule automatic updates for returned data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/disks" : {
      "get" : {
        "summary" : "Retrieve all DAOS disks.",
        "operationId" : "DaosDiskResource_getDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPosixDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List DAOS POSIX disks along with usage metadata and NVMe-oF associations.",
          "usage" : [ "Populate storage management views that show where DAOS disks are mapped.", "Assess impact before deleting pools or containers that host disks." ],
          "response_shape" : "PaginationResponse<DaosPosixDiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":100}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "500 if the underlying DAO queries fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after confirming the database and DAOS caches are reachable."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Disk inventory lookup"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/containers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new DAOS disk.",
        "operationId" : "DaosDiskResource_createDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS disk creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosDiskCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a DAOS POSIX disk record and persist capacity metadata.",
          "usage" : [ "Add disks for NVMe-oF gateway exports after provisioning storage.", "Automate DAOS disk onboarding as part of infrastructure pipelines." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Validate the target container is POSIX and sufficient space is available.",
            "post_action" : "Monitor the returned task and refresh the disk list once completed."
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Display name for the disk in croit.",
            "required" : true,
            "example" : "nvme-tier0"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "UUID of the pool hosting the disk.",
            "required" : true,
            "example" : "a6e1-..."
          }, {
            "name" : "container",
            "in" : "body",
            "description" : "UUID of the POSIX container.",
            "required" : true,
            "example" : "c02f-..."
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Capacity in bytes.",
            "required" : true,
            "example" : "1099511627776"
          }, {
            "name" : "oclass",
            "in" : "body",
            "description" : "Optional DAOS object class.",
            "required" : false,
            "example" : "OC_SX"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if validation fails (duplicate name, non-POSIX container)", "500 if persistence fails or task creation errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Expose validation feedback (e.g., ensure container is POSIX) and correct the payload."
          }, {
            "code" : "500",
            "action" : "Retry after database/DAOS issues resolve; abort the task if it remains pending."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Disk provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/disks", "/daos/{daosId}/pools/{pool}/containers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/disks/{daosDiskId}" : {
      "delete" : {
        "summary" : "Remove a DAOS disk.",
        "operationId" : "DaosDiskResource_removeDaosDisks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosDiskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove the DAOS disk record and reconfigure NVMe-oF gateways that reference it.",
          "usage" : [ "Decommission disks that are no longer exported via NVMe-oF.", "Clean up records after deleting the underlying DAOS storage." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Warn operators when the disk feeds NVMe-oF gateways; plan replacement first.",
            "post_action" : "Track the task for NVMe-oF reconfiguration and refresh disk listings on completion."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "daosDiskId",
            "in" : "path",
            "description" : "Internal croit disk ID.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the disk cannot be found", "400 if the disk belongs to another DAOS cluster", "500 if removal or NVMe-oF reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the disk inventory to ensure the ID is current before retrying."
          }, {
            "code" : "400",
            "action" : "Verify the requested DAOS cluster ID matches the disk's cluster."
          }, {
            "code" : "500",
            "action" : "Inspect task logs and NVMe-oF gateway status; retry once dependencies are stable."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Disk removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/disks", "/gateways/nvmeof/{gatewayId}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing the disk triggers NVMe-oF reconfiguration and deletes associated metadata."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/members" : {
      "get" : {
        "summary" : "Retrieve member states of the DAOS cluster.",
        "operationId" : "DaosClusterResource_getDaosState",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosSystemMemberResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed status and state information for all members in a DAOS cluster.",
          "usage" : [ "Call to monitor DAOS cluster health and identify problematic nodes.", "Use for troubleshooting cluster issues and verifying node participation in the cluster." ],
          "response_shape" : "PaginationResponse<DaosSystemMemberResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination to limit large cluster member lists.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to query member states for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if DAOS system query fails or cluster is unreachable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster ID exists and is properly configured."
          }, {
            "code" : "500",
            "action" : "Check DAOS cluster connectivity and engine health; verify network configuration."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "DAOS member state queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/containers" ],
          "postprocessing_hint" : "Group members by state; highlight failed or excluded nodes; show fabric connectivity status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pool-props" : {
      "get" : {
        "summary" : "Retrieve a list of known available pool properties for DAOS.",
        "operationId" : "DaosClusterResource_getDaosPoolProperties",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosProperty"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve available pool properties supported by the DAOS cluster version for pool configuration.",
          "usage" : [ "Call before creating or modifying DAOS pools to understand supported configuration options.", "Use to validate pool property names and value ranges when building pool creation requests." ],
          "response_shape" : "List<DaosProperty>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier to get version-specific pool properties for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if property metadata cannot be retrieved for the cluster version" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and is properly configured."
          }, {
            "code" : "500",
            "action" : "Check DAOS version compatibility and property schema availability."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Property schema queries"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 3600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/container-props" ],
          "postprocessing_hint" : "Group properties by category; show data types and validation rules; cache for pool creation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools" : {
      "get" : {
        "summary" : "List all DAOS pools.",
        "operationId" : "DaosPoolResource_getDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPoolDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return paginated DAOS pool details including rebuild and usage statistics.",
          "usage" : [ "Render the DAOS pools overview with live capacity and rebuild status information.", "Fetch before executing maintenance that depends on pool health (draining ranks, container operations)." ],
          "response_shape" : "PaginationResponse<DaosPoolDetails>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination request (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":25}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "500 if DAOS queryPool fails or the local cache deserialization fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after a short delay; if repeated, trigger DAOS status cache refresh or inspect control-plane logs."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Expensive pool detail aggregation"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 20,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/simple", "/daos/{daosId}/pools/{pool}" ],
          "postprocessing_hint" : "Call daosPoolCache.scheduleUpdates already returns warm data; avoid re-querying DAOS individually unless a field changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS pool.",
        "operationId" : "DaosPoolResource_createDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosPoolRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new DAOS pool with the requested capacity, ranks, and properties.",
          "usage" : [ "Create pools during initial DAOS onboarding workflows.", "Allocate separate pools for workload isolation or QoS changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Pool label. Must be unique within the DAOS cluster.",
            "required" : true,
            "example" : "analytics"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Pool size (bytes).",
            "required" : true,
            "example" : "1099511627776"
          }, {
            "name" : "scmPerc",
            "in" : "body",
            "description" : "Percentage of storage class memory to allocate (0-100).",
            "required" : false,
            "example" : "10"
          }, {
            "name" : "nranks",
            "in" : "body",
            "description" : "Explicit rank count when not providing ranks list.",
            "required" : false,
            "example" : "8"
          }, {
            "name" : "ranks",
            "in" : "body",
            "description" : "Optional list of target ranks to place the pool on.",
            "required" : false,
            "example" : "[0,1,2,3]"
          }, {
            "name" : "properties",
            "in" : "body",
            "description" : "Key/value property overrides passed to DAOS.",
            "required" : false,
            "example" : "{\"srv_psr_rank\":\"1\"}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if DAOS rejects the request (invalid size, duplicate name, or rank mismatch)", "500 if the control plane cannot execute the pool create command" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Surface DAOS validation feedback to the operator and prompt for corrected input."
          }, {
            "code" : "500",
            "action" : "Inspect the DAOS control plane logs; retry once the cluster reports healthy engines."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Pool creation is an administrative action"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/simple" : {
      "get" : {
        "summary" : "List all DAOS pools without any query information.",
        "operationId" : "DaosPoolResource_getSimpleDaosPools",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosPoolResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve lightweight identifiers for every DAOS pool in the cluster cache.",
          "usage" : [ "Populate selection widgets before drilling into detailed pool metrics.", "Fetch once when composing DAOS ACL or container workflows that only need name/UUID pairs." ],
          "response_shape" : "array<DaosPoolResponse>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "500 if the DAOS management RPC fails or the cache backend is unavailable" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying the DAOS control plane is reachable; if the issue persists trigger a manual cache refresh."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Read-only pool listings"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}" ],
          "postprocessing_hint" : "Sort pools alphabetically client-side; the cache preserves the natural DAOS order.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}" : {
      "get" : {
        "summary" : "Get detailed info on a single pool.",
        "operationId" : "DaosPoolResource_getDaosPoolInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosPoolDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect a specific DAOS pool including rebuild progress, tier stats, and leader information.",
          "usage" : [ "Drill into a pool after selecting it from the overview to display health diagnostics.", "Validate pool presence and status before submitting ACL or container changes that reference it." ],
          "response_shape" : "DaosPoolDetails",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool cannot be found on the DAOS cluster", "500 if DAOS queryPool returns an error" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the pool list or verify the pool spelling/UUID before retrying."
          }, {
            "code" : "500",
            "action" : "Check DAOS control plane availability; retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Targeted pool inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/reintegrate", "/daos/{daosId}/pools/{pool}/props" ],
          "postprocessing_hint" : "Surface rebuild.state/status prominently; stale data can be detected via the status timestamp fields.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS pool.",
        "operationId" : "DaosPoolResource_deleteDaosPool",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a DAOS pool from the specified cluster and remove cached metadata.",
          "usage" : [ "Clean up pools that are no longer required before reclaiming storage.", "Recreate pools with different properties after explicitly removing the old instance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier in croit.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID to delete.",
            "required" : true,
            "example" : "8601f8c6-..."
          } ],
          "failure_modes" : [ "404 if the pool cannot be resolved for the given cluster", "500 if the DAOS remove operation fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh DAOS pool listings and retry with a valid identifier."
          }, {
            "code" : "500",
            "action" : "Inspect DAOS server logs; ensure the pool is disconnected from clients before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "DAOS pool deletion"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools", "/daos/{daosId}/pools/{pool}/reintegrate" ],
          "postprocessing_hint" : "Trigger a DAOS pool cache refresh to update UI listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl" : {
      "post" : {
        "summary" : "Update or add a pool ACL entry.",
        "operationId" : "DaosPoolResource_updatePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update a single principal entry within the DAOS pool ACL.",
          "usage" : [ "Grant a user access without rebuilding the entire ACL file.", "Tighten permissions iteratively while monitoring audit results." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "ACL entry to upsert (principal + permissions).",
            "required" : true,
            "example" : "user:alice@:rw"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if the ACL entry is invalid", "500 if DAOS fails to apply the ACL change" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate the ACL syntax using DAOS tooling, then resubmit."
          }, {
            "code" : "500",
            "action" : "Inspect DAOS logs for ACL update failures; retry once resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "ACL updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the pool ACL.",
        "operationId" : "DaosPoolResource_overwritePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire DAOS pool ACL with a new definition.",
          "usage" : [ "Restore ACLs from a backup file.", "Bulk apply a curated ACL template across multiple pools." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "entries",
            "in" : "body",
            "description" : "Full list of ACL entries to apply. Mutually exclusive with aclFile.",
            "required" : false,
            "example" : "[{\"principal\":\"user:alice\",\"permissions\":[\"rw\"]}]"
          }, {
            "name" : "aclFile",
            "in" : "body",
            "description" : "Raw ACL string exported from DAOS.",
            "required" : false,
            "example" : "A::OWNER@:rw"
          }, {
            "name" : "ownerUser",
            "in" : "body",
            "description" : "Requested pool owner user (unsupported for pools).",
            "required" : false,
            "example" : "alice"
          }, {
            "name" : "ownerGroup",
            "in" : "body",
            "description" : "Requested pool owner group (unsupported for pools).",
            "required" : false,
            "example" : "analytics"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if both entries and aclFile are provided", "400 if ownerUser/ownerGroup are supplied (not permitted on pools)", "500 if DAOS fails to write the ACL" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Submit exactly one ACL source and omit owner changes for pools."
          }, {
            "code" : "500",
            "action" : "Verify DAOS service health, then retry with the same payload."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "ACL overwrite"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the DAOS pool ACL in structured and raw form.",
          "usage" : [ "Display current permissions before proposing edits.", "Export ACLs for backup or replication to other clusters." ],
          "response_shape" : "DaosAclResponse",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "500 if DAOS acl get command fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after confirming DAOS engines are reachable; if persistent, inspect daos_server logs."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl-structured", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a pool ACL entry.",
        "operationId" : "DaosPoolResource_deletePoolACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific principal from the DAOS pool ACL.",
          "usage" : [ "Call while revoking access for a user or group that no longer needs pool permissions.", "Use as part of cleanup workflows when rotating credentials." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "ACL entry describing the principal to drop.",
            "required" : false,
            "example" : "user:alice@:rw"
          }, {
            "name" : "principal",
            "in" : "body",
            "description" : "Principal string to remove (mutually exclusive with acl).",
            "required" : false,
            "example" : "user:alice"
          }, {
            "name" : "isGroup",
            "in" : "body",
            "description" : "Set true when the principal refers to a group.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "400 if neither acl nor principal information is supplied", "500 if DAOS cannot remove the entry" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure either the full ACL entry or principal + isGroup are provided."
          }, {
            "code" : "500",
            "action" : "Retry once DAOS control service is healthy; confirm the principal exists before reissuing."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "ACL removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "postprocessing_hint" : "Inform operators if the returned ACL still lists the principal, indicating DAOS refused the removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/acl-structured" : {
      "get" : {
        "summary" : "Get pool ACL.",
        "operationId" : "DaosPoolResource_getPoolACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the pool ACL entries parsed into structured principals and permissions only.",
          "usage" : [ "Use when editing specific principals without needing raw ACL strings.", "Fetch for validation routines that expect parsed grant semantics." ],
          "response_shape" : "array<DaosAclEntry>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "500 if DAOS ACL retrieval fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry later; if DAOS continues to fail, fall back to the raw ACL endpoint for troubleshooting."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL parsing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/aclFile" ],
          "postprocessing_hint" : "Map entries by principal for quick lookup when rendering editors.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/aclFile" : {
      "get" : {
        "summary" : "Get pool ACL file.",
        "operationId" : "DaosPoolResource_getPoolACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the raw DAOS ACL file for the pool.",
          "usage" : [ "Backup ACLs before performing bulk modifications.", "Feed into automation that expects DAOS native ACL format." ],
          "response_shape" : "string",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "500 if DAOS fails to render the ACL file" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check DAOS connectivity; retry once the control plane responds."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL export"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/acl", "/daos/{daosId}/pools/{pool}/acl-structured" ],
          "postprocessing_hint" : "Store original ACL files securely to enable rollback if an overwrite fails.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers" : {
      "get" : {
        "summary" : "List all DAOS containers with details in a pool.",
        "operationId" : "DaosContainerResource_getDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return paginated DAOS container details for a pool, including type and health metadata.",
          "usage" : [ "Render the containers table while monitoring pool utilisation.", "Refresh after provisioning or deleting containers to keep UI state in sync." ],
          "response_shape" : "PaginationResponse<DaosContainerDetails>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination settings (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":50}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool cannot be resolved", "500 if DAOS list/query operations fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the pool list to ensure the pool still exists and retry."
          }, {
            "code" : "500",
            "action" : "Retry after verifying DAOS service health; stale cache entries are refreshed automatically."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Container detail listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 20,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/list", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a DAOS container.",
        "operationId" : "DaosContainerResource_createDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS container creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CreateDaosContainerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a DAOS container inside the selected pool with optional class and property overrides.",
          "usage" : [ "Create containers during onboarding or workload separation workflows.", "Automate provisioning for application namespaces with tailored properties." ],
          "response_shape" : "DaosContainerDetails",
          "workflow_guidance" : {
            "pre_check" : "Ensure the pool has sufficient capacity and that the requested label is unique.",
            "post_action" : "Update UI caches and present the new container's ACL for review."
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Container label (unique in the pool).",
            "required" : true,
            "example" : "project-x"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Container type enum (defaults to UNKNOWN).",
            "required" : false,
            "example" : "POSIX"
          }, {
            "name" : "chunkSize",
            "in" : "body",
            "description" : "Optional chunk size in bytes.",
            "required" : false,
            "example" : "1048576"
          }, {
            "name" : "objectClass",
            "in" : "body",
            "description" : "Default object class identifier.",
            "required" : false,
            "example" : "OC_SX"
          }, {
            "name" : "directoryObjectClass",
            "in" : "body",
            "description" : "Directory object class override.",
            "required" : false,
            "example" : "OC_S1"
          }, {
            "name" : "fileObjectClass",
            "in" : "body",
            "description" : "File object class override.",
            "required" : false,
            "example" : "OC_S1"
          }, {
            "name" : "properties",
            "in" : "body",
            "description" : "Map of additional properties to set on creation.",
            "required" : false,
            "example" : "{\"checksum\":\"crc64\"}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool cannot be resolved", "400 if DAOS rejects the request (invalid name, conflicting properties)", "500 if the control plane fails to create the container" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the pool still exists and retry."
          }, {
            "code" : "400",
            "action" : "Surface the validation error to the operator and adjust the payload."
          }, {
            "code" : "500",
            "action" : "Retry after DAOS recovers; check server logs for context."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Container creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/list" : {
      "get" : {
        "summary" : "List all DAOS containers in a pool.",
        "operationId" : "DaosContainerResource_listDaosContainers",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosContainerListResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a lightweight list of DAOS container UUID + labels for selection workflows.",
          "usage" : [ "Populate dropdowns before choosing a container for ACL or property updates.", "Use prior to bulk operations to confirm inventory size." ],
          "response_shape" : "PaginationResponse<DaosContainerListResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":200}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool reference is invalid", "500 if DAOS listContainers fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Resolve pool naming mismatches; consider using the UUID."
          }, {
            "code" : "500",
            "action" : "Retry after DAOS control plane recovers; fall back to cached data if available."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container quick list"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 45,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}" : {
      "get" : {
        "summary" : "Get detailed info on a single container.",
        "operationId" : "DaosContainerResource_getDaosContainerInfo",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosContainerDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect a single DAOS container with its metrics, type, and redundancy settings.",
          "usage" : [ "Open the details view after selecting a container from the list.", "Validate container existence before editing ACLs or properties programmatically." ],
          "response_shape" : "DaosContainerDetails",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if the container cannot be found", "500 if DAOS queryContainer fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the container list to ensure the name/UUID is correct before retrying."
          }, {
            "code" : "500",
            "action" : "Retry after DAOS query recovers; examine DAOS logs if errors persist."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Container inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}/containers/{container}/props" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a DAOS container.",
        "operationId" : "DaosContainerResource_deleteDaosContainer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Force delete the container.",
          "name" : "force",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Destroy a DAOS container and invalidate related caches.",
          "usage" : [ "Remove retired datasets prior to freeing pool capacity.", "Force-delete containers that failed provisioning after confirming the data is no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Warn users if the container holds active data; consider exporting ACLs first.",
            "post_action" : "Refresh container and pool lists to confirm the removal."
          },
          "request_parameters" : [ {
            "name" : "force",
            "in" : "query",
            "description" : "Set true to skip DAOS safety checks when deleting.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if the pool or container cannot be resolved", "500 if DAOS refuses to destroy the container (e.g., still mounted)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload pool/container lists to ensure the identifiers are valid before retrying."
          }, {
            "code" : "500",
            "action" : "Check DAOS logs for mount or usage conflicts; retry after resolving or use force cautiously."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Container deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Container deletion permanently erases stored data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl" : {
      "post" : {
        "summary" : "Update or add a container ACL entry.",
        "operationId" : "DaosContainerResource_updateContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update a single ACL principal on the container.",
          "usage" : [ "Grant a user access during onboarding workflows.", "Iteratively adjust permissions while monitoring audit events." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "ACL entry to upsert.",
            "required" : true,
            "example" : "user:alice@:rw"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if the ACL entry cannot be parsed", "500 if DAOS fails to apply the ACL" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate the ACL using DAOS CLI and correct the syntax."
          }, {
            "code" : "500",
            "action" : "Retry when DAOS reports healthy; check logs for underlying issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ACL updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Overwrite the container ACL.",
        "operationId" : "DaosContainerResource_overwriteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Overwrite DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OverwriteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire container ACL and optionally adjust owner fields.",
          "usage" : [ "Restore ACLs from backup exports.", "Apply a predefined template across multiple containers." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "entries",
            "in" : "body",
            "description" : "List of ACL entries to apply. Mutually exclusive with aclFile.",
            "required" : false,
            "example" : "[{...}]"
          }, {
            "name" : "aclFile",
            "in" : "body",
            "description" : "Raw ACL file content to import.",
            "required" : false,
            "example" : "A::OWNER@:rw"
          }, {
            "name" : "ownerUser",
            "in" : "body",
            "description" : "Optional owner user to set after import.",
            "required" : false,
            "example" : "alice"
          }, {
            "name" : "ownerGroup",
            "in" : "body",
            "description" : "Optional owner group to set after import.",
            "required" : false,
            "example" : "analytics"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if both entries and aclFile are provided", "500 if DAOS fails to overwrite the ACL or set owners" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide exactly one ACL source (entries or aclFile)."
          }, {
            "code" : "500",
            "action" : "Retry after DAOS connectivity issues resolve; roll back using the previous ACL file if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 600,
            "note" : "Container ACL overwrite"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile", "/daos/{daosId}/pools/{pool}/containers/{container}/acl" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the DAOS container ACL including owner information.",
          "usage" : [ "Inspect permissions before editing or auditing access.", "Export ACLs to apply them to sibling containers." ],
          "response_shape" : "DaosAclResponse",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "500 if DAOS ACL retrieval fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying DAOS connectivity; review daos_server logs on repeated failure."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container ACL inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured", "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a container ACL entry.",
        "operationId" : "DaosContainerResource_deleteContainerACL",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Delete DAOS ACL request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDaosAclRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DaosAclResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific principal from the container ACL.",
          "usage" : [ "Revoke access after a user or group offboarding.", "Tighten permissions as part of security audits." ],
          "response_shape" : "DaosAclResponse",
          "request_parameters" : [ {
            "name" : "acl",
            "in" : "body",
            "description" : "ACL entry describing the principal to delete.",
            "required" : false,
            "example" : "user:alice@:rw"
          }, {
            "name" : "principal",
            "in" : "body",
            "description" : "Principal string when not supplying the full ACL entry.",
            "required" : false,
            "example" : "user:alice"
          }, {
            "name" : "isGroup",
            "in" : "body",
            "description" : "Mark true when the principal is a group.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "400 if neither an ACL entry nor principal information is provided", "500 if DAOS cannot remove the ACL entry" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide either the parsed ACL entry or principal + isGroup fields."
          }, {
            "code" : "500",
            "action" : "Retry after confirming DAOS service health; verify the principal exists before reissuing."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ACL removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "postprocessing_hint" : "Confirm the returned ACL no longer lists the principal; otherwise inform the operator.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" : {
      "get" : {
        "summary" : "Get container ACL.",
        "operationId" : "DaosContainerResource_getContainerACLParsed",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/DaosAclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the container ACL parsed into structured DAOS ACL entries only.",
          "usage" : [ "Drive UI editors that need per-principal permission flags.", "Validate expected principals programmatically without parsing raw strings." ],
          "response_shape" : "array<DaosAclEntry>",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "500 if DAOS ACL retrieval fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry later or fall back to the raw ACL endpoint for troubleshooting."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "Container ACL parsing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" ],
          "postprocessing_hint" : "Index entries by principal for quick comparison with desired policy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/aclFile" : {
      "get" : {
        "summary" : "Get container ACL file.",
        "operationId" : "DaosContainerResource_getContainerACLFile",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the raw DAOS ACL file for the container.",
          "usage" : [ "Backup ACLs before bulk modifications or migrations.", "Provide to external tooling that expects the DAOS-native ACL format." ],
          "response_shape" : "string",
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "500 if DAOS fails to export the ACL" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Inspect DAOS service logs; retry when the export command succeeds."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 60,
            "note" : "ACL export"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}/acl-structured" ],
          "postprocessing_hint" : "Store exports with metadata identifying pool/container to ease restores.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/owner" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerOwner",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS container owner request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosContainerOwnerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the owner of the DAOS container to a user or group.",
          "usage" : [ "Reassign ownership after team transitions.", "Align DAOS permissions with identity management automation." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "body",
            "description" : "Principal that should own the container.",
            "required" : true,
            "example" : "analytics-team"
          }, {
            "name" : "isGroup",
            "in" : "body",
            "description" : "Set true if owner refers to a group.",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if the pool or container cannot be resolved", "500 if DAOS fails to set the owner" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the container still exists; list containers to update identifiers."
          }, {
            "code" : "500",
            "action" : "Verify the principal exists in DAOS and retry after connectivity issues are resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container ownership changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/acl", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/containers/{container}/props" : {
      "put" : {
        "summary" : "Set a container property.",
        "operationId" : "DaosContainerResource_setContainerProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a DAOS container property value and refresh caches.",
          "usage" : [ "Adjust container behaviour parameters (e.g., redundancy, checksum).", "Automate configuration changes during deployment pipelines." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Property name to modify.",
            "required" : true,
            "example" : "checksum"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "New property value (string format expected by DAOS).",
            "required" : true,
            "example" : "crc64"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "404 if the pool or container cannot be resolved", "400 if the property name/value is invalid", "500 if DAOS fails to apply the change" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh container listings to ensure identifiers are current."
          }, {
            "code" : "400",
            "action" : "Confirm the property is supported and the value is in DAOS-compatible format."
          }, {
            "code" : "500",
            "action" : "Retry after DAOS service health is restored."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 40,
            "window_seconds" : 600,
            "note" : "Container property changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}/props", "/daos/{daosId}/pools/{pool}/containers/{container}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get container properties.",
        "operationId" : "DaosContainerResource_getContainerProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "Either the container name or the container UUID.",
          "name" : "container",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all DAOS container properties and their values.",
          "usage" : [ "Display configuration before editing properties.", "Audit properties across containers for compliance." ],
          "response_shape" : "PaginationResponse<DaosPropertyResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":50}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          }, {
            "name" : "container",
            "in" : "path",
            "description" : "Container name or UUID.",
            "required" : true,
            "example" : "c02f..."
          } ],
          "failure_modes" : [ "500 if property retrieval fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry when DAOS responds; otherwise inspect control plane logs."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Property inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/containers/{container}", "/daos/{daosId}/pools/{pool}/containers/{container}/props" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/props" : {
      "put" : {
        "summary" : "Set a pool property.",
        "operationId" : "DaosPoolResource_setPoolProp",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Set DAOS property request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SetDaosPropertyRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a single DAOS pool property value.",
          "usage" : [ "Tune pool behaviour (e.g., redundancy) as part of maintenance.", "Automate property changes during rollout scripts." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Property name to change.",
            "required" : true,
            "example" : "srv_psr_rank"
          }, {
            "name" : "value",
            "in" : "body",
            "description" : "New property value (string as accepted by DAOS).",
            "required" : true,
            "example" : "2"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool does not exist", "400 if DAOS rejects the property name or value", "500 if the DAOS control plane fails to apply the property" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload pool metadata to confirm the pool ID before retrying."
          }, {
            "code" : "400",
            "action" : "Validate the property against DAOS documentation and supply a supported value."
          }, {
            "code" : "500",
            "action" : "Inspect DAOS server logs for property update failures and retry afterwards."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Property changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}/props", "/daos/{daosId}/pools/{pool}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get pool properties.",
        "operationId" : "DaosPoolResource_getPoolProps",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDaosPropertyResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the list of DAOS pool properties and their current values.",
          "usage" : [ "Display pool configuration before applying property changes.", "Audit property states across pools during compliance checks." ],
          "response_shape" : "PaginationResponse<DaosPropertyResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":50}"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "500 if DAOS property fetch fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after ensuring the DAOS management service is responsive."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Property inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}", "/daos/{daosId}/pools/{pool}/props" ],
          "postprocessing_hint" : "Normalize values (especially JSON nodes) before diffing between clusters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/pools/{pool}/reintegrate" : {
      "post" : {
        "summary" : "Reintegrate a DAOS rank, or all ranks available, for a pool.",
        "operationId" : "DaosPoolResource_reintegrateDaosRank",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Either the pool name or the pool UUID.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Rank reintegrate request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RankReintegrateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off a ManagedThreadTask that reintegrates one or all DAOS ranks for the pool.",
          "usage" : [ "Run after failed engines return to service so the pool can rebalance data.", "Trigger from automated remediation when pool rebuild states remain degraded." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Resolve outstanding rebuild errors and determine whether a specific rank requires reintegration.",
            "post_action" : "Follow the returned task until completion; refresh pool details afterwards to confirm healthy state."
          },
          "request_parameters" : [ {
            "name" : "rank",
            "in" : "body",
            "description" : "Optional DAOS rank to reintegrate. When omitted, all ranks are attempted.",
            "required" : false,
            "example" : "4"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name or UUID.",
            "required" : true,
            "example" : "a6e1..."
          } ],
          "failure_modes" : [ "404 if the pool reference cannot be resolved", "500 if DAOS fails to reintegrate one of the requested ranks" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload pool metadata to ensure the pool still exists, then retry."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedThreadTask log for failing ranks and remediate engine issues before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Rank reintegration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/pools/{pool}", "/tasks/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers" : {
      "post" : {
        "summary" : "Add a server as client to DAOS.",
        "operationId" : "DaosClusterResource_addDaosServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server configuration for DAOS client",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosClientCreationServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enroll an existing croit server as a DAOS client node and restart the local DAOS services.",
          "usage" : [ "Expand the DAOS cluster with new client nodes after hardware rollout.", "Re-add a server after reinstalling the OS while preserving DAOS configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Confirm the server is not already part of another DAOS cluster and that NUMA/port information is available.",
            "post_action" : "Monitor the returned task; once complete, verify membership via GET /daos/{daosId}/members."
          },
          "request_parameters" : [ {
            "name" : "id",
            "in" : "body",
            "description" : "Server ID to enroll.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "DAOS port to use (defaults to 10001).",
            "required" : false,
            "example" : "10001"
          }, {
            "name" : "nics",
            "in" : "body",
            "description" : "Optional NIC IDs to configure as engines.",
            "required" : false,
            "example" : "[7,8]"
          }, {
            "name" : "provider",
            "in" : "body",
            "description" : "Interface provider override.",
            "required" : false,
            "example" : "ofi+verbs"
          }, {
            "name" : "targets",
            "in" : "body",
            "description" : "Target count override when provisioning engines.",
            "required" : false,
            "example" : "4"
          }, {
            "name" : "threads",
            "in" : "body",
            "description" : "Thread count override.",
            "required" : false,
            "example" : "8"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the DAOS cluster or server cannot be found", "400 if the server already belongs to a DAOS cluster or has NICs without NUMA metadata", "500 if DAOS configuration fails during restart" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh cluster/server lists and retry with current IDs."
          }, {
            "code" : "400",
            "action" : "Select a server that is not yet part of DAOS and ensure NIC metadata is complete."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedThreadTask log; resolve configuration issues and retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "DAOS server enrollment"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/members", "/daos/{daosId}/servers/{serverId}/reconfigure" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from a DAOS cluster.",
        "operationId" : "DaosClusterResource_removeServerFromDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach a DAOS client node from the cluster and remove its configuration.",
          "usage" : [ "Retire client nodes prior to decommissioning hardware.", "Temporarily remove a host before reimaging or repurposing it." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify the server operates as a DAOS client; server nodes cannot be removed via this endpoint.",
            "post_action" : "Track the ManagedThreadTask and unregister the host from dependent tooling if needed."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID to remove.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the cluster or server cannot be found", "400 if the server is a DAOS server node (not a client)", "500 if DAOS removal or service cleanup fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload cluster/server data to confirm membership before retrying."
          }, {
            "code" : "400",
            "action" : "Use DAOS cluster reconfiguration workflows for server nodes; only clients are supported here."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedThreadTask logs and host journalctl for DAOS errors before retriggering."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "DAOS server removal"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/servers", "/daos/{daosId}/servers/{serverId}/reconfigure" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing the server disconnects it from DAOS and may interrupt workloads using that client."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/servers/{serverId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure and restart DAOS on the server.",
        "operationId" : "DaosClusterResource_restartDaosOnServer",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart DAOS services on a specific server using the current cluster configuration.",
          "usage" : [ "Apply configuration changes after editing engine settings.", "Recover a node that drifted from the desired DAOS configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Ensure the server still belongs to the cluster and is reachable.",
            "post_action" : "Follow the ManagedThreadTask progress; if successful, confirm the node reports healthy via GET /daos/{daosId}/members."
          },
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID.",
            "required" : true,
            "example" : "3"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID to restart.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if either the cluster or server is unknown", "400 if the server is not a member of the specified cluster", "500 if the DAOS restart fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh cluster/server registry and retry with valid IDs."
          }, {
            "code" : "400",
            "action" : "Ensure the server is associated with the cluster before reconfiguring."
          }, {
            "code" : "500",
            "action" : "Inspect task logs; resolve DAOS errors on the host and rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "DAOS server reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/members", "/daos/{daosId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/daos/{daosId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "DaosClusterResource_testSshConnectionDaos",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Test SSH connectivity to all servers in a DAOS cluster to verify remote access and network reachability.",
          "usage" : [ "Call to verify SSH access before performing cluster operations or troubleshooting connectivity issues.", "Use for network diagnostics when DAOS services report communication problems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; SSH keys configured; Network connectivity available",
            "post_action" : "SSH connectivity verified; Remote access confirmed; Network path validated"
          },
          "request_parameters" : [ {
            "name" : "sleep",
            "in" : "query",
            "description" : "Seconds to sleep during each test iteration (0-60, defaults to 0).",
            "required" : false,
            "example" : "2"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID to test SSH connectivity for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if SSH connection fails or authentication errors occur" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and configuration is accessible."
          }, {
            "code" : "500",
            "action" : "Check SSH key configuration, network connectivity, and server accessibility; verify firewall settings."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "SSH connectivity testing"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Test runs 5 iterations with specified sleep interval; successful completion indicates SSH access is working for cluster operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/start-ranks" : {
      "post" : {
        "summary" : "Start a list of ranks.",
        "operationId" : "DaosClusterResource_startDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to start",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start specified DAOS engine ranks in a cluster to bring storage services online.",
          "usage" : [ "Call to start stopped DAOS ranks after maintenance or troubleshooting.", "Use to bring storage capacity back online by starting specific engine ranks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Specified ranks are stopped; No conflicting operations",
            "post_action" : "Target ranks started; Storage capacity available; Cluster rebalancing may occur"
          },
          "request_parameters" : [ {
            "name" : "ranks",
            "in" : "body",
            "description" : "List of rank numbers to start (empty list starts all stopped ranks).",
            "required" : false,
            "example" : "[0, 1, 2]"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the ranks to start.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if rank startup fails due to service or configuration issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and is accessible."
          }, {
            "code" : "500",
            "action" : "Check DAOS service health, rank configuration, and server connectivity."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS rank management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/stop-ranks", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Starting ranks brings storage capacity online; cluster may rebalance data automatically; monitor rank status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/daos/{daosId}/stop-ranks" : {
      "post" : {
        "summary" : "Stop a list of ranks.",
        "operationId" : "DaosClusterResource_stopDaosRanks",
        "tags" : [ "daos" ],
        "parameters" : [ {
          "description" : "DAOS cluster ID in croit.",
          "name" : "daosId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DAOS ranks to stop",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DaosRanksRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop specified DAOS engine ranks in a cluster to take storage services offline for maintenance.",
          "usage" : [ "Call to stop DAOS ranks for maintenance, troubleshooting, or graceful shutdown.", "Use before server maintenance to safely take storage capacity offline." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "DAOS cluster exists; Specified ranks are running; No critical operations in progress",
            "post_action" : "Target ranks stopped; Storage capacity offline; Data access may be affected"
          },
          "request_parameters" : [ {
            "name" : "ranks",
            "in" : "body",
            "description" : "List of rank numbers to stop (empty list stops all running ranks).",
            "required" : false,
            "example" : "[0, 1, 2]"
          } ],
          "path_parameters" : [ {
            "name" : "daosId",
            "in" : "path",
            "description" : "DAOS cluster ID containing the ranks to stop.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if DAOS cluster does not exist", "500 if rank shutdown fails due to active operations or service issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify DAOS cluster exists and is accessible."
          }, {
            "code" : "500",
            "action" : "Check for active I/O operations; ensure graceful shutdown procedures; verify DAOS service health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "DAOS rank management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/start-ranks", "/daos/{daosId}/members" ],
          "postprocessing_hint" : "Stopping ranks removes storage capacity; ensure redundancy before stopping; data may become inaccessible if insufficient replicas.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Stopping DAOS ranks will take storage capacity offline and may affect data availability"
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks" : {
      "get" : {
        "summary" : "List of all disks across all servers.",
        "operationId" : "DiskResource_getAllDisks",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all disks including their OSD assignments - shows which disks are used as OSDs with detailed hardware metadata.",
          "usage" : [ "List all disks including their OSD assignments.", "Find which disks are used as OSDs.", "Build storage inventory dashboards before drilling into per-server views", "Refresh after provisioning or wiping disks to confirm state changes" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"role\":{\"_in\":[\"osd\",\"journal\"]}}]}"
          }, {
            "name" : "osd-filtering",
            "in" : "response-processing",
            "description" : "Filter OSD-relevant disks from response. OSDs have role='osd' and osdId field set. Use where: [{\"role\":{\"_eq\":\"osd\"}}] to get only OSD disks. Check osdId field for OSD number, deviceClass for device type (ssd/hdd/nvme). Missing OSDs have role='osd' but missing=true.",
            "required" : false,
            "example" : "{\"where\":[{\"role\":{\"_eq\":\"osd\"}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Restrict large clusters to manageable chunks.",
            "pagination.where" : "Filter by role='osd' to get OSD disks, or by health/hostname before exporting."
          },
          "failure_modes" : [ "200 [] when no disks match the applied filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an empty state and prompt hardware rescan if disks are expected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Fleet-wide disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/crush", "/servers/{id}/disks", "/disks/paths" ],
          "postprocessing_hint" : "Filter OSDs by role='osd' field. Check osdId for OSD number, deviceClass for type. Highlight disks with missing stats and merge in SMART data where available. Use /crush for complete OSD topology with CRUSH hierarchy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/create-osds" : {
      "post" : {
        "summary" : "Create multiple OSDs",
        "operationId" : "DiskResource_createMultipleOsds",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "description" : "OSD creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ManagedTask"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision one or more OSD daemons on the specified servers and disks.",
          "usage" : [ "Call after planning OSD placement; chunk large batches per server to keep tasks manageable.", "Monitor each returned ManagedTask to verify disk wiping, ceph-volume, and CRUSH integration steps." ],
          "response_shape" : "array<ManagedTask>",
          "request_parameters" : [ {
            "name" : "osds[].server",
            "in" : "body",
            "description" : "Server that will host the new OSD.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "osds[].disk",
            "in" : "body",
            "description" : "Disk identifier selected for OSD creation.",
            "required" : true,
            "example" : "345"
          }, {
            "name" : "osds[].encrypted",
            "in" : "body",
            "description" : "true to enable dm-crypt for the OSD.",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "osds[].reuseOsdId",
            "in" : "body",
            "description" : "Optional existing OSD id to reuse when replacing disks.",
            "required" : false,
            "example" : "112"
          } ],
          "failure_modes" : [ "400 if crushDeviceClass contains whitespace", "400 if validation of journaling or encryption prerequisites fails", "500 if ceph-volume or hardware detection encounters fatal errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize request payload (e.g. remove spaces from device classes) and retry."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs for failing disks; rerun create-osds only for failed entries after remediation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Resource-intensive provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/replace-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Display one task per server; surface WARN logs for disks requiring manual cleanup.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating OSDs wipes disks and alters CRUSH topology."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/install-croit" : {
      "post" : {
        "summary" : "Install croit to disks.",
        "operationId" : "DiskResource_installCroitToDisk",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "description" : "Disk installation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/InstallCroitRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Install the croit management image onto selected boot disks across one or more servers.",
          "usage" : [ "Deploy croit onto fresh hardware before adding the servers to the cluster.", "Reinstall the management stack after wiping or replacing boot drives." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "disks[].server",
            "in" : "body",
            "description" : "Server ID hosting the disk.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "disks[].disk",
            "in" : "body",
            "description" : "Disk ID to receive the croit installation.",
            "required" : true,
            "example" : "145"
          }, {
            "name" : "disks[].serial",
            "in" : "body",
            "description" : "Disk serial for confirmation.",
            "required" : true,
            "example" : "S3X4ABCD"
          }, {
            "name" : "disks[].destroy",
            "in" : "body",
            "description" : "true to destroy existing OSD metadata when reusing disks.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the request is empty, contains duplicates, or disks are too small/in use", "400 if container switching is required but not allowed in offline mode", "200 ManagedTask(status=FAILED) if installation steps fail on a subset of disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure disks are unassigned, online, and meet size requirements; wipe them if necessary."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to identify failed hosts and rerun only for those disks."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Boot disk installation"
          },
          "related_endpoints" : [ "/disks/wipe", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "After the task succeeds, reboot the servers from the freshly installed disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/paths" : {
      "get" : {
        "summary" : "List of all known multipath disk paths across all servers.",
        "operationId" : "DiskResource_getAllDiskPaths",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseDiskPathResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect multipath device paths and their states across all servers.",
          "usage" : [ "Check path health when diagnosing disk or fabric issues", "Filter by inactive paths before dispatching remediation tasks" ],
          "response_shape" : "PaginationResponse<DiskPathResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sorting and filters.",
            "required" : false,
            "example" : "{\"where\":[{\"active\":{\"_eq\":false}}]}"
          } ],
          "failure_modes" : [ "200 [] when no multipath devices exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an informational banner that no multipath data is available."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipath inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/disks", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Group entries by diskId and surface inactive paths prominently.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/disks/replace-osds" : {
      "post" : {
        "summary" : "Replace an OSDs by creating one on another disk.",
        "operationId" : "DiskResource_replaceOsds",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ReplaceOsdsRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace existing OSDs by provisioning new instances on different disks, carrying over metadata where possible.",
          "usage" : [ "Run when disks fail and need to be replaced with new hardware.", "Use resizeOsd=true to reweigh the OSD after moving it to a larger disk." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "osds[].osd",
            "in" : "body",
            "description" : "ID of the OSD being replaced.",
            "required" : true,
            "example" : "112"
          }, {
            "name" : "osds[].disk",
            "in" : "body",
            "description" : "Disk ID that will host the new OSD.",
            "required" : true,
            "example" : "456"
          }, {
            "name" : "osds[].keepDbWal",
            "in" : "body",
            "description" : "true to reuse existing DB/WAL devices; set false and provide dbDisk/walDisk to move journals.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "osds[].resizeOsd",
            "in" : "body",
            "description" : "Reweigh the OSD according to the new disk size.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if OSDs or disks appear multiple times in the request", "400 if the prior DB/WAL configuration cannot be determined when keepDbWal=true", "500 if ceph-volume creation fails on the new disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Deduplicate the request payload and explicitly provide DB/WAL disks when required."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask logs for failing steps; rerun only for the OSDs that did not complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Disk replacement workload"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks/create-osds", "/servers/{id}/disks", "/tasks/{id}" ],
          "postprocessing_hint" : "Review warnings emitted in the ManagedTask to address multi-disk or journal ambiguities.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Replacing OSDs wipes disks and reconfigures CRUSH mappings."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/wipe" : {
      "delete" : {
        "summary" : "Wipe disks on servers.",
        "operationId" : "DiskResource_wipeDisksRequest",
        "tags" : [ "disks", "osds" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskDeleteRequestWrapper"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Securely wipe one or more disks, optionally destroying associated OSDs in the cluster map.",
          "usage" : [ "Prepare disks for reuse after removing OSDs or other data.", "Clean drives prior to decommissioning hardware from the cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "disks[].server",
            "in" : "body",
            "description" : "Server ID hosting the disk.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "disks[].disk",
            "in" : "body",
            "description" : "Disk ID to wipe.",
            "required" : true,
            "example" : "145"
          }, {
            "name" : "disks[].serial",
            "in" : "body",
            "description" : "Serial confirmation string to avoid wiping the wrong disk.",
            "required" : true,
            "example" : "S3X4ABCD"
          }, {
            "name" : "disks[].destroy",
            "in" : "body",
            "description" : "true to remove the OSD from the CRUSH map after wiping.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if the request is empty, contains duplicates, or serial numbers do not match", "400 if any disk is boot media or in use by DAOS", "200 ManagedTask(status=FAILED) if wiping fails on a subset of disks" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate disk ownership, serial numbers, and DAOS usage before retrying."
          }, {
            "code" : "200",
            "action" : "Inspect task logs to identify disks that failed and rerun the wipe for those drives only."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 3600,
            "note" : "Disk wiping"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/create-osds", "/tasks" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion and run hardware detection to confirm disks are blank.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}" : {
      "delete" : {
        "summary" : "Delete disk",
        "operationId" : "DiskResource_deleteDiskWithoutServerId",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk entry from the inventory, typically after permanent removal or decommissioning.",
          "usage" : [ "Call after detaching hardware or replacing a disk so it no longer appears in inventory.", "Use only when the disk is not referenced by DAOS or active OSDs." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "Identifier of the disk from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "400 if the disk is still referenced by DAOS", "404 if the disk id is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Detach the disk from DAOS engines or update DAOS mappings before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh disk lists to confirm the identifier and retry if necessary."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Inventory cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/disks", "/disks/create-osds", "/servers/{id}/disks" ],
          "postprocessing_hint" : "Refresh GET /disks or /servers/{id}/disks to confirm the entry is gone.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/disks/{diskId}/benchmark/basic" : {
      "post" : {
        "summary" : "Benchmark disk performance",
        "operationId" : "DiskResource_benchmarkDisk",
        "tags" : [ "disks", "osds" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a basic synchronous write benchmark on an unassigned disk to measure worst-case journal throughput.",
          "usage" : [ "Evaluate new disks before assigning them to critical roles (journals/DB).", "Collect performance metrics for hardware surveys or troubleshooting." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /disks or /servers/{id}/disks.",
            "required" : true,
            "example" : "512"
          } ],
          "failure_modes" : [ "404 if the disk or server no longer exists", "400 if the disk is assigned or has partitions/mountpoints", "200 ManagedTask(status=FAILED) if fio or SSH commands fail during the benchmark" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the disk is unassigned, unmounted, and wiped before benchmarking."
          }, {
            "code" : "200",
            "action" : "Review task logs for fio/SSH failures, correct the issue, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Disk benchmarking"
          },
          "related_endpoints" : [ "/disks", "/servers/{id}/disks", "/disks/install-croit" ],
          "postprocessing_hint" : "Capture the ManagedTask output for archival or hardware survey submissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/download/{token}/{fileName}" : {
      "get" : {
        "summary" : "Download file by token",
        "operationId" : "DownloadResource_download",
        "parameters" : [ {
          "name" : "fileName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "token",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download files using temporary access tokens provided by other API endpoints.",
          "usage" : [ "Called automatically by browser or download tools using URLs from file generation endpoints.", "Use token-based URLs returned from certificate downloads, backups, exports, and file generation operations." ],
          "response_shape" : "Binary file stream",
          "path_parameters" : [ {
            "name" : "token",
            "in" : "path",
            "description" : "Temporary access token UUID provided by file generation endpoints.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          }, {
            "name" : "fileName",
            "in" : "path",
            "description" : "Original filename for the download (must match token registration).",
            "required" : true,
            "example" : "backup-cluster-20241201.tar.gz"
          } ],
          "failure_modes" : [ "404 if token does not exist, has expired, or filename does not match", "500 if file generation or streaming fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Token may be expired or invalid; regenerate download from original endpoint."
          }, {
            "code" : "500",
            "action" : "File generation failed; check source system health and retry original operation."
          } ],
          "retry_strategy" : "regenerate_token",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "File downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/daos/{daosId}/certs/{certId}/crtFile", "/s3/backups", "/maintenance/export" ],
          "postprocessing_hint" : "Files auto-expire (15min-1hr); download immediately after receiving URL; supports both static files and dynamic streams.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/events/hook-scripts" : {
      "get" : {
        "summary" : "List all script files with their linked hooks.",
        "operationId" : "EventResource_getScriptsWithHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseScriptInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all hook scripts with their event hook associations for comprehensive automation management.",
          "usage" : [ "Call to view scripts and their linked event triggers in one unified view.", "Use to audit and manage event-driven automation configurations." ],
          "response_shape" : "PaginationResponse<ScriptInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Pagination settings for large script collections.",
            "required" : false,
            "example" : "{\"limit\": 20, \"offset\": 0}"
          } ],
          "failure_modes" : [ "500 if script or hook database access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check database connectivity and script storage system health."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Hook script listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts/{id}", "/events/hooks" ],
          "postprocessing_hint" : "Response includes script content, names, and associated hook events; use for managing automation workflows.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file and link hooks.",
        "operationId" : "EventResource_createScriptAndLinkHooks",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new hook script file and automatically link it to specified event hooks for automation.",
          "usage" : [ "Call when creating new automation scripts that should run on specific system events.", "Use to set up event-driven automation with script and hook configuration in one operation." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Script name is unique; Hook configurations are valid; Admin privileges confirmed",
            "post_action" : "Script created; Hooks linked; Script cache updated; Automation active on specified events"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Name for the new script file.",
            "required" : false,
            "example" : "backup-cleanup"
          }, {
            "name" : "contents",
            "in" : "body",
            "description" : "Script code content to execute.",
            "required" : false,
            "example" : "#!/bin/bash\\necho 'Running cleanup'"
          }, {
            "name" : "hooks",
            "in" : "body",
            "description" : "List of hook configurations to link to this script.",
            "required" : false,
            "example" : "[{\"event\": \"PostCephDaemonStart\", \"allServers\": true}]"
          } ],
          "failure_modes" : [ "400 if script name already exists or hook configuration is invalid", "500 if script creation or hook linking fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique script name; verify hook event names and server configurations are valid."
          }, {
            "code" : "500",
            "action" : "Check script storage permissions and hook system health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Script and hook creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script is immediately available for execution; hooks will trigger script on configured events; test automation carefully.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hook-scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file and linked hooks.",
        "operationId" : "EventResource_replaceScriptAndHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update a script file and automatically synchronize changes to all linked event hooks.",
          "usage" : [ "Call when modifying script logic or renaming scripts used by multiple hooks.", "Use to maintain script content and hook associations in a single operation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Name is unique if changing; Valid script syntax; Hook points exist",
            "post_action" : "Script updated; Content deployed to servers; Hook associations updated; Changes effective immediately"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New filename for the script (optional).",
            "required" : false,
            "example" : "backup-cleanup.sh"
          }, {
            "name" : "contents",
            "in" : "body",
            "description" : "Updated script content (optional).",
            "required" : false,
            "example" : "#!/bin/bash\necho 'Updated script'"
          }, {
            "name" : "hookPoints",
            "in" : "body",
            "description" : "Updated list of hook points where script should execute.",
            "required" : false,
            "example" : "[\"POOL_CREATED\", \"POOL_DELETED\"]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to update from hook script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if script name conflicts with existing script", "404 if script ID does not exist", "500 if script deployment to servers fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose a unique script name; verify hook point names are valid."
          }, {
            "code" : "404",
            "action" : "Verify script ID exists; refresh script list."
          }, {
            "code" : "500",
            "action" : "Check server connectivity; verify script syntax; review deployment logs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script content updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script changes propagate to all linked hooks; test script execution after updates; verify hook triggering works correctly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks" : {
      "get" : {
        "summary" : "List of all installed hook scripts.",
        "deprecated" : true,
        "operationId" : "EventResource_getHooks",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHookInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured hook event associations for automation monitoring and management.",
          "usage" : [ "Call to view all active event-script associations in the system.", "Use to audit which scripts run on which system events." ],
          "response_shape" : "OptionalPaginationResponse<HookInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large hook collections.",
            "required" : false,
            "example" : "{\"limit\": 20, \"offset\": 0}"
          } ],
          "failure_modes" : [ "500 if hook database access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check database connectivity and hook storage system health."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Hook listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks/{id}" ],
          "postprocessing_hint" : "Response shows script-event associations; deprecated in favor of /hook-scripts endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_createHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Hook creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Link an existing script to a system event hook point for automated execution.",
          "usage" : [ "Call to configure script execution on specific system events.", "Use to create event-driven automation with existing scripts." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Event name is valid; Server targeting is configured; No duplicate hooks",
            "post_action" : "Hook created; Script will execute on specified events; Hook cache updated"
          },
          "request_parameters" : [ {
            "name" : "scriptId",
            "in" : "body",
            "description" : "ID of existing script to link to the event.",
            "required" : true,
            "example" : "123"
          }, {
            "name" : "event",
            "in" : "body",
            "description" : "Event hook point name from /hooks/hook-points.",
            "required" : true,
            "example" : "PostCephDaemonStart"
          }, {
            "name" : "allServers",
            "in" : "body",
            "description" : "Execute on all servers (mutually exclusive with serverIds).",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "serverIds",
            "in" : "body",
            "description" : "Specific server IDs to execute on (mutually exclusive with allServers).",
            "required" : false,
            "example" : "[1, 2, 3]"
          } ],
          "failure_modes" : [ "400 if script is already linked to this event or invalid configuration", "404 if script ID or server IDs do not exist", "500 if hook configuration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Check if hook already exists; verify event name and server configuration."
          }, {
            "code" : "404",
            "action" : "Verify script ID and server IDs exist in the system."
          }, {
            "code" : "500",
            "action" : "Check hook system health and database connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Hook creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks/hook-points" ],
          "postprocessing_hint" : "Hook is immediately active; deprecated in favor of /hook-scripts endpoint for combined operations.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/hooks/hook-points" : {
      "get" : {
        "summary" : "List of all available hook points.",
        "operationId" : "EventResource_getHookPoints",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/HookPointInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover all available system event hook points where scripts can be executed automatically.",
          "usage" : [ "Call to view all event types where scripts can be triggered for automation.", "Use to understand hook point parameters and server targeting options." ],
          "response_shape" : "List<HookPointInfo>",
          "failure_modes" : [ "500 if hook system metadata access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check hook system health and metadata storage."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Hook point discovery"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/events/hooks", "/events/hook-scripts" ],
          "postprocessing_hint" : "Use event names from response for hook creation; canChooseServer indicates if server targeting is available; parameters show script inputs.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/events/hooks/{id}" : {
      "patch" : {
        "summary" : "Install a hook script at a given hook point.",
        "deprecated" : true,
        "operationId" : "EventResource_updateHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Hook update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HookUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing hook configuration to change script, event, or server targeting.",
          "usage" : [ "Call to modify hook event associations or server targeting.", "Use to update automation configuration without recreating hooks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Hook exists; New configuration is valid; Server IDs exist if specified",
            "post_action" : "Hook updated; Changes effective immediately; Hook cache updated"
          },
          "request_parameters" : [ {
            "name" : "scriptId",
            "in" : "body",
            "description" : "New script ID to associate with this hook (optional).",
            "required" : false,
            "example" : "123"
          }, {
            "name" : "event",
            "in" : "body",
            "description" : "New event hook point name (optional).",
            "required" : false,
            "example" : "PostCephDaemonStart"
          }, {
            "name" : "allServers",
            "in" : "body",
            "description" : "Execute on all servers (optional).",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "serverIds",
            "in" : "body",
            "description" : "Specific server IDs to execute on (optional).",
            "required" : false,
            "example" : "[1, 2, 3]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Hook ID to update from hook listings.",
            "required" : true,
            "example" : "456"
          } ],
          "failure_modes" : [ "404 if hook ID or specified server IDs do not exist", "500 if hook update fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify hook ID exists; check that server IDs are valid."
          }, {
            "code" : "500",
            "action" : "Check database connectivity and hook system health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Hook update operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hooks", "/events/hook-scripts/{id}" ],
          "postprocessing_hint" : "Hook changes are immediate; deprecated in favor of /hook-scripts/{id} endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a hook event.",
        "deprecated" : true,
        "operationId" : "EventResource_deleteHook",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a hook event configuration to stop script execution at specific system events.",
          "usage" : [ "Call when removing automation that should no longer run on system events.", "Use for cleanup when event-driven scripts are no longer needed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Hook event exists; Admin understands impact on automation",
            "post_action" : "Hook deleted; Hook cache updated; Script will no longer run on specified events"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Hook event ID to delete from the hook configuration.",
            "required" : true,
            "example" : "456"
          } ],
          "failure_modes" : [ "404 if the specified hook ID does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Hook may have already been deleted; refresh hook list to verify current configurations."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Hook management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hooks", "/events/scripts" ],
          "postprocessing_hint" : "Hook removal is immediate; scripts stop executing on events; hook cache updates automatically.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting hooks will stop automated script execution on system events"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts" : {
      "get" : {
        "summary" : "List all script files.",
        "deprecated" : true,
        "operationId" : "EventResource_getScripts",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseScriptIdentifier"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available hook script files for management and selection.",
          "usage" : [ "Call to view all stored scripts before selecting one for hook configuration.", "Use to browse available automation scripts in the system." ],
          "response_shape" : "OptionalPaginationResponse<ScriptIdentifier>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination settings to limit results.",
            "required" : false,
            "example" : "{\"limit\": 20, \"offset\": 0}"
          } ],
          "failure_modes" : [ "500 if script storage or database access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check script storage system health and database connectivity."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Script listing operations"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/hook-scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Use script IDs from response for hook creation or script content retrieval; deprecated in favor of /hook-scripts.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_createScript",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new script file for later use in hook configurations.",
          "usage" : [ "Call to store new automation scripts for later hook assignment.", "Use when separating script creation from hook configuration." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Script name is unique; Admin privileges confirmed",
            "post_action" : "Script created; Script cache updated; Script available for hook configuration"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Filename for the new script.",
            "required" : false,
            "example" : "backup-cleanup.sh"
          }, {
            "name" : "contents",
            "in" : "body",
            "description" : "Script code content.",
            "required" : false,
            "example" : "#!/bin/bash\necho 'Script created'"
          } ],
          "failure_modes" : [ "400 if script name already exists", "500 if script creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose a unique script name; check existing scripts."
          }, {
            "code" : "500",
            "action" : "Check script storage permissions and system health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script creation operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/hook-scripts", "/events/hooks" ],
          "postprocessing_hint" : "Use returned script ID for hook creation; deprecated in favor of /hook-scripts endpoint.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/execute" : {
      "post" : {
        "summary" : "Run a script immediately.",
        "operationId" : "EventResource_runHook",
        "tags" : [ "hooks" ],
        "requestBody" : {
          "description" : "Script execution configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RunScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a script immediately on specified servers for testing, troubleshooting, or manual operations.",
          "usage" : [ "Call to run stored scripts on demand for testing or manual maintenance tasks.", "Use to execute custom scripts with parameters on selected cluster nodes." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Script exists or content provided; Servers accessible; SSH connections available",
            "post_action" : "Script executed on target servers; Output captured in task logs; Temporary files cleaned up"
          },
          "request_parameters" : [ {
            "name" : "scriptId",
            "in" : "body",
            "description" : "ID of stored script to execute (mutually exclusive with script).",
            "required" : false,
            "example" : "123"
          }, {
            "name" : "script",
            "in" : "body",
            "description" : "Inline script content to execute (mutually exclusive with scriptId).",
            "required" : false,
            "example" : "#!/bin/bash\\necho 'Hello World'"
          }, {
            "name" : "args",
            "in" : "body",
            "description" : "Command-line arguments to pass to the script.",
            "required" : true,
            "example" : "[\"--verbose\", \"--config=/tmp/config\"]"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "List of server IDs where the script will be executed.",
            "required" : true,
            "example" : "[1, 2, 3]"
          } ],
          "failure_modes" : [ "400 if both scriptId and script are provided or neither is provided", "404 if specified scriptId or server IDs do not exist", "500 if script execution fails or SSH connectivity issues occur" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide either scriptId or script content, but not both; ensure exactly one is specified."
          }, {
            "code" : "404",
            "action" : "Verify script ID exists and all server IDs are valid in the cluster."
          }, {
            "code" : "500",
            "action" : "Check SSH connectivity to servers; review script syntax and permissions; monitor task logs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 600,
            "note" : "Script execution operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Monitor task progress for execution status; script output appears in task logs; connection failures are logged per server.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Script execution will run arbitrary code on cluster servers and may affect system state"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/events/scripts/{id}" : {
      "patch" : {
        "summary" : "Update or rename a script file.",
        "deprecated" : true,
        "operationId" : "EventResource_replaceScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Script update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ScriptRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "400" : {
            "description" : "Filename already exists."
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update script content or rename script files used in hook configurations.",
          "usage" : [ "Call to modify existing script logic or change script names.", "Use when updating automation scripts without changing hook associations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; New name is unique if changing; Valid script syntax",
            "post_action" : "Script updated; Changes effective in existing hooks; Script cache updated"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New script filename (optional).",
            "required" : false,
            "example" : "updated-backup.sh"
          }, {
            "name" : "contents",
            "in" : "body",
            "description" : "Updated script content (optional).",
            "required" : false,
            "example" : "#!/bin/bash\necho 'Updated script'"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to update from script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if new name conflicts with existing script", "404 if script ID does not exist", "500 if script update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose a unique script name; verify name availability."
          }, {
            "code" : "404",
            "action" : "Verify script ID exists; refresh script list."
          }, {
            "code" : "500",
            "action" : "Check script storage permissions and file system health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Script modification operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hook-scripts/{id}" ],
          "postprocessing_hint" : "Script changes affect all linked hooks; deprecated in favor of /hook-scripts/{id} endpoint.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the script file contents.",
        "operationId" : "EventResource_getScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the raw script content for editing, review, or debugging purposes.",
          "usage" : [ "Call to view script code before making modifications.", "Use to review script logic or debug hook automation issues." ],
          "response_shape" : "String (script content)",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID from script listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if script ID does not exist", "500 if script file access fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify script ID exists; refresh script list."
          }, {
            "code" : "500",
            "action" : "Check script storage system and file permissions."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Script content retrieval"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/events/scripts", "/events/scripts/{id}" ],
          "postprocessing_hint" : "Returns raw script content as plain text; use for editing or review purposes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a script file.",
        "operationId" : "EventResource_deleteScript",
        "tags" : [ "hooks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a hook script file and update the script cache to remove it from available scripts.",
          "usage" : [ "Call when removing unused or outdated hook scripts from the system.", "Use for cleanup when scripts are no longer needed or have been replaced." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Script exists; Not currently linked to active hooks (or hooks will be orphaned)",
            "post_action" : "Script file deleted; Script cache updated; Script no longer available for hook creation"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Script ID to delete from the script database.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if the specified script ID does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Script may have already been deleted; refresh script list to verify current scripts."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Script management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/events/scripts", "/events/hooks" ],
          "postprocessing_hint" : "Script deletion updates cache immediately; existing hooks using this script may become invalid.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting scripts may break existing hooks that depend on this script"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/extra-files-secure/{path}" : {
      "get" : {
        "summary" : "Authenticated static file server for files stored in /config/extra-files-secure, requires a croit account with the SECURE_FOLDER role.",
        "operationId" : "ExtraFileSecureResource_downloadSecureExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/extra-files/{path}" : {
      "get" : {
        "summary" : "Publicly accessible static file server for files stored in /config/extra-files.",
        "operationId" : "ExtraFileResource_downloadExtraFile",
        "tags" : [ "extra-files" ],
        "parameters" : [ {
          "name" : "path",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string",
            "pattern" : ".*"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        }
      }
    },
    "/gateways/iscsi" : {
      "get" : {
        "summary" : "List all iSCSI gateways.",
        "operationId" : "IscsiGatewayResource_getIscsiGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured iSCSI gateway clusters and descriptive metadata.",
          "usage" : [ "Call when rendering the iSCSI gateway overview page.", "Refresh after edits to confirm descriptions and service IDs." ],
          "response_shape" : "PaginationResponse<IscsiGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":25,\"where\":[{\"description\":{\"_ilike\":\"%prod%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":25,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.order.description" : "Sort stable lists of gateways for operators."
          },
          "failure_modes" : [ "200 data=[] when no iSCSI gateways exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Guide users to create an iSCSI gateway via POST /gateways/iscsi."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/servers", "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Render serviceId prominently so follow-up calls can reference it.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/disks" : {
      "get" : {
        "summary" : "List all iSCSI disks.",
        "operationId" : "IscsiGatewayResource_getIscsiDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayDisksResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the list of iSCSI-exposed RBD LUNs with group/host usage details.",
          "usage" : [ "Call when showing which RBD images are exported over iSCSI.", "Refresh after mapping or unmapping LUNs to confirm group/host assignments." ],
          "response_shape" : "PaginationResponse<IscsiGatewayDisksResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"image\":{\"_ilike\":\"%db%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no LUNs are mapped" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after verifying iSCSI gateway pods and Ceph manager logs."
          }, {
            "code" : "200",
            "action" : "Explain that no iSCSI disks are currently exported."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Highlight disks with empty groups to spot unused exports quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/groups" : {
      "get" : {
        "summary" : "List all iSCSI groups.",
        "operationId" : "IscsiGatewayResource_getIscsiGroups",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayGroupsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve iSCSI initiator groups with their members and mapped LUNs.",
          "usage" : [ "Load before editing group memberships or presenting access summaries.", "Refresh after changes to the iSCSI gateway config to confirm group composition." ],
          "response_shape" : "PaginationResponse<IscsiGatewayGroupsResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"group\":{\"_ilike\":\"%db%\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no groups are defined" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry with exponential backoff and inspect Ceph iSCSI gateway logs."
          }, {
            "code" : "200",
            "action" : "Indicate that no initiator groups are present currently."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI config snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/hosts", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Group response entries by serviceId and surface luns list so UI can expand per group.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/hosts" : {
      "get" : {
        "summary" : "List all iSCSI hosts.",
        "operationId" : "IscsiGatewayResource_getIscsiHosts",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayHostsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate iSCSI hosts, their credentials, group membership, and attached LUNs.",
          "usage" : [ "Fetch when displaying host access configuration or auditing CHAP credentials.", "Refresh after modifying hosts/groups to verify the resulting mappings." ],
          "response_shape" : "PaginationResponse<IscsiGatewayHostsResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"group\":{\"_eq\":\"production\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "failure_modes" : [ "500 if Ceph iSCSI configuration retrieval fails", "200 data=[] when no hosts are configured" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking iSCSI gateway daemons; include stderr in support logs."
          }, {
            "code" : "200",
            "action" : "Explain that no hosts have been created yet."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "iSCSI host snapshot"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi/groups", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Mask passwords when presenting to users lacking admin privileges; rely on username and luns for detail.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/iscsi/servers" : {
      "get" : {
        "summary" : "List all iSCSI servers.",
        "operationId" : "IscsiGatewayResource_getIscsiServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseIscsiGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Show iSCSI target services mapped to servers including health state and addresses.",
          "usage" : [ "Fetch when presenting the iSCSI server list so operators can verify IP and health.", "Re-query after modifying gateway services or Ceph config to validate deployment." ],
          "response_shape" : "PaginationResponse<IscsiGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter down to unhealthy targets for remediation.",
            "pagination.order.hostname" : "Keep server ordering predictable across refreshes."
          },
          "failure_modes" : [ "500 if fetching iSCSI configuration from Ceph fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking Ceph manager health; fall back to service logs for details."
          }, {
            "code" : "200",
            "action" : "If the list is empty, confirm that gateway services are deployed."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "iSCSI server status polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/iscsi", "/gateways/iscsi/groups", "/gateways/iscsi/hosts" ],
          "postprocessing_hint" : "Cross-reference config.gateways from Ceph to highlight servers known to Ceph but missing in croit.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs" : {
      "get" : {
        "summary" : "List all nfs clusters.",
        "operationId" : "NfsGatewayResource_getNfsGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate configured NFS gateway clusters and their base configuration.",
          "usage" : [ "Call to populate the NFS gateway overview before drilling into servers or exports.", "Refresh after creating or editing a gateway to verify forceSecure and transport defaults." ],
          "response_shape" : "PaginationResponse<NfsGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":25,\"where\":[{\"forceSecure\":{\"_eq\":true}}]}).",
            "required" : false,
            "example" : "{\"limit\":25,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS before attaching hosts.",
            "pagination.order.description" : "Sort consistently for large environments."
          },
          "failure_modes" : [ "200 data=[] when no NFS gateways are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display guidance on how to create an NFS gateway cluster."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs/servers", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Surface entries with non-empty hints first so admins notice configuration issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/exports" : {
      "get" : {
        "summary" : "List all nfs exports.",
        "operationId" : "NfsGatewayResource_getNfsExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayExportResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NFS exports, paths, and client permissions for all clusters.",
          "usage" : [ "Call before presenting export configuration so ACLs and protocols are visible.", "Refresh after creating, patching, or deleting exports to confirm the resulting state." ],
          "response_shape" : "PaginationResponse<NfsGatewayExportResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"serviceId\":{\"_eq\":1}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.serviceId" : "Limit exports to a single gateway before editing.",
            "pagination.where.path" : "Search for exports pointing at specific CephFS directories."
          },
          "failure_modes" : [ "200 data=[] when no exports exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a prompt describing how to create exports via POST /gateways/nfs/exports."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NFS export inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/servers" ],
          "postprocessing_hint" : "Group results by serviceId and display accessJoined for quick ACL review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nfs/servers" : {
      "get" : {
        "summary" : "List all nfs servers.",
        "operationId" : "NfsGatewayResource_getNfsServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNfsGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NFS gateway services per server including health information.",
          "usage" : [ "Fetch when rendering the NFS server table to expose hostnames, IPs and health.", "Re-query after restarting services or adjusting HA settings to confirm status changes." ],
          "response_shape" : "PaginationResponse<NfsGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy entries for alerting.",
            "pagination.order.hostname" : "Keep server order stable across refreshes."
          },
          "failure_modes" : [ "200 data=[] when no NFS gateway services are registered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no servers are mapped to the selected gateway yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS server status refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nfs", "/gateways/nfs/exports" ],
          "postprocessing_hint" : "Highlight servers with healthy=false or missing IPs so admins can remediate quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof" : {
      "get" : {
        "summary" : "List all NVMe-oF clusters.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFGatewayResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF gateway clusters including transport defaults and configuration hints.",
          "usage" : [ "Call before displaying the NVMe-oF overview dashboard.", "Refresh after task-based changes (e.g. add/delete gateway) to confirm state and surface hints." ],
          "response_shape" : "PaginationResponse<NvmeOFGatewayResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":20,\"where\":[{\"forceSecure\":{\"_eq\":true}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.forceSecure" : "Filter clusters that enforce TLS.",
            "pagination.order.name" : "Keep cluster ordering stable for operators."
          },
          "failure_modes" : [ "500 if NVMe-oF service status refresh fails", "200 data=[] when no NVMe-oF clusters exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting nvmeof-target tasks; include configurator logs for support."
          }, {
            "code" : "200",
            "action" : "Explain that no NVMe-oF clusters are configured yet and reference POST /gateways/nvmeof."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF gateway inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Flag gateways with non-empty hints to prompt admins to run remediation tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new NVMe-oF gateway cluster for high-performance block storage over fabrics.",
          "usage" : [ "Call when setting up NVMe-oF block storage access for client applications.", "Use to create scalable, high-performance storage access over RDMA or TCP networks." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Servers have SPDK support; NICs accessible; Network fabric configured; Valid transport settings",
            "post_action" : "Cluster created; Default subsystem added; Target services deployed; Listeners configured on fabrics"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Display name for the NVMe-oF cluster.",
            "required" : true,
            "example" : "production-nvmeof"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description for the cluster purpose.",
            "required" : false,
            "example" : "Production NVMe-oF gateway for application storage"
          }, {
            "name" : "forceSecure",
            "in" : "body",
            "description" : "Require TLS for all listeners in this cluster.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "transportDefaults",
            "in" : "body",
            "description" : "Default transport configurations for cluster services.",
            "required" : false,
            "example" : "[{\"type\": \"TCP\", \"maxQueueDepth\": 128}]"
          }, {
            "name" : "services",
            "in" : "body",
            "description" : "Initial target services to deploy on cluster nodes.",
            "required" : true,
            "example" : "[{\"serverId\": 1, \"listeners\": [...]}]"
          } ],
          "failure_modes" : [ "404 if specified server IDs or NIC IDs do not exist", "400 if server lacks SPDK support or configuration is invalid", "500 if cluster creation or service deployment fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify all server and NIC IDs exist; check hardware availability."
          }, {
            "code" : "400",
            "action" : "Ensure servers have SPDK-enabled images; validate listener and transport configurations."
          }, {
            "code" : "500",
            "action" : "Check server connectivity, SPDK daemon status, and network fabric configuration."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "NVMe-oF cluster creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/{gatewayId}" ],
          "postprocessing_hint" : "Monitor task progress for cluster setup; services will be configured with SPDK; cluster ready for subsystem and namespace configuration.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating NVMe-oF cluster requires SPDK configuration and may affect server networking"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters" : {
      "post" : {
        "summary" : "Add a new NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_setNvmeOFCephCluster",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFCephClusterResponse"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List all NVMe-oF ceph cluster configurations.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFCephClusters",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFCephClusterResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured Ceph cluster connections for NVMe-oF block device access.",
          "usage" : [ "Call when setting up NVMe-oF gateways to show available Ceph clusters for block device sources.", "Use to verify cluster connectivity before creating new block device mappings." ],
          "response_shape" : "PaginationResponse<NvmeOFCephClusterResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters for cluster list.",
            "required" : false,
            "example" : "{\"limit\":20}"
          } ],
          "failure_modes" : [ "200 with empty list if no Ceph clusters are configured for NVMe-oF" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates no Ceph clusters are configured; add clusters via POST /gateways/nvmeof/ceph-clusters."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Cluster configuration access"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/bdevs", "/gateways/nvmeof" ],
          "postprocessing_hint" : "Display cluster connectivity status; clusters are used as sources for RBD block devices in NVMe-oF subsystems.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/ceph-clusters/{name}" : {
      "delete" : {
        "summary" : "Remove a NVMe-oF ceph cluster configuration.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFCephCluster",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks" : {
      "get" : {
        "summary" : "List all NVMe-oF disks.",
        "operationId" : "NvmeOFBdevResource_getNvmeOFDisks",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF disks (Ceph RBD or DAOS) with identifiers, size, hints, and subsystem memberships.",
          "usage" : [ "Fetch before attaching disks to subsystems or auditing exported storage.", "Refresh after provisioning tasks to confirm image size lookups and DAOS metadata resolved without errors." ],
          "response_shape" : "PaginationResponse<NvmeOFDiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":2}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter to CEPH or DAOS disks depending on workflow.",
            "pagination.where.subsystems" : "Identify disks already attached to specific subsystems."
          },
          "failure_modes" : [ "500 if Ceph/DAOS metadata queries fail", "200 data=[] when no NVMe-oF disks are defined" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after confirming Ceph/DAOS connectivity; inspect hints array for partial failures."
          }, {
            "code" : "200",
            "action" : "Inform the user that no disks are exported yet."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "NVMe-oF disk inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Draw attention to entries with non-empty hints to highlight disks that need remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_addNvmeOFBdev",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NVMe-oF disk backed by either a Ceph RBD image or a DAOS object.",
          "usage" : [ "Expose a freshly created RBD image to NVMe-oF hosts via selected subsystems.", "Attach an existing DAOS disk to NVMe-oF after validating cluster prerequisites." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "type",
            "in" : "body",
            "description" : "NVMe-oF backend type: CEPH or DAOS.",
            "required" : true,
            "example" : "CEPH"
          }, {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "Gateway cluster ID hosting the disk.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subsystems[]",
            "in" : "body",
            "description" : "Subsystem IDs to attach immediately.",
            "required" : true,
            "example" : "[12]"
          }, {
            "name" : "pool/image",
            "in" : "body",
            "description" : "Ceph pool and RBD image (required for CEPH type).",
            "required" : false,
            "example" : "pool=nvme,image=lun01"
          }, {
            "name" : "daosDisk/daosId",
            "in" : "body",
            "description" : "Either reference an existing DAOS disk or provide DAOS cluster + pool/container info.",
            "required" : false,
            "example" : "daosDisk=42"
          }, {
            "name" : "blockSize",
            "in" : "body",
            "description" : "Block size in bytes (required for DAOS and optional override for CEPH).",
            "required" : false,
            "example" : "4096"
          } ],
          "failure_modes" : [ "400 if namespaces are supplied, required fields are missing, or validation checks fail (e.g. DAOS disk attached to multiple subsystems)", "404 if the gateway, subsystem, DAOS disk, or NIC references do not exist", "200 ManagedThreadTask(status=FAILED) if nvmeof-target reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the payload (remove namespace, supply mandatory fields, ensure blockSize is 512-aligned) and retry."
          }, {
            "code" : "404",
            "action" : "Refresh NVMe-oF inventories to pick valid IDs before resubmitting."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedThreadTask log and NVMe-oF configurator output, fix host issues, then rerun the task."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk provisioning"
          },
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/disks to confirm the disk appears with the expected subsystem bindings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_updateNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an NVMe-oF disk and propagate changes to the backing storage (Ceph RBD or DAOS).",
          "usage" : [ "Expand a Ceph-backed NVMe-oF LUN after increasing the application quota.", "Grow DAOS-backed exports once additional capacity has been provisioned." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "New size in bytes; omit to leave the disk unchanged.",
            "required" : false,
            "example" : "549755813888"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "200 null when no size is provided (no-op)", "400 if attempting to shrink a DAOS-backed disk", "500 if underlying Ceph/DAOS resize commands fail" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Provide a new size to trigger a resize."
          }, {
            "code" : "400",
            "action" : "Detach the disk from NVMe-oF and adjust it within DAOS before attempting to shrink."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedThreadTask log and storage backends; fix the issue then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk resize"
          },
          "related_endpoints" : [ "/gateways/nvmeof/disks", "/gateways/nvmeof/disks/{diskId}", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a NVMe-oF disk.",
        "operationId" : "NvmeOFBdevResource_removeNvmeOFDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DeleteDiskRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an NVMe-oF disk from the gateway, optionally deleting the backing RBD image.",
          "usage" : [ "Retire LUNs no longer needed by clients.", "Remove test disks while optionally cleaning up Ceph data." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "Set true to delete the underlying RBD image.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "diskId",
            "in" : "path",
            "description" : "NVMe-oF disk identifier.",
            "required" : true,
            "example" : "17"
          } ],
          "failure_modes" : [ "404 if the disk ID does not exist", "500 if gateway reconfiguration or Ceph deletion fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List NVMe-oF disks to verify the ID before retrying."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target and Ceph logs; clean up partially removed resources before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF disk removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services/{serviceId}/transports/{type}", "/gateways/nvmeof/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts" : {
      "get" : {
        "summary" : "List all NVMe-oF hosts.",
        "operationId" : "NvmeOFHostResource_getNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFHostResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF hosts (NQNs) with shared key status, subsystem memberships, and attached disks.",
          "usage" : [ "Fetch when auditing NVMe-oF access or before attaching hosts to subsystems.", "Refresh after task-managed host changes to confirm shared key masking and assignments." ],
          "response_shape" : "PaginationResponse<NvmeOFHostResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":3}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.hasSharedKey" : "Identify hosts that require TLS PSK enrollment.",
            "pagination.where.subsystems" : "Filter hosts attached to specific subsystems before detaching."
          },
          "failure_modes" : [ "500 if host data cannot be retrieved", "200 data=[] when no NVMe-oF hosts exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting nvmeof-target logs; ensure configurator finished running."
          }, {
            "code" : "200",
            "action" : "Inform the user that no hosts are registered with the gateway yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF host inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Mask sharedKey unless the actor has admin privileges; rely on hasSharedKey for UX cues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_addNvmeOFHost",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a new NVMe-oF host (client) with authentication credentials for subsystem access.",
          "usage" : [ "Call when onboarding new clients that need NVMe-oF storage access.", "Use to create host entries with optional authentication for secure storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; NQN is unique; Valid shared key format; Subsystems exist and match cluster",
            "post_action" : "Host registered; Authentication configured; Access granted to specified subsystems"
          },
          "request_parameters" : [ {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "NVMe-oF cluster ID where the host will be registered.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "nqn",
            "in" : "body",
            "description" : "NVMe Qualified Name for the client host (must be unique within cluster).",
            "required" : true,
            "example" : "nqn.2014-08.org.client:host01"
          }, {
            "name" : "sharedKey",
            "in" : "body",
            "description" : "Optional pre-shared key for host authentication (experimental feature).",
            "required" : false,
            "example" : "PSK:NVMeTLSkey01:..."
          }, {
            "name" : "subsystems",
            "in" : "body",
            "description" : "List of subsystem IDs to immediately grant access to.",
            "required" : false,
            "example" : "[1, 2]"
          } ],
          "failure_modes" : [ "400 if NQN is too long, already exists, invalid shared key format, or subsystem mismatch", "404 if cluster or subsystem IDs do not exist", "500 if host creation or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique NQN; validate shared key format; ensure subsystems belong to same cluster."
          }, {
            "code" : "404",
            "action" : "Verify cluster and subsystem IDs exist; check configuration."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity and NVMe-oF target service health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Host registration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for host registration; shared keys require secure channel configuration; host can immediately access specified subsystems.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Shared keys are experimental and require secure channels; ensure proper security configuration"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/hosts/{hostId}" : {
      "put" : {
        "summary" : "Update an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_updateNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF host update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NVMe-oF host configuration including NQN and access credentials.",
          "usage" : [ "Call when updating host identification or authentication settings.", "Use to modify host metadata or reconfigure security credentials." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Host exists; NQN is valid if specified; Authentication data is properly formatted",
            "post_action" : "Host configuration updated; New credentials deployed; Subsystem access updated; Active connections may require reauthentication"
          },
          "request_parameters" : [ {
            "name" : "nqn",
            "in" : "body",
            "description" : "New NVMe Qualified Name for the host (optional).",
            "required" : false,
            "example" : "nqn.2014-08.org.nvmexpress:uuid:12345678-1234-1234-1234-123456789abc"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "New description for the host (optional).",
            "required" : false,
            "example" : "Database server cluster node 1"
          }, {
            "name" : "authCredentials",
            "in" : "body",
            "description" : "Updated authentication credentials (optional).",
            "required" : false,
            "example" : "{\\\"username\\\":\\\"dbuser\\\",\\\"password\\\":\\\"secure-password\\\"}"
          } ],
          "path_parameters" : [ {
            "name" : "hostId",
            "in" : "path",
            "description" : "Host ID to update.",
            "required" : true,
            "example" : "8"
          } ],
          "failure_modes" : [ "404 if the host doesn't exist", "400 if NQN format is invalid or authentication credentials are malformed", "409 if NQN conflicts with existing host", "500 if host configuration update fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify host ID exists with GET /gateways/nvmeof/hosts before updating."
          }, {
            "code" : "400",
            "action" : "Ensure NQN follows NVMe standards and authentication data is correctly formatted."
          }, {
            "code" : "409",
            "action" : "Choose a unique NQN that doesn't conflict with existing hosts."
          }, {
            "code" : "500",
            "action" : "Check gateway service status and authentication systems before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host configuration changes"
          },
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for gateway-specific results; hosts may need to reconnect for authentication changes to take effect.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF host.",
        "operationId" : "NvmeOFHostResource_removeNvmeOFHost",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NVMe-oF host registration and revoke all subsystem access permissions.",
          "usage" : [ "Call when decommissioning clients or revoking NVMe-oF storage access.", "Use to clean up host registrations for clients no longer needing storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Host exists; Understand connection impact; Data safety confirmed",
            "post_action" : "Host registration removed; All subsystem access revoked; Active connections terminated"
          },
          "path_parameters" : [ {
            "name" : "hostId",
            "in" : "path",
            "description" : "Host ID to remove from host listings.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if host does not exist", "500 if host removal or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify host ID exists; host may have already been removed."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity; active connections from this host will be terminated."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Host removal operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for host removal; client loses immediate access to all subsystems; connections terminated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing host will immediately terminate all connections and revoke storage access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/listeners" : {
      "get" : {
        "summary" : "List all NVMe-oF listeners.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFListeners",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFListenerConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate NVMe-oF listeners across services including NIC, VLAN, port and TLS settings.",
          "usage" : [ "Call when displaying listener configuration to operators or ahead of network audits.", "Refresh after adding/removing listeners to confirm the configurator committed changes." ],
          "response_shape" : "PaginationResponse<NvmeOFListenerConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"type\":{\"_eq\":\"TCP\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.gatewayId" : "Filter listeners to a specific cluster before editing.",
            "pagination.where.secure" : "Identify listeners that already enforce TLS."
          },
          "failure_modes" : [ "500 if the DAO cannot retrieve listeners", "200 data=[] when no listeners are present" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking nvmeof-target tasks; resync the gateway if errors persist."
          }, {
            "code" : "200",
            "action" : "Inform the user that no listeners are defined yet."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof" ],
          "postprocessing_hint" : "Display nicName and vlan to align network automation with listener placement.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/services" : {
      "get" : {
        "summary" : "List all NVMe-oF services.",
        "operationId" : "NvmeOFGatewayResource_getNvmeOFServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF target services per server with hugepage config, NIC bindings, and errors.",
          "usage" : [ "Fetch when reviewing NVMe-oF deployment health to inspect service-level hints.", "Poll after task-managed changes (add/remove service, update listeners) to confirm the configurator applied updates." ],
          "response_shape" : "PaginationResponse<NvmeOFServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"gatewayId\":{\"_eq\":5}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.error" : "Filter services with outstanding configurator hints.",
            "pagination.order.serverHostname" : "Maintain ordering by host for easier comparisons."
          },
          "failure_modes" : [ "500 if NVMe-oF configurator fails to refresh service status", "200 data=[] when no services exist for the selected gateways" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after checking nvmeof-target logs; do not proceed with automation until status refresh succeeds."
          }, {
            "code" : "200",
            "action" : "Warn that no services are currently configured for these gateways."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF service health"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/listeners", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Highlight entries with non-null error or mismatched nrHugepages to prompt corrective actions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/nvmeof/subsystems" : {
      "get" : {
        "summary" : "List all NVMe-oF subsystems.",
        "operationId" : "NvmeOFSubsystemResource_getNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseNvmeOFSubsystemResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NVMe-oF subsystems with host and disk membership metadata.",
          "usage" : [ "Fetch before presenting subsystem details or attaching hosts/disks.", "Refresh after task operations (attach/detach) to validate membership state." ],
          "response_shape" : "PaginationResponse<NvmeOFSubsystemResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"gatewayId\":{\"_eq\":4}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.hosts" : "Filter subsystems that already expose to specific hosts.",
            "pagination.where.disks" : "Identify subsystems using a particular disk ID."
          },
          "failure_modes" : [ "500 if subsystem data cannot be retrieved", "200 data=[] when no subsystems exist" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after ensuring nvmeof-target configuration succeeded; review configurator logs."
          }, {
            "code" : "200",
            "action" : "Communicate that no subsystems are defined yet and point to POST /gateways/nvmeof/subsystems."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 300,
            "note" : "NVMe-oF subsystem inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/nvmeof/hosts", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Expose hostsFormatted and disksFormatted so UIs can show readable membership chips.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_addNvmeOFSubsystem",
        "tags" : [ "services" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new NVMe-oF subsystem for organizing namespaces and controlling host access to storage.",
          "usage" : [ "Call when setting up new storage partitions for different applications or tenants.", "Use to create isolated storage access domains within an NVMe-oF cluster." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; NQN is unique; Valid NQN format; Cluster services running",
            "post_action" : "Subsystem created; Available for host and disk attachment; Cluster configuration updated"
          },
          "request_parameters" : [ {
            "name" : "gatewayId",
            "in" : "body",
            "description" : "NVMe-oF cluster ID where the subsystem will be created.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "nqn",
            "in" : "body",
            "description" : "NVMe Qualified Name for the subsystem (must be unique within cluster).",
            "required" : true,
            "example" : "nqn.2024-06.io.croit:app-storage"
          } ],
          "failure_modes" : [ "400 if NQN is too long, already exists, or cluster does not exist", "500 if subsystem creation or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique NQN within cluster; ensure NQN follows naming conventions and length limits."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity and NVMe-oF target service health; verify SPDK configuration."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Subsystem creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for subsystem creation; ready for host and namespace configuration; use attach endpoints to add storage and access controls.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_updateNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Subsystem update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFSubsystemUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Modify configuration of an existing NVMe-oF subsystem including namespaces and host access.",
          "usage" : [ "Call when adding/removing block devices from subsystems or updating access controls.", "Use to modify subsystem metadata or reconfigure allowed hosts for security." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem exists; NQN is valid if specified; Block devices and hosts exist; No active I/O disruption planned",
            "post_action" : "Subsystem reconfigured; Namespace mappings updated; Host access controls applied; Active connections may require reconnection"
          },
          "request_parameters" : [ {
            "name" : "nqn",
            "in" : "body",
            "description" : "New NVMe Qualified Name for the subsystem (optional).",
            "required" : false,
            "example" : "nqn.2023-01.io.croit:subsystem-prod"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "New description for the subsystem (optional).",
            "required" : false,
            "example" : "Production storage subsystem"
          }, {
            "name" : "allowedHosts",
            "in" : "body",
            "description" : "Updated list of host IDs allowed to access this subsystem (optional).",
            "required" : false,
            "example" : "[1, 2, 3]"
          }, {
            "name" : "blockDeviceIds",
            "in" : "body",
            "description" : "Updated list of block device IDs to expose as namespaces (optional).",
            "required" : false,
            "example" : "[10, 11]"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to update.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the subsystem doesn't exist", "400 if NQN format is invalid or block device IDs are invalid", "409 if NQN conflicts with existing subsystem", "500 if subsystem reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify subsystem ID exists with GET /gateways/nvmeof/subsystems before updating."
          }, {
            "code" : "400",
            "action" : "Ensure NQN follows format standards and all block device IDs exist."
          }, {
            "code" : "409",
            "action" : "Choose a unique NQN that doesn't conflict with existing subsystems."
          }, {
            "code" : "500",
            "action" : "Check gateway service status and verify block devices are accessible before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Subsystem configuration changes"
          },
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts", "/gateways/nvmeof/bdevs" ],
          "postprocessing_hint" : "Monitor task for per-gateway results; clients may need to rediscover namespaces after block device changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_removeNvmeOFSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an NVMe-oF subsystem and remove all associated namespaces and host access controls.",
          "usage" : [ "Call when decommissioning storage partitions or cleaning up unused subsystems.", "Use to remove storage access domains that are no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem exists; No active client connections; Data backed up if needed",
            "post_action" : "Subsystem deleted; Namespaces removed; Host access revoked; Cluster configuration updated"
          },
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to delete from subsystem listings.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if subsystem does not exist", "500 if subsystem deletion or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify subsystem ID exists; subsystem may have already been deleted."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity and ensure no active client connections to subsystem."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Subsystem deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems" ],
          "postprocessing_hint" : "Monitor task for deletion progress; client connections will be terminated; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting subsystem will remove all namespaces and terminate client access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-disks" : {
      "post" : {
        "summary" : "Attach disks to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Disk attachment configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Attach storage devices to an NVMe-oF subsystem as namespaces for client access.",
          "usage" : [ "Call when adding storage capacity to existing subsystems.", "Use to expose new block devices through NVMe-oF to connected clients." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and disks exist; Same cluster; Within namespace limits; No DAOS conflicts",
            "post_action" : "Disks attached as namespaces; Storage exposed to clients; Namespace IDs assigned"
          },
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "List of NVMe-oF disk IDs to attach as namespaces.",
            "required" : true,
            "example" : "[10, 11, 12]"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to attach storage devices to.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if disks belong to different cluster, exceed max namespaces, or DAOS disk conflicts", "404 if subsystem or disk IDs do not exist", "500 if disk attachment or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure disks belong to same cluster; check namespace limits; verify DAOS disks aren't attached elsewhere."
          }, {
            "code" : "404",
            "action" : "Verify subsystem and disk IDs exist; check storage device availability."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity and storage backend health; verify SPDK bdev configuration."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Storage attachment operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Monitor task for storage attachment; clients may need to rescan for new namespaces; check namespace limits before adding more disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/attach-hosts" : {
      "post" : {
        "summary" : "Attach hosts to an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_attachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Grant host access to an NVMe-oF subsystem by attaching hosts to the access control list.",
          "usage" : [ "Call when granting new clients access to storage subsystems.", "Use to expand access permissions for existing storage partitions." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and hosts exist; Hosts belong to same cluster; Valid access permissions",
            "post_action" : "Hosts granted access; ACLs updated; Clients can connect to subsystem"
          },
          "request_parameters" : [ {
            "name" : "hosts",
            "in" : "body",
            "description" : "List of host IDs to grant access to the subsystem.",
            "required" : true,
            "example" : "[1, 2, 3]"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to attach hosts to.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if hosts belong to different cluster than subsystem", "404 if subsystem or host IDs do not exist", "500 if host attachment or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure hosts and subsystem belong to the same NVMe-oF cluster."
          }, {
            "code" : "404",
            "action" : "Verify subsystem and host IDs exist; check cluster configuration."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity and NVMe-oF target service health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host access management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for access configuration; attached hosts can now connect to subsystem namespaces.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-disks" : {
      "post" : {
        "summary" : "Detach disks from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachDisksToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFDisksAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove storage devices from an NVMe-oF subsystem to stop exposing them as namespaces.",
          "usage" : [ "Call when removing storage capacity or decommissioning storage devices.", "Use to stop exposing block devices through NVMe-oF to connected clients." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and disks exist; No active I/O; Data safety confirmed; Clients notified",
            "post_action" : "Disks detached; Namespaces removed; Storage no longer accessible to clients"
          },
          "request_parameters" : [ {
            "name" : "disks",
            "in" : "body",
            "description" : "List of NVMe-oF disk IDs to detach from namespaces.",
            "required" : true,
            "example" : "[10, 11]"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to detach storage devices from.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if subsystem or disk IDs do not exist", "500 if disk detachment or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify subsystem and disk IDs exist; disks may already be detached."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity; ensure no active I/O to these namespaces before detachment."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Storage detachment operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/disks" ],
          "postprocessing_hint" : "Monitor task for storage detachment; namespaces removed from client view; ensure client applications handle namespace removal gracefully.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Detaching disks will remove namespaces and may cause data unavailability for clients"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/subsystems/{subsystemId}/detach-hosts" : {
      "post" : {
        "summary" : "Detach hosts from an NVMe-oF subsystem.",
        "operationId" : "NvmeOFSubsystemResource_detachHostsToSubsystem",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "subsystemId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFHostsAttachRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Revoke host access from an NVMe-oF subsystem by removing hosts from the access control list.",
          "usage" : [ "Call when revoking client access to storage subsystems for security.", "Use to remove access permissions during client decommissioning." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Subsystem and hosts exist; Understand connection impact; Data safety confirmed",
            "post_action" : "Host access revoked; ACLs updated; Active connections terminated"
          },
          "request_parameters" : [ {
            "name" : "hosts",
            "in" : "body",
            "description" : "List of host IDs to revoke access from the subsystem.",
            "required" : true,
            "example" : "[1, 2]"
          } ],
          "path_parameters" : [ {
            "name" : "subsystemId",
            "in" : "path",
            "description" : "Subsystem ID to detach hosts from.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if subsystem or host IDs do not exist", "500 if host detachment or cluster reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify subsystem and host IDs exist; hosts may already be detached."
          }, {
            "code" : "500",
            "action" : "Check cluster connectivity; active connections from these hosts will be terminated."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Host access revocation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/subsystems", "/gateways/nvmeof/hosts" ],
          "postprocessing_hint" : "Monitor task for access revocation; detached hosts lose immediate access; connections terminated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Detaching hosts will immediately terminate their connections to the subsystem"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}" : {
      "patch" : {
        "summary" : "Update name or description of an NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFGatewayUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update configuration settings for an existing NVMe-oF gateway cluster.",
          "usage" : [ "Call when modifying gateway cluster name or description for better organization.", "Use to update gateway metadata without affecting active connections." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Gateway exists; New name is unique if specified; Cluster is accessible",
            "post_action" : "Gateway metadata updated; Changes visible in management UI; Active connections unaffected"
          },
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New name for the gateway cluster (optional).",
            "required" : false,
            "example" : "production-nvmeof"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "New description for the gateway cluster (optional).",
            "required" : false,
            "example" : "Production NVMe-oF cluster for high-performance workloads"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "Gateway cluster ID to update.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the gateway doesn't exist", "409 if the new name conflicts with existing gateway", "500 if gateway update fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify gateway ID exists with GET /gateways/nvmeof before updating."
          }, {
            "code" : "409",
            "action" : "Choose a unique name that doesn't conflict with existing gateways."
          }, {
            "code" : "500",
            "action" : "Check gateway service status and cluster connectivity before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Gateway configuration changes"
          },
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/{gatewayId}" ],
          "postprocessing_hint" : "Verify changes with GET /gateways/nvmeof/{gatewayId}; metadata changes don't affect I/O performance.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an NVMe-oF cluster. This also deletes all services and configuration associated with the cluster.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an NVMe-oF gateway cluster and all associated services, subsystems, and configurations.",
          "usage" : [ "Call when decommissioning NVMe-oF storage access or cleaning up unused clusters.", "Use for complete removal of NVMe-oF infrastructure from specific servers." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; No active client connections; Data backed up if needed",
            "post_action" : "All services stopped; SPDK targets removed; Configuration cleaned up; Cluster deleted"
          },
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to delete from cluster listings.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if NVMe-oF cluster does not exist", "500 if cluster deletion fails or services cannot be stopped" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster ID exists; cluster may have already been deleted."
          }, {
            "code" : "500",
            "action" : "Check server connectivity and SPDK daemon status; some services may need manual cleanup."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Cluster deletion operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task progress for cleanup; client connections will be terminated; servers will release SPDK resources; operation cannot be undone.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting NVMe-oF cluster will stop all storage access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NVMe-oF service configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add a new NVMe-oF target service to an existing cluster for expanded storage access points.",
          "usage" : [ "Call when scaling out NVMe-oF cluster to additional servers or network fabrics.", "Use to add redundant target services for high availability storage access." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; Server has SPDK support; NICs accessible; No listener conflicts",
            "post_action" : "Target service deployed; Hugepages configured; Listeners bound to fabrics; Service ready for subsystem attachment"
          },
          "request_parameters" : [ {
            "name" : "serverId",
            "in" : "body",
            "description" : "Server ID where the target service will run.",
            "required" : true,
            "example" : "2"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description for the target service.",
            "required" : false,
            "example" : "Additional target service for HA"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "Number of hugepages to configure for SPDK on this server.",
            "required" : false,
            "example" : "1024"
          }, {
            "name" : "listeners",
            "in" : "body",
            "description" : "Network listeners for client connections.",
            "required" : true,
            "example" : "[{\"type\": \"TCP\", \"nicId\": 5, \"port\": 4420}]"
          }, {
            "name" : "transports",
            "in" : "body",
            "description" : "Custom transport configurations for this service.",
            "required" : false,
            "example" : "[{\"type\": \"TCP\", \"maxQueueDepth\": 256}]"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to add the service to.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if cluster, server, or NIC IDs do not exist", "400 if server lacks SPDK support or has conflicting listeners", "500 if service deployment fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster, server, and NIC IDs exist; check hardware availability."
          }, {
            "code" : "400",
            "action" : "Ensure server has SPDK-enabled image; check for port conflicts; validate listener configurations."
          }, {
            "code" : "500",
            "action" : "Check server connectivity, SPDK daemon status, and network fabric configuration."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Service addition operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/{gatewayId}", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task for service deployment; hugepages allocated on server; service available for subsystem configuration.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/reconfigure" : {
      "post" : {
        "summary" : "Reconfigure the NVMe-oF cluster.",
        "operationId" : "NvmeOFGatewayResource_reconfigureNvmeOFGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "fromScratch",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reconfigure and redeploy NVMe-oF cluster services to apply configuration changes or fix issues.",
          "usage" : [ "Call after configuration changes to apply updates across all cluster services.", "Use to recover from configuration drift or service deployment issues." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster exists; Services accessible; Configuration valid; Backup recommended",
            "post_action" : "Services reconfigured; SPDK targets updated; Listeners rebound; Configuration synchronized"
          },
          "request_parameters" : [ {
            "name" : "fromScratch",
            "in" : "query",
            "description" : "Force complete reconfiguration from scratch instead of incremental updates.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF cluster ID to reconfigure.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if NVMe-oF cluster does not exist", "500 if reconfiguration fails or services cannot be restarted" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify cluster ID exists and is properly configured."
          }, {
            "code" : "500",
            "action" : "Check server connectivity, SPDK daemon status, and configuration validity; may need manual intervention."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Cluster reconfiguration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/gateways/nvmeof/{gatewayId}", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Monitor task for service restart progress; brief service interruption expected; configuration drift resolved after completion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Reconfiguration may temporarily interrupt client connections during service restart"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NVMe-oF service metadata, ANA state, transports, listeners, or hugepage settings.",
          "usage" : [ "Modify service parameters after hardware or configuration changes.", "Adjust ANA state or listener definitions as part of maintenance." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional user-facing description for the service.",
            "required" : false,
            "example" : "NVMe-oF target on node12"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "Desired hugepage allocation for the server.",
            "required" : false,
            "example" : "4096"
          }, {
            "name" : "anaState",
            "in" : "body",
            "description" : "ANA state to apply to all listeners.",
            "required" : false,
            "example" : "optimized"
          }, {
            "name" : "transports",
            "in" : "body",
            "description" : "Full list of transport configs to replace existing ones.",
            "required" : false,
            "example" : "[{\"type\":\"TCP\",\"maxIoSize\":1048576}]"
          }, {
            "name" : "listeners",
            "in" : "body",
            "description" : "Listener definitions to overwrite current configuration.",
            "required" : false,
            "example" : "[{\"type\":\"TCP\",\"nicId\":101,\"port\":4420}]"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if requested ANA state is invalid or listeners reference unsupported NICs", "404 if the gateway or service ID is unknown", "500 if nvmeof-target reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate requested parameters against cluster policy (forceSecure, NIC availability)."
          }, {
            "code" : "404",
            "action" : "Refresh the service list and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve errors, then resubmit the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF service reconfiguration"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to ensure updated settings are reflected before proceeding.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/errors" : {
      "delete" : {
        "summary" : "Forget any config errors associated with this service.",
        "operationId" : "NvmeOFGatewayResource_forgetNvmeOFConfigErrors",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clear cached NVMe-oF service configuration errors after they have been addressed.",
          "usage" : [ "Call once operators have fixed the reported misconfiguration and want the dashboard to reset.", "Use to acknowledge resolved errors before triggering a fresh service rescan." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID whose error cache should be cleared.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the service record no longer exists" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service list; recreate the service if it was deleted."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF error acknowledgements"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/services to confirm the error array is empty.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners" : {
      "post" : {
        "summary" : "Add a new listener to an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_addNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NVMe-oF listener bound to a specific NIC/VLAN for a target service.",
          "usage" : [ "Call when onboarding new fabrics or scaling out access points for an NVMe-oF service.", "Use right after provisioning additional NICs to expose the service on the new network segment." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "body.type",
            "in" : "body",
            "description" : "Transport type (TCP, RDMA, etc.).",
            "required" : true,
            "example" : "TCP"
          }, {
            "name" : "body.nicId",
            "in" : "body",
            "description" : "NIC ID to bind the listener to.",
            "required" : true,
            "example" : "101"
          }, {
            "name" : "body.vlanId",
            "in" : "body",
            "description" : "Optional VLAN ID for tagged listeners.",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "body.port",
            "in" : "body",
            "description" : "Override port; null falls back to cluster default.",
            "required" : false,
            "example" : "4420"
          }, {
            "name" : "body.secure",
            "in" : "body",
            "description" : "Set true to request TLS, subject to cluster policy.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier within the gateway.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "400 if NIC validation fails or the request would break security policy", "404 if the gateway or service ID is invalid", "500 if nvmeof-target configuration fails during apply" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify the NIC belongs to the service server and adjust VLAN/security settings."
          }, {
            "code" : "404",
            "action" : "Refresh services/listeners lists and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target logs on the host, resolve errors, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 600,
            "note" : "NVMe-oF listener creation"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/listeners to verify the listener appears with the expected NIC/VLAN.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/listeners/{listenerId}" : {
      "patch" : {
        "summary" : "Update an NVMe-oF listener's configuration.",
        "operationId" : "NvmeOFGatewayResource_updateNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Listener update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NvmeOFListenerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust port or TLS settings for an existing NVMe-oF listener.",
          "usage" : [ "Modify listener ports during maintenance without recreating the listener.", "Enable or disable TLS when policy changes." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "port",
            "in" : "body",
            "description" : "Optional port override; null keeps the existing value.",
            "required" : false,
            "example" : "4420"
          }, {
            "name" : "secure",
            "in" : "body",
            "description" : "Optional TLS flag.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID owning the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier to update.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if enabling TLS violates cluster security restrictions", "404 if the gateway/service/listener combination is invalid", "500 if nvmeof-target fails to reconfigure the listener" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Respect forceSecure policy and ensure TLS prerequisites are met."
          }, {
            "code" : "404",
            "action" : "Refresh listener inventory and retry with current IDs."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve errors, then rerun the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NVMe-oF listener updates"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/{gatewayId}/services/{serviceId}" ],
          "postprocessing_hint" : "Re-query GET /gateways/nvmeof/listeners to confirm new port/TLS state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a listener from an NVMe-oF service.",
        "operationId" : "NvmeOFGatewayResource_deleteNvmeOFListener",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "listenerId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NVMe-oF listener so the service stops exposing that network endpoint.",
          "usage" : [ "Call during listener maintenance (e.g. decommissioning a NIC or VLAN).", "Use ahead of recreating the listener with new parameters to avoid duplicate bindings." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "NVMe-oF gateway cluster ID.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Target service that owns the listener.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "listenerId",
            "in" : "path",
            "description" : "Listener identifier as returned by the listeners API.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the gateway, service, or listener cannot be found", "500 if nvmeof-target fails to reconfigure after removal" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh listeners for the service to obtain current IDs, then retry."
          }, {
            "code" : "500",
            "action" : "Check nvmeof-target tasks on the server and rerun once they finish successfully."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF listener removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/listeners", "/gateways/nvmeof/services" ],
          "postprocessing_hint" : "Refresh GET /gateways/nvmeof/listeners to ensure the listener ID disappears.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports/{type}" : {
      "delete" : {
        "summary" : "Delete a transport configuration.",
        "operationId" : "NvmeOFGatewayResource_deleteTransportConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "gatewayId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/NvmeOFTransportType"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a custom NVMe-oF transport configuration so the service falls back to cluster defaults.",
          "usage" : [ "Call after reverting transport tuning or decommissioning a transport type from the service.", "Use before recreating the transport with new parameters to avoid conflicting overrides." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "gatewayId",
            "in" : "path",
            "description" : "Numeric identifier of the NVMe-oF gateway cluster.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Internal service ID within the gateway.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Transport to remove (TCP, RDMA, etc.).",
            "required" : true,
            "example" : "TCP"
          } ],
          "failure_modes" : [ "404 if the gateway or service ID is invalid", "500 if the gateway fails to reconfigure after deleting the transport" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the NVMe-oF service list and verify you are using current IDs before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect nvmeof-target logs, resolve deployment issues, then rerun the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "NVMe-oF transport removal"
          },
          "related_endpoints" : [ "/gateways/nvmeof/services", "/gateways/nvmeof/{gatewayId}/services/{serviceId}/transports" ],
          "postprocessing_hint" : "Poll GET /gateways/nvmeof/services to confirm the service no longer lists the transport override.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/gateways/smb" : {
      "get" : {
        "summary" : "List all SMB clusters with their config.",
        "operationId" : "SmbGatewayResource_getSmbGateways",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured SMB gateway clusters with Active Directory and VIP metadata.",
          "usage" : [ "Query before rendering the SMB configuration overview.", "Refresh after editing domain settings or virtual IP pools to confirm changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayConfigResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":20,\"where\":[{\"type\":{\"_eq\":\"ACTIVE_DIRECTORY\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter clusters by Samba share type before managing shares.",
            "pagination.order.description" : "Maintain deterministic ordering across refreshes."
          },
          "failure_modes" : [ "200 data=[] when no SMB clusters are defined" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain how to create an SMB gateway via POST /gateways/smb."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB gateway inventory"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Expose joinWithSssd and domain details so administrators can confirm integration status quickly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/servers" : {
      "get" : {
        "summary" : "List all SMB servers.",
        "operationId" : "SmbGatewayResource_getSmbServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List SMB gateway servers with their NIC bindings, VLANs, and CTDB health.",
          "usage" : [ "Fetch when presenting the SMB server grid to monitor HA status and virtual IP placement.", "Re-query after rebalancing CTDB or adjusting NIC assignments to confirm effective changes." ],
          "response_shape" : "PaginationResponse<SmbGatewayServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"healthy\":{\"_eq\":false}}]}).",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "common_parameters" : {
            "pagination.where.healthy" : "Filter unhealthy nodes for quick remediation.",
            "pagination.order.hostname" : "Keep server lists stable between refreshes."
          },
          "failure_modes" : [ "200 data=[] when no SMB servers are associated with the cluster" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no servers are currently mapped to this SMB service."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB server health refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Highlight servers without virtual IPs or with unhealthy=false to draw operator focus.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/gateways/smb/shares" : {
      "get" : {
        "summary" : "List all SMB shares.",
        "operationId" : "SmbGatewayResource_getSmbShares",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseSmbGatewayShareResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return SMB shares, underlying paths, and access control definitions.",
          "usage" : [ "Fetch prior to editing share permissions or exposing share listings to operators.", "Refresh after share mutations to confirm guest/rw/ro settings and AD mappings." ],
          "response_shape" : "PaginationResponse<SmbGatewayShareResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":100,\"where\":[{\"serviceId\":{\"_eq\":2}}]}).",
            "required" : false,
            "example" : "{\"limit\":100}"
          } ],
          "common_parameters" : {
            "pagination.where.share" : "Search for a particular share name quickly.",
            "pagination.where.type" : "Filter to simple vs Active Directory shares when auditing access."
          },
          "failure_modes" : [ "200 data=[] when no SMB shares exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain that no shares are configured yet and point to POST /gateways/smb/shares."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "SMB share inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/gateways/smb", "/gateways/smb/servers" ],
          "postprocessing_hint" : "Surface rwUsersFormatted/roUsersFormatted alongside share names for quick permission audits.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images" : {
      "get" : {
        "summary" : "List available images",
        "operationId" : "ImageResource_listImages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List available croit node images with metadata and default selections.",
          "usage" : [ "Call to populate the image catalog UI before allowing selection or download.", "Refresh after invoking POST /images/refresh or /images/default to ensure state is current." ],
          "response_shape" : "ImageListReply",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON supporting filters (e.g. {\"limit\":20,\"where\":[{\"cpuArchitecture\":{\"_eq\":\"x86_64\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":20,\"after\":0}"
          } ],
          "common_parameters" : {
            "pagination.where" : "Filter by cpuArchitecture, isDefault or isNightly before presenting to users.",
            "pagination.order" : "Sort by timestamp desc to show latest images first."
          },
          "failure_modes" : [ "200 with images/data empty when no images have been synchronized yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state prompt to refresh images or contact support."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Catalog refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/images/refresh", "/images/{image}", "/images/archs" ],
          "postprocessing_hint" : "When pagination is absent use the `images` array; otherwise combine `data` and `total` for pagination UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/archs" : {
      "put" : {
        "summary" : "Set enabled architectures",
        "operationId" : "ImageResource_setEnabledArch",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Architecture configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ArchConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure which CPU architectures are supported for image deployment and server management.",
          "usage" : [ "Call when adding or removing support for different CPU architectures in the cluster.", "Use to control which architecture types can receive image deployments and OS installations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "At least one architecture enabled; Consider impact on existing servers; Admin understands implications",
            "post_action" : "Architecture support updated; Image availability filtered by enabled architectures; Server compatibility checked"
          },
          "request_parameters" : [ {
            "name" : "x86_64",
            "in" : "body",
            "description" : "Enable support for x86_64/AMD64 architecture servers.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "arm64",
            "in" : "body",
            "description" : "Enable support for ARM64 architecture servers.",
            "required" : true,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if both architectures are disabled (at least one must be enabled)", "400 if disabling architecture would affect existing servers with that architecture" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Enable at least one architecture; check if existing servers would be affected by architecture changes."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Architecture configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images/archs", "/images" ],
          "postprocessing_hint" : "Architecture changes are immediate; only enabled architectures show in image listings; verify server compatibility before changes.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Architecture changes affect which servers can receive images and may impact cluster operations"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get enabled architectures",
        "operationId" : "ImageResource_getEnabledArch",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ArchConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report which CPU architectures are currently enabled for croit images.",
          "usage" : [ "Read before displaying architecture toggles in the UI.", "Confirm the enabled state after PUT /images/archs or POST /images/default." ],
          "response_shape" : "ArchConfig",
          "failure_modes" : [ "200 with a flag set to false when that architecture has been explicitly disabled" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Communicate that no images will boot for disabled architectures until re-enabled."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Architecture toggle refresh"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images/archs (PUT)", "/images/default" ],
          "postprocessing_hint" : "Disable UI flows that assume images exist when an architecture flag is false.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/default" : {
      "post" : {
        "summary" : "Set default image",
        "operationId" : "ImageResource_setDefaultImage",
        "tags" : [ "images" ],
        "requestBody" : {
          "description" : "Default image request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/DefaultImageRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the default boot image for an architecture and optionally update existing servers to use it.",
          "usage" : [ "Call when establishing or changing the default image for new server deployments.", "Use to standardize cluster nodes on a specific OS image version across the architecture." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Image exists and is downloaded; Architecture supported; Server access available if overriding",
            "post_action" : "Default image updated; New deployments use new default; Existing servers updated if requested"
          },
          "request_parameters" : [ {
            "name" : "default",
            "in" : "body",
            "description" : "UUID of the image to set as default for its architecture.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          }, {
            "name" : "overrideServers",
            "in" : "body",
            "description" : "Whether to update existing servers to use the new default image.",
            "required" : true,
            "example" : "false"
          } ],
          "failure_modes" : [ "404 if the specified image UUID does not exist", "500 if server update operations fail when overrideServers is true" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify image UUID exists in catalog; refresh image list if needed."
          }, {
            "code" : "500",
            "action" : "Check server connectivity and image download status; review task logs for specific failures."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Default image changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images/default", "/images" ],
          "postprocessing_hint" : "Monitor task if overrideServers=true; new servers will use this image by default; existing servers updated based on override setting.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Setting default image affects new server deployments and may update existing servers"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get default image for architecture",
        "operationId" : "ImageResource_getDefaultImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "arch",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DefaultImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the default boot image UUID for a requested CPU architecture.",
          "usage" : [ "Call durant automated installs to learn which image croit nodes should boot by default.", "Verify that a default image is configured before prompting users to enable an architecture." ],
          "response_shape" : "DefaultImageResponse",
          "request_parameters" : [ {
            "name" : "arch",
            "in" : "query",
            "description" : "Architecture identifier (x86_64/amd64 or arm64/aarch64).",
            "required" : true,
            "example" : "x86_64"
          } ],
          "failure_modes" : [ "400 if the architecture string is not recognized", "404 if no default image is configured for the requested architecture" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize the architecture value to x86_64/amd64 or arm64/aarch64 and retry."
          }, {
            "code" : "404",
            "action" : "Prompt the administrator to set a default image via POST /images/default or enable the architecture."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/archs", "/images/default (POST)" ],
          "postprocessing_hint" : "Treat the returned UUID as authoritative until the image catalog refreshes.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/images/packages/{image}" : {
      "get" : {
        "summary" : "Get packages installed in an image",
        "operationId" : "ImageResource_getImagePackages",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ImagePackage"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List OS packages baked into a specific croit image for compliance or troubleshooting.",
          "usage" : [ "Fetch when an operator inspects package versions before rolling out the image.", "Compare package sets between images to validate upgrade impact." ],
          "response_shape" : "array<ImagePackage>",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "UUID from GET /images representing the image to inspect.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if the image UUID is unknown" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the image list and pick a currently available image before retrying."
          } ],
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 300,
            "note" : "Package audit"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Sort packages alphabetically and surface notable version differences to the user.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/images/refresh" : {
      "post" : {
        "summary" : "Refresh available images",
        "operationId" : "ImageResource_refreshImages",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageListReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Refresh the available images catalog from the remote repository to update local metadata.",
          "usage" : [ "Call when new images are expected to be available from the repository.", "Use to update image list after repository changes or to resolve missing images." ],
          "response_shape" : "ImageListReply",
          "workflow_guidance" : {
            "pre_check" : "Network connectivity available; Repository accessible; Admin privileges confirmed",
            "post_action" : "Image catalog updated; New images available for download; Existing image metadata refreshed"
          },
          "failure_modes" : [ "500 if image repository is unreachable or catalog update fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check network connectivity to image repository; verify repository URL configuration."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Image catalog refresh"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Updated catalog includes new images and revised metadata; refresh UI to show current available images.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/unused" : {
      "delete" : {
        "summary" : "Delete all unused images from disk. This includes all images that are not the default image and are not used by any server.",
        "operationId" : "ImageResource_deleteUnused",
        "tags" : [ "images" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete all unused images from disk storage to free up space while preserving active and default images.",
          "usage" : [ "Call for regular cleanup to remove images no longer needed by any servers.", "Use for maintenance to reclaim disk space by removing orphaned or outdated images." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Sufficient disk permissions; Default images identified; Server image usage analyzed",
            "post_action" : "Unused images deleted; Storage space freed; Default and active images preserved; Task completion reported"
          },
          "failure_modes" : [ "500 if image cleanup task fails to start or encounters disk errors" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check disk space and permissions; review task logs for specific cleanup failures."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 3600,
            "note" : "Bulk image cleanup operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Cleanup runs as background task; default images and images in use by servers are preserved; significant storage space may be freed.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bulk image deletion will permanently remove multiple images from disk storage"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}" : {
      "get" : {
        "summary" : "Get image information",
        "operationId" : "ImageResource_getImageInfo",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ImageInfoResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a concise description for a specific image (used by automated installers).",
          "usage" : [ "Call from provisioning workflows that need a human-readable label for the selected image.", "Validate that an image UUID obtained earlier still resolves before starting downloads." ],
          "response_shape" : "ImageInfoResponse",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "Image UUID returned by GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          } ],
          "failure_modes" : [ "404 if the image metadata is no longer present" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-sync images via POST /images/refresh or choose another UUID."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Installer metadata lookup"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/images", "/images/{image}/{file}", "/images/default" ],
          "postprocessing_hint" : "Display the description verbatim; it already includes timestamp and UUID.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      },
      "delete" : {
        "summary" : "Delete a downloaded image from disk",
        "operationId" : "ImageResource_deleteImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a specific downloaded image from disk to free up storage space.",
          "usage" : [ "Call when removing outdated or unused OS images to reclaim disk space.", "Use for cleanup when images are no longer needed for server deployments." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Image exists; Not currently used by any servers; Sufficient admin privileges",
            "post_action" : "Image file deleted from disk; Storage space freed; Image no longer available for deployment"
          },
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "UUID of the image to delete from disk storage.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          } ],
          "failure_modes" : [ "404 if the specified image UUID does not exist", "400 if image is currently in use by servers" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Image may have already been deleted; refresh image list to verify current images."
          }, {
            "code" : "400",
            "action" : "Check which servers are using this image via GET /images; cannot delete images in active use."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Image management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/unused" ],
          "postprocessing_hint" : "Image deletion is immediate; servers using this image are unaffected; re-download needed to restore image.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting images permanently removes them from disk and they must be re-downloaded if needed again"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/startDownload" : {
      "post" : {
        "summary" : "Start downloading an image",
        "operationId" : "ImageResource_startImageDownload",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate download of a specific image from the repository to local storage for server deployment.",
          "usage" : [ "Call when an image needs to be available locally before server deployment or upgrade.", "Use to pre-download images for faster server provisioning or offline deployment scenarios." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Image exists in catalog; Sufficient storage space; Repository accessible; No concurrent download",
            "post_action" : "Download initiated; Image will be available for deployment when complete; Progress trackable via status"
          },
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "Image identifier to download from the repository.",
            "required" : true,
            "example" : "croit-node-22.04-x86_64"
          } ],
          "failure_modes" : [ "404 if the specified image ID is not found in the catalog", "409 if image download is already in progress", "500 if download initiation fails due to network or storage issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh image catalog and verify image ID exists in available images."
          }, {
            "code" : "409",
            "action" : "Wait for current download to complete; check download progress via image status."
          }, {
            "code" : "500",
            "action" : "Check network connectivity, storage space, and repository accessibility."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Image download initiation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}" ],
          "postprocessing_hint" : "Monitor download progress via image status; large images may take significant time; downloaded images are immediately available for deployment.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/images/{image}/{file}" : {
      "get" : {
        "summary" : "Download an image file",
        "operationId" : "ImageResource_downloadImage",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "file",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "image",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download a raw croit OS image artifact for offline storage or provisioning.",
          "usage" : [ "Call when an administrator explicitly requests the binary image payload.", "Use ahead of manual provisioning workflows that need the kernel/initrd bundle on disk." ],
          "response_shape" : "application/octet-stream",
          "path_parameters" : [ {
            "name" : "image",
            "in" : "path",
            "description" : "Image identifier from GET /images.",
            "required" : true,
            "example" : "e3f7d4b8-7c8d-4eaa-9c1d-45c6b908f6af"
          }, {
            "name" : "file",
            "in" : "path",
            "description" : "Filename within the image directory (e.g. rootfs.img, initrd).",
            "required" : true,
            "example" : "rootfs.img"
          } ],
          "failure_modes" : [ "404 if the requested image or file does not exist on disk" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the image catalog, confirm the file name, and retry the download."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Large image download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/images", "/images/{image}", "/images/refresh" ],
          "postprocessing_hint" : "Stream the response directly to persistent storage and avoid logging binary data.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/install" : {
      "get" : {
        "summary" : "Get croit installation script",
        "operationId" : "InstallResource_getInstallScript",
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "text/plain" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download the automated croit installation script for setting up new cluster nodes.",
          "usage" : [ "Call when preparing to install croit on new servers or cluster nodes.", "Use to get the latest installation script with current configuration and dependencies." ],
          "response_shape" : "text/plain (shell script)",
          "workflow_guidance" : {
            "pre_check" : "Cluster configuration available; Template system initialized",
            "post_action" : "Installation script generated; Ready for execution on target servers"
          },
          "failure_modes" : [ "500 if template compilation fails due to missing configuration" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check cluster configuration completeness; verify template system is properly initialized."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Installation script downloads"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/cluster", "/servers" ],
          "postprocessing_hint" : "Execute script with root privileges on target servers; script contains cluster-specific configuration and connection details; verify network connectivity before execution.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/ipmi" : {
      "get" : {
        "summary" : "Show all IPMI devices",
        "operationId" : "IpmiResource_getIpmiDevices",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpmiDevice"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all IPMI devices in the cluster with their current power and health status.",
          "usage" : [ "Call when displaying server hardware management interface.", "Use to monitor server power states and hardware health across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<IpmiDevice>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters for device list.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "200 with empty list if no IPMI devices are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no IPMI interfaces are configured; add IPMI devices via server management."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI device queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/ipmi/poll-state", "/ipmi/config", "/servers" ],
          "postprocessing_hint" : "Display power state prominently; group devices by server rack or location; cache status data for dashboard updates.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/add" : {
      "post" : {
        "summary" : "Add an IPMI device that is not managed by croit's DHCP server",
        "operationId" : "IpmiResource_addIpmiServer",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI device information",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiDeviceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Register a new IPMI device that is not managed by croit's DHCP server for remote server management.",
          "usage" : [ "Call when adding servers with static IPMI configuration or external DHCP management.", "Use to integrate existing servers with configured IPMI into croit cluster management." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "IP address accessible; IPMI credentials valid; No existing device with same IP",
            "post_action" : "IPMI device registered; Available for server management operations; Power control enabled"
          },
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "IP address of the IPMI interface.",
            "required" : true,
            "example" : "192.168.1.100"
          }, {
            "name" : "access.username",
            "in" : "body",
            "description" : "IPMI username for authentication.",
            "required" : true,
            "example" : "admin"
          }, {
            "name" : "access.password",
            "in" : "body",
            "description" : "IPMI password for authentication.",
            "required" : true,
            "example" : "password123"
          } ],
          "failure_modes" : [ "400 if IP address is invalid or IPMI credentials are incorrect", "409 if IPMI device with the same IP already exists", "500 if IPMI communication test fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify IP address format and test IPMI credentials manually."
          }, {
            "code" : "409",
            "action" : "Check existing IPMI devices; remove duplicate if it's invalid."
          }, {
            "code" : "500",
            "action" : "Verify network connectivity to IPMI interface and credential validity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "IPMI device registration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "Device will appear in IPMI list; test connectivity with identify or power status commands; credentials stored securely.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/config" : {
      "patch" : {
        "summary" : "Set the global IPMI configuration",
        "operationId" : "IpmiResource_setIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "description" : "IPMI configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update global IPMI configuration including passwords for hardware management interfaces.",
          "usage" : [ "Call when setting up initial IPMI access or rotating IPMI passwords for security.", "Use after hardware changes or when standardizing IPMI credentials across the cluster." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid license active; IPMI interfaces accessible; New password meets complexity requirements",
            "post_action" : "IPMI admin password updated on all reachable devices; Task tracks per-device success/failure"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "New IPMI admin password to apply to all managed devices.",
            "required" : true,
            "example" : "new-ipmi-password"
          } ],
          "failure_modes" : [ "400 if license check fails", "500 if IPMI password update fails on some devices" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before updating IPMI configuration."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity to all devices; some devices may require manual intervention."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "IPMI configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/config", "/server-access/passwords" ],
          "postprocessing_hint" : "Monitor task progress for per-device results; failed devices may need manual password reset via BMC interface.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing IPMI passwords affects hardware access and may require physical intervention if connections fail"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the global IPMI configuration",
        "operationId" : "IpmiResource_getIpmiConfig",
        "tags" : [ "ipmi" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpmiConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve global IPMI configuration settings including admin password for hardware management.",
          "usage" : [ "Call when displaying IPMI settings in the administration interface.", "Use to verify current IPMI credentials before performing device operations." ],
          "response_shape" : "IpmiConfig",
          "failure_modes" : [ "200 with empty password if IPMI password is not configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty password indicates IPMI is not configured; set password via PATCH /ipmi/config."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI configuration queries"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/ipmi/config", "/server-access/passwords" ],
          "postprocessing_hint" : "Handle password securely; display configuration status rather than actual password value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/poll-state" : {
      "get" : {
        "summary" : "Poll the state of the given IPMI devices.",
        "operationId" : "IpmiResource_pollIpmiState",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/IpmiDeviceStateWrapper"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Poll current power and health status of specific IPMI devices for real-time monitoring.",
          "usage" : [ "Call when refreshing server status in dashboards or before performing power operations.", "Use to verify current device states before hardware management actions." ],
          "response_shape" : "Map<Int, IpmiDeviceStateWrapper>",
          "request_parameters" : [ {
            "name" : "id",
            "in" : "query",
            "description" : "List of IPMI device IDs to poll status for.",
            "required" : true,
            "example" : "[1, 2, 3]"
          } ],
          "failure_modes" : [ "200 with empty map if no matching device IDs are found" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response indicates device IDs don't exist; verify IDs with GET /ipmi before polling."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "IPMI status polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/ipmi", "/ipmi/config" ],
          "postprocessing_hint" : "Cache results for 5 seconds; displays current power state, temperature, and connectivity status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}" : {
      "delete" : {
        "summary" : "Remove an IPMI device, it will be re-detected if it still exists",
        "operationId" : "IpmiResource_deleteIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an IPMI device entry from croit's database (will be re-detected if device still exists).",
          "usage" : [ "Call when cleaning up stale IPMI device entries after hardware removal.", "Use to force re-detection of IPMI devices with updated network settings." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "IPMI device exists in database; Device is not critical for ongoing operations",
            "post_action" : "Device entry removed from database; Device will be re-detected if still accessible"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to remove from GET /ipmi.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if IPMI device ID does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Device may have already been deleted; refresh IPMI device list to verify."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "IPMI device management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "Device will automatically reappear in /ipmi if it's still network-accessible during next detection cycle.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/identify" : {
      "post" : {
        "summary" : "Turns on the identify LED for 5 minutes.",
        "operationId" : "IpmiResource_identifyIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Activate the server identification LED to physically locate hardware in a datacenter rack.",
          "usage" : [ "Call when physically locating servers for maintenance or troubleshooting.", "Use to identify specific hardware before performing physical operations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server supports LED identification",
            "post_action" : "Identification LED activated for 4 minutes; LED blinks to identify physical server location"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to identify from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI identify command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before IPMI operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and BMC identify LED functionality; some servers may not support LED control."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "IPMI identification operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/servers" ],
          "postprocessing_hint" : "LED will blink for 4 minutes to help locate server; safe operation with no impact on server functionality.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/ipmi/{id}/initialize" : {
      "post" : {
        "summary" : "Initialize an IPMI device to be used with croit.",
        "description" : "Sets boot device to PXE, and turns on power and optionally configures the ADMIN password to the default croit password.",
        "operationId" : "IpmiResource_initializeIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Optional information for accessing the IPMI device if it uses a non-default password.",
          "required" : false,
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IpmiAccess"
              }
            }
          }
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initialize an IPMI device for croit management by configuring PXE boot, passwords, and power state.",
          "usage" : [ "Call when preparing new servers for cluster integration via PXE boot.", "Use to standardize IPMI configuration and ensure servers can be managed remotely." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Current credentials available if needed",
            "post_action" : "Password changed to croit default; Boot device set to PXE; Server powered on; Ready for cluster integration"
          },
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "IPMI username for initial access (optional, defaults to ADMIN).",
            "required" : false,
            "example" : "admin"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Current IPMI password for authentication (optional).",
            "required" : false,
            "example" : "current-password"
          }, {
            "name" : "keepAdminPassword",
            "in" : "body",
            "description" : "Whether to keep current password instead of changing to croit default.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to initialize from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI authentication or command execution fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before IPMI operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity, credentials, and BMC functionality; may require physical access to BMC."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "IPMI initialization operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on" ],
          "postprocessing_hint" : "Monitor task progress for initialization steps; server will boot from PXE after completion; verify network boot sequence.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "IPMI initialization changes passwords and power state, potentially affecting server accessibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/ipmi-controller-reset" : {
      "post" : {
        "summary" : "Reboots the IPMI management controller itself.",
        "operationId" : "IpmiResource_rebootIpmiController",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reset the IPMI management controller (BMC) itself to resolve BMC issues or restore connectivity.",
          "usage" : [ "Call when IPMI interface becomes unresponsive or exhibits erratic behavior.", "Use as troubleshooting step for BMC firmware issues or network connectivity problems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; BMC is experiencing issues requiring reset",
            "post_action" : "BMC controller reset initiated; IPMI interface will be temporarily unavailable; BMC reboots and reinitializes"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID whose controller should be reset from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI controller reset command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before IPMI operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "BMC may be completely unresponsive; controller reset might require physical intervention or power cycle."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "BMC reset operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}" ],
          "postprocessing_hint" : "BMC will be unavailable for 1-3 minutes during reset; monitor connectivity; may resolve persistent IPMI issues.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "BMC reset will temporarily disable all IPMI functionality until the controller reboots"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-cycle" : {
      "post" : {
        "summary" : "Reboots a server.",
        "operationId" : "IpmiResource_rebootIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot a server remotely via IPMI with PXE boot for troubleshooting or configuration updates.",
          "usage" : [ "Call to restart unresponsive servers or apply configuration changes.", "Use to force server restart when software reboot is not possible." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is currently running",
            "post_action" : "Boot device set to PXE; Server power cycled; Server reboots from network"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to reboot from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI power cycle command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before power operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and BMC power management functionality; verify server is not in hardware fault state."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "IPMI reboot operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on", "/ipmi/{id}/power-off" ],
          "postprocessing_hint" : "Server will reboot from PXE; monitor boot sequence; cluster services will restart; expect 2-5 minute downtime.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Rebooting servers will temporarily interrupt cluster operations and may affect data availability"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-off" : {
      "post" : {
        "summary" : "Shutdown a server.",
        "operationId" : "IpmiResource_powerOffIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Shutdown a server remotely via IPMI for maintenance, power saving, or emergency situations.",
          "usage" : [ "Call to gracefully shutdown servers for maintenance or cluster operations.", "Use for emergency shutdown when servers become unresponsive." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is currently powered on",
            "post_action" : "Server shutdown command sent; Server powers down; Hardware enters standby state"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to power off from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI power command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before power operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and BMC power management functionality; server may already be powered off."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "IPMI power operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-on", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Monitor server status in cluster view; ensure data safety before shutdown; server will remain off until manually powered on.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Powering off servers will make them unavailable for cluster operations and may affect data availability"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/power-on" : {
      "post" : {
        "summary" : "Boots a server.",
        "operationId" : "IpmiResource_powerOnIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Power on a server remotely via IPMI with PXE boot configuration for cluster operations.",
          "usage" : [ "Call to start servers for cluster operations or after maintenance.", "Use to boot servers into croit-managed OS from network." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server is powered off or in standby",
            "post_action" : "Boot device set to PXE; Server power turned on; Server boots from network"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to power on from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI power command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before power operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and BMC power management functionality; verify server is not in fault state."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "IPMI power operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-off", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Server will boot from PXE; monitor network boot sequence; verify server appears in cluster within 5-10 minutes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/ipmi/{id}/reboot-to-bios" : {
      "post" : {
        "summary" : "Reboots a server and opens the BIOS setup menu.",
        "operationId" : "IpmiResource_rebootToBiosIpmiDevice",
        "tags" : [ "ipmi" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot a server and enter BIOS setup menu for hardware configuration or troubleshooting.",
          "usage" : [ "Call when BIOS settings need to be changed for hardware configuration.", "Use for hardware troubleshooting or firmware updates requiring BIOS access." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid license; IPMI device accessible; Server supports BIOS boot override",
            "post_action" : "Boot device set to BIOS; Server power cycled; Server boots to BIOS setup menu"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "IPMI device ID to reboot to BIOS from IPMI device listings.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if license check fails", "404 if IPMI device ID does not exist", "500 if IPMI boot device or power command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure valid license is active before power operations."
          }, {
            "code" : "404",
            "action" : "Verify IPMI device ID exists in device listings."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and BMC boot device functionality; some servers may not support BIOS boot override."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "BIOS boot operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/ipmi", "/ipmi/{id}/power-cycle" ],
          "postprocessing_hint" : "Server will boot to BIOS setup; requires physical console or KVM access; remember to reset boot device after BIOS changes.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Server will boot to BIOS and require manual intervention to return to normal operation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys" : {
      "get" : {
        "summary" : "List all Ceph users/keys.",
        "operationId" : "KeyResource_getCephKeys",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "description" : "Include Ceph and croit service keys (default: false)",
          "name" : "includeSystemKeys",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph authentication keys with their permissions and capabilities for access management.",
          "usage" : [ "Call when auditing Ceph access permissions or reviewing user authentication configurations.", "Use to identify which keys have access to specific pools, monitors, or metadata servers." ],
          "response_shape" : "OptionalPaginationResponse<CephUserResponse>",
          "request_parameters" : [ {
            "name" : "includeSystemKeys",
            "in" : "query",
            "description" : "Include system and service keys (default false).",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination with filtering by user name or permissions.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"user\":{\"_like\":\"%client%\"}}]}"
          } ],
          "failure_modes" : [ "500 if Ceph authentication service is unavailable" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Verify Ceph monitors are accessible and auth service is running; check ceph auth list manually."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Ceph key listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/keys/{user}", "/keys/{user}/download" ],
          "postprocessing_hint" : "Group by permission type; highlight admin/system keys; show capability summaries for each key.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add a new Ceph user/key, the specified user must not exist yet",
        "operationId" : "KeyResource_addCephKey",
        "tags" : [ "ceph-keys" ],
        "requestBody" : {
          "description" : "Ceph user/key configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph authentication key with specified permissions for client or service access.",
          "usage" : [ "Call when setting up new clients or services that need authenticated access to Ceph cluster.", "Use to create application-specific keys with minimal required permissions for security." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User name is unique; Permissions are valid; Ceph auth service accessible",
            "post_action" : "Ceph key created; User can authenticate to cluster; Key available for download"
          },
          "request_parameters" : [ {
            "name" : "user",
            "in" : "body",
            "description" : "Fully qualified Ceph user name (e.g., client.username).",
            "required" : true,
            "example" : "client.kubernetes"
          }, {
            "name" : "comment",
            "in" : "body",
            "description" : "Optional comment describing the key purpose.",
            "required" : false,
            "example" : "Kubernetes RBD access"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "Ceph capabilities defining access permissions.",
            "required" : true,
            "example" : "{\"mon\": \"allow r\", \"osd\": \"allow rw pool=kubernetes\"}"
          } ],
          "failure_modes" : [ "400 if user name already exists or permissions are invalid", "500 if key creation fails due to Ceph authentication service issues" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose a unique user name; validate permission syntax matches Ceph capability format."
          }, {
            "code" : "500",
            "action" : "Check Ceph monitor connectivity and authentication service health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Ceph key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}", "/keys/{user}/download" ],
          "postprocessing_hint" : "Key is immediately active; download keyring file for client configuration; warning issued if name resembles system key.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd" : {
      "get" : {
        "summary" : "Deploy the Ceph Container Storage Interface (CSI) driver for RBD",
        "operationId" : "KeyResource_downloadKubernetesCsiRbdConf",
        "tags" : [ "ceph-keys" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download Kubernetes CSI driver deployment configuration for Ceph RBD persistent volume provisioning.",
          "usage" : [ "Call when deploying Ceph CSI driver to Kubernetes cluster for the first time.", "Use to get standard CSI driver manifests for dynamic RBD volume provisioning." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "failure_modes" : [ "200 always succeeds with CSI driver configuration" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Download always succeeds; contains standard CSI driver deployment manifests."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "CSI driver downloads"
          },
          "cache_hint" : "medium-lived",
          "related_endpoints" : [ "/keys/kubernetes-csi/rbd/config/{user}/{pool}" ],
          "postprocessing_hint" : "Deploy to Kubernetes with kubectl apply -f csi-rbd.yml; configure StorageClass and Secrets separately using config endpoint; requires Kubernetes 1.14+.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes-csi/rbd/config/{user}/{pool}" : {
      "get" : {
        "summary" : "Generate the ConfigMap, StorageClass, and Secret objects needed by ceph-csi to provision a RBD backed PersistentVolume",
        "operationId" : "KeyResource_downloadKubernetesCsiCroitConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate Kubernetes CSI configuration (ConfigMap, StorageClass, Secret) for Ceph RBD persistent volumes.",
          "usage" : [ "Call when setting up Kubernetes persistent storage using Ceph RBD volumes.", "Use to generate CSI driver configuration for specific user and pool combinations." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "Ceph user name for RBD access (without client. prefix).",
            "required" : true,
            "example" : "kubernetes"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Ceph pool name for RBD volume provisioning.",
            "required" : true,
            "example" : "kubernetes"
          } ],
          "failure_modes" : [ "400 if specified pool does not exist", "400 if cluster is not properly configured", "404 if specified user key does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify pool exists via GET /pools and cluster setup is complete."
          }, {
            "code" : "404",
            "action" : "Create the Ceph user key first via POST /keys with appropriate RBD permissions."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Kubernetes CSI configuration generation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/pools", "/keys/kubernetes-csi/rbd" ],
          "postprocessing_hint" : "Apply to Kubernetes cluster using kubectl apply -f csi-croit.yml; contains ConfigMap, StorageClass, and Secret resources.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/kubernetes/{user}/{pool}" : {
      "get" : {
        "summary" : "Download Kubernetes configuration",
        "operationId" : "KeyResource_downloadKubernetesConf",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate legacy Kubernetes configuration for Ceph RBD storage integration (deprecated in favor of CSI).",
          "usage" : [ "Call when setting up older Kubernetes clusters with legacy RBD volume provisioning.", "Use for compatibility with Kubernetes versions prior to CSI driver adoption." ],
          "response_shape" : "DownloadableObject (YAML file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "Ceph user name for RBD access (without client. prefix).",
            "required" : true,
            "example" : "kubernetes"
          }, {
            "name" : "pool",
            "in" : "path",
            "description" : "Ceph pool name for RBD volume storage.",
            "required" : true,
            "example" : "kubernetes"
          } ],
          "failure_modes" : [ "400 if specified pool does not exist", "404 if specified user key does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify pool exists via GET /pools; create pool if needed."
          }, {
            "code" : "404",
            "action" : "Create the Ceph user key first via POST /keys with appropriate RBD permissions."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Legacy Kubernetes configuration generation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/pools", "/keys/kubernetes-csi/rbd/config/{user}/{pool}" ],
          "postprocessing_hint" : "Apply to Kubernetes using kubectl apply -f; consider migrating to CSI driver for modern Kubernetes clusters; contains legacy StorageClass and Secret configurations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}" : {
      "patch" : {
        "summary" : "Update an existing Ceph user",
        "operationId" : "KeyResource_updateCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Ceph user/key update configuration",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephUserUpdate"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update permissions or metadata for an existing Ceph user key without regenerating the authentication secret.",
          "usage" : [ "Call when user access requirements change and need permission adjustments.", "Use to add comments or modify capabilities while preserving the existing key secret." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Permissions are valid; Ceph auth service accessible; Admin confirms changes for system keys",
            "post_action" : "User permissions updated; Changes effective immediately; Key secret remains unchanged"
          },
          "request_parameters" : [ {
            "name" : "comment",
            "in" : "body",
            "description" : "Optional updated comment describing the key purpose.",
            "required" : false,
            "example" : "Updated Kubernetes RBD access"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "New Ceph capabilities to replace existing permissions.",
            "required" : false,
            "example" : "{\"mon\": \"allow r\", \"osd\": \"allow rw pool=kubernetes\"}"
          } ],
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to update.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "400 if permission syntax is invalid or user does not exist", "500 if Ceph authentication service is unavailable" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate permission syntax matches Ceph capability format; verify user exists."
          }, {
            "code" : "500",
            "action" : "Check Ceph monitor connectivity and authentication service health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Ceph key updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Permission changes are immediate; test user access after updates; warning issued for system key modifications.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Updating system or admin keys can impact cluster functionality; permission changes are immediate"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a Ceph user",
        "operationId" : "KeyResource_deleteCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph authentication key to revoke access for a specific user or service.",
          "usage" : [ "Call when decommissioning users or services that no longer need Ceph access.", "Use to clean up unused authentication keys for security compliance." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User key exists; Not a critical system key; Admin understands impact on services",
            "post_action" : "Ceph user key deleted; Authentication immediately revoked; Services using this key will fail"
          },
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to delete.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "404 if the specified user key does not exist", "500 if Ceph authentication service is unavailable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "User key may have already been deleted; refresh key list to verify."
          }, {
            "code" : "500",
            "action" : "Check Ceph monitor connectivity and authentication service health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Ceph key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Key deletion is immediate; update any services that were using this key; system keys generate warnings.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting Ceph keys will immediately revoke access for services using this authentication"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/keys/{user}/download" : {
      "get" : {
        "summary" : "Download a ceph.client.XYZ.keyring file",
        "operationId" : "KeyResource_downloadCephKey",
        "tags" : [ "ceph-keys" ],
        "parameters" : [ {
          "name" : "user",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download a Ceph keyring file containing authentication credentials for a specific user.",
          "usage" : [ "Call when configuring Ceph clients that need authentication credentials.", "Use to distribute authentication keys to applications or services accessing Ceph storage." ],
          "response_shape" : "DownloadableObject (keyring file)",
          "path_parameters" : [ {
            "name" : "user",
            "in" : "path",
            "description" : "Fully qualified Ceph user name (e.g., client.username) to download keyring for.",
            "required" : true,
            "example" : "client.kubernetes"
          } ],
          "failure_modes" : [ "404 if the specified user key does not exist", "500 if Ceph authentication service is unavailable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user key exists via GET /keys; create key first if needed."
          }, {
            "code" : "500",
            "action" : "Check Ceph monitor connectivity and authentication service health."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 300,
            "note" : "Keyring downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/keys", "/keys/{user}" ],
          "postprocessing_hint" : "Place keyring file in /etc/ceph/ on client systems; set appropriate file permissions (600); contains secret key material.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/license" : {
      "patch" : {
        "summary" : "Update license info.",
        "operationId" : "LicenseResource_patchLicenseInfo",
        "tags" : [ "license" ],
        "requestBody" : {
          "description" : "License update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/LicensePatchRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update license configuration settings including notification email address for license alerts.",
          "usage" : [ "Call when changing the email address for license expiration notifications.", "Use to configure or update license contact information without affecting license validity." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid email format provided; Admin permissions verified",
            "post_action" : "License notification email updated; Future license alerts sent to new address"
          },
          "request_parameters" : [ {
            "name" : "email",
            "in" : "body",
            "description" : "Valid email address for license notifications and alerts.",
            "required" : false,
            "example" : "admin@company.com"
          } ],
          "failure_modes" : [ "400 if email format is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide a valid email address format; verify email address can receive notifications."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "License configuration updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/license" ],
          "postprocessing_hint" : "Email address change is immediate; test email delivery for license notifications; affects future alert delivery only.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get license info.",
        "operationId" : "LicenseResource_licenseInfo",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current croit license status, usage limits, and compliance information.",
          "usage" : [ "Call when displaying license information in the administration interface.", "Use to check license compliance before enabling premium features or scaling the cluster." ],
          "response_shape" : "LicenseReply",
          "failure_modes" : [ "200 with active=false if license is invalid or expired" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Check message field for license issues; invalid licenses may restrict functionality."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "License status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/license", "/croit/dependencies" ],
          "postprocessing_hint" : "Display usage vs. limits prominently; show expiration warnings; indicate registration status with portal.croit.io.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/license/refresh" : {
      "post" : {
        "summary" : "Refresh license info.",
        "operationId" : "LicenseResource_refreshLicense",
        "tags" : [ "license" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/LicenseReply"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Refresh license information by checking with the license server for updated status and usage limits.",
          "usage" : [ "Call when license status appears outdated or after changes to cluster configuration.", "Use to validate license compliance after adding new capacity or features." ],
          "response_shape" : "LicenseReply",
          "workflow_guidance" : {
            "pre_check" : "Network connectivity available; License server accessible; Valid license configuration",
            "post_action" : "License status updated; Usage limits refreshed; Compliance status current"
          },
          "failure_modes" : [ "500 if license server is unreachable or license validation fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check network connectivity to license server; verify license key validity and cluster registration."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "License server queries"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/license" ],
          "postprocessing_hint" : "Updated license information reflects current server status; check for any compliance warnings or usage limit changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/logs/export" : {
      "get" : {
        "summary" : "Export Logs",
        "operationId" : "VictoriaLogsResource_exportLogs",
        "tags" : [ "logs" ],
        "parameters" : [ {
          "description" : "The optional output format. `json` is the default VictoriaLogs output format, while the others represent `journalctl -o output` formats.",
          "name" : "format",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/ExportFormats"
          },
          "required" : true
        }, {
          "name" : "query",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/LogsQLRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Export VictoriaLogs data based on a LogsQL query for offline analysis.",
          "usage" : [ "Build a LogsQLRequest with desired filters and optional time range", "Call this endpoint on-demand when a user requests a zipped log export" ],
          "response_shape" : "DownloadableObject",
          "workflow_guidance" : {
            "pre_check" : "Validate that the query JSON is well-formed and that requested servers exist.",
            "post_action" : "Store the returned download token and present a download link to the user."
          },
          "request_parameters" : [ {
            "name" : "query",
            "in" : "query",
            "description" : "Serialized LogsQLRequest JSON controlling filters, time range and pagination.",
            "required" : false,
            "example" : "{\"type\":\"query\",\"start\":1699999999,\"end\":1700003599}"
          }, {
            "name" : "format",
            "in" : "query",
            "description" : "Optional output format: raw|cat|short|with-unit.",
            "required" : false,
            "default" : "raw",
            "example" : "with-unit"
          } ],
          "common_parameters" : {
            "query.limit" : "Limit response size to avoid enormous exports.",
            "query.where" : "Apply filters to shrink the dataset before export."
          },
          "default_values" : {
            "format" : "raw"
          },
          "failure_modes" : [ "502 if VictoriaLogs backend is unreachable", "204 when the export contains no matching entries" ],
          "error_handling" : [ {
            "code" : "502",
            "action" : "Show an error and retry after verifying VictoriaLogs availability."
          }, {
            "code" : "204",
            "action" : "Inform the user that the query returned no data."
          } ],
          "retry_strategy" : "retry_on_502",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Expensive log export"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "WS /logs", "/cluster/status" ],
          "postprocessing_hint" : "The response is a streaming ZIP; pipe it to disk before presenting to users.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Exports may contain sensitive audit data"
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/allow-standby-replay" : {
      "put" : {
        "summary" : "Enable or disable standby replay.",
        "operationId" : "MaintenanceResource_setAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Standby replay configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/StandbyReplaySetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable CephFS standby replay for the specified filesystem.",
          "usage" : [ "Turn on standby replay to improve failover times for CephFS clients.", "Disable standby replay when reducing resource usage or during troubleshooting." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "allowStandbyReplay",
            "in" : "body",
            "description" : "true to enable standby replay.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "cephFsName",
            "in" : "body",
            "description" : "Optional CephFS name; defaults to croitConfig.cephFsName.",
            "required" : false,
            "example" : "cephfs"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or the filesystem name is unknown", "500 if the Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Create the CephFS (MDS service) or supply a valid filesystem name before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph health/logs; retry after resolving CLI errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "CephFS standby replay toggle"
          },
          "related_endpoints" : [ "/maintenance/allow-standby-replay", "/maintenance/max-mds" ],
          "postprocessing_hint" : "Sleep for a few seconds (as the method already does) then refresh GET /maintenance/allow-standby-replay to confirm.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the standby-replay setting (false if there is no cephfs)",
        "operationId" : "MaintenanceResource_getAllowStandbyReplay",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/StandbyReplaySetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose whether CephFS standby replay is enabled for the default filesystem.",
          "usage" : [ "Fetch when displaying the standby replay toggle in the CephFS settings.", "Re-query after PATCH /maintenance/allow-standby-replay to confirm the applied state." ],
          "response_shape" : "StandbyReplaySetting",
          "failure_modes" : [ "200 allowStandbyReplay=false when CephFS is not configured", "500 if the Ceph CLI command fails or Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain that CephFS is not yet configured; standby replay defaults to false."
          }, {
            "code" : "500",
            "action" : "Retry after checking CephFS health; the CLI response contains more detail."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS flag read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/allow-standby-replay (PATCH)", "/maintenance/max-mds" ],
          "postprocessing_hint" : "If cephFsName is null, display the cluster default CephFS name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/backup" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFile",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup archive for offline storage.",
          "usage" : [ "Invoke when an administrator requests a manual backup download from the UI.", "Use before major maintenance to archive the current configuration." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "500 if the backup cannot be generated due to non-default database credentials", "500 if backup creation fails for another reason" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show the backend error; if it references database configuration, revert to default credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/backup/basic-auth" : {
      "get" : {
        "summary" : "Download an unencrypted configuration backup.",
        "operationId" : "MaintenanceResource_downloadBackupFileBasicAuth",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitUser"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Download an unencrypted configuration backup using Basic Auth credentials.",
          "usage" : [ "Trigger from automation scripts relying on Basic Auth to fetch configuration backups.", "Invoke before maintenance when API clients cannot supply bearer tokens." ],
          "response_shape" : "application/zip stream",
          "failure_modes" : [ "500 if the backup cannot be generated due to non-default database credentials", "500 if backup creation fails for another reason" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Show the backend error; if it references database configuration, revert to default credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Full backup download"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/backup", "/maintenance/config-backups" ],
          "postprocessing_hint" : "Persist the binary data as a zip file named similar to croit-backup.zip and avoid logging contents.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups" : {
      "patch" : {
        "summary" : "Configure cloud configuration backups.",
        "operationId" : "MaintenanceResource_setBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Backup configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloudConfigBackupConfig"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable automatic offsite configuration backups.",
          "usage" : [ "Toggle cloud backups from the maintenance settings view.", "Disable backups temporarily before entering offline maintenance mode." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "true to turn on cloud backups, false to disable them.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if enabling backups while the appliance runs in offline mode" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Switch the system back to online mode or keep backups disabled."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Configuration toggles"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "After turning backups on, prompt the administrator to immediately generate and store the encryption key.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if cloud configuration backups are enabled and working.",
        "operationId" : "MaintenanceResource_getBackupConfiguration",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CloudConfigBackupStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Describe whether cloud configuration backups are enabled and the metadata of the last successful run.",
          "usage" : [ "Fetch when opening the backup settings page to show current status.", "Refresh after enabling, disabling, or running a backup to display the latest timestamp and checksum." ],
          "response_shape" : "CloudConfigBackupStatus",
          "failure_modes" : [ "200 with lastBackupTimestamp=null when no backup has been executed yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inform the user that no backup exists yet and suggest triggering one."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/config-backups (PATCH)", "/maintenance/config-backups/create", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Mask the backupEncryptionKey when presenting the data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/create" : {
      "post" : {
        "summary" : "Perform a cloud backup now.",
        "operationId" : "MaintenanceResource_runBackup",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an immediate cloud backup using the current encryption key.",
          "usage" : [ "Run after large configuration changes to capture the new state.", "Use when the UI indicates the last automatic backup failed." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if cloud backups are disabled in offline mode", "200 ManagedTask(status=FAILED) if the backup job encounters errors" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Switch the appliance back to online mode or keep backups disabled."
          }, {
            "code" : "200",
            "action" : "Inspect the managed task log; resolve the underlying issue before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "On-demand backup"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/generate-new-key" ],
          "postprocessing_hint" : "Stream task progress to the UI and surface the resulting timestamp and checksum once finished.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/config-backups/generate-new-key" : {
      "post" : {
        "summary" : "Generates a new crypto key used for all future backups.",
        "operationId" : "MaintenanceResource_regenerateKey",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate the encryption key used for cloud configuration backups.",
          "usage" : [ "Run after a key compromise to generate a fresh encryption key.", "Rotate keys during scheduled security maintenance before triggering new backups." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "200 ManagedTask(status=SUCCEEDED) always returns with the new key ID" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Read task messages to retrieve and securely store the new key identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Key rotation"
          },
          "related_endpoints" : [ "/maintenance/config-backups", "/maintenance/config-backups/create" ],
          "postprocessing_hint" : "Display the new key UUID and instruct operators to download the key material immediately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/croit-auto-update" : {
      "get" : {
        "summary" : "Get croit auto-update parameters.",
        "operationId" : "MaintenanceResource_getCroitAutoUpdateConfig",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the configured croit auto-update schedule and registry overrides.",
          "usage" : [ "Fetch to pre-fill the auto-update configuration form.", "Re-query after PUT /maintenance/croit-auto-update or /maintenance/update-now to ensure settings persisted." ],
          "response_shape" : "CroitAutoUpdateConfigRequest",
          "failure_modes" : [ "200 with enabled=false when automatic updates are disabled", "500 if the scheduler state cannot be loaded" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that auto updates are disabled and hide schedule-only controls."
          }, {
            "code" : "500",
            "action" : "Surface the backend error and suggest reviewing the job scheduler logs."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update (PUT)", "/maintenance/update-now" ],
          "postprocessing_hint" : "Redact registry credentials before logging or persisting the response.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "put" : {
        "summary" : "Change croit auto-update parameters.",
        "operationId" : "MaintenanceResource_configureCroitAutoUpdate",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Croit auto-update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CroitAutoUpdateConfigRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the automatic croit container update schedule and optional custom registry settings.",
          "usage" : [ "Enable scheduled updates after defining an appropriate maintenance window.", "Switch to a private registry or custom image tags for controlled rollouts." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "true to enable the cron-based auto-update job.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron expression executed when enabled; required if enabled=true.",
            "required" : false,
            "example" : "0 2 * * *"
          }, {
            "name" : "custom",
            "in" : "body",
            "description" : "true to override registry credentials/image/tag.",
            "required" : true,
            "example" : "false"
          }, {
            "name" : "registry",
            "in" : "body",
            "description" : "Custom registry URL when custom=true.",
            "required" : false,
            "example" : "registry.example.com"
          }, {
            "name" : "registryUsername",
            "in" : "body",
            "description" : "Custom registry username.",
            "required" : false,
            "example" : "robot"
          }, {
            "name" : "registryPassword",
            "in" : "body",
            "description" : "Custom registry password.",
            "required" : false,
            "example" : "******"
          }, {
            "name" : "imageName",
            "in" : "body",
            "description" : "Image repository name.",
            "required" : true,
            "example" : "croit/server"
          }, {
            "name" : "croitTag",
            "in" : "body",
            "description" : "Image tag to deploy.",
            "required" : true,
            "example" : "latest"
          } ],
          "failure_modes" : [ "400 if cron is missing while enabled=true, or registry credentials are incomplete", "400 if offline mode prevents enabling auto updates" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide matching registry credentials, a valid cron expression, and ensure offline mode is disabled before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Auto-update scheduling"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update", "/maintenance/update-now" ],
          "postprocessing_hint" : "Re-query GET /maintenance/croit-auto-update to verify the applied configuration.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/disable-cpu-idle-states" : {
      "put" : {
        "summary" : "Disable CPU idle states above set limit.",
        "operationId" : "MaintenanceResource_toggleHighPerformanceCPUMode",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "CPU idle state limit",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : [ "integer", "null" ],
                "format" : "int32"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the maximum allowed CPU idle state (C-state) to favor performance over power savings.",
          "usage" : [ "Enable high-performance mode on latency-sensitive clusters.", "Revert to default behaviour by sending null when the tuning window ends." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "limit",
            "in" : "body",
            "description" : "Maximum allowed C-state (null to disable restriction).",
            "required" : false,
            "example" : "1"
          } ],
          "failure_modes" : [ "500 if persisting the configuration fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check configuration storage/logs, then retry once the issue is resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "CPU tuning"
          },
          "related_endpoints" : [ "/maintenance/disable-cpu-idle-states", "/maintenance/update-now" ],
          "postprocessing_hint" : "Follow with GET /maintenance/disable-cpu-idle-states to show the applied value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Check if CPU idle states are disabled.",
        "operationId" : "MaintenanceResource_getIdleStates",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "integer",
                  "format" : "int32"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the configured CPU idle state limit for high performance mode.",
          "usage" : [ "Call when rendering the performance tuning page.", "Fetch again after PUT /maintenance/disable-cpu-idle-states to show the applied threshold." ],
          "response_shape" : "integer|null",
          "failure_modes" : [ "200 null when no idle state restriction is active" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat null as disabled and communicate that high performance mode is off."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Lightweight configuration read"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/maintenance/disable-cpu-idle-states (PUT)" ],
          "postprocessing_hint" : "Display non-null values as the maximum allowed C-state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags" : {
      "get" : {
        "summary" : "Ceph cluster flag overview.",
        "operationId" : "MaintenanceResource_getClusterFlags",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFlagReponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate Ceph cluster flags alongside recommended and current states.",
          "usage" : [ "Call when rendering the Ceph flag management screen.", "Refresh after toggling a flag to confirm the updated cluster state." ],
          "response_shape" : "array<CephFlagReponse>",
          "failure_modes" : [ "200 [] when the Ceph health cache has not populated flag data yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an informational banner that flag details are currently unavailable; Ceph may still be initialising."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "UI refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/flags/{flag}/set", "/maintenance/flags/{flag}/unset" ],
          "postprocessing_hint" : "Highlight entries where currentState differs from recommendedState.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/flags/{flag}/set" : {
      "put" : {
        "summary" : "Set a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_setClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable a Ceph cluster flag (e.g. noout, norecover).",
          "usage" : [ "Put the cluster into a maintenance posture before planned hardware work.", "Rapidly toggle debug flags during incident response." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "flag",
            "in" : "path",
            "description" : "Ceph cluster flag name.",
            "required" : true,
            "example" : "noout"
          } ],
          "failure_modes" : [ "400 if the flag name is invalid", "500 if the Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List available flags via GET /maintenance/flags before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph health/logs and reapply once the cluster is responsive."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 600,
            "note" : "Ceph flag toggles"
          },
          "related_endpoints" : [ "/maintenance/flags", "/maintenance/flags/{flag}/unset" ],
          "postprocessing_hint" : "Re-query GET /maintenance/flags to confirm the flag state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/flags/{flag}/unset" : {
      "put" : {
        "summary" : "Unset a Ceph cluster flag.",
        "operationId" : "MaintenanceResource_unsetClusterFlag",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "flag",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable a previously set Ceph cluster flag.",
          "usage" : [ "Return the cluster to normal behaviour after maintenance.", "Switch off debug or throttling flags post-investigation." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "flag",
            "in" : "path",
            "description" : "Ceph cluster flag name.",
            "required" : true,
            "example" : "noout"
          } ],
          "failure_modes" : [ "400 if the flag name is invalid", "500 if the Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm the flag name via GET /maintenance/flags."
          }, {
            "code" : "500",
            "action" : "Review Ceph status/logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 600,
            "note" : "Ceph flag toggles"
          },
          "related_endpoints" : [ "/maintenance/flags", "/maintenance/flags/{flag}/set" ],
          "postprocessing_hint" : "Check Ceph health once the flag is cleared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/max-mds" : {
      "put" : {
        "summary" : "Set the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_setMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Maximum MDS configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MaxMdsSetting"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust the CephFS max_mds value controlling the number of active metadata servers.",
          "usage" : [ "Increase max_mds when adding additional MDS daemons to scale read/write workloads.", "Lower max_mds after removing MDS servers or during troubleshooting." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "maxMds",
            "in" : "body",
            "description" : "Desired maximum number of active MDS ranks (must be >0).",
            "required" : true,
            "example" : "2"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or the value is  0", "200 with ignorable warning if decreasing could disrupt clients or insufficient MDS daemons are configured", "500 if the Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure a filesystem exists and choose a value greater than zero."
          }, {
            "code" : "200",
            "action" : "Review the warning (insufficient MDS servers or decreasing ranks) and acknowledge only if acceptable."
          }, {
            "code" : "500",
            "action" : "Check Ceph status/logs and retry once the command succeeds."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "CephFS MDS scaling"
          },
          "related_endpoints" : [ "/maintenance/allow-standby-replay", "/maintenance/max-mds" ],
          "postprocessing_hint" : "Monitor CephFS client health and re-fetch GET /maintenance/max-mds to confirm the new value.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the maximum number of active MDS (max_mds).",
        "operationId" : "MaintenanceResource_getMaxMds",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MaxMdsSetting"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Report the configured CephFS max_mds value (active MDS count).",
          "usage" : [ "Fetch when rendering the CephFS scaling settings.", "Refresh after PUT /maintenance/max-mds to ensure the new limit is in effect." ],
          "response_shape" : "MaxMdsSetting",
          "failure_modes" : [ "500 if CephFS is not configured or the Ceph CLI call fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Inform the operator that CephFS must exist and Ceph must be reachable before retrying."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "CephFS configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/max-mds (PUT)", "/maintenance/allow-standby-replay" ],
          "postprocessing_hint" : "Validate UI input to stay within the available MDS server count.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations" : {
      "get" : {
        "summary" : "Check which Ceph upgrades or container switches can be performed.",
        "operationId" : "MaintenanceResource_availableMigrations",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/AvailableMigrationTasks"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Summarise which Ceph major upgrades or container switches are still available.",
          "usage" : [ "Fetch before presenting the upgrade wizard so only valid actions are shown.", "Re-query after completing an upgrade or container switch to refresh the UI state." ],
          "response_shape" : "AvailableMigrationTasks",
          "failure_modes" : [ "200 with all flags false when no further upgrades are pending" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that the cluster is already on the latest supported release."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Administrative status check"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/migrations/{release}", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Use `switchTarget` to highlight the recommended container tag.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/migrations/switch-container" : {
      "post" : {
        "summary" : "Switch to the correct croit container.",
        "operationId" : "MaintenanceResource_switchContainer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Switch the running croit container to the image required by the target Ceph release.",
          "usage" : [ "Invoke when GET /maintenance/migrations indicates a container switch is required before continuing upgrades.", "Use to realign container versions after manual changes." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if running offline or already on the correct container", "400 if the target release is below the minimum supported", "500 if the switch process fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Follow the guidance in the error message (disable offline mode or upgrade Ceph first)."
          }, {
            "code" : "500",
            "action" : "Review task logs to address failures before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Container switch"
          },
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/{release}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/migrations/{release}" : {
      "post" : {
        "summary" : "Perform a Ceph major version upgrade.",
        "operationId" : "MaintenanceResource_upgrade",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "release",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/CephRelease"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Kick off a Ceph major upgrade to the specified release.",
          "usage" : [ "Upgrade Ceph to a newer supported release following the guided migration flow.", "Resume an interrupted upgrade by reissuing the same release once prerequisites are satisfied." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "release",
            "in" : "path",
            "description" : "Target Ceph release (e.g. quincy, reef).",
            "required" : true,
            "example" : "reef"
          } ],
          "failure_modes" : [ "400 if the release is unsupported or prerequisites are not met", "500 if upgrade steps fail midway" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use GET /maintenance/migrations to verify available upgrades and resolve prerequisites."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, address reported issues, then rerun the upgrade."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Ceph major upgrade"
          },
          "related_endpoints" : [ "/maintenance/migrations", "/maintenance/migrations/switch-container" ],
          "postprocessing_hint" : "Monitor the ManagedTask and validate cluster health after completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/min-compat-client" : {
      "put" : {
        "summary" : "Set the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_setMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Minimum compatible client version",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MinCompatClientVersion"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Raise or lower the minimum allowed Ceph client version (min-compat-client).",
          "usage" : [ "Enforce a newer client baseline before rolling out features that require it.", "Relax the requirement temporarily when supporting older clients during migrations." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "release",
            "in" : "body",
            "description" : "Minimum client Ceph release (e.g. octopus, pacific).",
            "required" : true,
            "example" : "pacific"
          } ],
          "failure_modes" : [ "400 if the requested release is newer than the running cluster version", "500 if the Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Upgrade the cluster first or pick a release  current cluster version."
          }, {
            "code" : "500",
            "action" : "Check Ceph health/logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Client compatibility update"
          },
          "related_endpoints" : [ "/maintenance/min-compat-client" ],
          "postprocessing_hint" : "Notify client owners about the new minimum version requirement.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the minimum ceph version clients need to be compatible with the cluster (min-compat-client).",
        "operationId" : "MaintenanceResource_getMinCompatClient",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephRelease"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the enforced minimum Ceph client release (min-compat-client).",
          "usage" : [ "Fetch when displaying the client compatibility settings.", "Refresh after PUT /maintenance/min-compat-client to verify the cluster accepted the change." ],
          "response_shape" : "CephRelease|null",
          "failure_modes" : [ "200 null when no explicit minimum has been set", "500 if the Ceph CLI command fails or Ceph is unreachable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display that the cluster uses the Ceph default and prompt admins to set one if needed."
          }, {
            "code" : "500",
            "action" : "Retry after checking Ceph health; the CLI stderr contains the root cause."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/min-compat-client (PUT)" ],
          "postprocessing_hint" : "Render releases using standard Ceph codenames.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd-full-ratios" : {
      "patch" : {
        "summary" : "Update OSD full ratios.",
        "operationId" : "MaintenanceResource_setOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "OSD full ratios update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/OsdFullRatios"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust the Ceph OSD fullness thresholds (nearfull/backfillfull/full) to control when warnings and backfill throttling occur.",
          "usage" : [ "Tighten thresholds before maintenance to trigger earlier alerts.", "Relax thresholds temporarily during capacity expansions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "nearfull",
            "in" : "body",
            "description" : "Optional new nearfull ratio (01).",
            "required" : false,
            "example" : "0.80"
          }, {
            "name" : "backfillfull",
            "in" : "body",
            "description" : "Optional new backfillfull ratio (01).",
            "required" : false,
            "example" : "0.85"
          }, {
            "name" : "full",
            "in" : "body",
            "description" : "Optional new full ratio (01).",
            "required" : false,
            "example" : "0.95"
          } ],
          "failure_modes" : [ "400 if the invariant 0 < nearfull < backfillfull < full < 0.98 is violated or NaN is provided", "500 if any Ceph CLI command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Submit ratios that preserve the strict inequality and fall below 0.98."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and re-run once commands succeed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "OSD fullness tuning"
          },
          "related_endpoints" : [ "/maintenance/osd-full-ratios" ],
          "postprocessing_hint" : "After applying, monitor osd perf counters to ensure new thresholds behave as expected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get OSD full ratios.",
        "operationId" : "MaintenanceResource_getOsdFullRatios",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OsdFullRatios"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the current Ceph OSD fullness thresholds (nearfull/backfillfull/full).",
          "usage" : [ "Call when rendering the OSD fullness configuration panel before allowing edits.", "Refresh immediately after PATCH /maintenance/osd-full-ratios to confirm the applied values." ],
          "response_shape" : "OsdFullRatios",
          "failure_modes" : [ "504 if the Ceph CLI does not respond in time", "500 if the Ceph CLI returns an error or malformed JSON" ],
          "error_handling" : [ {
            "code" : "504",
            "action" : "Retry after 15 seconds and alert operators if timeouts persist."
          }, {
            "code" : "500",
            "action" : "Surface the backend error and request operators to check Ceph health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Ceph CLI backed read"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/osd-full-ratios (PATCH)" ],
          "postprocessing_hint" : "Convert decimals to percentages with two decimals before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/osd/{osdId}/deep-scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to deep-scrub all its PGs.",
        "operationId" : "MaintenanceResource_deepScrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request a deep scrub (byte-for-byte verification) for all PGs on a specific OSD.",
          "usage" : [ "Run after hardware incidents to validate data integrity.", "Supplement automatic deep scrubs for clusters with extended intervals." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the OSD ID is unknown", "500 if Ceph refuses the deep scrub (cluster busy or unhealthy)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the OSD still exists before retrying."
          }, {
            "code" : "500",
            "action" : "Wait until cluster load decreases and deep-scrub throttles permit execution."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 86400,
            "note" : "Manual deep scrubs"
          },
          "related_endpoints" : [ "/maintenance/osd/{osdId}/scrub", "/pools/{name}/deep-scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/osd/{osdId}/scrub" : {
      "post" : {
        "summary" : "Instruct an OSD to scrub all its PGs.",
        "operationId" : "MaintenanceResource_scrubOsd",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "osdId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request an immediate scrub for all placement groups hosted by a specific OSD.",
          "usage" : [ "Invoke after resolving data inconsistencies or performing disk maintenance.", "Trigger periodic manual scrubs for critical OSDs outside automatic scheduling." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "osdId",
            "in" : "path",
            "description" : "Numeric OSD identifier (without the osd. prefix).",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the OSD ID is unknown", "500 if Ceph rejects the scrub request" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh OSD inventories before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph health detail and active scrubs; retry once the cluster is ready."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual OSD scrubs"
          },
          "related_endpoints" : [ "/maintenance/osd/{osdId}/deep-scrub", "/pools/{name}/scrub" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/reboot-all-servers" : {
      "post" : {
        "summary" : "Reboot all servers not running their configured image.",
        "operationId" : "MaintenanceResource_rebootServersToUpdateImage",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Reboot every server that is not running its configured croit image to apply pending updates.",
          "usage" : [ "Execute after updating the default image to ensure all nodes boot the latest version.", "Use when maintenance tasks require a coordinated restart across the fleet." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "200 ManagedTask(status=FAILED) if some servers fail to reboot" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to identify hosts that did not reboot and handle them manually before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "Fleet-wide reboot"
          },
          "related_endpoints" : [ "/servers/reboot", "/servers/{id}/reboot", "/tasks" ],
          "postprocessing_hint" : "Monitor host status and service health once the task completes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/recovery-speed" : {
      "put" : {
        "summary" : "Set the recovery speed.",
        "description" : "This can be used to fine-tune the balance between client IOPS and data rebalancing.",
        "operationId" : "MaintenanceResource_setRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Recovery speed configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RecoverySpeed"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tune Ceph OSD recovery throttling using a normalized 110 scale (higher = faster recovery).",
          "usage" : [ "Slow down recovery during peak client traffic to preserve performance.", "Speed up rebalancing after large hardware events or OSD additions." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "speed",
            "in" : "body",
            "description" : "Integer 110 (0 resets to default).",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "500 if Ceph configuration updates fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Inspect Ceph config logs and ensure monitors accept the new values before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Recovery speed tuning"
          },
          "related_endpoints" : [ "/maintenance/recovery-speed" ],
          "postprocessing_hint" : "Monitor recovery IOPS and client latency after changing the speed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the recovery speed.",
        "operationId" : "MaintenanceResource_getRecoverySpeed",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RecoverySpeed"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return the effective Ceph recovery throttle speed normalised to the 1-10 slider.",
          "usage" : [ "Fetch when rendering the recovery speed configuration form.", "Re-query after updating the throttle to confirm the active value." ],
          "response_shape" : "RecoverySpeed",
          "failure_modes" : [ "500 if Ceph configuration values are unavailable or invalid" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Display the backend message and prompt operators to inspect ceph.conf and cluster health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Admin-only configuration read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/recovery-speed (PUT)" ],
          "postprocessing_hint" : "Map `speed` to the UI slider; 10 represents the default fastest behaviour.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/restart-croit" : {
      "post" : {
        "summary" : "Restart the croit container. Will only work if the restart policy in docker has been configured correctly.",
        "operationId" : "MaintenanceResource_restartCroit",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger a restart of the croit management container.",
          "usage" : [ "Call after applying configuration updates that require a management restart.", "Monitor the returned ManagedTask to ensure the restart completes before issuing further API calls." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if a Ceph upgrade is currently in progress", "500 if the container restart fails due to Docker policy" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Wait for the ongoing Ceph upgrade task to finish before retrying."
          }, {
            "code" : "500",
            "action" : "Check Docker restart policies and host logs; rerun once the failure is corrected."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Management restart"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/maintenance/update-now", "/tasks/{id}", "/cluster/status" ],
          "postprocessing_hint" : "Use the ManagedTask id to poll /tasks/{id} and wait for completion before calling other management APIs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Restarting the management container interrupts active sessions and background jobs."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/maintenance/schedulingTimezone" : {
      "patch" : {
        "summary" : "Update the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_patchSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Scheduling timezone update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SchedulingSettings"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the timezone used for scheduled maintenance jobs and cron-like tasks.",
          "usage" : [ "Align scheduled tasks with a new operations timezone after datacenter handover.", "Adjust cron execution times for daylight-saving or corporate policy changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "timezone",
            "in" : "body",
            "description" : "IANA timezone identifier (e.g. Europe/Berlin, GMT-8:00).",
            "required" : true,
            "example" : "America/Los_Angeles"
          } ],
          "failure_modes" : [ "400 if the timezone is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm the timezone string is a valid IANA identifier or supported offset."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Scheduling configuration"
          },
          "related_endpoints" : [ "/maintenance/schedulingTimezone", "/maintenance/croit-auto-update" ],
          "postprocessing_hint" : "Update user documentation because cron expressions continue to run but interpreted in the new timezone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the timezone applied to the schedule.",
        "operationId" : "MaintenanceResource_getSchedulingTimezone",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TimezoneSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide the timezone used for scheduled jobs along with available options.",
          "usage" : [ "Call to populate the scheduling timezone dropdown.", "Re-query after PATCH /maintenance/schedulingTimezone to confirm the new selection." ],
          "response_shape" : "TimezoneSettings",
          "failure_modes" : [ "200 timezone=\"UTC\" when no explicit timezone has been configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Inform the user that UTC is used until a different timezone is selected."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Rare settings read"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/maintenance/schedulingTimezone (PATCH)" ],
          "postprocessing_hint" : "Use the `options` list to render a dropdown of valid timezones.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/maintenance/update-now" : {
      "post" : {
        "summary" : "Check for updates now.",
        "operationId" : "MaintenanceResource_updateNow",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Immediately check for and apply available croit container updates.",
          "usage" : [ "Run after adjusting auto-update settings to validate connectivity and registry credentials.", "Trigger a one-off update outside the scheduled window." ],
          "response_shape" : "ManagedTask",
          "failure_modes" : [ "400 if the system is configured for offline mode", "500 if the update process fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Disable offline mode or mirror the container image locally before retrying."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log for pull/authentication errors and retry once resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Manual update trigger"
          },
          "related_endpoints" : [ "/maintenance/croit-auto-update", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules" : {
      "get" : {
        "summary" : "List ceph mgr modules.",
        "operationId" : "MgrModuleResource_listModules",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephModuleStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available Ceph manager modules with their enabled/disabled status and capabilities.",
          "usage" : [ "Call when displaying the cluster module management interface.", "Use to check which modules are available before enabling specific functionality." ],
          "response_shape" : "CephModuleStatus",
          "failure_modes" : [ "500 if unable to communicate with Ceph manager service" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph manager service health and cluster connectivity."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Module status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/services", "/modules/dashboard/enable", "/modules/balancer/enable" ],
          "postprocessing_hint" : "Group modules by category; highlight enabled modules; show balancer status separately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/balancer/disable" : {
      "put" : {
        "summary" : "Toggle balancer module off.",
        "operationId" : "MgrModuleResource_disableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable the Ceph balancer module to stop automatic PG distribution optimization.",
          "usage" : [ "Call when manual control over PG placement is needed or during maintenance windows.", "Use to stop automatic balancing that may be impacting cluster performance." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Balancer module is currently enabled; Ceph manager is healthy",
            "post_action" : "Balancer module disabled; Automatic PG balancing stopped; Manual PG management required"
          },
          "failure_modes" : [ "500 if Ceph manager module cannot be disabled" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph manager health and ensure module is currently active."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Module lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/balancer/enable", "/modules" ],
          "postprocessing_hint" : "PG distribution will remain static until balancer is re-enabled or manual ceph osd reweight commands are used.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/balancer/enable" : {
      "put" : {
        "summary" : "Toggle balancer module on.",
        "operationId" : "MgrModuleResource_enableBalancer",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable the Ceph balancer module to automatically optimize PG distribution across OSDs.",
          "usage" : [ "Call after adding or removing OSDs to rebalance data distribution automatically.", "Use to enable automated PG balancing instead of manual intervention." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All clients support upmap feature; Ceph manager is healthy; No active balancing operations",
            "post_action" : "Balancer module enabled; Minimum client compatibility set to Luminous; Upmap mode activated"
          },
          "failure_modes" : [ "400 if some clients don't support upmap feature (pre-Luminous clients)", "500 if Ceph manager module cannot be enabled" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Update client compatibility requirements to Luminous or newer; older clients will be disconnected."
          }, {
            "code" : "500",
            "action" : "Check Ceph manager health and module availability before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Module lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/balancer/disable", "/modules" ],
          "postprocessing_hint" : "Monitor cluster performance during initial balancing; pre-Luminous clients will be disconnected.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling balancer will start automatic data movement and may disconnect pre-Luminous clients"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "operationId" : "MgrModuleResource_listCrashes",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "description" : "Include archived and old crashes (older than 2 weeks with default config)",
          "name" : "show-all",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMgrCrashReportEntry"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph daemon crash reports collected by the manager crash module for troubleshooting.",
          "usage" : [ "Call when investigating cluster health warnings related to daemon crashes.", "Use to monitor system stability and identify patterns in daemon failures." ],
          "response_shape" : "OptionalPaginationResponse<MgrCrashReportEntry>",
          "request_parameters" : [ {
            "name" : "show-all",
            "in" : "query",
            "description" : "Include archived and old crashes (older than 2 weeks).",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters for crash list.",
            "required" : false,
            "example" : "{\"limit\":50}"
          } ],
          "failure_modes" : [ "200 with empty list if no crashes have occurred or crash module is disabled" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty response may indicate no crashes or crash module is not enabled; check module status."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Crash report queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/crashes/{crashId}", "/modules/crashes/archive-all", "/status" ],
          "postprocessing_hint" : "Sort by timestamp; highlight unarchived crashes that trigger health warnings; group by hostname for pattern analysis.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/archive-all" : {
      "post" : {
        "summary" : "Archive all recent crash reports, clearing all warnings.",
        "operationId" : "MgrModuleResource_archiveAllCrashReports",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Archive all unarchived Ceph daemon crash reports to clear health warnings.",
          "usage" : [ "Call after investigating crashes to clean up cluster health status.", "Use for bulk cleanup when multiple crashes have been addressed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Manager crash module is enabled; Cluster connectivity available",
            "post_action" : "All recent crashes archived; Health warnings cleared; Status cache updated"
          },
          "failure_modes" : [ "500 if crash archival operation fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph manager crash module status and cluster health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Crash report management"
          },
          "related_endpoints" : [ "/modules/crashes", "/status" ],
          "postprocessing_hint" : "Check cluster health status to confirm warnings are cleared; archived crashes remain available for analysis.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This archives all crash reports and may hide important diagnostic information"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/crashes/{crashId}" : {
      "get" : {
        "summary" : "List crashes of Ceph daemons collected by the mgr crash module.",
        "description" : "The return value is the raw json as reported by Ceph and may change with minor Ceph releases.",
        "operationId" : "MgrModuleResource_getCrashDetails",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed crash information for a specific Ceph daemon crash for debugging and analysis.",
          "usage" : [ "Call when investigating specific crashes to get stack traces and diagnostic details.", "Use for providing detailed crash data to Ceph support or for root cause analysis." ],
          "response_shape" : "object",
          "path_parameters" : [ {
            "name" : "crashId",
            "in" : "path",
            "description" : "Crash ID from GET /modules/crashes to get details for.",
            "required" : true,
            "example" : "2023-09-19_08:42:36.123456Z_osd.3"
          } ],
          "failure_modes" : [ "404 if the crash ID doesn't exist or has been purged" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify crash ID exists with GET /modules/crashes before requesting details."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Crash detail queries"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/modules/crashes", "/modules/crashes/{crashId}/archive" ],
          "postprocessing_hint" : "Parse stack trace for error patterns; extract relevant daemon and version info; raw JSON format may vary between Ceph versions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/crashes/{crashId}/archive" : {
      "post" : {
        "summary" : "Archive a crash report, clearing the Ceph health warning related to it.",
        "operationId" : "MgrModuleResource_archiveCrashReport",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "description" : "Id of the crash as returned by /crashes",
          "name" : "crashId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Archive a specific Ceph daemon crash report to clear the associated health warning.",
          "usage" : [ "Call after investigating a crash to remove it from active health warnings.", "Use when individual crashes have been analyzed and no longer require attention." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Crash exists and is not already archived; Manager crash module enabled",
            "post_action" : "Crash marked as archived; Health warning cleared; Status cache updated"
          },
          "path_parameters" : [ {
            "name" : "crashId",
            "in" : "path",
            "description" : "Crash ID from GET /modules/crashes to archive.",
            "required" : true,
            "example" : "2023-09-19_08:42:36.123456Z_osd.3"
          } ],
          "failure_modes" : [ "404 if crash ID doesn't exist or has already been archived", "500 if crash archival operation fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify crash ID exists and is not already archived via GET /modules/crashes."
          }, {
            "code" : "500",
            "action" : "Check Ceph manager connectivity and crash module status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Individual crash archival"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/crashes", "/modules/crashes/archive-all", "/status" ],
          "postprocessing_hint" : "Status cache is automatically updated; archived crash remains visible with show-all=true.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/disable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module off.",
        "operationId" : "MgrModuleResource_disableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Disable the Ceph manager dashboard module to shut down the web-based monitoring interface.",
          "usage" : [ "Call when disabling web access to Ceph dashboard for security or maintenance.", "Use to free up manager resources by disabling the dashboard module." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module is currently enabled; Ceph manager is healthy",
            "post_action" : "Dashboard module disabled; Web interface inaccessible; Manager resources freed"
          },
          "failure_modes" : [ "500 if Ceph manager module cannot be disabled" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph manager health and ensure dashboard module is currently enabled."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Dashboard lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/enable", "/modules" ],
          "postprocessing_hint" : "Dashboard web interface will be unavailable; use CLI tools for cluster management.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/enable" : {
      "put" : {
        "summary" : "Toggle ceph mgr dashboard module on.",
        "operationId" : "MgrModuleResource_enableDashboard",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable the Ceph manager dashboard module with user migration and SSL configuration.",
          "usage" : [ "Call when setting up Ceph dashboard access for administrators and monitoring.", "Use to enable the built-in Ceph web interface with croit user integration." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Ceph manager is healthy; Dashboard module is available; User accounts exist",
            "post_action" : "Dashboard enabled; SSL disabled; Users migrated; Password policies disabled; Pseudo role created"
          },
          "failure_modes" : [ "500 if Ceph manager module cannot be enabled or user migration fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph manager health and user account integrity; some user imports may fail."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Dashboard lifecycle operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/disable", "/modules/dashboard/users", "/modules/dashboard/roles" ],
          "postprocessing_hint" : "Monitor task for user migration results; dashboard accessible via manager; SSL disabled for DashboardProxy.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling dashboard will migrate croit users and disable SSL for proxy compatibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/roles" : {
      "get" : {
        "summary" : "List ceph mgr dashboard roles.",
        "operationId" : "MgrModuleResource_listDashboardRoles",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardRole"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all available Ceph Dashboard roles with their permissions for user management.",
          "usage" : [ "Call when displaying role selection options during user creation or modification.", "Use to understand available permission sets before assigning roles to users." ],
          "response_shape" : "List<CephDashboardRole>",
          "failure_modes" : [ "200 with empty list if no dashboard roles are defined" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no custom roles exist; create roles via PUT /modules/dashboard/roles/{rolename}."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dashboard role queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/dashboard/roles/{rolename}", "/modules/dashboard/users" ],
          "postprocessing_hint" : "Hide reserved croit-import-pseudo-role from UI; group permissions by scope for clarity.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/roles/{rolename}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_updateDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing Ceph Dashboard role by adding or removing specific permissions.",
          "usage" : [ "Call when modifying role permissions without recreating the entire role.", "Use to fine-tune access control by adding or removing specific permission scopes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Role exists; Role not reserved; Add/delete operations don't conflict",
            "post_action" : "Role permissions updated; Changes immediately effective for all users with this role"
          },
          "request_parameters" : [ {
            "name" : "addPerms",
            "in" : "body",
            "description" : "Map of scope to permissions to add to the role.",
            "required" : false,
            "example" : "{\"rbd\": [\"create\", \"delete\"]}"
          }, {
            "name" : "delPerms",
            "in" : "body",
            "description" : "List of permission scopes to remove from the role.",
            "required" : false,
            "example" : "[\"rgw\", \"iscsi\"]"
          } ],
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name of the dashboard role to update (cannot be reserved).",
            "required" : true,
            "example" : "cluster-viewer"
          } ],
          "failure_modes" : [ "400 if rolename is reserved or conflicting add/delete operations", "404 if role does not exist", "500 if dashboard role update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Cannot modify reserved roles; ensure add/delete operations don't conflict."
          }, {
            "code" : "404",
            "action" : "Verify role exists via GET /modules/dashboard/roles."
          }, {
            "code" : "500",
            "action" : "Check dashboard module health and permission structure validity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/roles/{rolename}" ],
          "postprocessing_hint" : "Permission changes affect all users with this role immediately; users may need to refresh dashboard.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_deleteDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a custom Ceph Dashboard role to clean up unused permission sets.",
          "usage" : [ "Call when decommissioning custom roles that are no longer needed.", "Use to maintain a clean role hierarchy by removing obsolete permission sets." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name of the dashboard role to delete (cannot be croit-import-pseudo-role).",
            "required" : true,
            "example" : "custom-readonly"
          } ],
          "failure_modes" : [ "400 if trying to delete the reserved croit-import-pseudo-role", "404 if the role doesn't exist", "409 if role is still assigned to users" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Reserved roles cannot be deleted; verify the role name is correct."
          }, {
            "code" : "404",
            "action" : "Check that the role exists with GET /modules/dashboard/roles before deletion."
          }, {
            "code" : "409",
            "action" : "Remove role assignments from all users before attempting deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard role management"
          },
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/users" ],
          "postprocessing_hint" : "Verify removal by checking GET /modules/dashboard/roles; ensure no users are left without appropriate permissions.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting roles may affect user access permissions in Ceph Dashboard"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard role.",
        "operationId" : "MgrModuleResource_addDashboardRole",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "rolename",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard role creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardRoleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph Dashboard role with specified permissions for fine-grained access control.",
          "usage" : [ "Call when creating custom roles with specific permission sets for different user types.", "Use to implement role-based access control for dashboard functionality." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module enabled; Role name not reserved; Permission structure valid",
            "post_action" : "Dashboard role created; Role available for user assignment; Permissions active"
          },
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Human-readable description of the role's purpose.",
            "required" : true,
            "example" : "Read-only access to cluster status"
          }, {
            "name" : "permissions",
            "in" : "body",
            "description" : "Map of scope to permissions for this role.",
            "required" : true,
            "example" : "{\"osd\": [\"read\"], \"pool\": [\"read\"]}"
          } ],
          "path_parameters" : [ {
            "name" : "rolename",
            "in" : "path",
            "description" : "Name for the new dashboard role (cannot be reserved name).",
            "required" : true,
            "example" : "cluster-viewer"
          } ],
          "failure_modes" : [ "400 if rolename is reserved for croit import functionality", "500 if dashboard role creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use a different role name; some names are reserved for internal use."
          }, {
            "code" : "500",
            "action" : "Check dashboard module health and permission validity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Dashboard role management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/roles", "/modules/dashboard/roles/{rolename}" ],
          "postprocessing_hint" : "Assign role to users via PUT/PATCH user endpoints; role takes effect immediately.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/dashboard/users" : {
      "get" : {
        "summary" : "List ceph mgr dashboard users.",
        "operationId" : "MgrModuleResource_listDashboardUsers",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephDashboardUser"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph Dashboard user accounts with their roles and metadata.",
          "usage" : [ "Call when displaying the dashboard user management interface.", "Use to audit user access permissions and role assignments in Ceph Dashboard." ],
          "response_shape" : "List<CephDashboardUser>",
          "failure_modes" : [ "200 with empty list if no dashboard users are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no dashboard users exist; create users via PUT /modules/dashboard/users/{username}."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Dashboard user queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/modules/dashboard/users/{username}", "/modules/dashboard/roles" ],
          "postprocessing_hint" : "Distinguish croit-imported users from manually created ones; display role assignments clearly.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/modules/dashboard/users/{username}" : {
      "patch" : {
        "summary" : "Update ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_updateDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update an existing Ceph Dashboard user's password, password hash, or role assignments.",
          "usage" : [ "Call when changing user passwords or modifying role assignments.", "Use to add/remove specific roles without replacing the entire role set." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Parameters are not conflicting; Dashboard module enabled",
            "post_action" : "User password/roles updated; Changes immediately effective; User can log in with new credentials"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "New plaintext password (mutually exclusive with passwordHash).",
            "required" : false,
            "example" : "new-password"
          }, {
            "name" : "passwordHash",
            "in" : "body",
            "description" : "New password hash (mutually exclusive with password).",
            "required" : false,
            "example" : "$1$..."
          }, {
            "name" : "setRoles",
            "in" : "body",
            "description" : "Replace all roles with this list (mutually exclusive with add/delRoles).",
            "required" : false,
            "example" : "[\"administrator\", \"read-only\"]"
          }, {
            "name" : "addRoles",
            "in" : "body",
            "description" : "Add these roles to the user (mutually exclusive with setRoles).",
            "required" : false,
            "example" : "[\"pool-manager\"]"
          }, {
            "name" : "delRoles",
            "in" : "body",
            "description" : "Remove these roles from the user (mutually exclusive with setRoles).",
            "required" : false,
            "example" : "[\"read-only\"]"
          } ],
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "Username of the dashboard user to update.",
            "required" : true,
            "example" : "dashboard-admin"
          } ],
          "failure_modes" : [ "400 if conflicting parameters provided (password+passwordHash, setRoles+addRoles, etc.)", "404 if username does not exist", "500 if dashboard user update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure mutually exclusive parameters are not used together; check request structure."
          }, {
            "code" : "404",
            "action" : "Verify username exists via GET /modules/dashboard/users."
          }, {
            "code" : "500",
            "action" : "Check dashboard module health and user account status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard user updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/users", "/modules/dashboard/users/{username}" ],
          "postprocessing_hint" : "Role changes are immediate; user may need to log out and back in to see new permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_deleteDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph Dashboard user account to revoke access (excludes croit-imported users).",
          "usage" : [ "Call when decommissioning dashboard-only user accounts.", "Use to clean up test or temporary accounts that are no longer needed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "Username of the dashboard user to delete (cannot delete croit-imported users).",
            "required" : true,
            "example" : "temp-user"
          } ],
          "failure_modes" : [ "400 if trying to delete a user imported from croit", "404 if the user doesn't exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Croit-managed users cannot be deleted through this endpoint; manage them through croit user management."
          }, {
            "code" : "404",
            "action" : "Verify the username exists with GET /modules/dashboard/users before deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Dashboard user management"
          },
          "related_endpoints" : [ "/modules/dashboard/users" ],
          "postprocessing_hint" : "Confirm removal with GET /modules/dashboard/users; user sessions will be invalidated.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting users revokes their access to Ceph Dashboard permanently"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add ceph mgr dashboard user.",
        "operationId" : "MgrModuleResource_addDashboardUser",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "username",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Dashboard user creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DashboardUserCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Ceph Dashboard user account with the specified username and configuration.",
          "usage" : [ "Call when adding new administrators or users who need dashboard access.", "Use to create dashboard-specific user accounts separate from croit users." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Dashboard module enabled; Username not conflicting with croit users; Valid password provided",
            "post_action" : "Dashboard user created; Random password generated if not provided; User available for role assignment"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "Password for the new user (random generated if omitted).",
            "required" : false,
            "example" : "secure-password"
          } ],
          "path_parameters" : [ {
            "name" : "username",
            "in" : "path",
            "description" : "Username for the new dashboard user account.",
            "required" : true,
            "example" : "dashboard-admin"
          } ],
          "failure_modes" : [ "400 if username conflicts with croit-imported user", "500 if dashboard user creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Cannot create users that are imported from croit; choose a different username."
          }, {
            "code" : "500",
            "action" : "Check dashboard module is enabled and manager connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Dashboard user management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/modules/dashboard/users", "/modules/dashboard/users/{username}" ],
          "postprocessing_hint" : "Assign roles to the new user; password is randomly generated if not specified in request.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/modules/services" : {
      "get" : {
        "summary" : "List live ceph mgr module services.",
        "operationId" : "MgrModuleResource_listServices",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the live Ceph manager service endpoints (dashboard, REST API, etc.).",
          "usage" : [ "Display URLs for active mgr modules in the UI.", "Verify that mgr-managed services are reachable before automation proceeds." ],
          "response_shape" : "map<string,string>",
          "failure_modes" : [ "500 if the ceph command to list services fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph mgr logs and ensure the mgr daemons are healthy, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Mgr service discovery"
          },
          "related_endpoints" : [ "/modules", "/modules/balancer" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics" : {
      "put" : {
        "summary" : "Configure ping metrics.",
        "operationId" : "PingResource_updateMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping metrics configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingMetricsConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure network ping metrics collection including enabling/disabling and setting target network.",
          "usage" : [ "Call when setting up network monitoring or changing which network to monitor.", "Use to enable/disable automatic ping collection between servers for performance tracking." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists (if specified); Servers have IP addresses in target network; ICMP allowed between servers",
            "post_action" : "Ping metrics collection enabled/disabled; Target network configured; Automatic pinging starts/stops"
          },
          "request_parameters" : [ {
            "name" : "enable",
            "in" : "body",
            "description" : "Whether to enable ping metrics collection.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "network",
            "in" : "body",
            "description" : "Network ID to monitor (null to disable network-specific monitoring).",
            "required" : false,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if specified network ID does not exist", "500 if metrics collection configuration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify network ID exists via GET /networks; use null to disable network monitoring."
          }, {
            "code" : "500",
            "action" : "Check server connectivity and network infrastructure health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Metrics configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/netping/metrics", "/netping/metrics/summary", "/networks" ],
          "postprocessing_hint" : "Monitor warnings for servers not found in target network; metrics appear in summary after collection interval.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Enabling ping metrics will start regular ICMP traffic between servers which may impact network performance"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get ping metrics configuration.",
        "operationId" : "PingResource_getMetrics",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PingMetricsConfiguration"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current ping metrics collection configuration including enabled status and monitored network.",
          "usage" : [ "Call when displaying network monitoring settings in the UI.", "Use to check if ping metrics collection is active before requesting performance data." ],
          "response_shape" : "PingMetricsConfiguration",
          "failure_modes" : [ "200 with enable=false if ping metrics are disabled" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "When enabled=false, ping metrics are not being collected; enable via PUT /netping/metrics if monitoring needed."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Metrics configuration queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/netping/metrics", "/netping/metrics/summary" ],
          "postprocessing_hint" : "Show network name if configured; indicate collection status prominently in monitoring UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/metrics/summary" : {
      "get" : {
        "summary" : "Get ping metrics summary.",
        "operationId" : "PingResource_getMetricsSummary",
        "tags" : [ "maintenance" ],
        "parameters" : [ {
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/PingMetricsSummary"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve network latency and packet loss statistics between servers for performance analysis.",
          "usage" : [ "Call when displaying network performance dashboards or investigating connectivity issues.", "Use to identify network bottlenecks or problematic server connections." ],
          "response_shape" : "List<PingMetricsSummary>",
          "request_parameters" : [ {
            "name" : "startTime",
            "in" : "query",
            "description" : "Start time for metrics (Unix timestamp or negative offset in seconds).",
            "required" : true,
            "example" : "-3600"
          }, {
            "name" : "endTime",
            "in" : "query",
            "description" : "End time for metrics (Unix timestamp or negative offset, 0 for now).",
            "required" : true,
            "example" : "0"
          } ],
          "failure_modes" : [ "200 with empty list if no ping metrics are available or collection is disabled", "500 if Graphite backend is unavailable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list may indicate ping metrics are disabled or no data exists for time range."
          }, {
            "code" : "500",
            "action" : "Graphite errors are suppressed and return empty list; check metrics backend connectivity."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Network performance queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/netping/metrics", "/netping/ping" ],
          "postprocessing_hint" : "Display as network topology heat map; highlight high latency or packet loss between server pairs.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/netping/ping" : {
      "post" : {
        "summary" : "Ping hosts.",
        "operationId" : "PingResource_ping",
        "tags" : [ "maintenance" ],
        "requestBody" : {
          "description" : "Ping parameters",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PingParameters"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/PingResult"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute ICMP ping tests between servers to diagnose network connectivity issues.",
          "usage" : [ "Call when troubleshooting network connectivity problems between cluster nodes.", "Use to verify network performance before deploying new services or during maintenance." ],
          "response_shape" : "Map<Int, PingResult>",
          "workflow_guidance" : {
            "pre_check" : "Source and target servers exist; Network connectivity available; ICMP allowed",
            "post_action" : "Ping results returned with latency and packet loss statistics"
          },
          "request_parameters" : [ {
            "name" : "count",
            "in" : "body",
            "description" : "Number of ICMP packets to send (default 10).",
            "required" : false,
            "example" : "5"
          }, {
            "name" : "period",
            "in" : "body",
            "description" : "Interval between packets in milliseconds (default 10).",
            "required" : false,
            "example" : "20"
          }, {
            "name" : "fromId",
            "in" : "body",
            "description" : "Source server ID (0 for management server).",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "toIds",
            "in" : "body",
            "description" : "List of target server IDs to ping (0 for management server).",
            "required" : true,
            "example" : "[2, 3, 4]"
          }, {
            "name" : "network",
            "in" : "body",
            "description" : "Network ID to use for pinging (optional).",
            "required" : false,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if server IDs are invalid or network configuration is incorrect", "500 if ping execution fails due to network issues" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify server IDs exist and network configuration is valid."
          }, {
            "code" : "500",
            "action" : "Check network connectivity and firewall rules between specified servers."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Network diagnostic operations"
          },
          "related_endpoints" : [ "/netping/metrics", "/networks" ],
          "postprocessing_hint" : "Analyze packet loss and latency for network performance; high loss or latency indicates connectivity issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/networks" : {
      "get" : {
        "summary" : "List all configured networks.",
        "operationId" : "NetworkResource_getNetworks",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNetworkInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all configured network segments and their settings for cluster communication and traffic segregation.",
          "usage" : [ "Call to display network configuration overview and validate network setup.", "Use for network planning and troubleshooting connectivity issues across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<NetworkInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large network lists.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "failure_modes" : [ "200 with empty list if no networks are configured", "500 if database access fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list may indicate network setup is incomplete; configure networks via POST /networks."
          }, {
            "code" : "500",
            "action" : "Database connectivity issue; check system health and retry."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Network configuration queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/networks/{id}", "/servers" ],
          "postprocessing_hint" : "Group networks by purpose (storage, management, client); highlight subnet conflicts; show DHCP status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new network",
        "operationId" : "NetworkResource_addNetwork",
        "tags" : [ "networks" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NetworkInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new network configuration for cluster communication, storage traffic, or management purposes.",
          "usage" : [ "Call when setting up network segregation for different traffic types (storage, management, client).", "Use to define network segments for cluster expansion or infrastructure organization." ],
          "response_shape" : "NetworkInfo",
          "workflow_guidance" : {
            "pre_check" : "IP range is valid; No network overlaps; DHCP service accessible; Network type appropriate",
            "post_action" : "Network created; DHCP server updated; Gateway configuration checked; Network available for assignment"
          },
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Any IP address within the network range (not necessarily the network address).",
            "required" : true,
            "example" : "192.168.1.100"
          }, {
            "name" : "netmask",
            "in" : "body",
            "description" : "CIDR prefix length for the network subnet.",
            "required" : true,
            "example" : "24"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Network type (CROIT, IPMI, STORAGE, etc.).",
            "required" : true,
            "example" : "STORAGE"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description for the network purpose.",
            "required" : false,
            "example" : "Storage network for Ceph traffic"
          }, {
            "name" : "mtu",
            "in" : "body",
            "description" : "Maximum transmission unit size (defaults to 1500).",
            "required" : false,
            "example" : "9000"
          } ],
          "failure_modes" : [ "400 if IP address or CIDR format is invalid", "409 if network overlaps with existing network configurations", "500 if DHCP server update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify IP address format and CIDR notation; ensure valid network configuration."
          }, {
            "code" : "409",
            "action" : "Check existing networks for overlaps; adjust IP range or remove conflicting networks."
          }, {
            "code" : "500",
            "action" : "Check DHCP service health and network interface availability."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Network configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/networks/{id}" ],
          "postprocessing_hint" : "Network is immediately available for server assignment; DHCP configuration updated automatically; gateway settings validated asynchronously.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/networks/{id}" : {
      "put" : {
        "summary" : "Replace a network, must provide the full network config",
        "operationId" : "NetworkResource_replaceNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NetworkUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Completely replace an existing network configuration with new settings and update DHCP server accordingly.",
          "usage" : [ "Call when network requirements change significantly and need complete reconfiguration.", "Use to update all network parameters including IP range, gateway, and DHCP settings in one operation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists; New configuration is valid; No network overlaps; DHCP service accessible",
            "post_action" : "Network configuration replaced; DHCP server updated; Gateway configuration checked; Network available for assignment"
          },
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Any IP address within the new network range.",
            "required" : true,
            "example" : "192.168.2.100"
          }, {
            "name" : "netmask",
            "in" : "body",
            "description" : "CIDR prefix length for the new network subnet.",
            "required" : true,
            "example" : "24"
          }, {
            "name" : "type",
            "in" : "body",
            "description" : "Network type (CROIT, IPMI, STORAGE, etc.).",
            "required" : true,
            "example" : "STORAGE"
          }, {
            "name" : "gateway",
            "in" : "body",
            "description" : "Optional gateway IP for default routing.",
            "required" : false,
            "example" : "192.168.2.1"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description for the network purpose.",
            "required" : false,
            "example" : "Updated storage network"
          }, {
            "name" : "mtu",
            "in" : "body",
            "description" : "Maximum transmission unit size (defaults to 1500).",
            "required" : false,
            "example" : "9000"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Network ID to replace configuration for.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if IP address or CIDR format is invalid", "404 if network ID does not exist", "409 if new network configuration overlaps with existing networks", "500 if DHCP server update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify IP address format and CIDR notation; ensure valid network configuration."
          }, {
            "code" : "404",
            "action" : "Verify network ID exists; refresh network list."
          }, {
            "code" : "409",
            "action" : "Check for network overlaps; adjust IP range or modify conflicting networks."
          }, {
            "code" : "500",
            "action" : "Check DHCP service health and network interface availability."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Network replacement operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/networks" ],
          "postprocessing_hint" : "Network changes are immediate; may affect server connectivity; DHCP configuration updated automatically; gateway settings validated asynchronously.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Network replacement affects all servers using this network and may disrupt connectivity"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a network by its ID",
        "operationId" : "NetworkResource_deleteNetwork",
        "tags" : [ "networks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a network configuration and update DHCP server to reflect the change.",
          "usage" : [ "Call when decommissioning network segments or consolidating network configurations.", "Use to clean up unused network definitions that are no longer part of the cluster architecture." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Network exists; No active connections depend on this network; DHCP server accessible",
            "post_action" : "Network configuration removed; DHCP server updated; Task advisor recommendations refreshed"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Network ID to delete from the configuration.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if network ID does not exist", "500 if DHCP server update fails after network deletion" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Network may have been already deleted; refresh network list to verify."
          }, {
            "code" : "500",
            "action" : "Check DHCP server connectivity and configuration; network may be deleted but DHCP not updated."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Network configuration changes"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/networks", "/servers" ],
          "postprocessing_hint" : "DHCP server is automatically updated; task advisor checks network connectivity; verify cluster connectivity after deletion.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting networks may affect cluster connectivity and server accessibility"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs" : {
      "get" : {
        "summary" : "List all PGs in a pool.",
        "operationId" : "PlacementGroupResource_getPgDetails",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseCephPgStat"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve status and statistics for all placement groups across all pools in the cluster.",
          "usage" : [ "Call to monitor placement group health and identify stuck or degraded PGs.", "Use for capacity planning and understanding data distribution across the cluster." ],
          "response_shape" : "PaginationResponse<CephPgStat>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Pagination parameters to manage large PG lists.",
            "required" : true,
            "example" : "{\"limit\": 100, \"offset\": 0}"
          } ],
          "failure_modes" : [ "500 if Ceph cluster is unreachable or PG query fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check Ceph cluster health and manager connectivity; retry after verifying cluster status."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "PG status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pgs/{pg}/details", "/cluster/status" ],
          "postprocessing_hint" : "Group PGs by state (active, degraded, stuck); highlight problematic PGs requiring attention; sort by pool for better organization.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/backfill" : {
      "post" : {
        "summary" : "Force backfill of a placement group",
        "operationId" : "PlacementGroupResource_forceBackfill",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force backfill operation to redistribute data in a placement group after OSD changes or rebalancing.",
          "usage" : [ "Call when data redistribution is stuck or needs prioritization after cluster changes.", "Use to expedite data movement when rebalancing is proceeding too slowly." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG needs rebalancing; Target OSDs available; Sufficient network bandwidth",
            "post_action" : "Backfill initiated; Data redistribution in progress; Network utilization increased"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to force backfill (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "404 if placement group does not exist", "500 if backfill operation fails due to OSD unavailability or cluster issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement group ID format and existence; check pool configuration."
          }, {
            "code" : "500",
            "action" : "Check target OSD health, network connectivity, and available storage space."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "Backfill operations (bandwidth intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/recover" ],
          "postprocessing_hint" : "Monitor backfill progress and network utilization; operation may take considerable time depending on data volume.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Force backfill will consume significant network bandwidth and may impact cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/deep-scrub" : {
      "post" : {
        "summary" : "Start deep scrubbing a placement group",
        "operationId" : "PlacementGroupResource_deepScrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate a deep scrub operation that reads all data from disk and verifies both checksums and replica consistency.",
          "usage" : [ "Call when thorough data verification is needed or after detecting data corruption.", "Use for comprehensive integrity checking that validates data on disk against replicas." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG exists; Cluster healthy; Sufficient I/O capacity; No ongoing scrub operations",
            "post_action" : "Deep scrub initiated; High I/O load expected; Comprehensive data verification in progress"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to deep scrub (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "404 if placement group does not exist", "500 if deep scrub operation fails to start due to cluster or I/O issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement group ID format and existence; check pool status."
          }, {
            "code" : "500",
            "action" : "Check cluster health, OSD disk health, and available I/O capacity."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "Deep scrub operations (I/O intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/scrub" ],
          "postprocessing_hint" : "Monitor cluster performance during deep scrub; operation may take significant time; all data read from disk for verification.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deep scrub is I/O intensive and may impact cluster performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/details" : {
      "get" : {
        "summary" : "Get detailed information about a placement group",
        "operationId" : "PlacementGroupResource_queryPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve comprehensive diagnostic information for a specific placement group including state, recovery progress, and OSD mapping.",
          "usage" : [ "Call when investigating specific PG issues or monitoring recovery operations.", "Use for detailed troubleshooting when PGs are stuck, degraded, or showing errors." ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID in format 'pool.pg' (e.g., '1.a3').",
            "required" : true,
            "example" : "1.a3"
          } ],
          "failure_modes" : [ "404 if placement group ID does not exist", "500 if Ceph query fails or cluster is unreachable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify PG ID format and existence via GET /pgs before querying details."
          }, {
            "code" : "500",
            "action" : "Check Ceph cluster connectivity and manager health; retry after cluster stabilizes."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Detailed PG queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pgs", "/pgs/{pg}/scrub", "/pgs/{pg}/repair" ],
          "postprocessing_hint" : "Raw Ceph JSON format; extract key fields like state, recovery_progress, and acting OSDs; format varies by Ceph version.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pgs/{pg}/recover" : {
      "post" : {
        "summary" : "Force recovery of a placement group",
        "operationId" : "PlacementGroupResource_forceRecovery",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force recovery of a placement group that is stuck in an incomplete or degraded state.",
          "usage" : [ "Call when a PG is stuck in recovery and standard recovery mechanisms have failed.", "Use as last resort to restore access to data when automatic recovery is blocked." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG is stuck in recovery; Standard recovery failed; Admin understands potential data loss risk",
            "post_action" : "Recovery forced; PG may become active; Potential data loss if insufficient replicas"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to force recovery (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "404 if placement group does not exist", "500 if force recovery fails due to severe cluster issues or data loss" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement group ID format and existence; check if PG has been removed."
          }, {
            "code" : "500",
            "action" : "Check OSD availability, disk health, and cluster connectivity; may indicate data loss."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Force recovery operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/backfill" ],
          "postprocessing_hint" : "Monitor PG status after force recovery; verify data accessibility; may need follow-up repair operations.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Force recovery may result in data loss if insufficient healthy replicas exist"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/repair" : {
      "post" : {
        "summary" : "Repair a placement group",
        "operationId" : "PlacementGroupResource_repairPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Repair inconsistencies in a placement group by rebuilding corrupted or missing objects from replicas.",
          "usage" : [ "Call when scrub operations detect inconsistencies that need correction.", "Use to fix data corruption or replica mismatches in a specific placement group." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG has detected inconsistencies; Sufficient healthy replicas available; Cluster stable",
            "post_action" : "Repair operation initiated; Corrupted objects rebuilt; Data consistency restored"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to repair (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "404 if placement group does not exist", "500 if repair operation fails due to insufficient replicas or cluster issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement group ID format and existence; check pool status."
          }, {
            "code" : "500",
            "action" : "Ensure sufficient healthy replicas exist; check cluster health and OSD availability."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 1800,
            "note" : "PG repair operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/scrub" ],
          "postprocessing_hint" : "Monitor repair progress in PG status; verify data consistency after completion; may involve significant I/O activity.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Repair operations modify data and may impact application performance"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pgs/{pg}/scrub" : {
      "post" : {
        "summary" : "Start scrubbing a placement group",
        "operationId" : "PlacementGroupResource_scrubPg",
        "tags" : [ "placement-groups" ],
        "parameters" : [ {
          "name" : "pg",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Initiate a scrub operation on a placement group to verify data integrity by checking object checksums.",
          "usage" : [ "Call when investigating data integrity issues or performing routine maintenance checks.", "Use to verify object consistency and detect silent data corruption in a specific PG." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "PG exists; Cluster healthy; No ongoing deep-scrub on same PG",
            "post_action" : "Scrub operation initiated; Progress visible in PG status; Inconsistencies reported if found"
          },
          "path_parameters" : [ {
            "name" : "pg",
            "in" : "path",
            "description" : "Placement group ID to scrub (format: pool.pg_id).",
            "required" : true,
            "example" : "rbd.0"
          } ],
          "failure_modes" : [ "404 if placement group does not exist", "500 if scrub operation fails to start due to cluster issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement group ID format and existence; check pool status."
          }, {
            "code" : "500",
            "action" : "Check cluster health, OSD availability, and ongoing recovery operations."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 600,
            "note" : "PG maintenance operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pgs/{pg}/details", "/pgs/{pg}/deep-scrub" ],
          "postprocessing_hint" : "Monitor PG status for scrub completion; scrub may take time depending on data volume; inconsistencies logged if detected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools" : {
      "get" : {
        "summary" : "List all pools.",
        "operationId" : "PoolResource_getPools",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephPoolResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph storage pools with capacity, protection and usage stats.",
          "usage" : [ "Populate the pool overview grid before drilling into details", "Refresh periodically when monitoring utilization or pool flags" ],
          "response_shape" : "OptionalPaginationResponse<CephPoolResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to filter/sort pools (by name, application, deleteProtected, etc.).",
            "required" : false,
            "example" : "{\"limit\":25,\"where\":[{\"application\":{\"_eq\":\"rbd\"}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Limit results on large clusters to keep responses manageable.",
            "pagination.where" : "Filter by deleteProtected or application before executing actions."
          },
          "failure_modes" : [ "200 [] when no pools are discovered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state encouraging pool creation or hardware discovery."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{name}/details", "/pools/{name}/compression", "/stats/pool-names" ],
          "postprocessing_hint" : "Derive warning badges for pools with erasureCodingOverwriteSupportMissing or nearing quotas.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a pool.",
        "operationId" : "PoolResource_createPool",
        "tags" : [ "ceph-pools" ],
        "requestBody" : {
          "description" : "Pool creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new Ceph pool with optional erasure coding, quotas, and CRUSH rule adjustments.",
          "usage" : [ "Call when onboarding new application workloads requiring dedicated pools.", "Follow up with GET /pools to confirm quotas, size, and application flags." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Pool name without whitespace.",
            "required" : true,
            "example" : "rbd-app"
          }, {
            "name" : "erasureCoding",
            "in" : "body",
            "description" : "true to create an erasure-coded pool (requires dataChunks/parityChunks).",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "Desired pg_num; defaults to 128 if omitted.",
            "required" : false,
            "example" : "256"
          }, {
            "name" : "crushRule",
            "in" : "body",
            "description" : "Optional CRUSH rule id to assign immediately after creation.",
            "required" : false,
            "example" : "2"
          }, {
            "name" : "application",
            "in" : "body",
            "description" : "Pool application type - strongly recommended to set. Use 'rbd' for RBD pools, 'cephfs' for CephFS, 'rgw' for S3/RGW.",
            "required" : false,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if the name is missing or contains whitespace", "400 if mutual parameters (e.g. erasure coding chunks) are inconsistent", "409 if a pool with the same name already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Sanitize the request payload (name formatting, EC parameters) and retry."
          }, {
            "code" : "409",
            "action" : "Skip creation or choose a different name; GET /pools to confirm existing entries."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Pool provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}", "/crush" ],
          "postprocessing_hint" : "If creating an EC pool, verify allow_ec_overwrites succeeded in the ManagedTask logs.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating pools impacts cluster placement groups and storage utilization."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/all-infos" : {
      "get" : {
        "summary" : "Get mirror infos on all pools.",
        "operationId" : "RbdMirrorResource_getAllPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Aggregate mirroring status for every pool with mirroring enabled.",
          "usage" : [ "Show the global mirroring overview dashboard.", "Run before bulk configuration changes to confirm current peer connectivity." ],
          "response_shape" : "array<RbdMirrorPoolInfo>",
          "failure_modes" : [ "200 [] when no pools have mirroring enabled" ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Pool mirror inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/rbd-mirror/schedules" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/rbd-mirror/schedules" : {
      "get" : {
        "summary" : "Get mirror snapshot schedules of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getSnapshotSchedules",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all configured RBD mirror snapshot schedules across pools and namespaces",
          "usage" : [ "Review current snapshot scheduling configuration", "Audit mirroring automation settings", "Identify scheduled replication intervals" ],
          "response_shape" : "List<RbdMirrorSnapshotSchedule>",
          "failure_modes" : [ "200 empty list if no schedules configured", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no schedules; create schedules using POST /pools/rbd-mirror/schedules."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for mirroring operations."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Schedule listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Schedules apply at pool, namespace, or image level; check granularity for each entry.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a schedule for RBD mirror snapshots. Call this endpoint with the same request body as when adding a schedule (via POST). The task returned by this endpoint will not provide information on whether or not a schedule was removed. To check if deletion was successful, request the list of schedules and check for any changes.",
        "operationId" : "RbdMirrorResource_deleteSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a snapshot mirroring schedule at pool/image/namespace granularity.",
          "usage" : [ "Clean up schedules after converting images away from snapshot-based mirroring.", "Remove erroneously configured intervals prior to creating new ones." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "interval",
            "in" : "body",
            "description" : "Schedule interval string (e.g. 24h).",
            "required" : true,
            "example" : "24h"
          }, {
            "name" : "startTime",
            "in" : "body",
            "description" : "Optional start timestamp in ISO-8601; null to accept default.",
            "required" : false,
            "example" : "2024-05-01T00:00:00Z"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Optional pool scope (use '-' to indicate unspecified).",
            "required" : false,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Optional image scope (use '-' to indicate unspecified).",
            "required" : false,
            "example" : "vm-001"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Optional namespace scope (use '-' for default).",
            "required" : false,
            "example" : "-"
          } ],
          "failure_modes" : [ "404 if the targeted schedule does not exist", "500 if the Ceph command to remove the schedule fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List schedules first and ensure the payload matches exactly (pool/rbd/namespace/interval)."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs; retry after resolving any CLI errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror schedule management"
          },
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/rbd-mirror/schedules (POST)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a new schedule for rbd mirror snapshots.",
        "operationId" : "RbdMirrorResource_createSnapshotSchedule",
        "tags" : [ "rbd-mirror" ],
        "requestBody" : {
          "description" : "Snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSnapshotSchedule"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a snapshot mirroring schedule scoped to a pool, namespace, or individual image.",
          "usage" : [ "Automate regular snapshot creation for mirroring to remote clusters.", "Set up per-image schedules when different intervals are required." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "interval",
            "in" : "body",
            "description" : "Interval string (e.g. 24h, 1h).",
            "required" : true,
            "example" : "24h"
          }, {
            "name" : "startTime",
            "in" : "body",
            "description" : "Optional start timestamp in ISO-8601; null means immediate.",
            "required" : false,
            "example" : "2024-05-01T00:00:00Z"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Pool scope (use '-' to indicate all pools).",
            "required" : false,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Optional image name (use '-' to target entire pool).",
            "required" : false,
            "example" : "vm-001"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Optional namespace for Octopus+ (use '-' for default).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "failure_modes" : [ "400 if mirroring is not configured or the request is invalid", "500 if Ceph fails to add the schedule" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the pool/image is set to snapshot mode with peers configured before retrying."
          }, {
            "code" : "500",
            "action" : "Review Ceph logs; retry after resolving CLI errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror schedule management"
          },
          "related_endpoints" : [ "/pools/rbd-mirror/schedules", "/pools/rbd-mirror/schedules (DELETE)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}" : {
      "patch" : {
        "summary" : "Update pool flags.",
        "operationId" : "PoolResource_updatePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update pool metadata, quotas, or replication settings without recreating the pool.",
          "usage" : [ "Adjust pg_num, quotas, or CRUSH rules during capacity planning.", "Rename pools or toggle delete protection after confirming migration plans." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Optional new pool name (no commas allowed).",
            "required" : false,
            "example" : "rbd-prod"
          }, {
            "name" : "pgNum",
            "in" : "body",
            "description" : "Target pg_num/pgp_num; triggers ceph osd pool set commands.",
            "required" : false,
            "example" : "256"
          }, {
            "name" : "quotaMaxBytes",
            "in" : "body",
            "description" : "Pool byte quota; 0 disables the limit.",
            "required" : false,
            "example" : "1099511627776"
          }, {
            "name" : "unprotect",
            "in" : "body",
            "description" : "true to clear the delete protection flag for 15 minutes.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "compression",
            "in" : "body",
            "description" : "Compression mode and algorithm overrides.",
            "required" : false,
            "example" : "{\"mode\":\"aggressive\",\"algorithm\":\"zstd\"}"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Current pool name.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if the payload is invalid (e.g. new name contains commas)", "404 if the pool cannot be found", "500 if Ceph rejects configuration changes (quota, pg updates, CRUSH adjustments)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fix the offending field (rename formatting, conflicting flags) and resubmit."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list to select an existing pool."
          }, {
            "code" : "500",
            "action" : "Review Ceph command output, ensure the cluster is healthy, then retry in smaller increments if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Pool configuration changes"
          },
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Monitor ceph health for remapping/backfill and refresh GET /pools to confirm updated stats.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete pool.",
        "operationId" : "PoolResource_deletePool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Pool deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephPoolDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a Ceph pool after confirming it no longer holds important data.",
          "usage" : [ "Call once all data is migrated away and the pool is unprotected (include the confirmation token).", "Monitor ceph health after deletion to ensure PGs return to active/clean state." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "poolId",
            "in" : "body",
            "description" : "Expected pool id as safety check.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Must equal the confirmation string 'I know this will delete data'.",
            "required" : true,
            "example" : "I know this will delete data"
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name to remove.",
            "required" : true,
            "example" : "rbd-old"
          } ],
          "failure_modes" : [ "400 if confirmation text or poolId mismatches", "400 if the pool is still protected", "409 if the pool is in use by RGW or other services" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the confirmation string and identifiers match the target pool before retrying."
          }, {
            "code" : "409",
            "action" : "Check RGW placement targets or dependent services and detach them first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Pool deletion risk"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/details", "/s3/buckets" ],
          "postprocessing_hint" : "Watch ceph health and PG states for the affected pool until no longer listed.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting a pool irreversibly removes data and affects the CRUSH map."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/compression" : {
      "get" : {
        "summary" : "Get pool compression info.",
        "operationId" : "PoolResource_getCompressionSettings",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PoolCompressionSettings"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve compression settings for a specific pool to validate configuration.",
          "usage" : [ "Open the compression settings dialog before editing", "Check current values after updating compression policies" ],
          "response_shape" : "PoolCompressionSettings",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if compression info cannot be parsed (ENOENT)", "404 if the pool does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Show a toast that compression is not configured and allow setting defaults."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list and inform the user the pool was removed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Pool configuration viewing"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{name}", "/pools" ],
          "postprocessing_hint" : "Display human-readable algorithm labels using PoolCompressionAlgorithm.cephName.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/deep-scrub" : {
      "post" : {
        "summary" : "Add pool to deep scrub queue.",
        "operationId" : "PoolResource_deepScrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a deep scrub for the pool to read and verify all data blocks.",
          "usage" : [ "Trigger after hardware issues or inconsistent PGs to perform a thorough validation.", "Schedule less frequent deep scrubs on mission-critical pools between maintenance windows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for deep scrub.",
            "required" : true,
            "example" : "ec-archive"
          } ],
          "failure_modes" : [ "500 if Ceph refuses the deep scrub (pool missing, deep scrub throttled, or cluster unhealthy)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Ensure the cluster is healthy and deep-scrub is permitted, then resubmit when load is low."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Deep scrub scheduling"
          },
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Watch ceph health detail for deep-scrub progress and follow up on any reported inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/details" : {
      "get" : {
        "summary" : "Get pool details.",
        "operationId" : "PoolResource_getPoolDetails",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose raw Ceph pool detail JSON for diagnostics and advanced tooling.",
          "usage" : [ "Fetch when the admin opens the pool detail drawer", "Use in support bundles or advanced troubleshooting" ],
          "response_shape" : "JsonNode",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name returned by GET /pools",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool is absent" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Inform the user that the pool no longer exists and reload the pool list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Detailed pool inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools", "/pools/{name}/compression" ],
          "postprocessing_hint" : "Render only relevant fields and hide sensitive Ceph internals in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{name}/enable-ec-overwrites" : {
      "post" : {
        "summary" : "Enable the ec_overwrites flag for the pool.",
        "description" : "croit tries to enable this when creating the pool, however, this may fail if there are non-Bluestore OSDs. Pools that should have this flag but don't can be identified by the field 'erasureCodingOverwriteSupportMissing'.",
        "operationId" : "PoolResource_enableEcOverwrites",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable Ceph erasure-coded overwrites so the pool can host RBD or CephFS workloads.",
          "usage" : [ "Run after upgrading legacy OSDs when the UI shows erasureCodingOverwriteSupportMissing=true.", "Execute immediately after creating an EC pool if the automatic flag enable failed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name as returned by GET /pools.",
            "required" : true,
            "example" : "ec-data"
          } ],
          "failure_modes" : [ "404 if the pool cannot be found", "500 if Ceph rejects the command (e.g. OSDs not BlueStore or cluster unavailable)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the pool list and retry with an existing pool name."
          }, {
            "code" : "500",
            "action" : "Inspect ceph osd logs, ensure all target OSDs are BlueStore, then rerun the request."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "EC overwrite toggles"
          },
          "related_endpoints" : [ "/pools/{name}", "/pools/{name}/details" ],
          "postprocessing_hint" : "Refresh GET /pools/{name} to confirm erasureCodingOverwriteSupportMissing cleared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{name}/scrub" : {
      "post" : {
        "summary" : "Add pool to scrub queue.",
        "operationId" : "PoolResource_scrubPool",
        "tags" : [ "ceph-pools" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a standard scrub for the pool to validate replica consistency.",
          "usage" : [ "Run after resolving object errors to force Ceph to rescan the pool.", "Schedule periodic health checks for critical pools outside the automatic window." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Pool name targeted for scrubbing.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "500 if Ceph refuses the scrub (pool missing, command throttled, or mon connection failed)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check ceph health detail for active scrubs or errors, wait for the cluster to stabilize, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Manual pool scrubs"
          },
          "related_endpoints" : [ "/pools/{name}", "/cluster/status" ],
          "postprocessing_hint" : "Monitor ceph health detail until the scrub completes without new inconsistencies.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a pool and optional namespace.",
        "operationId" : "PoolRbdResource_forceCacheUpdate",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for a specific namespace within the pool.",
          "usage" : [ "Refresh cached metadata after editing images in a single tenant namespace.", "Call after restoring from backup scripts that bypass croit caching." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Namespace to clear; omit for default namespace.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the namespace.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "200 even if the namespace cache is already empty" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No follow-up required; next read repopulates the cache."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 90,
            "window_seconds" : 3600,
            "note" : "Namespace cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbd-namespaces" ],
          "postprocessing_hint" : "Issue a GET with details=true to rebuild cache entries on demand.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/cache-update-all" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for pool including all namespaces.",
        "operationId" : "PoolRbdResource_forceCacheUpdateAll",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on (including all of its namespaces)",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate the RBD cache for all namespaces in the pool.",
          "usage" : [ "Force croit to refresh image metadata after bulk CLI changes.", "Clear stale size/feature information before audits." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose cache should be flushed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "200 even if no cache entries existed" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No action needed; subsequent GET calls repopulate the cache."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "postprocessing_hint" : "Follow with GET requests to rebuild the cache for affected workloads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/qos" : {
      "post" : {
        "summary" : "Set qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_setPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Apply or update QoS limits for an entire RBD pool.",
          "usage" : [ "Throttle IOPS/BPS for all images in a pool with shared workloads.", "Restore defaults by submitting commands with null/0 limits to remove overrides." ],
          "response_shape" : "array<QosCommandAppliedResponse>",
          "request_parameters" : [ {
            "name" : "commands[].command",
            "in" : "body",
            "description" : "QoS command identifier (e.g. pool_iops_max).",
            "required" : true,
            "example" : "pool_iops_max"
          }, {
            "name" : "commands[].limit",
            "in" : "body",
            "description" : "Unsigned integer limit (0 or null removes).",
            "required" : false,
            "example" : "1000"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose QoS should be adjusted.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if any command is invalid or duplicated", "500 if Ceph fails to apply the limit" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use supported QoS commands listed in documentation and avoid duplicates."
          }, {
            "code" : "500",
            "action" : "Review Ceph logs; ensure the pool exists and retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "related_endpoints" : [ "/pools/{pool}/qos", "/pools/{pool}/rbds/{rbd}/qos" ],
          "postprocessing_hint" : "Retrieve GET /pools/{pool}/qos to verify each command's result.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_listPoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve QoS (Quality of Service) limits configured for a pool",
          "usage" : [ "Display current IOPS and bandwidth limits for a pool", "Check QoS configuration before modifying limits" ],
          "response_shape" : "List<QosCommandsResponse>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to query QoS settings",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "404 if pool not found", "200 [] if no QoS limits configured" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify pool exists"
          }, {
            "code" : "200",
            "action" : "Empty list indicates no QoS limits set"
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "QoS query"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{pool}/qos (POST)", "/pools/{pool}/qos (DELETE)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limits of a pool.",
        "operationId" : "QosPoolSettingResources_deletePoolQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove previously configured pool-level QoS limits for all images in the pool.",
          "usage" : [ "Reset QoS settings before applying new limits across the pool.", "Clear inherited limits when migrating to per-image QoS policies." ],
          "response_shape" : "QosCommandAppliedResponse",
          "request_parameters" : [ {
            "name" : "command",
            "in" : "body",
            "description" : "QoS command identifier to remove (e.g. pool_iops_max).",
            "required" : true,
            "example" : "pool_iops_max"
          }, {
            "name" : "limit",
            "in" : "body",
            "description" : "Ignored for deletion; supply 0 to mirror the POST payload format.",
            "required" : false,
            "example" : "0"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose QoS limit should be removed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if the command name is invalid", "500 if the Ceph command fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List valid commands via GET /pools/qos commands (or documentation) and retry with a supported value."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs; ensure the pool exists and retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "related_endpoints" : [ "/pools/{pool}/qos", "/pools/{pool}/rbds/{rbd}/qos" ],
          "postprocessing_hint" : "Fetch GET /pools/{pool}/qos to confirm the command is absent.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update a pool's mirroring settings.",
        "operationId" : "RbdMirrorResource_updatePoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to update.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Pool mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPoolUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RBD mirroring mode for a pool (disabled/pool/image)",
          "usage" : [ "Enable or disable mirroring for an entire pool", "Switch between pool-based and image-based mirroring modes" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Check for existing peers and mirrored images before disabling",
            "post_action" : "Monitor task for any image-level conflicts when changing modes"
          },
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace (Octopus+)",
            "required" : false
          }, {
            "name" : "poolMirrorMode",
            "in" : "body",
            "description" : "Target mirror mode: disabled/pool/image",
            "required" : true,
            "example" : "pool"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to update mirroring for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "400 if namespace used on pre-Octopus", "409 if peers exist when disabling", "409 if mirrored images exist when changing modes" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Remove namespace parameter on pre-Octopus clusters"
          }, {
            "code" : "409",
            "action" : "Remove peers or disable image mirroring first"
          } ],
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing mirror modes affects data replication"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a pool's mirroring settings for all namespaces.",
        "operationId" : "RbdMirrorResource_getPoolMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool to get mirror settings of.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Optional RBD namespace, or the default namespace if null.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdMirrorPoolInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect mirroring configuration and peer status for a single pool/namespace.",
          "usage" : [ "Drill into a pool's mirroring state before adjusting settings.", "Confirm mirror health when troubleshooting replication issues." ],
          "response_shape" : "RbdMirrorPoolInfo",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional Ceph namespace (Octopus+).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to inspect.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "200 null when the pool or namespace is not mirrored" ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Per-pool mirror inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/token", "/pools/{pool}/rbd-mirror/peers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/journaling" : {
      "post" : {
        "summary" : "Enable/Disable journaling for all images not in snapshot mode in the pool.",
        "operationId" : "RbdMirrorResource_updatePoolJournalingSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool with the images.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional).",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Journaling update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdJournalingUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Toggle journaling on all non-snapshot mirrored images within a pool.",
          "usage" : [ "Enable journaling before switching a pool to journal-based mirroring.", "Disable journaling to improve performance once snapshot mode is in use." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace scope.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "enableJournaling",
            "in" : "body",
            "description" : "true to enable, false to disable.",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose images should be updated.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if journaling is requested on incompatible images or CephFS is not configured", "500 if enabling/disabling fails on individual images" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure images are not in snapshot mode when enabling journaling and client support exists."
          }, {
            "code" : "500",
            "action" : "Inspect task logs for failed images; address issues and rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Pool journaling toggle"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "postprocessing_hint" : "Review the task log for per-image errors and request a resync if needed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers" : {
      "post" : {
        "summary" : "Add a pool peer using the bootstrap token from a remote cluster.",
        "operationId" : "RbdMirrorResource_addPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Import an RBD mirroring peer into the pool using a bootstrap token.",
          "usage" : [ "Set up bi-directional mirroring between clusters by applying the remote token.", "Re-add a peer after cleaning up mismatched keys or changing site names." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "peerToken",
            "in" : "body",
            "description" : "Bootstrap token JSON from the remote cluster.",
            "required" : true,
            "example" : "{...}"
          }, {
            "name" : "direction",
            "in" : "body",
            "description" : "Mirroring direction (rx_tx or tx_only).",
            "required" : false,
            "example" : "rx_tx"
          }, {
            "name" : "siteName",
            "in" : "body",
            "description" : "Optional remote site label.",
            "required" : false,
            "example" : "prod-west"
          }, {
            "name" : "localSiteName",
            "in" : "body",
            "description" : "Optional local site label to embed in the remote cluster.",
            "required" : false,
            "example" : "prod-east"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool that should mirror to the remote peer.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "400 if mirroring is disabled or more than one peer is unsupported", "400 if site names have invalid characters", "500 if importing the token fails (e.g. key conflicts)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Enable mirroring and ensure only one peer is configured when Ceph restricts it."
          }, {
            "code" : "500",
            "action" : "Review task output for key mismatches; delete conflicting keys when prompted and retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Peer onboarding"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers/{id}", "/pools/{pool}/rbd-mirror/token" ],
          "postprocessing_hint" : "Restart rbd-mirror daemons if necessary and verify the peer appears in GET /pools/{pool}/rbd-mirror.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/peers/{id}" : {
      "patch" : {
        "summary" : "Change pool peer settings. These changes only take effect after restarting the rbd-mirror daemon service.",
        "operationId" : "RbdMirrorResource_updatePoolPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool for which to add a peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Peer update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorPeerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RBD mirroring peer configuration for a pool",
          "usage" : [ "Modify peer connection settings after initial setup", "Change mirroring direction (rx-only/tx-only/rx-tx)", "Update peer authentication credentials" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify peer exists and Octopus+ for direction changes",
            "post_action" : "Restart rbd-mirror daemon service for changes to take effect"
          },
          "request_parameters" : [ {
            "name" : "client",
            "in" : "body",
            "description" : "Client name for authentication",
            "required" : false
          }, {
            "name" : "cluster",
            "in" : "body",
            "description" : "Remote cluster name",
            "required" : false
          }, {
            "name" : "direction",
            "in" : "body",
            "description" : "Mirror direction: rx-only/tx-only/rx-tx (Octopus+)",
            "required" : false,
            "example" : "rx-tx"
          }, {
            "name" : "siteName",
            "in" : "body",
            "description" : "Remote site name identifier",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name with the peer",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Peer global UUID",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "400 if direction used on pre-Octopus", "404 if peer not found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Remove direction parameter on pre-Octopus clusters"
          }, {
            "code" : "404",
            "action" : "List peers first to get valid peer ID"
          } ],
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Restart rbd-mirror daemon after changes",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a specific peer mirroring cluster from a pool.",
        "operationId" : "RbdMirrorResource_deletePoolMirrorPeer",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The global ID of the peer to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        }, {
          "description" : "The pool containing the peer.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a configured RBD mirroring peer from a pool.",
          "usage" : [ "Call when retiring a remote cluster from mirroring.", "Clean up misconfigured peers before adding correct settings." ],
          "response_shape" : "ManagedThreadTask",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose peer should be removed.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Global peer UUID to delete.",
            "required" : true,
            "example" : "3cf9834e-9d34-4e3e-8b39-4bbdcf3c4a59"
          } ],
          "failure_modes" : [ "404 if the peer ID is unknown", "500 if Ceph refuses to remove the peer" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List peers first and retry with a valid UUID."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs; ensure the peer is not in use before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror peer management"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror/peers", "/pools/{pool}/rbd-mirror/peers (POST)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-mirror/token" : {
      "patch" : {
        "summary" : "Change the site name of the pool.",
        "operationId" : "RbdMirrorResource_updatePoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to set the site name.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Site name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorSiteNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update the site name identifier for RBD mirroring pool",
          "usage" : [ "Set meaningful site name for cluster identification in mirroring", "Update site name when cluster role or location changes" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "siteName",
            "in" : "body",
            "description" : "New site name for the pool",
            "required" : true,
            "example" : "datacenter-west"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to update site name for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "404 if pool not found", "400 if mirroring not enabled on pool" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify pool exists and has mirroring enabled"
          }, {
            "code" : "400",
            "action" : "Enable mirroring on pool first"
          } ],
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/token" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the bootstrap token to set up a peer for the pool. This token can be imported on a peer cluster to automatically set up a connection between the two clusters to mirror the pool. Note that the token contains sensitive information about your cluster!\n\nWill return null if anything fails while trying to create the token (e.g. mirroring is not enabled on the pool).",
        "operationId" : "RbdMirrorResource_getPoolPeerToken",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool for which to generate a token for.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate bootstrap token for setting up RBD mirroring peer connection",
          "usage" : [ "Exchange tokens between clusters to establish mirroring", "Initial setup of cross-cluster replication", "Provide to remote cluster administrators" ],
          "response_shape" : "String?",
          "workflow_guidance" : {
            "pre_check" : "Pool exists; Mirroring enabled; Admin permissions confirmed",
            "post_action" : "Token generated containing cluster connection details; Share securely with peer administrator"
          },
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool name to generate token for",
            "required" : true,
            "example" : "rbd-pool"
          } ],
          "failure_modes" : [ "404 if pool not found", "null response if mirroring not enabled on pool", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify pool exists and has mirroring enabled."
          }, {
            "code" : "null",
            "action" : "Enable mirroring on pool first using PATCH /pools/{pool}/rbd-mirror."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for mirroring operations."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Token generation for peer setup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbd-mirror/peers" ],
          "postprocessing_hint" : "Token contains sensitive information; transmit securely to peer cluster administrator.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Token contains sensitive cluster information and should be handled securely"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbd-namespaces" : {
      "get" : {
        "summary" : "List all existing RBD namespaces",
        "operationId" : "RbdNamespaceResource_listRbdNamespaces",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNamespace"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List namespaces available within an RBD pool.",
          "usage" : [ "Discover namespaces before provisioning images for a tenant.", "Refresh after creating or deleting namespaces to update UI selections." ],
          "response_shape" : "array<RbdNamespace>",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool whose namespaces should be listed.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool is unknown", "200 [] when the pool has no namespaces" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state encouraging namespace creation."
          }, {
            "code" : "404",
            "action" : "Refresh the pool list and retry with a valid name."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Namespace discovery"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces/{namespace}", "/pools/{pool}/rbds" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/pools/{pool}/rbd-namespaces/{namespace}" : {
      "delete" : {
        "summary" : "Delete a RBD namespace",
        "operationId" : "RbdNamespaceResource_deleteRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an empty RBD namespace from the pool.",
          "usage" : [ "Clean up deprecated namespaces after migrating images to a new structure.", "Delete temporary namespaces once automation has drained them." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to remove.",
            "required" : true,
            "example" : "vm"
          } ],
          "failure_modes" : [ "400 if the namespace still contains images", "500 if Ceph rejects the deletion (namespace missing or command failed)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List images in the namespace, delete them first, then retry."
          }, {
            "code" : "500",
            "action" : "Verify the namespace still exists via rbd namespace list and reissue the request once the cluster is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 86400,
            "note" : "Namespace cleanup"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbd-namespaces to confirm the namespace disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new RBD namespace",
        "operationId" : "RbdNamespaceResource_createRbdNamespace",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The name of the new namespace",
          "name" : "namespace",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a dedicated namespace within a pool to group related RBD images.",
          "usage" : [ "Call during tenant onboarding to isolate their images.", "Create staging namespaces before cloning golden images for tests." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool that will contain the namespace.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "path",
            "description" : "Namespace identifier to create.",
            "required" : true,
            "example" : "tenant-a"
          } ],
          "failure_modes" : [ "409 if the namespace already exists", "500 if Ceph rejects the command (pool missing or insufficient permissions)" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Skip creation and reuse the existing namespace."
          }, {
            "code" : "500",
            "action" : "Verify the pool name and Ceph health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Namespace creation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbd-namespaces", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Immediately refresh the namespace list or create initial images within the new namespace.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds" : {
      "get" : {
        "summary" : "List all RBDs including their details in a pool",
        "operationId" : "PoolRbdResource_listRbdImages",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images in a pool (optionally including details) for inventory or UI browsing.",
          "usage" : [ "Populate pool detail views before selecting an image to manage.", "Page through RBDs when auditing capacity or identifying stale images." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters, sort order, and limits.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"namespace\":{\"_is_null\":true}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Name of the pool containing the images.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "404 if the pool does not exist", "200 data=[] when the pool has no images" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the pool list and retry with a valid name."
          }, {
            "code" : "200",
            "action" : "Display an empty state encouraging image creation."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "RBD inventory"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new RBD",
        "operationId" : "PoolRbdResource_createRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdImageCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new RBD image within the selected pool (optionally creating the namespace).",
          "usage" : [ "Provision a backing volume for a VM or application before mapping it to clients.", "Bootstrap automation that prepares RBDs for NVMe-oF or iSCSI exports." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "Image size in bytes (must be >0).",
            "required" : true,
            "example" : "268435456000"
          }, {
            "name" : "features[]",
            "in" : "body",
            "description" : "Optional RBD feature list (UPPERCASE enum values required).",
            "required" : false,
            "example" : "[\"EXCLUSIVE_LOCK\",\"OBJECT_MAP\",\"LAYERING\"]"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Optional namespace; created on the fly if missing.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "erasureCodedPool",
            "in" : "body",
            "description" : "Optional metadata-only pool when using EC data pool offload.",
            "required" : false,
            "example" : "ec-data"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Target pool for the image.",
            "required" : true,
            "example" : "rbd"
          } ],
          "failure_modes" : [ "409 if an image with the same name already exists", "500 if Ceph refuses creation (e.g. invalid namespace or pool)" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Choose a unique image name or delete the existing one."
          }, {
            "code" : "500",
            "action" : "Validate pool/namespace existence and review Ceph logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD provisioning"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "Trigger GET /pools/{pool}/rbds with details=true to confirm the image appears with correct features.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}" : {
      "patch" : {
        "summary" : "Change properties of an existing RBD image.",
        "operationId" : "PoolRbdResource_updateRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Details to be changed",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Adjust metadata of an existing RBD image (rename, grow, or toggle features).",
          "usage" : [ "Increase image size after storage expansion.", "Rename an image before migrating clients to a new naming scheme.", "Enable features such as object-map or fast-diff after ensuring client compatibility." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the image.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New image name; triggers ceph rename when provided.",
            "required" : false,
            "example" : "vm-001-renamed"
          }, {
            "name" : "size",
            "in" : "body",
            "description" : "New size in bytes (must be >= current size).",
            "required" : false,
            "example" : "322122547200"
          }, {
            "name" : "features[]",
            "in" : "body",
            "description" : "Replace enabled features list (UPPERCASE enum values required).",
            "required" : false,
            "example" : "[\"EXCLUSIVE_LOCK\",\"OBJECT_MAP\",\"LAYERING\"]"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Current image name.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if the image belongs to a different pool/namespace or if a shrink is attempted", "400 if the image is still in use by Ceph iSCSI (warning escalated via ignorable warnings)", "500 if Ceph resize or rename commands fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify payload consistency and ensure the target size is >= current size before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs for failures, resolve the issue, then reissue the update."
          }, {
            "code" : "200",
            "action" : "If you receive an ignorable warning about iSCSI usage, coordinate downtime before retrying disruptive changes."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "RBD metadata updates"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Force an RBD cache refresh for the image and notify dependent services of name changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get details of a specific RBD image (not cached)",
        "operationId" : "PoolRbdResource_rbdDetails",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve up-to-date details for a specific RBD image, bypassing caches when necessary.",
          "usage" : [ "Inspect features, mirroring status, and snapshots before performing maintenance.", "Verify image metadata immediately after updates to confirm changes took effect." ],
          "response_shape" : "RbdImageResponse",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace if the image is not in the default namespace.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to retrieve.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if the image cannot be found", "500 if Ceph fails to return image details" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the image list and retry with the current name."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and retry once connectivity is restored."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Image detail lookup"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/cache-update" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an existing RBD image",
        "operationId" : "PoolRbdResource_rbdDelete",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the RBD to delete",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD deletion request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdDeleteRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RBD image after validating confirmations and dependencies.",
          "usage" : [ "Remove retired images once snapshots are purged and consumers are detached.", "Automate cleanup workflows after migrating workloads to a new pool." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace; omit for default.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Repeat the pool name for confirmation.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "body",
            "description" : "Repeat the image name for confirmation.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Must equal the confirmation phrase to proceed.",
            "required" : true,
            "example" : "I'm really sure that I want to delete this"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name to delete.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if confirmation fields or namespace do not match the request path", "400 if the image still has snapshots", "500 if Ceph rejects the deletion (image already gone or cluster unhealthy)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Fix the confirmation payload, remove snapshots, and reissue the deletion."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log and Ceph health; retry after resolving cluster errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RBD deletions"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}/snapshots", "/gateways/iscsi/disks" ],
          "postprocessing_hint" : "Stream the ManagedTask output to the UI and refresh GET /pools/{pool}/rbds once it finishes.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting an RBD image permanently removes all data."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/cache-update" : {
      "post" : {
        "summary" : "Force update the cache for RBD images for a single RBD image.",
        "operationId" : "PoolRbdResource_forceCacheUpdateRbd",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Invalidate cached metadata for a single RBD image.",
          "usage" : [ "Clear stale size or feature info after manual rbd CLI operations.", "Use during troubleshooting when the UI shows outdated data for one image." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace for the image.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name being refreshed.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "200 even if no cache entry existed" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "No additional handling required; trigger a GET to repopulate metadata."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 3600,
            "note" : "Image cache invalidation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds" ],
          "postprocessing_hint" : "Next GET request will reconstruct the cache entry; avoid back-to-back invalidations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/flatten" : {
      "post" : {
        "summary" : "Flatten a clone, making it independent of its parent. Flattening happens in the background and may take hours to complete.",
        "operationId" : "PoolRbdResource_flattenRbdImage",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a background flattening job to detach a clone from its parent snapshot.",
          "usage" : [ "Run before deleting or expiring the parent snapshot chain.", "Reduce read amplification on steady-state clones kept long term." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the clone.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the clone.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Clone image name to flatten.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "200 ManagedTask(status=FAILED) if flattening encounters errors or the clone disappears" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Monitor the ManagedTask log; resolve underlying Ceph issues and rerun if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Clone flatten operations"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Wait for the ManagedTask to complete and then verify the parent snapshot can be safely removed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/qos" : {
      "post" : {
        "summary" : "Set qos limits of an image.",
        "operationId" : "QosRbdSettingResources_setRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS commands to apply",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/QosCommandLimit"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure QoS limits on a specific RBD image, optionally overriding pool defaults.",
          "usage" : [ "Throttle noisy tenants by applying per-image IOPS/BPS caps.", "Remove overrides by sending commands with null/0 limit values." ],
          "response_shape" : "array<QosCommandAppliedResponse>",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "commands[].command",
            "in" : "body",
            "description" : "QoS command identifier (e.g. limit_iops).",
            "required" : true,
            "example" : "limit_iops"
          }, {
            "name" : "commands[].limit",
            "in" : "body",
            "description" : "Unsigned integer limit; null removes the setting.",
            "required" : false,
            "example" : "500"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to configure.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if commands are invalid or duplicated", "500 if Ceph fails to apply the limit" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure commands come from the supported set and avoid duplicates."
          }, {
            "code" : "500",
            "action" : "Check Ceph logs; verify the image exists and retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos", "/pools/{pool}/qos" ],
          "postprocessing_hint" : "Call GET /pools/{pool}/rbds/{rbd}/qos to confirm applied limits and inherited values.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "List the current qos limits of an image.",
        "operationId" : "QosRbdSettingResources_listRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/QosCommandsResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve QoS limits configured for a specific RBD image",
          "usage" : [ "Display per-image IOPS and bandwidth limits", "Compare image QoS settings with pool defaults" ],
          "response_shape" : "List<QosCommandsResponse>",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace for the image",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-001"
          } ],
          "failure_modes" : [ "404 if image not found", "200 [] if no QoS limits configured" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify image exists in the pool"
          }, {
            "code" : "200",
            "action" : "Empty list means image uses pool defaults"
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "QoS query"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos (POST)", "/pools/{pool}/rbds/{rbd}/qos (DELETE)", "/pools/{pool}/qos" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete qos limit of an image.",
        "operationId" : "QosRbdSettingResources_deleteRbdQosSettings",
        "tags" : [ "qos-settings" ],
        "parameters" : [ {
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "QOS command to delete",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/QosCommandLimit"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/QosCommandAppliedResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a specific QoS limit from an RBD image (optionally scoped by namespace).",
          "usage" : [ "Clear overrides before inheriting pool-wide QoS policies.", "Reset an image to unlimited IOPS/BPS after finishing migration tests." ],
          "response_shape" : "QosCommandAppliedResponse",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "command",
            "in" : "body",
            "description" : "QoS command identifier to remove (e.g. limit_iops).",
            "required" : true,
            "example" : "limit_iops"
          }, {
            "name" : "limit",
            "in" : "body",
            "description" : "Ignored for deletion; provide 0 for compatibility with POST payloads.",
            "required" : false,
            "example" : "0"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name whose QoS is being cleared.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if the command name is invalid", "500 if Ceph fails to remove the QoS setting" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use a supported QoS command (see documentation) before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph logs and ensure the image exists; retry once resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "QoS configuration"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/qos", "/pools/{pool}/qos" ],
          "postprocessing_hint" : "Re-run GET /pools/{pool}/rbds/{rbd}/qos to verify the command is absent.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror" : {
      "patch" : {
        "summary" : "Update RBD mirroring settings for the image.",
        "operationId" : "RbdMirrorResource_updateImageMirrorSettings",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to update.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Image mirror update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdMirrorImageUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure RBD image-level mirroring settings",
          "usage" : [ "Enable/disable mirroring for specific RBD images", "Switch between journal and snapshot mirroring modes", "Configure mirroring schedule for snapshot mode" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify pool mirror mode, image features, and Ceph version compatibility",
            "post_action" : "Monitor task for feature enablement and mode changes"
          },
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace (Octopus+)",
            "required" : false
          }, {
            "name" : "imageMirrorMode",
            "in" : "body",
            "description" : "Mirror mode: disabled/journal/snapshot",
            "required" : false,
            "example" : "snapshot"
          }, {
            "name" : "scheduleName",
            "in" : "body",
            "description" : "Schedule name for snapshot mode",
            "required" : false
          }, {
            "name" : "scheduleInterval",
            "in" : "body",
            "description" : "Schedule interval for snapshots",
            "required" : false,
            "example" : "1h"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-001"
          } ],
          "failure_modes" : [ "400 if snapshot mode on pre-Octopus", "409 if pool not in image mirror mode", "409 if journaling conflicts with snapshot mode" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use journal mode on pre-Octopus clusters"
          }, {
            "code" : "409",
            "action" : "Switch pool to image mode or resolve feature conflicts"
          } ],
          "related_endpoints" : [ "/pools/{pool}/rbd-mirror", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changes affect image replication behavior"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/resync" : {
      "post" : {
        "summary" : "Force a RBD mirroring resync on the image. Note that this only flags the image, it's up to the rbd-mirror daemon to execute the resync.",
        "operationId" : "RbdMirrorResource_resyncImage",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image to resync.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Request a re-synchronization of a mirrored RBD image with its remote peer.",
          "usage" : [ "Trigger after recovering from divergence on a secondary image.", "Flag an image for resync when the remote copy may be stale." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace (Octopus+).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to resync.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if the image is primary or mirroring is disabled", "400 if namespaces are used on unsupported releases", "500 if Ceph fails to mark the image for resync" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the image is a non-primary mirrored secondary and that namespaces are supported."
          }, {
            "code" : "500",
            "action" : "Inspect Ceph logs to identify why the resync flag could not be set."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Mirror maintenance"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror", "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots" : {
      "get" : {
        "summary" : "Get mirror snapshots of the image, or an empty list if snapshot mode is not enabled.",
        "operationId" : "RbdMirrorResource_getImageSnapshots",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdMirrorSnapshot"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List mirror snapshots for a specific RBD image configured for snapshot-based mirroring",
          "usage" : [ "Review available recovery points for mirrored images", "Audit snapshot history for specific images", "Check mirroring progress" ],
          "response_shape" : "List<RbdMirrorSnapshot>",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace (Octopus and later)",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the RBD image",
            "required" : true,
            "example" : "rbd-pool"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "RBD image name",
            "required" : true,
            "example" : "vm-disk-01"
          } ],
          "failure_modes" : [ "200 empty list if image not in snapshot mode", "404 if pool or image not found", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates image not in snapshot mode or no snapshots created."
          }, {
            "code" : "404",
            "action" : "Verify pool and image names exist."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for mirroring operations."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Image snapshot listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots", "/pools/{pool}/rbd-mirror" ],
          "postprocessing_hint" : "Snapshots are ordered by creation time; use for point-in-time recovery planning.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create a mirror snapshot of the image",
        "operationId" : "RbdMirrorResource_createImageSnapshot",
        "tags" : [ "rbd-mirror" ],
        "parameters" : [ {
          "description" : "The pool containing the image.",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The image with snapshots.",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on (optional). Only in Ceph Octopus or later.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a mirroring snapshot for an image configured in snapshot mode.",
          "usage" : [ "Generate an on-demand snapshot to seed mirroring prior to scheduled runs.", "Create recovery points before maintenance on mirrored workloads." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace (Octopus+).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to snapshot.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "400 if the image is not in snapshot mirror mode", "400 if the pool has no configured peers", "400 if namespaces are used on unsupported releases", "500 if Ceph fails to create the snapshot" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the image operates in snapshot mode with peers configured before retrying."
          }, {
            "code" : "500",
            "action" : "Review Ceph logs for snapshot creation errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Mirror snapshot operations"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/rbd-mirror", "/pools/{pool}/rbds/{rbd}/rbd-mirror/snapshots (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}" : {
      "patch" : {
        "summary" : "Update an existing snapshot of an image.",
        "operationId" : "PoolRbdResource_updateRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to update",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to update",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot update request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rename or change protection status for an existing RBD snapshot.",
          "usage" : [ "Protect snapshots before exposing clones to prevent accidental deletion.", "Rename snapshots to follow retention policies after automation triggers." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace for the snapshot.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New snapshot name.",
            "required" : false,
            "example" : "pre-upgrade-2024-04"
          }, {
            "name" : "protect",
            "in" : "body",
            "description" : "true to protect, false to unprotect.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Current snapshot name.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "404 if the snapshot cannot be found", "500 if Ceph rejects the rename/protect command or dependencies exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the snapshot list to confirm its presence before retrying."
          }, {
            "code" : "500",
            "action" : "Ensure dependent clones are detached and Ceph is healthy, then retry the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot metadata updates"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Re-fetch snapshot details to confirm the new name or protection status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a snapshot of an image.",
        "operationId" : "PoolRbdResource_deleteRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to operate on",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot name to delete",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RBD snapshot to free storage or allow subsequent image deletion.",
          "usage" : [ "Clean up snapshots after confirming they are no longer needed for rollback.", "Run before deleting the parent image, because deletions require all snapshots to be gone." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace if the image is not in the default.",
            "required" : false,
            "example" : "prod"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool hosting the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Parent image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to delete.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "500 if Ceph refuses to delete the snapshot (still protected or clones depend on it)" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Unprotect the snapshot and detach dependent clones before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Snapshot deletions"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "Refresh GET /pools/{pool}/rbds/{rbd} to verify the snapshot list updated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new snapshot of an image.",
        "operationId" : "PoolRbdResource_createRbdSnap",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image name to snapshot",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "Name of the new snapshot",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a point-in-time snapshot for an RBD image.",
          "usage" : [ "Take an application-consistent snapshot prior to maintenance or upgrade steps.", "Capture a base image before cloning it to new environments." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace containing the image.",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Pool containing the source image.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Image name to snapshot.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to create.",
            "required" : true,
            "example" : "pre-upgrade"
          } ],
          "failure_modes" : [ "409 if a snapshot with the same name already exists", "500 if Ceph refuses to create the snapshot" ],
          "error_handling" : [ {
            "code" : "409",
            "action" : "Choose a unique snapshot name or delete the existing one."
          }, {
            "code" : "500",
            "action" : "Verify image accessibility and Ceph health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Snapshot creation"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots", "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" ],
          "postprocessing_hint" : "List snapshots to confirm creation and consider protecting it if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/pools/{pool}/rbds/{rbd}/snapshots/{snap}/clone" : {
      "post" : {
        "summary" : "Create a clone of a snapshot on an existing image.",
        "operationId" : "PoolRbdResource_createRbdClone",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The pool to operate on",
          "name" : "pool",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The RBD image to clone",
          "name" : "rbd",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The snapshot to clone",
          "name" : "snap",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The namespace to operate on, optional, default is the default namespace",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Clone creation request",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/CloneRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Clone an RBD snapshot into a writable image, optionally in another pool or namespace.",
          "usage" : [ "Provision a new VM from a golden snapshot without copying data.", "Create point-in-time test environments while keeping linkage to the parent image." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace of the source snapshot.",
            "required" : false,
            "example" : "prod"
          }, {
            "name" : "pool",
            "in" : "body",
            "description" : "Destination pool for the clone.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "name",
            "in" : "body",
            "description" : "New clone name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "namespace",
            "in" : "body",
            "description" : "Destination namespace (requires Mimic+ clients for cross-namespace clones).",
            "required" : false,
            "example" : "tenant-a"
          } ],
          "path_parameters" : [ {
            "name" : "pool",
            "in" : "path",
            "description" : "Source pool containing the snapshot.",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "rbd",
            "in" : "path",
            "description" : "Source image name.",
            "required" : true,
            "example" : "golden-template"
          }, {
            "name" : "snap",
            "in" : "path",
            "description" : "Snapshot identifier to clone.",
            "required" : true,
            "example" : "2024-01-01"
          } ],
          "failure_modes" : [ "400 if clone v2 is required but min-compat-client is too low", "500 if Ceph refuses the clone (snapshot missing, insufficient permissions)" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Upgrade clients or run 'ceph osd set-require-min-compat-client mimic' before retrying."
          }, {
            "code" : "500",
            "action" : "Verify the snapshot exists and is protected when required, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "RBD clone operations"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds/{rbd}", "/pools/{pool}/rbds/{rbd}/snapshots" ],
          "postprocessing_hint" : "List the destination pool to confirm the clone appears and schedule flattening if long-lived.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/rbds" : {
      "get" : {
        "summary" : "List all RBD details in all pools",
        "operationId" : "RbdResource_listAllRbds",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseRbdImageResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images with size, mirroring, and feature details across all pools/namespaces.",
          "usage" : [ "Call to populate RBD inventory tables in the UI.", "Refresh after provisioning or deleting RBDs to ensure cached details are current." ],
          "response_shape" : "PaginationResponse<RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset, sorting, and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"pool\":{\"_eq\":\"rbd\"}}]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Set limit <=100 to avoid large ceph-volume dumps.",
            "pagination.where.namespace" : "Filter by namespace when browsing multi-tenant pools."
          },
          "failure_modes" : [ "500 if Ceph queries fail or the RBD cache is unavailable" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Use fallback: GET /rbds/rbd-names for basic listing, then GET /rbds/rbd-infos for details. This two-step approach is more reliable when Ceph cache is unstable. COMMON TROUBLESHOOTING: no_rbds_found - Check if any pools have application=rbd set; permission_denied - Verify ceph.client.admin keyring access."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "RBD inventory refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds/rbd-names", "/rbds/rbd-infos", "/rbds/rbd-pools" ],
          "postprocessing_hint" : "If withDetails=false, schedule detail fetches for visible rows before rendering.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-infos" : {
      "get" : {
        "summary" : "Get RBD details (size, features, parent, data-pool) for a list of images.",
        "operationId" : "RbdResource_rbdDetailsMultiple",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "Images to query, syntax is pool/image or pool/namespace/image.",
          "name" : "image",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "$ref" : "#/components/schemas/RbdImageResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch detailed metadata for specific RBD images in bulk.",
          "usage" : [ "Call when an operator selects multiple images to inspect mirroring, parent, or feature flags.", "Use after provisioning to confirm images picked up expected settings." ],
          "response_shape" : "map<string,RbdImageResponse>",
          "request_parameters" : [ {
            "name" : "image",
            "in" : "query",
            "description" : "Repeatable query parameter in the form pool/image or pool/namespace/image.",
            "required" : true,
            "example" : "rbd/my-image"
          } ],
          "failure_modes" : [ "400 if an image identifier is malformed", "500 if RBD detail retrieval fails for all requested images" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Normalize image identifiers to pool[/namespace]/image before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect logs for ceph/rbd errors; reissue the request for affected images only. COMMON TROUBLESHOOTING: no_rbds_found - Check if any pools have application=rbd set; permission_denied - Verify ceph.client.admin keyring access."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "Detailed RBD metadata"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "Warn users when map entries are null (images unavailable) and suggest refreshing the cache.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-names" : {
      "get" : {
        "summary" : "List all RBD names in all pools",
        "operationId" : "RbdResource_listAllRbdNames",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdNameResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Lightweight fallback for RBD listing when GET /rbds fails - return basic RBD identifiers only.",
          "usage" : [ "Use as primary RBD discovery when full details not needed.", "Fallback when GET /rbds returns 500 errors.", "Populate dropdowns when prompting the user to select an image.", "Call before issuing detailed queries to avoid loading full image metadata." ],
          "response_shape" : "array<RbdNameResponse>",
          "failure_modes" : [ "500 if Ceph rbd list commands fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Log the exception and retry once Ceph connectivity is restored. COMMON TROUBLESHOOTING: no_rbds_found - Check if any pools have application=rbd set; permission_denied - Verify ceph.client.admin keyring access."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD name lookup"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 180,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-pools", "/rbds/rbd-infos" ],
          "postprocessing_hint" : "Sort results alphabetically and group by pool for UI widgets. FALLBACK ENDPOINT: Use when /rbds fails. Follow with /rbds/rbd-infos for detailed information.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/rbd-pools" : {
      "get" : {
        "summary" : "List all RBD pools and namespaces",
        "operationId" : "RbdResource_listAllRbdPools",
        "tags" : [ "rbds" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RbdPoolInfo"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "First step in RBD discovery - find which pools contain RBDs before listing images.",
          "usage" : [ "Check if RBD pools exist before listing RBDs.", "Diagnose empty RBD responses.", "Call prior to presenting pool/namespace selectors in the UI.", "Use to validate that a target pool is active before provisioning RBDs." ],
          "response_shape" : "array<RbdPoolInfo>",
          "failure_modes" : [ "500 if Ceph reports errors while enumerating pools" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Retry after inspecting Ceph manager logs; inactive pools may need activation. COMMON TROUBLESHOOTING: no_rbds_found - Check if any pools have application=rbd set; permission_denied - Verify ceph.client.admin keyring access."
          } ],
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 300,
            "note" : "RBD pool listing"
          },
          "cache_hint" : "long-lived",
          "recommended_poll_interval" : {
            "value" : 600,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/rbds", "/rbds/rbd-names" ],
          "postprocessing_hint" : "PRE-CHECK for /rbds: Non-empty list indicates RBDs should be available. Highlight pools with active=false to signal decommissioned namespaces. Use before /rbds to understand which pools contain RBD images.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/rbds/used-size" : {
      "get" : {
        "summary" : "Returns RBD pool/namespace/image used size",
        "operationId" : "RbdResource_rbdUsedSize",
        "tags" : [ "rbds" ],
        "parameters" : [ {
          "description" : "The namespace to query. If omitted or set to null, the default namespace will be used.",
          "name" : "namespace",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "description" : "The pool to query (required).",
          "name" : "pool",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "The rbd to query. If omitted or set to null,the size of the entire namespace will be returned, otherwise only the size of this rbd.",
          "name" : "rbd",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RbdUsedSizeResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate provisioned and used size for a pool, namespace, or specific RBD image.",
          "usage" : [ "Display usage data before reclaiming space or deleting snapshots.", "Assess capacity distribution across namespaces for reporting." ],
          "response_shape" : "RbdUsedSizeResponse",
          "request_parameters" : [ {
            "name" : "pool",
            "in" : "query",
            "description" : "Pool name to query (required).",
            "required" : true,
            "example" : "rbd"
          }, {
            "name" : "namespace",
            "in" : "query",
            "description" : "Optional namespace to scope usage calculations.",
            "required" : false,
            "example" : "tenant-a"
          }, {
            "name" : "rbd",
            "in" : "query",
            "description" : "Optional image name to return a single-image result.",
            "required" : false,
            "example" : "vm-001"
          } ],
          "failure_modes" : [ "404 if the pool cannot be found", "500 if Ceph usage queries fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the pool exists before retrying."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and rerun once the cluster responds to usage queries."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Usage reporting"
          },
          "related_endpoints" : [ "/pools/{pool}/rbds", "/pools/{pool}/rbds/{rbd}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets" : {
      "get" : {
        "summary" : "List of all buckets.",
        "operationId" : "RgwResource_getRgwBuckets",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with usage, owner and placement details.",
          "usage" : [ "Render the bucket inventory view", "Filter via pagination when exporting bucket data" ],
          "response_shape" : "OptionalPaginationResponse<RgwBucketResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for large bucket sets.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"owner\":{\"_eq\":\"alice\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no buckets exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show onboarding guidance to create buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/policy" ],
          "postprocessing_hint" : "Aggregate usageSum across zones for dashboard totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}" : {
      "patch" : {
        "summary" : "Update RGW bucket",
        "operationId" : "RgwResource_updateRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update S3 bucket ownership, ACLs, or versioning configuration.",
          "usage" : [ "Call when transferring bucket ownership between users or tenants.", "Use to modify bucket versioning settings or access controls post-creation." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; New owner user exists if changing ownership; ACL entries valid",
            "post_action" : "Bucket configuration updated; Ownership transferred if requested; Versioning state changed"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "body",
            "description" : "New owner UID for bucket ownership transfer.",
            "required" : false,
            "example" : "tenant2:bob"
          }, {
            "name" : "acl",
            "in" : "body",
            "description" : "Updated access control list for the bucket.",
            "required" : false,
            "example" : "[{\"user\":\"bob\",\"permission\":\"READ\"}]"
          }, {
            "name" : "versioning",
            "in" : "body",
            "description" : "Updated versioning setting (OFF, SUSPENDED, ENABLED).",
            "required" : false,
            "example" : "SUSPENDED"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to update.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if ACL is empty or versioning setting is invalid", "404 if the bucket does not exist", "500 if S3 configuration update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate ACL entries and versioning parameter values."
          }, {
            "code" : "404",
            "action" : "Verify the bucket exists and is accessible."
          }, {
            "code" : "500",
            "action" : "Check RGW service status and retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "S3 bucket updates"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/users" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName} to confirm updated settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW bucket details",
        "operationId" : "RgwResource_getRgwBucketDetails",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BucketDetails"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return ACL, CORS and versioning information for a bucket via RGW.",
          "usage" : [ "Open before editing bucket access settings", "Refresh after applying policy or versioning changes to confirm state" ],
          "response_shape" : "BucketDetails",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID to disambiguate tenants when looking up the bucket.",
            "required" : false,
            "example" : "tenant1:alice"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (with tenant prefix if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found", "400 if the provided owner does not match" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt the operator to refresh the bucket inventory or verify ownership."
          }, {
            "code" : "400",
            "action" : "Validate owner input and retry without an owner if unsure."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket detail inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/buckets/{bucketName}/policy", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Mask sensitive ACL entries when presenting to non-admin viewers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete RGW bucket",
        "operationId" : "RgwResource_deleteRgwBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket deletion request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketDeletionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an RGW bucket, optionally purging all objects first.",
          "usage" : [ "Call with deleteData=true to purge objects for large cleanup operations (returns a ManagedTask).", "Use deleteData=false to remove an empty bucket immediately." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "deleteData",
            "in" : "body",
            "description" : "true to delete all objects before dropping the bucket.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "thisWillDeleteData",
            "in" : "body",
            "description" : "Confirmation string required when deleteData=true (I know this will delete data).",
            "required" : false,
            "example" : "I know this will delete data"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (without tenant prefix).",
            "required" : true,
            "example" : "logs-prod"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist or the name mismatch", "400 if deleteData=true without confirmation string" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /s3/buckets to confirm the bucket still exists before retrying."
          }, {
            "code" : "400",
            "action" : "Provide the exact confirmation text when deleting data."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Bucket lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects", "/tasks/{id}" ],
          "postprocessing_hint" : "If a ManagedTask is returned, monitor it for WARN logs when objects fail to delete.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting buckets (especially with deleteData=true) permanently removes stored objects."
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new S3 bucket.",
        "operationId" : "RgwResource_createBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BucketCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new S3 bucket with optional versioning, placement, and ACL configuration.",
          "usage" : [ "Call when provisioning new buckets for applications or user storage.", "Use after setting up placement policies to create buckets with specific storage requirements." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Bucket name is unique; Owner user exists; Placement policy valid if specified",
            "post_action" : "Bucket created with specified configuration; ACLs applied; Versioning enabled if requested"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "body",
            "description" : "S3 user ID who will own the bucket.",
            "required" : true,
            "example" : "tenant1:alice"
          }, {
            "name" : "placement",
            "in" : "body",
            "description" : "Optional placement policy name for storage class.",
            "required" : false,
            "example" : "fast-ssd"
          }, {
            "name" : "versioning",
            "in" : "body",
            "description" : "Bucket versioning setting (OFF or ENABLED).",
            "required" : false,
            "example" : "ENABLED"
          }, {
            "name" : "acl",
            "in" : "body",
            "description" : "Access control list for the bucket.",
            "required" : false,
            "example" : "[{\"user\":\"alice\",\"permission\":\"FULL_CONTROL\"}]"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to create.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if bucket name already exists or versioning setting is invalid", "404 if the specified owner user does not exist", "500 if S3 bucket creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify bucket name uniqueness and validate versioning parameter."
          }, {
            "code" : "404",
            "action" : "Ensure the owner user exists before creating the bucket."
          }, {
            "code" : "500",
            "action" : "Check RGW service status and retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "S3 bucket creation"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/buckets/{bucketName}", "/s3/placements" ],
          "postprocessing_hint" : "Poll GET /s3/buckets to confirm the bucket appears with correct ownership and settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/download" : {
      "get" : {
        "summary" : "Download an object.",
        "operationId" : "RgwResource_downloadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stream a single S3 object through croit with presigned token handling.",
          "usage" : [ "Allow administrators to download objects directly from the UI", "Use for one-off retrievals; do not poll" ],
          "response_shape" : "DownloadableObject",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenant resolution.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to download.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object is missing", "403 if the caller lacks permission" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Warn the administrator and suggest refreshing the object list."
          }, {
            "code" : "403",
            "action" : "Require admin credentials and ensure ACLs allow access."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Object downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Trigger the download immediately; do not attempt resumable transfers via this endpoint.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. API params are identical to object listing.",
        "operationId" : "RgwResource_listMultipartUploads",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/MultipartUploadListing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Inspect ongoing multipart uploads for a bucket using native S3 markers.",
          "usage" : [ "Display uploads that may require cleanup", "Use before deciding to abort stalled uploads" ],
          "response_shape" : "MultipartUploadListing",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "max",
            "in" : "query",
            "description" : "Maximum uploads to return (default 50).",
            "required" : false,
            "example" : "100"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Filter uploads by key prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "continuationToken",
            "in" : "query",
            "description" : "Continue listing from previous response.",
            "required" : false,
            "example" : "CgAJAA..."
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to list without delimiter.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to list.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the bucket inventory before retrying."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads-paginated", "/s3/buckets/{bucketName}/multipart-uploads" ],
          "postprocessing_hint" : "Sort by initiated time to highlight oldest uploads.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Cancel an active or abandoned multi-part upload.",
        "operationId" : "RgwResource_cancelMultipartUpload",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "uploadId",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Abort an in-progress S3 multipart upload",
          "usage" : [ "Clean up incomplete uploads to free storage", "Cancel failed or abandoned upload sessions" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional bucket owner",
            "required" : false
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key of the upload",
            "required" : true,
            "example" : "large-file.zip"
          }, {
            "name" : "uploadId",
            "in" : "query",
            "description" : "Multipart upload ID",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if bucket, key, or uploadId not found", "403 if lacking permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List multipart uploads first to get valid uploadId"
          }, {
            "code" : "403",
            "action" : "Verify bucket ownership or admin rights"
          } ],
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 60,
            "note" : "Upload management"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/multipart-uploads-paginated" : {
      "get" : {
        "summary" : "List active and abandoned multi-part uploads. Uses croit's pagination.",
        "operationId" : "RgwResource_listMultipartUploadsPaginated",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3MultipartUploadResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate multipart uploads with server-side filtering and caching of continuation tokens.",
          "usage" : [ "Use in admin UIs where consistent paging is required", "Prefer when sorting/filtering uploads by metadata" ],
          "response_shape" : "S3MultipartUploadResponse",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for the bucket.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Filter uploads by prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter grouping.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          }, {
            "name" : "maxQueried",
            "in" : "query",
            "description" : "Cap on how many uploads to scan server-side per request (default 10000).",
            "required" : false,
            "example" : "5000"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket whose multipart uploads to page through.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the bucket name/owner before retrying."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Multipart upload monitoring"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/multipart-uploads", "/s3/buckets/{bucketName}/objects-paginated" ],
          "postprocessing_hint" : "Reuse the pagination.after and returned next markers to continue the listing without re-querying earlier data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects" : {
      "get" : {
        "summary" : "List objects in a bucket. Refer to S3 documentation for listing details",
        "operationId" : "RgwResource_listBucketObjects",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "continuationToken",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "name" : "max",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Listing"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Perform an S3 object listing with optional prefix and pagination markers.",
          "usage" : [ "Use for browsing objects in classic delimiter-based mode", "When more control is needed, prefer the paginated variant" ],
          "response_shape" : "S3Listing",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "max",
            "in" : "query",
            "description" : "Maximum keys per response (defaults to 50).",
            "required" : false,
            "example" : "100"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Restrict listing to keys with this prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "continuationToken",
            "in" : "query",
            "description" : "Opaque marker to continue a previous listing.",
            "required" : false,
            "example" : "CgABAA..."
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter-based folder emulation.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to list objects from.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket does not exist", "400 if listing parameters are invalid" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the bucket list and confirm the owner parameter."
          }, {
            "code" : "400",
            "action" : "Validate prefix and continuation token before retrying."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Interactive bucket browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects-paginated", "/s3/buckets/{bucketName}/objects/metadata" ],
          "postprocessing_hint" : "Combine prefixes and objects to render directory-style listings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an object by name.",
        "operationId" : "RgwResource_deleteS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a specific S3 object from a bucket",
          "usage" : [ "Remove individual files from storage", "Clean up obsolete or temporary objects" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional bucket owner",
            "required" : false
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to delete",
            "required" : true,
            "example" : "path/to/file.txt"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if bucket or object not found", "403 if lacking permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket and object exist"
          }, {
            "code" : "403",
            "action" : "Check bucket ownership or admin rights"
          } ],
          "rate_limit" : {
            "limit" : 1000,
            "window_seconds" : 60,
            "note" : "Object operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects (GET)", "/s3/buckets/{bucketName}/objects (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Object deletion is permanent and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects-paginated" : {
      "get" : {
        "summary" : "List objects and prefixes in a bucket. Uses croit's pagination.",
        "operationId" : "RgwResource_listBucketObjectsAndPrefixes",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "flatView",
          "in" : "query",
          "schema" : {
            "type" : [ "boolean", "null" ]
          }
        }, {
          "description" : "Maximum number of S3 objects queried for filtering.",
          "name" : "maxQueried",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "prefix",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3ObjectsResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide consistent server-side pagination over bucket contents with filtering and sorting support.",
          "usage" : [ "Use in UI tables that need deterministic paging and sorting", "Cache continuation tokens returned via pagination.after for subsequent calls" ],
          "response_shape" : "S3ObjectsResponse",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenant-aware lookups.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "prefix",
            "in" : "query",
            "description" : "Restrict listing to objects with this prefix.",
            "required" : false,
            "example" : "backup/"
          }, {
            "name" : "flatView",
            "in" : "query",
            "description" : "true to disable delimiter-based grouping.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON controlling limit, offset, sort and filters.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          }, {
            "name" : "maxQueried",
            "in" : "query",
            "description" : "Upper bound for objects scanned per request (default 10000).",
            "required" : false,
            "example" : "5000"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to enumerate.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket cannot be found", "400 if filters are invalid" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket ownership or refresh the inventory."
          }, {
            "code" : "400",
            "action" : "Adjust pagination filters or reduce maxQueried when timeouts occur."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 120,
            "note" : "Paginated object browsing"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Merge prefixes with objects when presenting a tree view; use nextMarker caching to avoid re-querying prior pages.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/acl" : {
      "put" : {
        "summary" : "Override an object's ACL.",
        "operationId" : "RgwResource_setObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Object ACL",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/AclEntry"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update access control list for a specific S3 object.",
          "usage" : [ "Call when modifying object permissions for users or groups.", "Use to grant or revoke access to specific objects without affecting bucket ACLs." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Object exists; ACL entries are valid; User has permission to modify ACLs",
            "post_action" : "Object ACL updated with new permissions; Previous ACL entries replaced"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID to disambiguate bucket access.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key (filename) to update ACL for.",
            "required" : true,
            "example" : "logs/app.log"
          }, {
            "name" : "acl",
            "in" : "body",
            "description" : "New access control list for the object.",
            "required" : true,
            "example" : "[{\"user\":\"bob\",\"permission\":\"READ\"}]"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket containing the object.",
            "required" : true,
            "example" : "my-app-logs"
          } ],
          "failure_modes" : [ "400 if ACL list is empty", "404 if the object or bucket does not exist", "500 if S3 ACL update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure ACL contains at least one entry with valid permissions."
          }, {
            "code" : "404",
            "action" : "Verify object key and bucket name are correct."
          }, {
            "code" : "500",
            "action" : "Check RGW service status and retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Object ACL updates"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName}/objects/acl to confirm updated permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the current ACL of an object.",
        "operationId" : "RgwResource_getObjectAcl",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/AclEntry"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the ACL grants for a specific object.",
          "usage" : [ "Display permissions before editing", "Audit who has access to sensitive objects" ],
          "response_shape" : "array<AclEntry>",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key whose ACL to load.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object or bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the object key is correct and the user has permission to read it."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object ACL inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Highlight grants that provide public access or wildcard permissions.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/copy" : {
      "put" : {
        "summary" : "Copy an object.",
        "operationId" : "RgwResource_copyS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Copy an S3 object to another location within the same or different bucket.",
          "usage" : [ "Call when duplicating objects for backup or organizing data.", "Use to copy objects between buckets with different storage policies." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Source object exists; Destination bucket accessible; Source and destination differ",
            "post_action" : "Object copied with original ACLs preserved; Destination object created"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for destination bucket access.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Source object key to copy.",
            "required" : true,
            "example" : "data/file.txt"
          }, {
            "name" : "dstBucketName",
            "in" : "query",
            "description" : "Destination bucket name (defaults to source bucket).",
            "required" : false,
            "example" : "backup-bucket"
          }, {
            "name" : "dstKey",
            "in" : "query",
            "description" : "Destination object key name.",
            "required" : true,
            "example" : "archive/file-backup.txt"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Source bucket containing the object to copy.",
            "required" : true,
            "example" : "source-bucket"
          } ],
          "failure_modes" : [ "400 if source and destination are identical", "404 if source or destination bucket does not exist", "500 if S3 copy operation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure destination differs from source in bucket name or object key."
          }, {
            "code" : "404",
            "action" : "Verify both source and destination buckets exist and are accessible."
          }, {
            "code" : "500",
            "action" : "Check RGW service status and retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Object copy operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/move" ],
          "postprocessing_hint" : "Verify copy with GET /s3/buckets/{dstBucketName}/objects to confirm object appears at destination.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/metadata" : {
      "put" : {
        "summary" : "Override object metadata.",
        "operationId" : "RgwResource_putS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "S3 metadata",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/S3Metadata"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update metadata headers for a specific S3 object without changing the object content.",
          "usage" : [ "Call when modifying object content-type, cache-control, or custom metadata.", "Use to update metadata without requiring object re-upload or version change." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Object exists; New metadata is valid; User has write permissions",
            "post_action" : "Object metadata updated; ACLs preserved; Object content unchanged"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID to disambiguate bucket access.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to update metadata for.",
            "required" : true,
            "example" : "files/document.pdf"
          }, {
            "name" : "metadata",
            "in" : "body",
            "description" : "New metadata headers for the object.",
            "required" : true,
            "example" : "{\"contentType\":\"application/pdf\",\"userMetadata\":{\"author\":\"alice\"}}"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket containing the object.",
            "required" : true,
            "example" : "my-app-data"
          } ],
          "failure_modes" : [ "404 if the object or bucket does not exist", "500 if S3 metadata update fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify object key and bucket name are correct and accessible."
          }, {
            "code" : "500",
            "action" : "Check RGW service status and retry after resolving connectivity issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Object metadata updates"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects/metadata", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Verify changes with GET /s3/buckets/{bucketName}/objects/metadata to confirm updated headers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get metadata of an object.",
        "operationId" : "RgwResource_getS3Metadata",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3Metadata"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch S3 object metadata (size, content type, custom headers) without downloading the object.",
          "usage" : [ "Inspect metadata prior to downloads", "Verify custom metadata set by clients" ],
          "response_shape" : "S3Metadata",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional owner UID for tenanted buckets.",
            "required" : false,
            "example" : "tenant1:alice"
          }, {
            "name" : "key",
            "in" : "query",
            "description" : "Object key to inspect.",
            "required" : true,
            "example" : "backup/archive.tar.gz"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket containing the object.",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the object or bucket does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Recheck the key (case sensitive) and ensure the bucket is selected correctly."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 120,
            "note" : "Object metadata inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/acl", "/s3/buckets/{bucketName}/download" ],
          "postprocessing_hint" : "Expose both standard headers and user metadata distinctly in the UI.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/buckets/{bucketName}/objects/move" : {
      "put" : {
        "summary" : "Move an object.",
        "operationId" : "RgwResource_moveS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "dstBucketName",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        }, {
          "name" : "dstKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "key",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Move an S3 object to a different location or bucket",
          "usage" : [ "Reorganize object storage", "Rename objects", "Move objects between buckets" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Source object exists; Destination bucket accessible; Source and destination differ",
            "post_action" : "Object moved to new location; Original object removed from source"
          },
          "request_parameters" : [ {
            "name" : "key",
            "in" : "query",
            "description" : "Source object key",
            "required" : true,
            "example" : "folder/file.txt"
          }, {
            "name" : "dstKey",
            "in" : "query",
            "description" : "Destination object key",
            "required" : true,
            "example" : "new-folder/renamed-file.txt"
          }, {
            "name" : "dstBucketName",
            "in" : "query",
            "description" : "Destination bucket name (defaults to source bucket)",
            "required" : false
          }, {
            "name" : "owner",
            "in" : "query",
            "description" : "Bucket owner override",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Source bucket name",
            "required" : true
          } ],
          "failure_modes" : [ "400 if source and destination are identical", "404 if source object or bucket not found", "403 if insufficient permissions for move operation" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure destination differs from source in bucket name or object key."
          }, {
            "code" : "404",
            "action" : "Verify source object exists and destination bucket is accessible."
          }, {
            "code" : "403",
            "action" : "Check bucket ownership and permissions for both source and destination."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Object move operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/objects/copy" ],
          "postprocessing_hint" : "Verify move with GET /s3/buckets/{dstBucketName}/objects to confirm object at destination and original location is empty.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/policy" : {
      "post" : {
        "summary" : "Create or update a bucket policy. See the ceph documentation for the list of currently supported actions.",
        "operationId" : "RgwResource_setPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "description" : "Bucket policy in JSON format",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create or update S3 bucket access policy",
          "usage" : [ "Set bucket permissions", "Configure cross-account access", "Apply security policies" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Policy JSON is valid; Actions are Ceph-supported",
            "post_action" : "Policy applied to bucket; Access permissions updated"
          },
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Bucket owner override",
            "required" : false
          }, {
            "name" : "policyJson",
            "in" : "body",
            "description" : "Bucket policy in AWS IAM JSON format",
            "required" : true,
            "example" : "{\"Version\": \"2012-10-17\", \"Statement\": [{\"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::bucket/*\"}]}"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to apply policy to",
            "required" : true
          } ],
          "failure_modes" : [ "404 if bucket not found", "400 if policy format is invalid or contains unsupported actions", "403 if insufficient permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket exists and is accessible."
          }, {
            "code" : "400",
            "action" : "Validate policy JSON format and ensure only Ceph-supported actions are used."
          }, {
            "code" : "403",
            "action" : "Check bucket ownership and admin permissions."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Policy management operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/policy", "/s3/buckets/{bucketName}" ],
          "postprocessing_hint" : "Verify policy with GET /s3/buckets/{bucketName}/policy to confirm applied settings.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Policy changes affect bucket access permissions for all users"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get a bucket policy.",
        "operationId" : "RgwResource_getPolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the JSON policy attached to an S3 bucket.",
          "usage" : [ "Display the existing policy before editing", "Export policies for compliance reviews" ],
          "response_shape" : "BucketPolicy",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional bucket owner to resolve tenancy.",
            "required" : false,
            "example" : "tenant1:alice"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket identifier (may include tenant prefix).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket has no policy or does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Inform the user that no policy is set and offer to create one."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Policy inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/buckets/{bucketName}/objects" ],
          "postprocessing_hint" : "Pretty-print the JSON before displaying to administrators.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete a bucket policy.",
        "operationId" : "RgwResource_deletePolicy",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove the access policy from an S3 bucket",
          "usage" : [ "Reset bucket permissions to default", "Remove custom access policies before reconfiguration" ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "owner",
            "in" : "query",
            "description" : "Optional bucket owner",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "S3 bucket name",
            "required" : true,
            "example" : "my-bucket"
          } ],
          "failure_modes" : [ "404 if bucket not found", "403 if lacking permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket exists"
          }, {
            "code" : "403",
            "action" : "Check bucket ownership or admin rights"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Policy management"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/policy (GET)", "/s3/buckets/{bucketName}/policy (PUT)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Removing bucket policy may affect access for existing users"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/quota" : {
      "put" : {
        "summary" : "Set a quota for this bucket.",
        "operationId" : "RgwResource_setBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Bucket quota configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set storage quota limits for an S3 bucket",
          "usage" : [ "Limit bucket storage consumption", "Prevent bucket from growing beyond specified limits", "Enforce storage policies" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Quota values are valid; Admin permissions confirmed",
            "post_action" : "Quota limits applied; Future uploads will be checked against limits"
          },
          "request_parameters" : [ {
            "name" : "quota",
            "in" : "body",
            "description" : "Quota configuration with maxObjects, maxSize, and enabled flags",
            "required" : true,
            "example" : "{\"maxObjects\": 10000, \"maxSize\": \"1TB\", \"enabled\": true}"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to set quota for",
            "required" : true
          } ],
          "failure_modes" : [ "404 if bucket not found", "400 if quota values are invalid", "403 if insufficient permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket exists and is accessible."
          }, {
            "code" : "400",
            "action" : "Validate quota values are positive and within reasonable limits."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for bucket quota management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Quota management operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}", "/s3/users/{uid}/bucket-quota" ],
          "postprocessing_hint" : "Monitor bucket usage to ensure quota limits are appropriate for use case.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Quota changes may prevent future uploads if current usage exceeds new limits"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/buckets/{bucketName}/upload" : {
      "put" : {
        "summary" : "Upload an object.",
        "operationId" : "RgwResource_uploadS3Object",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "owner",
          "in" : "query",
          "schema" : {
            "type" : [ "string", "null" ]
          }
        } ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UploadS3ObjectRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Upload a file to an S3 bucket",
          "usage" : [ "Store files in object storage", "Upload documents or media", "Backup files to S3" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Bucket exists; Sufficient quota available; File size within limits",
            "post_action" : "Object stored in bucket; Metadata indexed; File accessible via S3 API"
          },
          "request_parameters" : [ {
            "name" : "key",
            "in" : "query",
            "description" : "Object key/path in bucket",
            "required" : true,
            "example" : "folder/document.pdf"
          }, {
            "name" : "file",
            "in" : "body",
            "description" : "File content as multipart form data",
            "required" : true
          }, {
            "name" : "owner",
            "in" : "query",
            "description" : "Bucket owner override",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Name of the bucket to upload to",
            "required" : true
          } ],
          "failure_modes" : [ "404 if bucket not found", "413 if file exceeds bucket quota or size limits", "403 if insufficient upload permissions", "507 if insufficient storage space" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify bucket exists and is accessible."
          }, {
            "code" : "413",
            "action" : "Check bucket quota settings and file size limits."
          }, {
            "code" : "403",
            "action" : "Verify write permissions for the bucket."
          }, {
            "code" : "507",
            "action" : "Check cluster storage capacity and increase if needed."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 3600,
            "note" : "File upload operations"
          },
          "related_endpoints" : [ "/s3/buckets/{bucketName}/objects", "/s3/buckets/{bucketName}/multipart-uploads" ],
          "postprocessing_hint" : "For large files consider using multipart upload for better reliability and progress tracking.",
          "idempotent" : true,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/default-placement" : {
      "put" : {
        "summary" : "Set the default placement rule. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setDefaultPlacement",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "Default placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwDefaultPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set the default S3 placement rule for new buckets",
          "usage" : [ "Configure default storage location", "Set cluster-wide bucket placement policy", "Manage storage tier defaults" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Placement rule exists; Not in multi-site configuration; Admin permissions confirmed",
            "post_action" : "Default placement updated; New buckets will use this placement rule"
          },
          "request_parameters" : [ {
            "name" : "placementRule",
            "in" : "body",
            "description" : "Default placement rule name",
            "required" : true,
            "example" : "default-placement"
          }, {
            "name" : "storageClass",
            "in" : "body",
            "description" : "Default storage class for the placement rule",
            "required" : false,
            "example" : "STANDARD"
          } ],
          "failure_modes" : [ "400 if placement rule does not exist", "403 if insufficient admin permissions", "500 if multi-site configuration conflicts" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify placement rule exists using GET /s3/placements."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for placement configuration."
          }, {
            "code" : "500",
            "action" : "This API does not support multi-site setups; use Ceph native tools."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Placement configuration changes"
          },
          "related_endpoints" : [ "/s3/placements", "/s3/placements/{name}" ],
          "postprocessing_hint" : "Verify change with GET /s3/placements to confirm new default is applied.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing default placement affects all future bucket creation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements" : {
      "get" : {
        "summary" : "List all available placement policies in all zones.",
        "operationId" : "RgwResource_getPlacements",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwPlacementResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose RGW placement policies and the default placement for configuration UIs.",
          "usage" : [ "Load when editing bucket placement settings", "Refresh after creating or deleting placements" ],
          "response_shape" : "RgwPlacementResponse",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON. When omitted, placements array is returned; with pagination, data/total/after/limit are provided.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          } ],
          "failure_modes" : [ "200 with empty placements when no policies exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Prompt admins to create a placement before assigning buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Placement configuration"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/buckets", "/s3/default-placement" ],
          "postprocessing_hint" : "Prefer the field data when pagination is used; fallback to placements otherwise.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/placements/{name}" : {
      "put" : {
        "summary" : "Create a new placement policy in the default zonegroup in the default zone. This API does not support multi-site setups.",
        "operationId" : "RgwResource_addPlacement",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name for the policy, each zone within a zonegroup must have a policy with the same name.",
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Placement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwPlacementRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new S3 placement policy for bucket storage configuration",
          "usage" : [ "Define custom storage locations", "Create tiered storage policies", "Configure pool assignments for buckets" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Pools exist and are accessible; Placement name is unique; Not in multi-site setup",
            "post_action" : "Placement policy created; Available for bucket assignment"
          },
          "request_parameters" : [ {
            "name" : "dataPool",
            "in" : "body",
            "description" : "Pool for storing object data",
            "required" : true,
            "example" : "ssd-pool"
          }, {
            "name" : "indexPool",
            "in" : "body",
            "description" : "Pool for bucket index data",
            "required" : true,
            "example" : "index-pool"
          }, {
            "name" : "dataExtraPool",
            "in" : "body",
            "description" : "Additional pool for metadata (cannot be erasure coded)",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Name for the placement policy",
            "required" : true,
            "example" : "ssd-placement"
          } ],
          "failure_modes" : [ "400 if pools do not exist or are invalid", "409 if placement policy name already exists", "500 if multi-site configuration conflicts" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify all specified pools exist and are accessible."
          }, {
            "code" : "409",
            "action" : "Choose a different placement policy name or update existing policy."
          }, {
            "code" : "500",
            "action" : "This API does not support multi-site setups; use Ceph native tools."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Placement policy creation"
          },
          "related_endpoints" : [ "/s3/placements", "/s3/default-placement" ],
          "postprocessing_hint" : "Verify creation with GET /s3/placements and consider setting as default if appropriate.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Creating placement policies affects storage architecture"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/placements/{placementRule}/storage-classes/{storageClass}" : {
      "put" : {
        "summary" : "Set storage classes on placement rules. This API does not support multi-site setups.",
        "operationId" : "RgwResource_setStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to add or edit.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Storage class configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwStorageClassRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure storage class for a placement rule",
          "usage" : [ "Define tiered storage options", "Configure performance vs cost storage classes", "Set up storage class hierarchy" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Placement rule exists; Data pool is valid; Not in multi-site setup",
            "post_action" : "Storage class configured; Available for bucket use"
          },
          "request_parameters" : [ {
            "name" : "dataPool",
            "in" : "body",
            "description" : "Pool for storing data with this storage class",
            "required" : true,
            "example" : "cold-storage-pool"
          } ],
          "path_parameters" : [ {
            "name" : "placementRule",
            "in" : "path",
            "description" : "Name of existing placement rule",
            "required" : true,
            "example" : "ssd-placement"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "Storage class name to add or modify",
            "required" : true,
            "example" : "STANDARD_IA"
          } ],
          "failure_modes" : [ "404 if placement rule does not exist", "400 if data pool is invalid", "500 if multi-site configuration conflicts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Create placement rule first using PUT /s3/placements/{name}."
          }, {
            "code" : "400",
            "action" : "Verify data pool exists and is accessible."
          }, {
            "code" : "500",
            "action" : "This API does not support multi-site setups; use Ceph native tools."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Storage class configuration"
          },
          "related_endpoints" : [ "/s3/placements", "/s3/placements/{placementRule}/storage-classes/{storageClass}" ],
          "postprocessing_hint" : "Test storage class by creating a bucket with the new placement rule and storage class.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Storage class changes affect data placement and performance characteristics"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a storage class on a placement rule. Deletes the entire placement rule when specifying the STANDARD storage class. This API does not support multi-site setups.",
        "operationId" : "RgwResource_deleteStorageClass",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "description" : "The name of an (existing) placement rule.",
          "name" : "placementRule",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "The name for storage class to remove, or STANDARD to remove the entire placement rule.",
          "name" : "storageClass",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a storage class from a placement rule",
          "usage" : [ "Remove unused storage classes", "Clean up placement configuration", "Remove entire placement rule (STANDARD class)" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Storage class exists; No buckets using this placement; Not in multi-site setup",
            "post_action" : "Storage class deleted; Placement rule removed if STANDARD class deleted"
          },
          "path_parameters" : [ {
            "name" : "placementRule",
            "in" : "path",
            "description" : "Name of the placement rule",
            "required" : true,
            "example" : "ssd-placement"
          }, {
            "name" : "storageClass",
            "in" : "path",
            "description" : "Storage class to delete (STANDARD deletes entire placement rule)",
            "required" : true,
            "example" : "STANDARD_IA"
          } ],
          "failure_modes" : [ "404 if placement rule or storage class not found", "409 if buckets are using this placement/storage class", "500 if multi-site configuration conflicts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify placement rule and storage class exist."
          }, {
            "code" : "409",
            "action" : "Move or delete buckets using this placement before removing it."
          }, {
            "code" : "500",
            "action" : "This API does not support multi-site setups; use Ceph native tools."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Storage class deletion"
          },
          "related_endpoints" : [ "/s3/placements", "/s3/buckets" ],
          "postprocessing_hint" : "Verify deletion with GET /s3/placements and check no buckets are using removed placement.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting storage classes affects bucket placement options; STANDARD deletion removes entire rule"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/usage/by-bucket/{bucketName}" : {
      "get" : {
        "summary" : "Retrieve latest usage statistics for a given S3 bucket.",
        "description" : "Return results aggregated into 1 hour intervals for all users that accessed the bucket.\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByBucket",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "bucketName",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForBucketByUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Aggregate hourly RGW usage for a bucket across all users.",
          "usage" : [ "Feed billing reports or compliance exports", "Schedule periodic runs; avoid interactive polling" ],
          "response_shape" : "S3UsageForBucketByUserResponse",
          "request_parameters" : [ {
            "name" : "hours",
            "in" : "query",
            "description" : "Number of prior hours to include.",
            "required" : true,
            "example" : "24"
          } ],
          "path_parameters" : [ {
            "name" : "bucketName",
            "in" : "path",
            "description" : "Bucket to analyze (with tenant if applicable).",
            "required" : true,
            "example" : "logs"
          } ],
          "failure_modes" : [ "404 if the bucket has no usage records" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Confirm usage logging is enabled and the bucket has recent activity."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-user/{uid}", "/stats" ],
          "postprocessing_hint" : "Group the returned per-user lists before persisting to accounting systems; trimming is triggered automatically.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/usage/by-user/{uid}" : {
      "get" : {
        "summary" : "Retrieve usage statistics for a given S3 user.",
        "description" : "Return results aggregated into 1 hour intervals for all buckets the user accessed. Caution: this cannot be used for the anonymous user\nThis can be an expensive call in term of IOPS, do not poll this unnecessarily. The idea is to store the results in an accounting system.\nCalling this will also trim the S3 usage log if enabled in /config/config.yml, see trimS3Usage in /config/config.yml.default\nThis requires enabling the Ceph option \"rgw enable usage log\", see https://docs.ceph.com/docs/master/man/8/radosgw/#usage-logging",
        "operationId" : "RgwResource_getS3UsageStatisticsByUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "description" : "How many hours to go back.",
          "name" : "hours",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/S3UsageForUserByBucketResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Collect hourly RGW usage metrics for a specific user to feed billing or analytics.",
          "usage" : [ "Trigger on-demand reports and persist results externally", "Avoid frequent polling; schedule periodic exports instead" ],
          "response_shape" : "S3UsageForUserByBucketResponse",
          "request_parameters" : [ {
            "name" : "hours",
            "in" : "query",
            "description" : "Number of hours to include (integer).",
            "required" : true,
            "example" : "24"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to report on.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if usage data is unavailable or logging disabled" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify RGW usage logging is enabled and the user has activity within the requested window."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Expensive usage reporting"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/usage/by-bucket/{bucketName}", "/stats" ],
          "postprocessing_hint" : "Aggregate returned hourly buckets before billing; consider trimming data once exported.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/user-names" : {
      "get" : {
        "summary" : "Get list of RGW user names",
        "operationId" : "RgwResource_getRgwUsers",
        "tags" : [ "s3" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide a lightweight list of RGW user IDs for selectors or autocomplete.",
          "usage" : [ "Populate dropdowns when selecting a user", "Refresh occasionally to pick up new accounts" ],
          "response_shape" : "array<string>",
          "failure_modes" : [ "200 [] when RGW is not configured or no users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Fallback to an empty state and allow user creation."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Sort user IDs alphabetically before display.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users" : {
      "get" : {
        "summary" : "List of S3 users.",
        "operationId" : "RgwResource_getRgwUserInfo",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "uid",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRgwUserResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW users with metadata for management or dashboards.",
          "usage" : [ "Render the S3 user inventory table", "Filter by uid to fetch specific users before editing" ],
          "response_shape" : "OptionalPaginationResponse<RgwUserResponse>",
          "request_parameters" : [ {
            "name" : "uid",
            "in" : "query",
            "description" : "Optional list of user IDs to fetch; when provided results are unpaginated.",
            "required" : false,
            "example" : "[\"user1\",\"user2\"]"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for general listing.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0}"
          } ],
          "failure_modes" : [ "200 [] when RGW is configured but no users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show onboarding guidance to create S3 users."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "User inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/user-names", "/s3/users/{uid}/keys" ],
          "postprocessing_hint" : "Merge cached data to avoid hitting RGW for every refresh.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create RGW user",
        "operationId" : "RgwResource_createRgwUser",
        "tags" : [ "s3" ],
        "requestBody" : {
          "description" : "New RGW user creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewUserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision a new RGW user account for S3 access.",
          "usage" : [ "Call before generating access keys via /s3/users/{uid}/keys.", "Provide tenant when working in multi-tenant deployments to segregate users." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "uid",
            "in" : "body",
            "description" : "Unique RGW user id.",
            "required" : true,
            "example" : "app-backups"
          }, {
            "name" : "tenant",
            "in" : "body",
            "description" : "Optional tenant identifier for multi-tenant setups.",
            "required" : false,
            "example" : "customer-a"
          }, {
            "name" : "defaultPlacement",
            "in" : "body",
            "description" : "Placement target for new buckets (optional).",
            "required" : false,
            "example" : "default-placement"
          } ],
          "failure_modes" : [ "400 if the user already exists", "400 if placement or storage class names are invalid", "503 if RGW is unavailable" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the uid or tenant and retry."
          }, {
            "code" : "503",
            "action" : "Wait for RGW availability; check cluster health before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "RGW user provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/keys", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Immediately request credentials via /s3/users/{uid}/keys to complete onboarding.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}" : {
      "patch" : {
        "summary" : "Update RGW user",
        "operationId" : "RgwResource_updateRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW user account properties and settings",
          "usage" : [ "Modify user metadata", "Update placement or storage class defaults", "Change user display name or email" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Placement/storage class valid if specified; Admin permissions confirmed",
            "post_action" : "User metadata updated; New defaults apply to future buckets"
          },
          "request_parameters" : [ {
            "name" : "displayName",
            "in" : "body",
            "description" : "User display name",
            "required" : false
          }, {
            "name" : "email",
            "in" : "body",
            "description" : "User email address",
            "required" : false
          }, {
            "name" : "defaultPlacement",
            "in" : "body",
            "description" : "Default placement rule for user's buckets",
            "required" : false
          }, {
            "name" : "defaultStorageClass",
            "in" : "body",
            "description" : "Default storage class for user's objects",
            "required" : false
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to update",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if user not found", "400 if placement rule or storage class is invalid", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user exists using GET /s3/users."
          }, {
            "code" : "400",
            "action" : "Validate placement and storage class exist."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for user management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User account modifications"
          },
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Changes affect future bucket creation; existing buckets retain current settings.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW user",
        "operationId" : "RgwResource_deleteRgwUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an RGW user account and invalidate its credentials cache.",
          "usage" : [ "Call after migrating data away from the user or revoking access.", "Remove all keys and subusers beforehand to avoid orphaned credentials." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user id to remove.",
            "required" : true,
            "example" : "app-backups"
          } ],
          "failure_modes" : [ "404 if the user does not exist", "409 if the user still owns buckets or subusers" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /s3/users to confirm the uid before retrying."
          }, {
            "code" : "409",
            "action" : "Delete existing buckets or subusers tied to the user first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User deprovisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/buckets", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Invalidate any UI caches and update IAM dashboards to reflect the removal.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Create RGW subuser",
        "operationId" : "RgwResource_createRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a subuser under an existing RGW user account",
          "usage" : [ "Add Swift API access for applications", "Create compartmentalized access within user account", "Set up limited-permission subusers" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Parent user exists; Subuser name is unique; Access level is valid",
            "post_action" : "Subuser created with specified permissions; Keys generated if requested"
          },
          "request_parameters" : [ {
            "name" : "subuser",
            "in" : "body",
            "description" : "Subuser name",
            "required" : true,
            "example" : "app1"
          }, {
            "name" : "access",
            "in" : "body",
            "description" : "Permission level (read, write, readwrite, full)",
            "required" : true,
            "example" : "readwrite"
          }, {
            "name" : "keyType",
            "in" : "body",
            "description" : "Key type (swift or s3)",
            "required" : false,
            "default" : "swift"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID to create subuser under",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if parent user not found", "409 if subuser already exists", "400 if invalid access level or key type" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Create parent user first using POST /s3/users."
          }, {
            "code" : "409",
            "action" : "Choose different subuser name or update existing subuser."
          }, {
            "code" : "400",
            "action" : "Use valid access levels: read, write, readwrite, full."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Subuser creation"
          },
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}/keys" ],
          "postprocessing_hint" : "Monitor returned task; generate keys after creation if needed.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/bucket-quota" : {
      "put" : {
        "summary" : "Set a quota for all buckets owned by this user.",
        "operationId" : "RgwResource_setUserBucketQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User bucket quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set quota limits for all buckets owned by a user",
          "usage" : [ "Control bucket storage per user", "Apply bucket-level limits across user's buckets", "Prevent individual bucket bloat" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Quota values valid; Admin permissions confirmed",
            "post_action" : "Per-bucket quota applied to all user's buckets; Future uploads checked per bucket"
          },
          "request_parameters" : [ {
            "name" : "maxObjects",
            "in" : "body",
            "description" : "Maximum objects per bucket for this user",
            "required" : false,
            "example" : "50000"
          }, {
            "name" : "maxSize",
            "in" : "body",
            "description" : "Maximum size per bucket for this user",
            "required" : false,
            "example" : "50GB"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether bucket quota enforcement is enabled",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to set bucket quota for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if user not found", "400 if quota values are invalid", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user exists using GET /s3/users."
          }, {
            "code" : "400",
            "action" : "Use positive values and valid size formats."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for quota management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Bucket quota management"
          },
          "related_endpoints" : [ "/s3/users/{uid}/quota", "/s3/users/{uid}/buckets" ],
          "postprocessing_hint" : "Monitor individual bucket usage to ensure per-bucket limits are appropriate.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Bucket quota changes may prevent uploads to existing buckets if limits are exceeded"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/buckets" : {
      "get" : {
        "summary" : "List all buckets owner by the user.",
        "operationId" : "RgwResource_getRgwBucketsForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwBucketResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List buckets owned by a specific RGW user, including usage and quotas.",
          "usage" : [ "Display per-user bucket inventory", "Validate bucket ownership before applying user-level policies" ],
          "response_shape" : "array<RgwBucketResponse>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID whose buckets to list.",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt the operator to refresh or recreate the user before viewing buckets."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Bucket inventory by user"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/s3/buckets", "/s3/users" ],
          "postprocessing_hint" : "Sum usage across buckets to show per-user totals.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file",
        "operationId" : "RgwResource_getS3CfgFile",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file containing credentials and endpoint info for an RGW user.",
          "usage" : [ "Offer the config download after creating or rotating credentials", "Avoid repeated downloads; regenerate when IPs or keys change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user or subuser ID (user or user:subuser).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist", "400 if no RGW gateway servers are available" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt admins to refresh the user list."
          }, {
            "code" : "400",
            "action" : "Ensure an RGW gateway is running before allowing downloads."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" ],
          "postprocessing_hint" : "Serve the download immediately; tokens are short-lived.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/key" : {
      "get" : {
        "summary" : "Get RGW user key",
        "operationId" : "RgwResource_getRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/RgwUserKey"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the credentials for a specific S3 subuser or main user.",
          "usage" : [ "Display access/secret keys when downloading configuration files", "Call after key rotation to show the new credentials" ],
          "response_shape" : "RgwUserKey",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (format user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the key is not found", "403 if RGW is not configured" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt to create the key via PUT /users/{uid}/keys/{accessKey}."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key inspection"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users" ],
          "postprocessing_hint" : "Redact secretKey in logs and restrict exposure to admins.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys" : {
      "put" : {
        "summary" : "Update RGW keys",
        "operationId" : "RgwResource_updateRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW keys update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateKeysRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update or regenerate access keys for an RGW user",
          "usage" : [ "Rotate compromised credentials", "Update multiple keys at once", "Generate new access/secret key pairs" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "User exists; Key configurations are valid; No duplicate access keys",
            "post_action" : "Keys updated; Old keys invalidated; New keys ready for use"
          },
          "request_parameters" : [ {
            "name" : "keys",
            "in" : "body",
            "description" : "Array of key configurations to update",
            "required" : true,
            "example" : "[{\"accessKey\": \"AKIAIOSFODNN7EXAMPLE\", \"secretKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\", \"generate\": false}]"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to update keys for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if user not found", "400 if key format is invalid or duplicates exist", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user exists using GET /s3/users."
          }, {
            "code" : "400",
            "action" : "Ensure unique access keys and valid key formats."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for key management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Key management operations"
          },
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}/cfg-file/download" ],
          "postprocessing_hint" : "Monitor returned task; distribute new credentials to applications; test access before confirming.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Key updates invalidate existing credentials and may break active applications"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW user keys",
        "operationId" : "RgwResource_getRgwKeys",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all access keys belonging to a user or subuser.",
          "usage" : [ "Show existing keys before rotating or deleting", "Audit which subusers have credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User or subuser ID (user[:subuser]).",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Offer to create the user or refresh the list of S3 users."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/key" ],
          "postprocessing_hint" : "Mask secretKey values unless explicitly requested by an admin.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW user key",
        "operationId" : "RgwResource_removeRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an S3 access key from a RGW user",
          "usage" : [ "Revoke compromised or unused access keys", "Rotate credentials by removing old keys" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Access key to delete",
            "required" : true,
            "example" : "AKIAIOSFODNN7EXAMPLE"
          } ],
          "failure_modes" : [ "404 if user not found", "404 if access key not found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user and key exist"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Key management"
          },
          "related_endpoints" : [ "/s3/users/{uid}/keys (POST)", "/s3/users/{uid}/keys (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW user key",
        "operationId" : "RgwResource_createRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new access key with specified access key ID and secret for an RGW user.",
          "usage" : [ "Call when generating custom access keys for applications or users.", "Use to create keys with specific access key IDs for integration requirements." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Access key ID is unique; Valid key formats; RGW service running",
            "post_action" : "Access key created; Available for S3 authentication; Secret stored securely"
          },
          "request_parameters" : [ {
            "name" : "secretKey",
            "in" : "query",
            "description" : "Secret key to pair with the access key.",
            "required" : true,
            "example" : "abcdefghijklmnopqrstuvwxyz123456"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID to create the access key for.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Specific access key ID to create.",
            "required" : true,
            "example" : "ABCDEFGHIJKLMNOPQRST"
          } ],
          "failure_modes" : [ "400 if RGW is not configured or key format is invalid", "404 if user does not exist", "409 if access key already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure RGW service is running; validate access key and secret key formats."
          }, {
            "code" : "404",
            "action" : "Create the user first via POST /s3/users."
          }, {
            "code" : "409",
            "action" : "Choose a different access key ID; use DELETE to remove existing key first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Access key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/keys", "/s3/users/{uid}" ],
          "postprocessing_hint" : "Access key immediately active for S3 operations; store secret key securely; test authentication after creation.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/quota" : {
      "put" : {
        "summary" : "Set a quota for this user.",
        "operationId" : "RgwResource_setUserQuota",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "User quota request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwQuotaRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set storage quota limits for an RGW user account",
          "usage" : [ "Limit user's total storage consumption", "Enforce storage policies per user", "Prevent runaway storage usage" ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Quota values are valid; Admin permissions confirmed",
            "post_action" : "User quota applied; Future uploads checked against limits"
          },
          "request_parameters" : [ {
            "name" : "maxObjects",
            "in" : "body",
            "description" : "Maximum number of objects user can store",
            "required" : false,
            "example" : "100000"
          }, {
            "name" : "maxSize",
            "in" : "body",
            "description" : "Maximum storage size for user",
            "required" : false,
            "example" : "100GB"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether quota enforcement is enabled",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "User ID to set quota for",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if user not found", "400 if quota values are invalid", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user exists using GET /s3/users."
          }, {
            "code" : "400",
            "action" : "Use positive quota values and valid size formats."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for quota management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "User quota management"
          },
          "related_endpoints" : [ "/s3/users/{uid}", "/s3/users/{uid}/bucket-quota" ],
          "postprocessing_hint" : "Monitor user storage to ensure quota limits are appropriate for use case.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Quota changes may prevent future uploads if current usage exceeds new limits"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers" : {
      "put" : {
        "summary" : "Update RGW subusers",
        "operationId" : "RgwResource_updateRgwSubusers",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subusers update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwUpdateSubusersRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update multiple subusers for an RGW user account",
          "usage" : [ "Batch update subuser permissions", "Modify multiple subuser access levels", "Update subuser configurations in bulk" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Parent user exists; Subuser configurations valid; Admin permissions confirmed",
            "post_action" : "Subusers updated with new permissions; Keys generated if requested"
          },
          "request_parameters" : [ {
            "name" : "subusers",
            "in" : "body",
            "description" : "Array of subuser configurations to update",
            "required" : true,
            "example" : "[{\"subuser\": \"app1\", \"access\": \"readwrite\", \"generateKey\": false}]"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "testuser"
          } ],
          "failure_modes" : [ "404 if parent user not found", "400 if subuser configurations are invalid", "403 if insufficient admin permissions" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify parent user exists using GET /s3/users."
          }, {
            "code" : "400",
            "action" : "Use valid access levels and ensure subuser names are valid."
          }, {
            "code" : "403",
            "action" : "Check admin permissions for subuser management."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Subuser batch operations"
          },
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}" ],
          "postprocessing_hint" : "Monitor returned task; verify subuser access after changes; update application configurations.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Subuser permission changes affect application access patterns"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get RGW subusers for user",
        "operationId" : "RgwResource_getRgwSubusersForUser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwSubUser"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List subusers belonging to an RGW account, including their permissions.",
          "usage" : [ "Load subusers before editing their keys or ACLs", "Display subuser information in account dashboards" ],
          "response_shape" : "array<RgwSubUser>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          } ],
          "failure_modes" : [ "404 if the user does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Prompt creation of the user or refresh the users list."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subuser inspection"
          },
          "cache_hint" : "short-lived",
          "related_endpoints" : [ "/s3/users", "/s3/users/{uid}/subusers/{subuser}/keys" ],
          "postprocessing_hint" : "Group results by permissions to highlight read-only subusers.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}" : {
      "patch" : {
        "summary" : "Update RGW subuser",
        "operationId" : "RgwResource_updateRgwSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "RGW subuser update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RgwSubuserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update RGW subuser permissions and configuration without recreating the subuser.",
          "usage" : [ "Call when modifying subuser access permissions or settings.", "Use to update subuser permissions without disrupting existing access keys." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "User and subuser exist; Valid permission level; RGW service running",
            "post_action" : "Subuser permissions updated; Access control changes effective immediately; Keys preserved unless regenerated"
          },
          "request_parameters" : [ {
            "name" : "permission",
            "in" : "body",
            "description" : "New permission level for the subuser (read, write, readwrite, full).",
            "required" : false,
            "example" : "readwrite"
          }, {
            "name" : "generateAccessKey",
            "in" : "body",
            "description" : "Whether to generate a new access key for the subuser.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID that owns the subuser.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to update.",
            "required" : true,
            "example" : "appuser"
          } ],
          "failure_modes" : [ "400 if RGW is not configured or invalid permission specified", "404 if user or subuser does not exist", "500 if subuser update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure RGW service is running; validate permission values (read, write, readwrite, full)."
          }, {
            "code" : "404",
            "action" : "Verify user and subuser exist; check subuser listings."
          }, {
            "code" : "500",
            "action" : "Check RGW service health and configuration; retry after ensuring service stability."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Subuser configuration updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Monitor task progress for permission updates; existing access keys remain valid unless explicitly regenerated.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete RGW subuser",
        "operationId" : "RgwResource_deleteRgwSubser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a RGW subuser from a parent user account",
          "usage" : [ "Clean up unused subusers", "Revoke Swift API access for specific subusers" ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify subuser exists and is not in use",
            "post_action" : "Monitor task completion and verify removal"
          },
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to delete",
            "required" : true,
            "example" : "swift-user"
          } ],
          "failure_modes" : [ "404 if user or subuser not found", "timeout if deletion takes longer than 1 minute" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user and subuser exist"
          }, {
            "code" : "timeout",
            "action" : "Check RGW status and retry"
          } ],
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 60,
            "note" : "Subuser management"
          },
          "related_endpoints" : [ "/s3/users/{uid}/subusers (POST)", "/s3/users/{uid}/subusers (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting subuser removes all access for that identity"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/cfg-file/download" : {
      "get" : {
        "summary" : "Download S3 configuration file for subuser",
        "operationId" : "RgwResource_getS3CfgFileForsubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DownloadableObject"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate an .s3cfg file scoped to a specific subuser.",
          "usage" : [ "Offer immediately after creating a subuser", "Reuse only until credentials or endpoints change" ],
          "response_shape" : "DownloadableObject",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "backup"
          } ],
          "failure_modes" : [ "404 if user or subuser is unknown" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload subusers for the account and retry."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Configuration downloads"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/cfg-file/download", "/s3/users/{uid}/subusers" ],
          "postprocessing_hint" : "Download immediately; tokens expire quickly.",
          "idempotent" : false,
          "streaming_response" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys" : {
      "get" : {
        "summary" : "Get RGW keys for subuser",
        "operationId" : "RgwResource_getRgwKeysForSubuser",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RgwUserKey"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List credentials for a specific RGW subuser.",
          "usage" : [ "Review keys before regenerating or deleting", "Audit which subusers have active credentials" ],
          "response_shape" : "array<RgwUserKey>",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Main user ID",
            "required" : true,
            "example" : "alice"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser identifier",
            "required" : true,
            "example" : "alice:tenant"
          } ],
          "failure_modes" : [ "404 if user or subuser is missing" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Suggest reloading subusers or creating the subuser first."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Key management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers", "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" ],
          "postprocessing_hint" : "Mask secret keys in UI unless explicitly requested.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/s3/users/{uid}/subusers/{subuser}/keys/{accessKey}" : {
      "delete" : {
        "summary" : "Remove RGW key for subuser",
        "operationId" : "RgwResource_removeSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an S3 access key from a RGW subuser",
          "usage" : [ "Revoke subuser access without deleting the subuser", "Rotate subuser credentials" ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "Parent user ID",
            "required" : true,
            "example" : "user123"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name",
            "required" : true,
            "example" : "swift-user"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Access key to delete",
            "required" : true,
            "example" : "AKIAIOSFODNN7EXAMPLE"
          } ],
          "failure_modes" : [ "404 if user, subuser, or key not found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify user, subuser, and key exist"
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Subuser key management"
          },
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}/keys (PUT)", "/s3/users/{uid}/subusers/{subuser}/keys (GET)" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create RGW key for subuser",
        "operationId" : "RgwResource_createSubuserRgwKey",
        "tags" : [ "s3" ],
        "parameters" : [ {
          "name" : "accessKey",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "subuser",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "uid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "secretKey",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new access key with specified access key ID and secret for an RGW subuser.",
          "usage" : [ "Call when generating custom access keys for subuser applications.", "Use to create keys with specific access key IDs for subuser integration requirements." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User and subuser exist; Access key ID is unique; Valid key formats; RGW service running",
            "post_action" : "Subuser access key created; Available for S3 authentication; Secret stored securely"
          },
          "request_parameters" : [ {
            "name" : "secretKey",
            "in" : "query",
            "description" : "Secret key to pair with the access key for subuser.",
            "required" : true,
            "example" : "subuser-secret-key-123456789"
          } ],
          "path_parameters" : [ {
            "name" : "uid",
            "in" : "path",
            "description" : "RGW user ID that owns the subuser.",
            "required" : true,
            "example" : "testuser"
          }, {
            "name" : "subuser",
            "in" : "path",
            "description" : "Subuser name to create the access key for.",
            "required" : true,
            "example" : "appuser"
          }, {
            "name" : "accessKey",
            "in" : "path",
            "description" : "Specific access key ID to create for the subuser.",
            "required" : true,
            "example" : "SUBUSER123ACCESSKEY"
          } ],
          "failure_modes" : [ "400 if RGW is not configured or key format is invalid", "404 if user or subuser does not exist", "409 if access key already exists" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure RGW service is running; validate access key and secret key formats."
          }, {
            "code" : "404",
            "action" : "Create the user and subuser first via appropriate endpoints."
          }, {
            "code" : "409",
            "action" : "Choose a different access key ID; use DELETE to remove existing key first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Subuser access key creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/s3/users/{uid}/subusers/{subuser}/keys", "/s3/users/{uid}/subusers/{subuser}" ],
          "postprocessing_hint" : "Subuser access key immediately active for S3 operations; store secret key securely; test authentication after creation.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/server-access/host-keys" : {
      "get" : {
        "summary" : "Get the SSH host keys configured on the servers as pairs of key type, public key.",
        "operationId" : "SshKeyResource_getHostKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "object",
                  "additionalProperties" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve SSH host public keys for server identity verification during SSH connections.",
          "usage" : [ "Call when setting up SSH client configurations to verify server identities.", "Use to populate known_hosts files for automated SSH connections to cluster servers." ],
          "response_shape" : "Map<String, String?>",
          "failure_modes" : [ "200 with null values if some key types are not configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Null values indicate that specific key types are not configured; use available keys for host verification."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Host key retrieval"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/server-access/keys", "/servers" ],
          "postprocessing_hint" : "Add non-null keys to SSH known_hosts files; keys remain constant unless servers are rebuilt.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/keys" : {
      "put" : {
        "summary" : "Replace all SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_replaceSshKeys",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/KeyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the complete list of SSH public keys authorized for server access.",
          "usage" : [ "Call when updating team member SSH access or rotating keys for security.", "Use to synchronize authorized keys with external identity management systems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All SSH keys are valid public keys; Team member access requirements confirmed",
            "post_action" : "All server authorized_keys files updated; Old keys revoked; New keys immediately active"
          },
          "request_parameters" : [ {
            "name" : "keys",
            "in" : "body",
            "description" : "Complete list of SSH public keys to authorize (replaces existing keys).",
            "required" : true,
            "example" : "[\"ssh-rsa AAAAB3...\", \"ssh-ed25519 AAAAC3...\"]"
          } ],
          "failure_modes" : [ "400 if any SSH key format is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate all SSH public keys are in correct format before sending request."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "SSH key management"
          },
          "related_endpoints" : [ "/server-access/keys" ],
          "postprocessing_hint" : "Verify SSH access works with new keys before removing backup access methods; key changes are immediate.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This replaces all SSH keys and may lock out users with keys not in the new list"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the SSH keys allowed to access the managed servers.",
        "operationId" : "SshKeyResource_getSshKeys",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all SSH public keys currently authorized for server access.",
          "usage" : [ "Call when auditing SSH access permissions or preparing key rotation.", "Use to verify which team members have SSH access to cluster servers." ],
          "response_shape" : "List<String>",
          "failure_modes" : [ "200 with empty list if no SSH keys are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no SSH key access is configured; consider adding keys via PUT /server-access/keys."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "SSH key listing"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/server-access/keys", "/server-access/passwords" ],
          "postprocessing_hint" : "Display key fingerprints for identification; validate key formats before using for authentication.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/server-access/passwords" : {
      "patch" : {
        "summary" : "Set server passwords",
        "operationId" : "SshKeyResource_setServerPasswords",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerAccessPasswords"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update server root and IPMI passwords for physical access and hardware management.",
          "usage" : [ "Call when rotating passwords for security compliance or after suspected compromise.", "Use to set initial passwords during cluster setup or hardware provisioning." ],
          "response_shape" : "ManagedThreadTask or null",
          "workflow_guidance" : {
            "pre_check" : "Passwords meet complexity requirements; IPMI interfaces accessible; Root access confirmed",
            "post_action" : "Passwords updated on all accessible servers; IPMI admin credentials changed; Root password available for console access"
          },
          "request_parameters" : [ {
            "name" : "rootPassword",
            "in" : "body",
            "description" : "New root password for console/physical access (SSH key auth preferred).",
            "required" : false,
            "example" : "strong-password-123"
          }, {
            "name" : "ipmiPassword",
            "in" : "body",
            "description" : "New IPMI admin password for hardware management interfaces.",
            "required" : false,
            "example" : "ipmi-admin-password"
          } ],
          "failure_modes" : [ "400 if password format is invalid or does not meet complexity requirements", "500 if IPMI password update fails on some servers" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure passwords meet complexity requirements before updating."
          }, {
            "code" : "500",
            "action" : "Check IPMI connectivity and hardware status; some servers may require manual intervention."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Password management operations"
          },
          "related_endpoints" : [ "/server-access/passwords", "/ipmi" ],
          "postprocessing_hint" : "Test access with new passwords; IPMI changes may take time to propagate; monitor task for per-server results.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Password changes affect server access and may require physical intervention if SSH keys fail"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get server passwords.",
        "operationId" : "SshKeyResource_getServerPasswords",
        "tags" : [ "servers" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ServerAccessPasswords"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current server root and IPMI passwords for emergency access and hardware management.",
          "usage" : [ "Call when administrators need access credentials for console login or IPMI management.", "Use during disaster recovery when SSH key access is unavailable." ],
          "response_shape" : "ServerAccessPasswords",
          "failure_modes" : [ "200 with empty strings if passwords are not configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty passwords indicate they are not set; configure via PATCH /server-access/passwords if needed."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Password retrieval"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/server-access/passwords", "/ipmi" ],
          "postprocessing_hint" : "Handle passwords securely; use for emergency access only; SSH keys are preferred for regular operations.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers" : {
      "get" : {
        "summary" : "List all servers.",
        "operationId" : "ServerResource_getServers",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseServerResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all managed servers including hardware, health and service metadata.",
          "usage" : [ "Populate inventory or overview tables before drilling into per-server details", "Refresh every 30 seconds at most when tracking cluster health in dashboards" ],
          "response_shape" : "OptionalPaginationResponse<ServerResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional JSON string (PaginationRequest) controlling sort, filters, offset and limit.",
            "required" : false,
            "example" : "{\"limit\":50,\"after\":0,\"sortBy\":[[\"hostname\",\"ASC\"]]}"
          } ],
          "common_parameters" : {
            "pagination.limit" : "Cap list size to avoid fetching every server on large clusters.",
            "pagination.where" : "Filter by hostname, roles or states before requesting details."
          },
          "failure_modes" : [ "200 [] when no servers match the applied filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Treat empty data as 'no servers discovered' and prompt setup if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "Shared viewer polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/services", "/servers/ips" ],
          "postprocessing_hint" : "Derive UI aggregates (e.g. running service counts) from the response before displaying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIps",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "string"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return a simple list of free IP addresses within a subnet for quick selection.",
          "usage" : [ "Use in auto-complete inputs when assigning new IPs", "Run immediately before reserving an address to avoid stale results" ],
          "response_shape" : "array<string>",
          "request_parameters" : [ {
            "name" : "subnet",
            "in" : "query",
            "description" : "CIDR representing the pool to search (e.g. 10.0.0.0/24).",
            "required" : true,
            "example" : "10.0.0.0/24"
          }, {
            "name" : "limit",
            "in" : "query",
            "description" : "Maximum number of addresses to return.",
            "required" : true,
            "example" : "8"
          } ],
          "failure_modes" : [ "400 if subnet is invalid", "200 [] when no free IPs are found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate the subnet locally and show friendly feedback on formatting errors."
          }, {
            "code" : "200",
            "action" : "Fallback to a manual entry flow when no addresses are returned."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips-obj", "/servers/ips" ],
          "postprocessing_hint" : "Display the results in ascending order and avoid caching them beyond the current form interaction.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/free-ips-obj" : {
      "get" : {
        "summary" : "List free IP addresses in a subnet.",
        "operationId" : "ServerResource_listFreeIpsObjects",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "limit",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        }, {
          "name" : "subnet",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseFreeIp"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Calculate a list of free IP addresses within a subnet, returning structured records.",
          "usage" : [ "Call before provisioning new services to reserve free management IPs", "Use in UI workflows that require both IP and subnet context" ],
          "response_shape" : "OptionalPaginationResponse<FreeIp>",
          "request_parameters" : [ {
            "name" : "subnet",
            "in" : "query",
            "description" : "CIDR describing the pool to scan for free addresses (e.g. 10.0.0.0/24).",
            "required" : true,
            "example" : "10.0.0.0/24"
          }, {
            "name" : "limit",
            "in" : "query",
            "description" : "Maximum number of free addresses to return.",
            "required" : true,
            "example" : "16"
          }, {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON if additional client-side paging is desired.",
            "required" : false,
            "example" : "{\"after\":0,\"limit\":10}"
          } ],
          "failure_modes" : [ "400 if the subnet parameter is not valid CIDR", "200 [] when no free addresses are available" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate CIDR formatting client-side and prompt the user to correct it."
          }, {
            "code" : "200",
            "action" : "Inform the user that no free IPs remain in the subnet."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Subnet capacity checks"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/free-ips", "/servers/ips", "/servers/ips-with-subnet" ],
          "postprocessing_hint" : "Hold the response only transiently; recalculate before committing allocations to avoid races.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ha-groups" : {
      "get" : {
        "summary" : "List of all configured HA groups.",
        "operationId" : "HaGroupResource_getHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseHaGroupResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List configured HA groups with associated VIP and members.",
          "usage" : [ "Render the HA groups overview table.", "Check current failover configuration before editing or deleting a group." ],
          "response_shape" : "OptionalPaginationResponse<HaGroupResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination request (index + size).",
            "required" : false,
            "example" : "{\"index\":0,\"size\":20}"
          } ],
          "failure_modes" : [ "200 [] when no HA groups exist" ],
          "retry_strategy" : "no_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 60,
            "note" : "HA group listing"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create HA group",
        "operationId" : "HaGroupResource_createHagroup",
        "tags" : [ "ha-groups" ],
        "requestBody" : {
          "description" : "HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new HA group with failover policies and member servers.",
          "usage" : [ "Provision HA for RGW/NFS services during initial setup.", "Automate HA group creation as part of cluster expansion workflows." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Verify license validity and ensure selected servers share matching RGW zones/DNS and unique VIPs.",
            "post_action" : "Monitor the task for provisioning errors; run health checks once created."
          },
          "request_parameters" : [ {
            "name" : "id",
            "in" : "body",
            "description" : "Must be null when creating.",
            "required" : false,
            "example" : "null"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Human-readable name for the HA group.",
            "required" : true,
            "example" : "RGW Frontend"
          }, {
            "name" : "virtualIp",
            "in" : "body",
            "description" : "Floating virtual IPv4 address.",
            "required" : true,
            "example" : "10.0.0.50"
          }, {
            "name" : "service",
            "in" : "body",
            "description" : "Service type (nfs/rgw).",
            "required" : true,
            "example" : "rgw"
          }, {
            "name" : "servers",
            "in" : "body",
            "description" : "Participating servers with NIC/VLAN info.",
            "required" : true,
            "example" : "[{\"server\":1,\"nic\":12}]"
          }, {
            "name" : "failback",
            "in" : "body",
            "description" : "Whether to fail back to the primary server once it recovers.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "failoverTime",
            "in" : "body",
            "description" : "Seconds before triggering failover.",
            "required" : false,
            "example" : "30"
          }, {
            "name" : "failbackTime",
            "in" : "body",
            "description" : "Seconds before failing back.",
            "required" : false,
            "example" : "60"
          }, {
            "name" : "evictNfsClientsOnFailback",
            "in" : "body",
            "description" : "Disconnect NFS clients when failing back.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if RGW prerequisites are violated (multi-zone, non-default ports, duplicate IP)", "400 if id is provided", "500 if database persistence fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Surface validation details (IP conflicts, RGW restrictions) and request corrected input."
          }, {
            "code" : "500",
            "action" : "Check logs for DB errors; retry once the issue is resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "HA group provisioning"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ha-groups/{id}" : {
      "put" : {
        "summary" : "Update HA group",
        "operationId" : "HaGroupResource_updateHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated HA group configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/HaGroup"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update HA group configuration including VIP, membership, and timings.",
          "usage" : [ "Adjust failover timings based on operational feedback.", "Replace servers in the HA set during maintenance swaps." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Validate RGW constraints and confirm the HA group ID matches the payload.",
            "post_action" : "Monitor the update task; notify clients if the VIP or membership changes."
          },
          "request_parameters" : [ {
            "name" : "group",
            "in" : "body",
            "description" : "Complete HA group object with updated fields.",
            "required" : true,
            "example" : "{...}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Existing HA group ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if RGW constraints fail or payload id mismatches path", "500 if database update fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Align the request to RGW requirements and ensure the ID matches."
          }, {
            "code" : "500",
            "action" : "Inspect logs for DB constraint violations; retry once fixed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "HA group updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete HA group",
        "operationId" : "HaGroupResource_deleteHagroup",
        "tags" : [ "ha-groups" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an HA group definition and release its virtual IP.",
          "usage" : [ "Decommission HA for a service that has been migrated or disabled.", "Clean stale entries before recreating with different parameters." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "HA group ID to delete.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the HA group cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the HA group list to obtain a current ID before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "HA group deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers/ha-groups", "/servers/ha-groups/{id}" ],
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting the HA group immediately removes the floating IP and failover policy."
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/ips" : {
      "get" : {
        "summary" : "List all IP addresses in use.",
        "operationId" : "ServerResource_listIps",
        "tags" : [ "servers" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IpAddressInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return all IP addresses in use across NICs, VLANs, HA groups and SMB services.",
          "usage" : [ "Generate concise IP usage summaries before assigning new addresses", "Cross-check address ownership during troubleshooting sessions" ],
          "response_shape" : "IpAddressInfo",
          "failure_modes" : [ "200 with empty lists when no IP data has been discovered yet" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a guidance message to trigger hardware discovery if lists are empty."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "IP usage overview requests"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips-with-subnet", "/servers/free-ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Deduplicate IPv4/IPv6 entries before presenting, since some addresses appear in multiple categories.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/ips-with-subnet" : {
      "get" : {
        "summary" : "List all used IP addresses with their subnet.",
        "operationId" : "ServerResource_listIpsWithSubnet",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseIpGeneralInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enumerate IP addresses with subnet metadata for capacity analysis.",
          "usage" : [ "Run before allocating new addresses to ensure subnet availability", "Filter by subnet to produce reports for network teams" ],
          "response_shape" : "OptionalPaginationResponse<IpGeneralInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters (e.g. by subnet) and limits.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"subnetShort\":{\"_eq\":\"10.0.0.0/24\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no IPs match the requested filters" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Return an empty table and recommend verifying discovery if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Subnet utilisation lookups"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/ips", "/servers/free-ips-obj" ],
          "postprocessing_hint" : "Group results by subnetShort to highlight utilisation hotspots.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/nics" : {
      "get" : {
        "summary" : "List all nics.",
        "operationId" : "ServerResource_getAllNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List NICs across all servers with bond and VLAN metadata.",
          "usage" : [ "Build global network inventory views or export NIC data", "Filter for unused interfaces before provisioning new services" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling filters, sorting and limits.",
            "required" : false,
            "example" : "{\"limit\":100,\"where\":[{\"bond\":{\"_is_null\":true}}]}"
          } ],
          "failure_modes" : [ "200 [] when no NICs exist in the cluster" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Present a zero-state hinting that hardware discovery has not completed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Cluster-wide NIC inventory"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Aggregate by bond or NUMA node if needed in dashboards.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/reboot" : {
      "post" : {
        "summary" : "Reboot multiple servers",
        "operationId" : "ServerResource_rebootServers",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerRebootRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule reboots for multiple servers in one request.",
          "usage" : [ "Roll dozens of hosts after applying kernel or firmware patches.", "Automate controlled restarts during maintenance windows." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Set of server IDs to reboot.",
            "required" : true,
            "example" : "[21,22,23]"
          } ],
          "failure_modes" : [ "400 if the server list is empty or contains duplicates", "404 if any referenced server IDs are invalid", "200 ManagedTask(status=FAILED) if some nodes fail to reboot" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide at least one unique server ID."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and remove missing entries."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask log to determine which servers failed and retry individually."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Bulk reboot scheduling"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/shutdown", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/update-grub" : {
      "post" : {
        "summary" : "Update GRUB on all boot disks of the given servers.",
        "operationId" : "ServerResource_updateGrub",
        "tags" : [ "servers" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UpdateGrubRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Regenerate GRUB configurations on the selected servers' boot disks.",
          "usage" : [ "Run after modifying kernel parameters or reinstalling bootloaders.", "Execute during recovery workflows to ensure the correct boot image is selected." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "List of server IDs whose boot disks should be updated.",
            "required" : true,
            "example" : "[12,14]"
          } ],
          "failure_modes" : [ "400 if the server list is empty", "200 ManagedTask(status=FAILED) if bootloader updates fail on one or more hosts" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Specify at least one server ID before retrying."
          }, {
            "code" : "200",
            "action" : "Inspect the ManagedTask logs to resolve host-specific issues, then rerun for failed servers only."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 4,
            "window_seconds" : 86400,
            "note" : "Bootloader maintenance"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/tasks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}" : {
      "patch" : {
        "summary" : "Update server",
        "operationId" : "ServerResource_updateServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Server update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServerUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update server metadata and optionally queue background tasks for image changes or hugepage reconfiguration.",
          "usage" : [ "Rename a server or adjust its management IP after hardware changes.", "Switch the boot image or adjust hugepage reservations prior to deploying NVMe-oF/DAOS services." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "hostname",
            "in" : "body",
            "description" : "Optional new hostname.",
            "required" : false,
            "example" : "ceph-node-3"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional management IPv4 address.",
            "required" : false,
            "example" : "192.168.10.23"
          }, {
            "name" : "image",
            "in" : "body",
            "description" : "Image UUID or 'default' to restore defaults.",
            "required" : false,
            "example" : "default"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes displayed in the UI.",
            "required" : false,
            "example" : "Reserved for DR testing"
          }, {
            "name" : "nrHugepages",
            "in" : "body",
            "description" : "Number of 2MiB hugepages to configure.",
            "required" : false,
            "example" : "2048"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found", "400 if image validation fails or incompatible services are detected", "500 if background ManagedTask steps fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review validation errors (boot disks, compatibility warnings) and adjust the payload."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, resolve issues (e.g. image download failures), then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server configuration updates"
          },
          "related_endpoints" : [ "/servers/{id}", "/servers/{id}/reboot", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask and reboot the server if the image was changed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete server",
        "operationId" : "ServerResource_deleteServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a server from croit inventory after services and dependencies are cleared.",
          "usage" : [ "Retire hardware that has been physically removed from the cluster.", "Clean up failed installations before re-registering the host." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server is already gone", "400 if the server hosts DAOS resources", "400 if a monitor service is still assigned to the server" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the server list to confirm removal and skip further action."
          }, {
            "code" : "400",
            "action" : "Detach DAOS assignments or remove Ceph monitor services before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 86400,
            "note" : "Server deletions"
          },
          "related_endpoints" : [ "/servers/{id}/services", "/servers/{id}/disks", "/servers/{id}/nics" ],
          "postprocessing_hint" : "Update external inventory systems and reread GET /servers to ensure the host disappeared.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks" : {
      "get" : {
        "summary" : "List disks on the server.",
        "operationId" : "ServerResource_getDisks",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseDiskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List disks attached to a specific server with live utilization details.",
          "usage" : [ "Inspect storage layout before scheduling OSD or service changes", "Refresh after maintenance to verify disk states and statistics" ],
          "response_shape" : "OptionalPaginationResponse<DiskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling sorting, limit and filters.",
            "required" : false,
            "example" : "{\"limit\":25,\"where\":[{\"role\":{\"_eq\":\"osd\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric server identifier returned by GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server has no disks or the identifier is unknown" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Surface an empty-state message and prompt a rescan if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Heavy data payload per server"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers", "/disks", "/servers/{id}/services" ],
          "postprocessing_hint" : "Highlight disks with missing stats and merge with smart metrics if available.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/disks/{diskId}" : {
      "patch" : {
        "summary" : "Update disk",
        "operationId" : "ServerResource_updateDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/DiskUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update per-disk metadata, assign roles, or toggle identify LEDs for maintenance workflows.",
          "usage" : [ "Promote an unassigned disk to journal/DB/WAL after validation.", "Locate a disk in the chassis by enabling the identify LED." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "role",
            "in" : "body",
            "description" : "New disk role (e.g. journal).",
            "required" : false,
            "example" : "journal"
          }, {
            "name" : "partitions",
            "in" : "body",
            "description" : "Partition count when preparing journal disks.",
            "required" : false,
            "example" : "4"
          }, {
            "name" : "identifyLed",
            "in" : "body",
            "description" : "true to enable the LED, false to disable.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes stored with the disk.",
            "required" : false,
            "example" : "Installed in bay 4"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the disk is not associated with the specified server", "400 if the disk is missing, already assigned, or the role change is not supported", "500 if LED commands or journal preparation fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the disk inventory and retry with correct IDs."
          }, {
            "code" : "400",
            "action" : "Ensure the disk is unassigned/online and that requested roles match cluster state."
          }, {
            "code" : "500",
            "action" : "Check daemon logs for LED or journal preparation failures before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Disk metadata updates"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/disks/wipe" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete disk",
        "operationId" : "ServerResource_deleteDisk",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a disk record from a server after hardware replacement or removal.",
          "usage" : [ "Clear stale entries when a disk was taken out but the hardware scan has not run yet.", "Reset the inventory before reimporting a disk with a new role." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the disk ID is not associated with the server", "400 if DAOS currently uses the disk" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-run hardware detection or list disks to confirm valid IDs."
          }, {
            "code" : "400",
            "action" : "Detach the disk from DAOS engines before retrying the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "Disk inventory cleanup"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}/smart" ],
          "postprocessing_hint" : "Run hardware re-detect or import to refresh disk listings after removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/disks/{diskId}/smart" : {
      "post" : {
        "summary" : "Update disk SMART details",
        "operationId" : "ServerResource_updateDiskSmartDetails",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "diskId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/DiskSmartStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger an on-demand SMART data refresh for a specific disk.",
          "usage" : [ "Pull the latest health metrics before deciding to replace a disk.", "Validate alerts from monitoring systems with real-time SMART data." ],
          "response_shape" : "DiskSmartStatus",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "diskId",
            "in" : "path",
            "description" : "Disk identifier from GET /servers/{id}/disks.",
            "required" : true,
            "example" : "145"
          } ],
          "failure_modes" : [ "404 if the server or disk cannot be resolved", "500 if the SMART refresh task fails or times out" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh server/disk inventories and retry with correct IDs."
          }, {
            "code" : "500",
            "action" : "Inspect daemon task logs; ensure SMART tooling is healthy before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "SMART refresh"
          },
          "related_endpoints" : [ "/servers/{id}/disks", "/servers/{id}/disks/{diskId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics" : {
      "get" : {
        "summary" : "List nics on the server.",
        "operationId" : "ServerResource_getNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseNicResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve NIC inventory and link status for a specific server.",
          "usage" : [ "Load before rendering network configuration dialogs", "Re-query after applying NIC or VLAN changes to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<NicResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or filter returned NICs.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"type\":{\"_neq\":\"virtual\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server has no NICs or the id is unknown" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state and suggest refreshing hardware data if unexpected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server NIC inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/nics", "/servers" ],
          "postprocessing_hint" : "Group bonded members and flag stale lastSeen values for manual review.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/nics/bonds" : {
      "post" : {
        "summary" : "Create network bond",
        "operationId" : "ServerResource_createBond",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Bond creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BondRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an LACP or active/passive bond on a server and migrate existing IP configuration.",
          "usage" : [ "Call during network onboarding to aggregate multiple NICs under a single bond interface.", "Rebuild bonds after replacing physical adapters while preserving IP assignments." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Bond interface name (15 characters).",
            "required" : true,
            "example" : "bond0"
          }, {
            "name" : "nics[]",
            "in" : "body",
            "description" : "List of NIC IDs that form the bond (minimum two).",
            "required" : true,
            "example" : "[101,102]"
          }, {
            "name" : "activePassive",
            "in" : "body",
            "description" : "true for active/passive (mode 1), false for LACP.",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "primary",
            "in" : "body",
            "description" : "Primary NIC ID when activePassive=true.",
            "required" : false,
            "example" : "101"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if constraints are violated (duplicate name, <2 NICs, mixed NIC types, conflicting primary)", "404 if the server or one of the NIC IDs does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Adjust the payload to satisfy bond rulesensure NICs belong to the server and match the selected mode."
          }, {
            "code" : "404",
            "action" : "Refresh the server/NIC inventory and retry with valid identifiers."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Bond configuration"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Re-run hardware detection or networking checks to verify the bond state on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}" : {
      "patch" : {
        "summary" : "Update network interface",
        "operationId" : "ServerResource_updateNics",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NIC update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NicUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NIC addressing, notes, MAC address, or adjust bonded NIC membership on a server.",
          "usage" : [ "Reconfigure IPs after a network change.", "Replace a failed NIC while keeping MAC reservations up to date." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address (CIDR).",
            "required" : false,
            "example" : "192.168.120.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address (CIDR).",
            "required" : false,
            "example" : "fd00:120::5/64"
          }, {
            "name" : "notes",
            "in" : "body",
            "description" : "Operator notes stored with the NIC.",
            "required" : false,
            "example" : "Connected to TOR A"
          }, {
            "name" : "mac",
            "in" : "body",
            "description" : "Override MAC when replacing hardware (server must be offline).",
            "required" : false,
            "example" : "02:00:5e:10:00:00"
          }, {
            "name" : "bond.activePassive",
            "in" : "body",
            "description" : "Switch bond mode between active/passive and LACP.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "bond.primary",
            "in" : "body",
            "description" : "Primary NIC ID when active/passive mode is selected.",
            "required" : false,
            "example" : "101"
          }, {
            "name" : "bond.nics[]",
            "in" : "body",
            "description" : "New list of slave NIC IDs for the bond.",
            "required" : false,
            "example" : "[101,102]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier from GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "404 if the NIC does not belong to the server", "400 for invalid IP formats, unsupported MAC replacements, or incompatible bond settings", "500 if bonding operations fail while updating slave membership" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh NIC inventory before retrying."
          }, {
            "code" : "400",
            "action" : "Ensure the server is offline for MAC changes and that bond requests follow hardware constraints."
          }, {
            "code" : "500",
            "action" : "Inspect server logs for bonding errors; apply changes incrementally if needed."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "NIC configuration changes"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/nics/bonds", "/servers/{id}/nics/{nicId}/vlans" ],
          "postprocessing_hint" : "Restart DHCP updates and verify network reachability after changes.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete network interface",
        "operationId" : "ServerResource_deleteNic",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a network interface record from the server inventory (and tear down virtual links).",
          "usage" : [ "Clean up NIC entries after replacing hardware or undoing temporary bonding.", "Delete misconfigured virtual interfaces before reapplying network settings." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "Identifier of the NIC to remove.",
            "required" : true,
            "example" : "58"
          } ],
          "failure_modes" : [ "404 if the NIC is not attached to the server", "400 if DAOS still references the NIC", "200 with warning when the NIC IP is used by a monitor service (requires manual acknowledgement)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the NIC list and choose a valid identifier."
          }, {
            "code" : "400",
            "action" : "Detach the NIC from DAOS engines before retrying."
          }, {
            "code" : "200",
            "action" : "If an ignorable warning cites a Ceph monitor IP, remove the monitor or change its address first."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NIC deletions"
          },
          "postprocessing_hint" : "Trigger DHCP regeneration and re-run hardware detection to refresh NIC state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans" : {
      "get" : {
        "summary" : "List vlans configured on the nic.",
        "operationId" : "ServerResource_getVlans",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseVlanInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List VLAN interfaces configured on a specific NIC.",
          "usage" : [ "Inspect VLAN assignments before modifying network topology", "Verify applied VLAN changes after POST/PATCH operations" ],
          "response_shape" : "OptionalPaginationResponse<VlanInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or filter VLAN entries.",
            "required" : false,
            "example" : "{\"limit\":20,\"where\":[{\"vlan\":{\"_gte\":100}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "200 [] when the NIC has no VLANs or identifiers are invalid" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show an empty list and prompt the user to add VLANs if needed."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-NIC VLAN inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/nics" ],
          "postprocessing_hint" : "Present both IPv4 and IPv6 columns and indicate overlapping DHCP pools.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add VLAN",
        "operationId" : "ServerResource_addVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewVlanRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Attach a tagged VLAN interface to a specific server NIC, including optional IPv4/IPv6 addresses.",
          "usage" : [ "Provision tenant networks on dedicated NICs.", "Restore VLAN configuration after replacing network hardware." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "vlan",
            "in" : "body",
            "description" : "VLAN tag to assign.",
            "required" : true,
            "example" : "110"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address for the VLAN.",
            "required" : false,
            "example" : "10.0.110.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address for the VLAN.",
            "required" : false,
            "example" : "fd00:110::5/64"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier returned by GET /servers/{id}/nics.",
            "required" : true,
            "example" : "7"
          } ],
          "failure_modes" : [ "400 if the IP conflicts with another interface on the server", "404 if the NIC does not belong to the server" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique IP assignments or clear conflicting addresses first."
          }, {
            "code" : "404",
            "action" : "Refresh NIC inventory and retry with the correct NIC ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN provisioning"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}/vlans/{vlanId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/nics/{nicId}/vlans/{vlanId}" : {
      "patch" : {
        "summary" : "Update VLAN",
        "operationId" : "ServerResource_updateVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "VLAN update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VlanUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update VLAN tag or IP configuration for an existing VLAN interface on a NIC.",
          "usage" : [ "Change addressing after moving the VLAN to a new subnet.", "Adjust tagging when consolidating VLAN numbering." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "vlan",
            "in" : "body",
            "description" : "Optional new VLAN tag.",
            "required" : false,
            "example" : "120"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Optional IPv4 address (CIDR).",
            "required" : false,
            "example" : "10.0.120.5/24"
          }, {
            "name" : "ip6",
            "in" : "body",
            "description" : "Optional IPv6 address (CIDR).",
            "required" : false,
            "example" : "fd00:120::5/64"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "42"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier hosting the VLAN.",
            "required" : true,
            "example" : "7"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "404 if the VLAN or NIC cannot be found", "400 if new IP assignments conflict with existing interfaces" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh VLAN listings before retrying."
          }, {
            "code" : "400",
            "action" : "Resolve IP conflicts or choose a unique VLAN tag before reissuing the update."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 3600,
            "note" : "VLAN updates"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Validate routing and DHCP settings after modifying VLAN parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete VLAN",
        "operationId" : "ServerResource_deleteVlan",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "nicId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "vlanId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a VLAN interface from a server NIC and clean up the underlying host link if possible.",
          "usage" : [ "Call after migrating VLAN traffic away from the interface.", "Undo temporary VLAN assignments made for maintenance tasks." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID owning the NIC.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "nicId",
            "in" : "path",
            "description" : "NIC identifier within the server.",
            "required" : true,
            "example" : "58"
          }, {
            "name" : "vlanId",
            "in" : "path",
            "description" : "VLAN record identifier.",
            "required" : true,
            "example" : "104"
          } ],
          "failure_modes" : [ "404 if the NIC/VLAN combination does not exist", "200 with warning if the VLAN IP is still used by a monitor service", "500 if SSH cleanup fails; VLAN entry is still removed from the database" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the VLAN list for the NIC before retrying."
          }, {
            "code" : "200",
            "action" : "Acknowledge the ignorable warning and remove dependent monitor services before reassigning the IP."
          }, {
            "code" : "500",
            "action" : "Manually delete the VLAN on the host (ip link del) and retry hardware detection if required."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "VLAN removal"
          },
          "related_endpoints" : [ "/servers/{id}/nics/{nicId}/vlans", "/servers/{id}/nics/{nicId}" ],
          "postprocessing_hint" : "Run hardware re-detect or reapply network configuration to confirm the VLAN disappeared on the host.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/reboot" : {
      "post" : {
        "summary" : "Reboot server",
        "operationId" : "ServerResource_rebootServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Schedule an immediate reboot of the specified server via the croit agent.",
          "usage" : [ "Restart a node after applying configuration changes.", "Recover a machine that requires a manual reboot outside of rolling operations." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server list and retry with a valid ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server reboot"
          },
          "related_endpoints" : [ "/servers/{id}/shutdown", "/servers/reboot" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/redetect" : {
      "post" : {
        "summary" : "Redetect hardware",
        "operationId" : "ServerResource_redetectHardware",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Trigger the agent to rescan hardware (NICs, disks, etc.) for the specified server.",
          "usage" : [ "Refresh inventory after physically swapping components.", "Revalidate hardware information when monitoring detects discrepancies." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server inventory before retrying."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 1800,
            "note" : "Hardware re-detect"
          },
          "related_endpoints" : [ "/servers/{id}/nics", "/servers/{id}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services" : {
      "get" : {
        "summary" : "List services on the server.",
        "operationId" : "ServerResource_getServices",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List Ceph and gateway services running on a specific server.",
          "usage" : [ "Audit service placement before scheduling migrations", "Refresh after service start/stop actions to confirm state" ],
          "response_shape" : "OptionalPaginationResponse<ServiceResource.MultiServerServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON controlling limit, offset and filters (e.g. by service type).",
            "required" : false,
            "example" : "{\"where\":[{\"type\":{\"_eq\":\"mon\"}}]}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "200 [] when the server runs no services" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state card noting that no services are scheduled on the host."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Per-server service inspection"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/servers/{id}/disks", "/servers" ],
          "postprocessing_hint" : "Highlight services with WARN/ERROR health before showing to the operator.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/servers/{id}/services/{serviceId}" : {
      "delete" : {
        "summary" : "Delete service",
        "operationId" : "ServerResource_deleteService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach a service instance from a specific server, optionally triggering managed removal tasks.",
          "usage" : [ "Remove a service from a node prior to decommissioning the server.", "Force-stop a misbehaving service by removing it from the host." ],
          "response_shape" : "ManagedTask?",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID assigned to the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if either the server or service mapping is unknown", "409 if the service manager refuses the removal because another operation holds the lock" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /servers/{id}/services to confirm the mapping before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other service control tasks to finish, then reissue the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Server service removal"
          },
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/start", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/shutdown" : {
      "post" : {
        "summary" : "Shutdown server",
        "operationId" : "ServerResource_shutdownServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Gracefully shut down a server through the croit agent and mark it as shutting down.",
          "usage" : [ "Power off a node before hardware maintenance.", "Prepare servers for planned outages after migrating workloads." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server inventory and retry with a valid ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "Manual server shutdown"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/reboot" ],
          "postprocessing_hint" : "Update runbooks to reflect that the server is offline and monitor for daemon task completion.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{id}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the server via SSH.",
        "operationId" : "TerminalResource_connectToTerminalProxy",
        "tags" : [ "images" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Establish a secure SSH terminal connection to a server through the croit terminal proxy.",
          "usage" : [ "Call when administrators need direct shell access for troubleshooting or maintenance.", "Use to create secure, audited connections to cluster servers without exposing SSH directly." ],
          "response_shape" : "TerminalConnection",
          "workflow_guidance" : {
            "pre_check" : "Server exists; SSH connectivity verified; Terminal proxy running",
            "post_action" : "Connection established; Session token generated; Connection expires after 1 minute if unused"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Server ID to connect to (use 0 for localhost/manager node).",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if server ID does not exist in the database", "500 if SSH connection test fails or terminal proxy is unavailable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify server exists and is registered in the cluster."
          }, {
            "code" : "500",
            "action" : "Check server SSH connectivity and terminal proxy service status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Terminal connections"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/servers", "/servers/{id}" ],
          "postprocessing_hint" : "Connect immediately using returned connection details; session expires quickly; all terminal activity is audited and logged.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Terminal access provides full administrative control over cluster servers"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mds" : {
      "post" : {
        "summary" : "Add MDS service",
        "operationId" : "ServerResource_addMdsService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a CephFS metadata server (MDS) on the specified host.",
          "usage" : [ "Scale CephFS metadata capacity by adding another MDS daemon.", "Recreate an MDS after host replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run the MDS daemon.",
            "required" : true,
            "example" : "25"
          } ],
          "failure_modes" : [ "400 if an MDS already runs on the server or CephFS setup blocks provisioning", "404 if the server ID cannot be found", "500 if key creation or daemon start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure the server is not already hosting an MDS and CephFS pools are ready."
          }, {
            "code" : "404",
            "action" : "Refresh the server list before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs and fix host issues prior to reattempting."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "MDS provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/mon" : {
      "post" : {
        "summary" : "Add monitor service",
        "operationId" : "ServerResource_addMonService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Monitor service creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MonServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a Ceph monitor on the specified server, provisioning keys and optional disk wiping.",
          "usage" : [ "Scale out the monitor quorum when adding new nodes.", "Redeploy a monitor after replacing hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "ip",
            "in" : "body",
            "description" : "IPv4 address for the monitor to bind to.",
            "required" : true,
            "example" : "192.168.10.11"
          }, {
            "name" : "diskId",
            "in" : "body",
            "description" : "Disk ID used for the monitor store; will be wiped if necessary.",
            "required" : true,
            "example" : "104"
          } ],
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that should host the monitor.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if Ceph is not yet configured or a duplicate monitor exists", "404 if the server or disk ID is invalid", "500 if key creation or service start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Deploy the initial monitor first or remove existing monitor instances."
          }, {
            "code" : "404",
            "action" : "Refresh server/disk inventories before retrying."
          }, {
            "code" : "500",
            "action" : "Review the ManagedTask log, resolve host issues, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Monitor provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rbd-mirror" : {
      "post" : {
        "summary" : "Start a rbd mirror daemon on the server. Only one rbd mirror daemon is allowed to run on each server.",
        "operationId" : "ServerResource_addRbdMirrorService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an rbd-mirror daemon on the specified server, including keyring creation.",
          "usage" : [ "Provision replication capacity between clusters by adding mirror daemons.", "Recreate a mirror daemon after node recovery." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will run rbd-mirror.",
            "required" : true,
            "example" : "31"
          } ],
          "failure_modes" : [ "400 if a mirror daemon already exists on the server or required packages are missing", "404 if the server ID cannot be resolved", "500 if key creation or daemon start fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure rbd-mirror is installed and no other mirror service exists on the host."
          }, {
            "code" : "404",
            "action" : "Refresh the server list and retry."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to resolve host issues before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "rbd-mirror provisioning"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/services/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/rgw" : {
      "post" : {
        "summary" : "Add RGW service",
        "operationId" : "ServerResource_addRgwService",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a RADOS Gateway (RGW) instance on the specified server.",
          "usage" : [ "Scale RGW capacity by adding additional gateways.", "Recreate an RGW daemon after server replacement." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID that will host the RGW service.",
            "required" : true,
            "example" : "28"
          } ],
          "failure_modes" : [ "400 if an RGW already runs on the server", "404 if the server ID cannot be found", "500 if key creation, Ceph configuration, or daemon startup fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure multi-RGW per server is enabled or remove the existing RGW first."
          }, {
            "code" : "404",
            "action" : "Refresh GET /servers and retry with a valid ID."
          }, {
            "code" : "500",
            "action" : "Inspect ManagedTask logs, resolve host issues, and rerun the deployment."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "RGW provisioning"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/servers/{serverId}/services/{serviceId}/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServerResource_restartServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a service instance on a specific server.",
          "usage" : [ "Bounce a daemon after applying configuration changes on a single node.", "Recover a service exhibiting issues without affecting other replicas." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not bound to the server", "409 if another control task conflicts", "500 if the restart fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server's service list before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other actions to complete."
          }, {
            "code" : "500",
            "action" : "Review server logs to resolve issues and retry once healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service restart"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServerResource_startServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service instance on a particular server.",
          "usage" : [ "Bring a daemon online on a chosen node without affecting other replicas.", "Recover a service after host maintenance." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to start on the server.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not associated with the server", "409 if another control action is in progress", "500 if the daemon fails to start" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List services for the server and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to complete before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect logs on the server to fix underlying issues prior to reissuing the command."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service start"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/stop", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServerResource_stopServiceOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance running on a specific server.",
          "usage" : [ "Drain a daemon prior to host maintenance.", "Temporarily disable a problematic service on one server." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server hosting the service.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service is not linked to the server", "409 if other control operations are pending", "500 if the daemon fails to stop" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List server services to confirm mapping before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for existing tasks to finish."
          }, {
            "code" : "500",
            "action" : "Investigate logs on the server and retry once issues are resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service stop"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{serviceId}/start", "/servers/{serverId}/services/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServerResource_restartServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "description" : "",
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Bounce a daemon after applying configuration updates.", "Recover an OSD exhibiting issues on a particular node." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "404 if the mapping is invalid", "409 if a conflicting task is already queued", "500 if the restart fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the mapping via GET /servers/{serverId}/services before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to finish."
          }, {
            "code" : "500",
            "action" : "Inspect logs on the server; resolve issues before running again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD restart"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServerResource_startServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a specific service or OSD on a given server, disambiguating by type.",
          "usage" : [ "Start an OSD process on its host after maintenance.", "Bring a specific service replica online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "45"
          } ],
          "failure_modes" : [ "404 if the specified ID is not associated with the server", "409 if another control action conflicts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch the server's service/OSD list and retry with a valid ID."
          }, {
            "code" : "409",
            "action" : "Retry after existing operations complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD start"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/stop", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/services/{type}/{serviceId}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServerResource_stopServiceOrOsdOnServer",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a specific service or OSD instance on a server, identified by type and ID.",
          "usage" : [ "Drain an OSD or service prior to maintenance.", "Temporarily disable a daemon causing issues." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Target server ID.",
            "required" : true,
            "example" : "23"
          }, {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service or OSD ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the mapping is invalid", "409 if another control task is in progress" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the server's service list and retry."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to complete before reissuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Per-server service/OSD stop"
          },
          "related_endpoints" : [ "/servers/{serverId}/services/{type}/{serviceId}/start", "/servers/{serverId}/services/{type}/{serviceId}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/servers/{serverId}/ssh-test" : {
      "post" : {
        "summary" : "Simple ssh test",
        "operationId" : "ServerResource_testSshConnection",
        "tags" : [ "servers" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Use SSH with retries.",
          "name" : "retry",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        }, {
          "description" : "How many seconds to sleep for, repeated 5 times.",
          "name" : "sleep",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Run a simple SSH connectivity test against the specified server (optionally with retries).",
          "usage" : [ "Diagnose SSH access issues before scheduling tasks that require remote commands.", "Measure whether retry logic is needed for unstable connections." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "sleep",
            "in" : "query",
            "description" : "Sleep duration (seconds) per iteration to simulate work.",
            "required" : false,
            "example" : "1"
          }, {
            "name" : "retry",
            "in" : "query",
            "description" : "true to use the retry-enabled SSH client.",
            "required" : false,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server identifier from GET /servers.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "404 if the server cannot be found", "500 if SSH connection attempts fail" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Review server reachability, credentials, and logs before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "SSH diagnostics"
          },
          "related_endpoints" : [ "/servers/{id}/reboot", "/servers/{id}/redetect" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services" : {
      "get" : {
        "summary" : "List of all services across all servers.",
        "operationId" : "ServiceResource_getAllServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseMultiServerServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all Ceph and croit services with health, state, and placement details.",
          "usage" : [ "Call to render the service inventory dashboard with pagination support.", "Refresh after starting/stopping services or during maintenance to monitor state transitions." ],
          "response_shape" : "OptionalPaginationResponse<MultiServerServiceResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON (e.g. {\"limit\":50,\"where\":[{\"type\":{\"_eq\":\"osd\"}}]}).",
            "required" : false,
            "example" : "{\"limit\":50,\"order\":[{\"state\":\"asc\"}]}"
          } ],
          "common_parameters" : {
            "pagination.where.type" : "Filter to service types like mon/mds/nfs before bulk actions.",
            "pagination.where.running" : "Focus on stopped services when triaging issues."
          },
          "failure_modes" : [ "200 data=[],total=0 when no services match the filter" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Relax filters or confirm that services have been provisioned before retrying."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Service monitoring"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/{serviceId}", "/services/restart" ],
          "postprocessing_hint" : "Group services by type and highlight entries with health.uptime=null to indicate unseen daemons.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi" : {
      "post" : {
        "summary" : "Create a new iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addIscsiGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "iSCSI gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision the single supported iSCSI gateway cluster and deploy ceph-iscsi gateways on selected servers.",
          "usage" : [ "Call during initial setup to instantiate the iSCSI control plane.", "Use after wiping an old deployment (servers rebooted) to recreate the gateway." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[].serverId",
            "in" : "body",
            "description" : "Server ID to host the gateway instance.",
            "required" : true,
            "example" : "101"
          }, {
            "name" : "servers[].ip",
            "in" : "body",
            "description" : "Client-facing IP already configured on the server.",
            "required" : true,
            "example" : "192.168.10.50"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional display name for the gateway.",
            "required" : false,
            "example" : "Primary iSCSI cluster"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or a second gateway is attempted", "404 if any referenced server ID does not exist", "409 if another creation task is currently running", "500 if Ceph pool or ceph-iscsi provisioning fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Configure CephFS and ensure only one gateway is defined before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and submit only managed server IDs."
          }, {
            "code" : "409",
            "action" : "Wait for the existing creation task to finish; retry if it failed."
          }, {
            "code" : "500",
            "action" : "Inspect task logs, reboot gateway servers if necessary, then re-run the creation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "iSCSI cluster provisioning"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "Monitor the ManagedTask output; once complete, verify gateway health via GET /services/iscsi.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}" : {
      "patch" : {
        "summary" : "Update an iSCSI gateway.",
        "operationId" : "IscsiServiceResource_updateIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable metadata on the iSCSI gateway service (currently the description).",
          "usage" : [ "Rename the gateway in the UI after reassigning responsibilities.", "Clarify the service description following infrastructure changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional new description shown to operators.",
            "required" : false,
            "example" : "Production iSCSI service"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID to update.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service ID cannot be found" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi to confirm the service still exists before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI metadata update"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Inspect the ceph-iscsi gateway configuration.",
        "operationId" : "IscsiServiceResource_getIscsiGatewayConfig",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiGatewayConfig"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch the ceph-iscsi configuration snapshot for the selected gateway.",
          "usage" : [ "Load the gateway detail view before presenting targets and clients.", "Refresh after finishing gateway maintenance or changing the active target." ],
          "response_shape" : "IscsiGatewayConfig",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "200 with empty clients/disks lists when no exports are configured", "500 if reading gateway.conf from the Ceph iSCSI config pool fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state and guide the user to add disks or clients."
          }, {
            "code" : "500",
            "action" : "Check Ceph health and ensure the iSCSI config pool exists before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Gateway configuration refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI service.",
        "operationId" : "IscsiServiceResource_deleteIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down the iSCSI gateway service and purge its Ceph-side configuration.",
          "usage" : [ "Invoke when decommissioning the iSCSI deployment or migrating to new hardware.", "Use before recreating the gateway to ensure no residual configuration remains." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier as returned by GET /services/iscsi.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service ID no longer exists", "500 if another operation currently modifies the gateway or Ceph config cleanup fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the iSCSI service list and retry only if the gateway still exists."
          }, {
            "code" : "500",
            "action" : "Wait for concurrent tasks to finish, inspect server logs, then retry the deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway removal"
          },
          "related_endpoints" : [ "/services/iscsi", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Inform operators that affected servers must be rebooted before provisioning a new gateway.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add a server to an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_addServerToIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiGatewayServer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale out the iSCSI gateway by adding another server with its client-facing IP.",
          "usage" : [ "Use when onboarding a new gateway node to increase throughput.", "Call after replacing hardware to reinstate the node into the gateway cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "serverId",
            "in" : "body",
            "description" : "Server ID being added to the gateway.",
            "required" : true,
            "example" : "102"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "Client-facing IP already configured on the server.",
            "required" : true,
            "example" : "192.168.10.51"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Existing iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service or server ID is unknown", "409 if ceph-iscsi reports the gateway is already defined on the host", "500 if starting the gateway daemon or reconfiguring peers fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch the current gateway and server list, then retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Ensure the server was rebooted after previous deletions and retry once the daemon is stopped."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log for details; address host issues before re-running."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway scaling"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/servers/{hostname}", "/services/iscsi/{serviceId}/disks" ],
          "postprocessing_hint" : "After success, run GET /services/iscsi/{serviceId} to confirm the new server appears and is healthy.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}" : {
      "delete" : {
        "summary" : "Delete an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an iSCSI client definition and revoke its access credentials.",
          "usage" : [ "Call when retiring a host that should no longer access exported LUNs.", "Use before recreating the client with new CHAP secrets to avoid duplicates." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN as shown in the gateway configuration.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the service or client name cannot be found", "500 if the gateway rejects the deletion request" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} to confirm current clients before retrying."
          }, {
            "code" : "500",
            "action" : "Verify gateway connectivity and logs, then retry once the control plane is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI client removal"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Re-run GET /services/iscsi/{serviceId} to confirm the client entry is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Configure a new iSCSI client",
        "operationId" : "IscsiServiceResource_createIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client creation configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientCreationRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI client entry (CHAP credentials plus optional host group assignment).",
          "usage" : [ "Add a new initiator to access exported LUNs.", "Recreate a client with fresh credentials during onboarding." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "CHAP username (8-64 chars).",
            "required" : true,
            "example" : "client-user"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "CHAP secret (12-16 chars).",
            "required" : true,
            "example" : "Sup3rS3cret123"
          }, {
            "name" : "group",
            "in" : "body",
            "description" : "Optional host group to auto-assign.",
            "required" : false,
            "example" : "prod-nodes"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Desired client name or IQN.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newhost"
          } ],
          "failure_modes" : [ "400 if the credentials fail validation or host group assignment is invalid", "404 if the service ID is unknown", "500 if the gateway cannot create the client" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure username/password meet length requirements and host group exists."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi to confirm the service ID."
          }, {
            "code" : "500",
            "action" : "Check iscsi-gateway logs; delete any partial client and retry once healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI client creation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "patch" : {
        "summary" : "Change a client's username/password",
        "operationId" : "IscsiServiceResource_changeIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "iSCSI client change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiClientChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Rotate CHAP credentials for an existing iSCSI client.",
          "usage" : [ "Update secrets after a credential leak or scheduled rotation.", "Rename the client user while preserving existing LUN mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "Optional new CHAP username (8-64 chars).",
            "required" : false,
            "example" : "client-rotated"
          }, {
            "name" : "password",
            "in" : "body",
            "description" : "Optional new CHAP secret (12-16 chars).",
            "required" : false,
            "example" : "N3wSecret123456"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Existing client name/IQN to update.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the client cannot be found", "500 if the gateway rejects the update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the client list to verify the name before retrying."
          }, {
            "code" : "500",
            "action" : "Check gateway logs; if the update partially applied, reapply with consistent credentials."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI credential rotation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/clients/{name}/disks" : {
      "delete" : {
        "summary" : "Unmap a disk from an iSCSI client",
        "operationId" : "IscsiServiceResource_deleteLunFromIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach an exported RBD image (LUN) from an iSCSI client without deleting the data.",
          "usage" : [ "Invoke when revoking a client's access to a specific disk before remapping it elsewhere.", "Use during maintenance to unmap volumes ahead of storage reconfiguration." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body.pool",
            "in" : "body",
            "description" : "RBD pool that hosts the disk to unmap.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.name",
            "in" : "body",
            "description" : "RBD image name to remove from the client mapping.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN whose mapping should be removed.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "404 if the LUN is not mapped to the client", "500 if the gateway connection fails or rejects the update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId}/clients/{name}/disks to confirm active mappings before retrying."
          }, {
            "code" : "500",
            "action" : "Check gateway logs/connectivity, then rerun once the management plane is responsive."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI LUN detach"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "postprocessing_hint" : "After success, refresh the client's disk list to verify the mapping is gone.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add new disk(s) to an iSCSI client",
        "operationId" : "IscsiServiceResource_addLunToIscsiClient",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD image will be created if it doesn't exist yet",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map existing or newly created RBD images to an iSCSI client.",
          "usage" : [ "Provision LUNs for a host by creating and exporting images in one call.", "Re-attach disks to a client after recreating credentials." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].pool",
            "in" : "body",
            "description" : "RBD pool for the disk.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "[].name",
            "in" : "body",
            "description" : "RBD image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "[].size",
            "in" : "body",
            "description" : "Size in MB for new images (null to use existing).",
            "required" : false,
            "example" : "102400"
          }, {
            "name" : "[].backstore",
            "in" : "body",
            "description" : "Backstore type (USER/USERBLOCK/...) when supported.",
            "required" : false,
            "example" : "USER"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "name",
            "in" : "path",
            "description" : "Client name/IQN receiving the disks.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:client01"
          } ],
          "failure_modes" : [ "400 if backstore changes are attempted on unsupported servers or the LUN already exists", "404 if the service or client is unknown", "500 if Ceph or the gateway fails during mapping" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure backstore options match server OS and avoid duplicate mappings."
          }, {
            "code" : "404",
            "action" : "Confirm the service/client exists via GET /services/iscsi/{serviceId}."
          }, {
            "code" : "500",
            "action" : "Check gateway logs; remove partially created disks before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk mapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/clients/{name}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/disks" : {
      "get" : {
        "summary" : "List iSCSI RBD exports for a gateway.",
        "operationId" : "IscsiServiceResource_getImages",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Include image details",
          "name" : "details",
          "in" : "query",
          "schema" : {
            "type" : "boolean"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/IscsiImagesResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images exported by the iSCSI gateway, optionally with metadata.",
          "usage" : [ "Populate the disks tab for an iSCSI gateway detail view.", "Refresh after adding, deleting or resizing LUNs." ],
          "response_shape" : "IscsiImagesResponse",
          "request_parameters" : [ {
            "name" : "details",
            "in" : "query",
            "description" : "true to include per-disk metadata (pool, WWN, controls).",
            "required" : false,
            "default" : "false",
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "200 with disks=[] when no exports exist", "404 if the gateway has no active servers to answer API requests", "500 if the ceph-iscsi API call fails or gateway.conf cannot be read" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Render an empty state and prompt creation of new exports."
          }, {
            "code" : "404",
            "action" : "Refresh the gateway list and ensure at least one server is assigned and online."
          }, {
            "code" : "500",
            "action" : "Inspect ceph-iscsi logs and verify API credentials before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "iSCSI disk inventory polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/iscsi/{serviceId}/disks/{wwn}" : {
      "patch" : {
        "summary" : "Update parameters for an exported RBD image.",
        "operationId" : "IscsiServiceResource_updateDisk",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "Image change configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/IscsiImageChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Resize an exported iSCSI disk without removing it from clients.",
          "usage" : [ "Grow a LUN after expanding underlying storage.", "Adjust disk size during maintenance while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "size",
            "in" : "body",
            "description" : "New disk size in MB.",
            "required" : true,
            "example" : "102400"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID owning the disk.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "Disk WWN identifier as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "404 if the disk cannot be found by WWN", "500 if Ceph rejects the resize or the gateway API fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the disk list and retry with the current WWN."
          }, {
            "code" : "500",
            "action" : "Inspect gateway/Ceph logs; ensure the new size is valid before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI disk resize"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/disks/{wwn}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an iSCSI-managed disk",
        "operationId" : "IscsiServiceResource_deleteIscsiImage",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "wwn",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an exported iSCSI disk and optionally remove the backing RBD image.",
          "usage" : [ "Call when retiring a LUN after data migration.", "Use to free capacity once a client no longer needs the associated disk." ],
          "response_shape" : "ManagedTask?",
          "request_parameters" : [ {
            "name" : "body.deleteData",
            "in" : "body",
            "description" : "Set true to delete the RBD data, false to only remove the export.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "body.pool",
            "in" : "body",
            "description" : "Pool that stores the image; must match gateway metadata.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.image",
            "in" : "body",
            "description" : "RBD image name to confirm for deletion.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Owning iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "wwn",
            "in" : "path",
            "description" : "World Wide Name of the disk as reported by the gateway.",
            "required" : true,
            "example" : "naa.6001405fb0d035ba"
          } ],
          "failure_modes" : [ "404 if the WWN is unknown to the gateway", "500 if the pool/image confirmation does not match gateway metadata or Ceph rejects disk deletion" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the iSCSI disk list to obtain the current WWN before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect gateway and Ceph logs; correct mismatched parameters or retry once the storage backend is healthy."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI disk deletion"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "If deleteData=true, wait for the ManagedTask to finish before reusing the pool/image name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}" : {
      "delete" : {
        "summary" : "Delete a host group.",
        "operationId" : "IscsiServiceResource_deleteHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an iSCSI host group after unmapping its members.",
          "usage" : [ "Call once all hosts and disks have been reassigned and the group is no longer needed.", "Use prior to recreating the group with a different membership or policy." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name as displayed by the gateway.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the group does not exist", "500 if the gateway refuses to remove the group while hosts or disks remain mapped" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} to confirm current groups before retrying."
          }, {
            "code" : "500",
            "action" : "Remove remaining host/disk mappings, acknowledge the warning, then delete again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group updates"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "postprocessing_hint" : "Warn operators that mapped images stay attached until explicitly unmapped.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Create a new host group.",
        "operationId" : "IscsiServiceResource_createHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an iSCSI host group to manage access for multiple clients.",
          "usage" : [ "Organize initiators before mapping disks in bulk.", "Prepare a group for automated provisioning workflows." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Name of the host group to create.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the service ID is invalid", "500 if the gateway refuses to create the host group" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi and retry with a valid service ID."
          }, {
            "code" : "500",
            "action" : "Inspect gateway logs; ensure the group name is unique before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group creation"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/disks" : {
      "delete" : {
        "summary" : "Remove a disk from a host group.",
        "operationId" : "IscsiServiceResource_deleteDiskFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach RBD disks from an iSCSI host group without deleting the images.",
          "usage" : [ "Trim group access before assigning disks to a different client or group.", "Use as part of group decommissioning to clear remaining disk mappings." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body.pool",
            "in" : "body",
            "description" : "Pool containing the disk to remove from the group.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "body.name",
            "in" : "body",
            "description" : "RBD image name to unmap from the group.",
            "required" : true,
            "example" : "vm-001"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the disk mapping is unknown to the group", "500 if the gateway API fails while updating masks" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh group disk listings and retry with a current pool/image pair."
          }, {
            "code" : "500",
            "action" : "Check ceph-iscsi logs; retry once connectivity is restored."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI disk unmapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "postprocessing_hint" : "Verify the host groups access list in GET /services/iscsi/{serviceId} to confirm removal.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add disks to a host group.",
        "operationId" : "IscsiServiceResource_addDiskToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of disks to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/IscsiAddDiskToClientRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Map one or more RBD images to every client in a host group.",
          "usage" : [ "Grant a fleet of initiators access to new storage in a single call.", "Pre-provision LUNs before adding hosts to the group." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].pool",
            "in" : "body",
            "description" : "RBD pool for each disk.",
            "required" : true,
            "example" : "iscsi-images"
          }, {
            "name" : "[].name",
            "in" : "body",
            "description" : "RBD image name.",
            "required" : true,
            "example" : "vm-001"
          }, {
            "name" : "[].size",
            "in" : "body",
            "description" : "Optional size in MB for images that should be created if missing.",
            "required" : false,
            "example" : "102400"
          }, {
            "name" : "[].backstore",
            "in" : "body",
            "description" : "Backstore type (defaults to USER).",
            "required" : false,
            "example" : "USER"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Target host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "400 if changing backstore is unsupported or images already exist in the group", "404 if the service or group is unknown", "500 if gateway operations fail while adding mappings" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm backstore compatibility and avoid duplicate mappings."
          }, {
            "code" : "404",
            "action" : "List host groups to verify the name before retrying."
          }, {
            "code" : "500",
            "action" : "Check iscsi-gateway logs; remove partially added disks before rerunning."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host-group disk mapping"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/disks", "/services/iscsi/{serviceId}/clients/{name}/disks" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts" : {
      "delete" : {
        "summary" : "Remove hosts from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostsFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove multiple hosts from an iSCSI host group in a single call.",
          "usage" : [ "Call when bulk decommissioning initiators or moving them to another group.", "Use before deleting the host group to ensure no members remain." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body[]",
            "in" : "body",
            "description" : "Array of host identifiers (IQNs) to remove.",
            "required" : true,
            "example" : "[\"iqn.1993-08.org.debian:01:node01\", \"iqn.1993-08.org.debian:01:node02\"]"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if any supplied host is not associated with the group", "500 if the gateway API fails mid-update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Re-read group membership and retry with only existing hosts."
          }, {
            "code" : "500",
            "action" : "Check ceph-iscsi logs and retry once the control plane is responsive."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk iSCSI host unassign"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "postprocessing_hint" : "Confirm that remaining hosts are correct before assigning new disks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add hosts to a host group.",
        "operationId" : "IscsiServiceResource_addHostsToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "List of hosts to add to host group",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Bulk add multiple initiator IQNs to an iSCSI host group.",
          "usage" : [ "Onboard a batch of servers that should share the same LUN set.", "Restore group membership after recreating host entries." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body[]",
            "in" : "body",
            "description" : "Array of host IQNs to add to the group.",
            "required" : true,
            "example" : "[\"iqn.1993-08.org.debian:01:node01\",\"iqn.1993-08.org.debian:01:node02\"]"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          } ],
          "failure_modes" : [ "404 if the service or group does not exist", "500 if any host fails to join" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the group exists via GET /services/iscsi/{serviceId} before retrying."
          }, {
            "code" : "500",
            "action" : "Review gateway logs and retry with hosts that succeeded removed from the list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Bulk host enrollment"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" : {
      "delete" : {
        "summary" : "Remove a host from a host group.",
        "operationId" : "IscsiServiceResource_deleteHostFromHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single host from an iSCSI host group while leaving its disk mappings intact.",
          "usage" : [ "Call when revoking a specific initiators access to the group.", "Use ahead of moving the host into a different group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to remove.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:node01"
          } ],
          "failure_modes" : [ "404 if the host is not currently part of the group", "500 if the gateway rejects the membership update" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List group hosts and retry with a valid identifier."
          }, {
            "code" : "500",
            "action" : "Inspect ceph-iscsi logs, resolve connectivity issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host unassign"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "put" : {
        "summary" : "Add a host to a host group.",
        "operationId" : "IscsiServiceResource_addHostToHostGroup",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "group",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "host",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add a single initiator IQN to an existing iSCSI host group.",
          "usage" : [ "Grant an additional server access to the group's mapped LUNs.", "Re-enroll a host that was previously removed from the group." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "group",
            "in" : "path",
            "description" : "Host group name.",
            "required" : true,
            "example" : "prod-nodes"
          }, {
            "name" : "host",
            "in" : "path",
            "description" : "Host IQN or identifier to add.",
            "required" : true,
            "example" : "iqn.1993-08.org.debian:01:newnode"
          } ],
          "failure_modes" : [ "404 if the service or group does not exist", "500 if the gateway fails to add the host" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List host groups to verify the group name and ensure the service ID is valid."
          }, {
            "code" : "500",
            "action" : "Inspect gateway logs; confirm the host IQN is formatted correctly before retrying."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "iSCSI host enrollment"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}/groups/{group}/hosts", "/services/iscsi/{serviceId}/groups/{group}/hosts/{host}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/servers/{hostname}" : {
      "delete" : {
        "summary" : "Remove a server from an existing iSCSI gateway service.",
        "operationId" : "IscsiServiceResource_removeServerFromIscsiGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "hostname",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Detach one gateway server from the iSCSI cluster, stopping its service and cleaning ceph-iscsi config entries.",
          "usage" : [ "Call during node maintenance or decommission to drain a specific server from the gateway.", "Use before deleting the entire gateway to remove surplus servers cleanly." ],
          "response_shape" : "ManagedTask",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Gateway service identifier (see GET /services/iscsi).",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "hostname",
            "in" : "path",
            "description" : "Server hostname/FQDN exactly as registered with the gateway.",
            "required" : true,
            "example" : "gw1.example.com"
          } ],
          "failure_modes" : [ "400 if attempting to remove the final server from the gateway", "404 if the service or hostname cannot be mapped to the gateway", "500 if another management action currently locks the service" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use DELETE /services/iscsi/{serviceId} to remove the last server instead."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi/{serviceId} and retry with a current hostname."
          }, {
            "code" : "500",
            "action" : "Wait for concurrent tasks to finish, then rerun the removal."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "iSCSI gateway node removal"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers" ],
          "postprocessing_hint" : "Monitor the ManagedTask until completion before reusing the server for other roles.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/target" : {
      "put" : {
        "summary" : "Set iSCSI target to be used in other endpoints",
        "operationId" : "IscsiServiceResource_setIscsiTarget",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Target IQN string",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "string"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Set or override the global target IQN used for a specific iSCSI service.",
          "usage" : [ "Adjust target IQN after importing an existing configuration.", "Correct the target identifier when recovering from configuration drift." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "body",
            "in" : "body",
            "description" : "Target IQN string.",
            "required" : true,
            "example" : "iqn.2003-01.com.example:iscsi-gw"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "400 if the provided IQN is not present in the ceph-iscsi configuration", "404 if the service ID cannot be found" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review the warning emitted by ignorableWarnings and confirm if overriding is intended."
          }, {
            "code" : "404",
            "action" : "Refresh GET /services/iscsi and retry with a valid service ID."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "iSCSI target IQN update"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/clients/{name}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/iscsi/{serviceId}/terminal/connect" : {
      "post" : {
        "summary" : "Connect to the ceph-iscsi config shell",
        "operationId" : "IscsiServiceResource_connectToIscsiTerminal",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TerminalConnection"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Open an authenticated shell session on the active iSCSI gateway server for manual iscsi-config commands.",
          "usage" : [ "Use for troubleshooting ceph-iscsi configuration without SSHing manually.", "Call to automate scripted adjustments via the exposed terminal stream." ],
          "response_shape" : "TerminalConnection",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "iSCSI service ID whose active node should be targeted.",
            "required" : true,
            "example" : "1"
          } ],
          "failure_modes" : [ "404 if the service or active server cannot be determined", "500 if the shell session fails to initialize" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Ensure the gateway is running and retry once an active server is available."
          }, {
            "code" : "500",
            "action" : "Check terminal service logs; attempt a new connection after resolving host issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "iSCSI management shell"
          },
          "related_endpoints" : [ "/services/iscsi/{serviceId}", "/services/iscsi/{serviceId}/servers/{hostname}" ],
          "postprocessing_hint" : "Close the terminal when finished; state changes may require subsequent API calls to refresh cached data.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways" : {
      "post" : {
        "summary" : "Create a new NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "NFS gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayService"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provision an NFS cluster backed by CephFS across the selected servers.",
          "usage" : [ "Run during initial setup to expose CephFS over NFS.", "Recreate the cluster after a teardown to restore service." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "List of server IDs that will host the ganesha daemons.",
            "required" : true,
            "example" : "[12,13,14]"
          }, {
            "name" : "exports[]",
            "in" : "body",
            "description" : "Optional exports to seed during creation.",
            "required" : false,
            "example" : "[{\"nfsPath\":\"/exports/data\",\"backendPath\":\"/cephfs/data\"}]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional human-readable description shown in the UI.",
            "required" : false,
            "example" : "Production NFS"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured or a server already participates in another NFS cluster", "404 if any referenced server ID does not exist", "500 if ganesha provisioning fails on a target host" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Configure CephFS and ensure each server belongs to at most one NFS cluster."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and resubmit valid IDs."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log; resolve host issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "NFS cluster provisioning"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "postprocessing_hint" : "Monitor the task until completion and confirm cluster health via GET /services/nfs-gateways/{serviceId}.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}" : {
      "patch" : {
        "summary" : "Update an NFS cluster.",
        "operationId" : "NfsServiceResource_patchNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NfsGatewayServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update NFS cluster metadata and server membership.",
          "usage" : [ "Adjust the cluster description or server list after hardware changes.", "Swap out nodes while keeping exports intact." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Optional new server list replacing the existing membership.",
            "required" : false,
            "example" : "[12,15,16]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional updated description shown in the UI.",
            "required" : false,
            "example" : "NFS cluster for analytics"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if a server is already part of another NFS cluster", "404 if the service ID or referenced servers are unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure servers belong to only one NFS cluster before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh service/server inventories and resubmit with valid IDs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS cluster updates"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Retrieve the NFS cluster configuration snapshot.",
        "operationId" : "NfsServiceResource_getNfsGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayService"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve servers and exports configured for the NFS gateway cluster.",
          "usage" : [ "Load the NFS cluster detail view for administrators.", "Refresh after modifying servers or exports to confirm the applied state." ],
          "response_shape" : "NfsGatewayService",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 with exports=[] and servers=[] when no configuration exists yet" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service inventory and retry with an existing cluster ID."
          }, {
            "code" : "400",
            "action" : "Ensure the selected service is of type nfs_gateway before proceeding."
          }, {
            "code" : "200",
            "action" : "Display an empty state explaining that no servers or exports are assigned yet."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "NFS cluster detail refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports" : {
      "get" : {
        "summary" : "List exports belonging to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayExports",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/NfsGatewayExport"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List exports defined for the NFS gateway cluster.",
          "usage" : [ "Populate the exports tab in the NFS cluster view.", "Refresh after creating, updating or deleting an export." ],
          "response_shape" : "array<NfsGatewayExport>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 [] when the cluster currently has no exports" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify the cluster still exists and retry."
          }, {
            "code" : "400",
            "action" : "Ensure only NFS gateway IDs are used for this call."
          }, {
            "code" : "200",
            "action" : "Show an empty state inviting the user to create exports."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS export list polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Add an export to the NFS cluster.",
        "operationId" : "NfsServiceResource_addNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/NfsGatewayExport"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create an NFS export and trigger the ganesha daemons to apply it.",
          "usage" : [ "Expose new CephFS directories over NFS.", "Call after preparing data that should be served to clients." ],
          "response_shape" : "NfsGatewayExport",
          "request_parameters" : [ {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "Export path visible to clients.",
            "required" : true,
            "example" : "/exports/data"
          }, {
            "name" : "backendPath",
            "in" : "body",
            "description" : "CephFS path backing the export.",
            "required" : true,
            "example" : "/cephfs/data"
          }, {
            "name" : "squash",
            "in" : "body",
            "description" : "Optional squash policy (e.g. root_squash).",
            "required" : false,
            "example" : "root_squash"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "400 if an export with the same nfsPath already exists", "404 if the service ID is invalid", "500 if ganesha fails to reload the configuration" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "List existing exports and choose a unique nfsPath."
          }, {
            "code" : "404",
            "action" : "Ensure the cluster still exists before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ganesha logs on member servers; resolve issues then resubmit."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export creation"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports/{exportId}", "/services/nfs-gateways/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/exports/{exportId}" : {
      "put" : {
        "summary" : "Replace an export entry on the NFS cluster.",
        "operationId" : "NfsServiceResource_replaceNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "NFS export replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewNfsGatewayExport"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing NFS export definition with new parameters.",
          "usage" : [ "Adjust export paths or permissions after reorganizing data.", "Update squash or client access settings without recreating the export." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "nfsPath",
            "in" : "body",
            "description" : "New export path presented to clients.",
            "required" : true,
            "example" : "/exports/data"
          }, {
            "name" : "backendPath",
            "in" : "body",
            "description" : "CephFS path backing the export.",
            "required" : true,
            "example" : "/cephfs/data"
          }, {
            "name" : "squash",
            "in" : "body",
            "description" : "Squash mode (e.g. root_squash).",
            "required" : false,
            "example" : "root_squash"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Existing export identifier.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the export ID or service ID is unknown", "500 if ganesha reload fails or servers reject the new configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the export list before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect ganesha logs; correct configuration issues then resubmit."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "NFS export updates"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an export entry from the NFS cluster.",
        "operationId" : "NfsServiceResource_deleteNfsGatewayExport",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "exportId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an NFS export from the gateway and propagate the deletion to all servers.",
          "usage" : [ "Invoke after decommissioning a dataset so clients lose access.", "Use prior to redefining the export with new parameters to avoid duplicate entries." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS gateway service ID.",
            "required" : true,
            "example" : "12"
          }, {
            "name" : "exportId",
            "in" : "path",
            "description" : "Numeric export identifier from GET /services/nfs-gateways/{serviceId}/exports.",
            "required" : true,
            "example" : "3"
          } ],
          "failure_modes" : [ "404 if the service or export ID is unknown", "500 if server-side export deletion fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the export list; retry with a current ID."
          }, {
            "code" : "500",
            "action" : "Inspect Ganesha logs and rerun once the management task succeeds."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "NFS export removal"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}/exports", "/services/nfs-gateways/{serviceId}/exports/{exportId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/nfs-gateways/{serviceId}/servers" : {
      "get" : {
        "summary" : "List server IDs assigned to the NFS cluster.",
        "operationId" : "NfsServiceResource_getNfsGatewayServers",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "type" : "integer",
                    "format" : "int32"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server IDs participating in the NFS gateway cluster.",
          "usage" : [ "Populate the servers tab in the NFS cluster detail view.", "Refresh after adding or removing nodes from the cluster." ],
          "response_shape" : "array<int>",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "NFS cluster ID.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "400 if the referenced service is not an NFS cluster", "200 [] when the cluster has no active servers" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the cluster list and retry with a current ID."
          }, {
            "code" : "400",
            "action" : "Select a service of type nfs_gateway before calling this endpoint."
          }, {
            "code" : "200",
            "action" : "Show an empty state indicating that no servers are assigned yet."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "NFS server membership polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services/nfs-gateways/{serviceId}", "/services/nfs-gateways/{serviceId}/exports" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/services/restart" : {
      "post" : {
        "summary" : "Restart services or OSDs.",
        "operationId" : "ServiceResource_restartMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart multiple services or OSDs immediately without waiting for long-running tasks.",
          "usage" : [ "Batch restart selected daemons after applying configuration changes.", "Prefer POST /services/rolling-restart for critical services that require sequential safety." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "true if the entry refers to an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "404 if any referenced service or server is unknown", "409 if the service manager rejects concurrent restarts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Fetch current assignments via GET /services before resubmitting."
          }, {
            "code" : "409",
            "action" : "Defer the restart or switch to /services/rolling-restart to queue safely."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered restarts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/rolling-restart", "/tasks" ],
          "postprocessing_hint" : "Refresh GET /services to confirm the new state; consider monitoring /tasks if follow-up jobs were triggered.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/rolling-restart" : {
      "post" : {
        "summary" : "Performs a rolling restart on the provided services or OSDs.",
        "description" : "Each service is restarted one after another. Should one of the services fail to restart, the rolling restart will be stopped.\nOnly one rolling restart will run at a time, i.e.multiple calls to this endpoint won't run in parallel.",
        "operationId" : "ServiceResource_restartMultipleServicesRolling",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Queue a sequential restart of multiple services/OSDs, enforcing cluster health checks between steps.",
          "usage" : [ "Use for critical daemons where concurrency would cause downtime (monitors, managers, SMB servers, etc.).", "Trigger after rolling out configuration or package updates when a safe restart cadence is required." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "Set true when the entry refers to an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if any referenced service/OSD is unknown", "409 if another rolling restart is already in progress", "500 if a step fails to restart within safety thresholds" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Refresh GET /services to fetch current IDs before resubmitting."
          }, {
            "code" : "409",
            "action" : "Wait for the currently running rolling restart task to finish before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to identify the failing service, resolve its issue, then rerun with the remaining entries."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "Rolling restart orchestration"
          },
          "related_endpoints" : [ "/services/restart", "/tasks" ],
          "postprocessing_hint" : "Monitor the returned ManagedTask; if it stops on a failure, address the reported service before retrying.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb" : {
      "post" : {
        "summary" : "Create a new simple SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy a simple SMB cluster backed by CephFS across the specified servers.",
          "usage" : [ "Call during initial SMB setup once CephFS and required networks are configured.", "Recreate the cluster after teardown when migrating to new hardware." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Array of server/NIC/VLAN tuples that will host CTDB nodes.",
            "required" : true,
            "example" : "[{\"server\":21,\"nic\":7,\"vlan\":null}]"
          }, {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Floating IPs that will be distributed across nodes.",
            "required" : true,
            "example" : "[\"192.168.20.100\",\"192.168.20.101\"]"
          }, {
            "name" : "shares[]",
            "in" : "body",
            "description" : "Optional share definitions to seed during creation.",
            "required" : false,
            "example" : "[{\"name\":\"data\",\"path\":\"/cephfs/data\"}]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional display name for the SMB cluster.",
            "required" : false,
            "example" : "Production SMB"
          } ],
          "failure_modes" : [ "400 if CephFS is not configured, no servers are provided, or virtual IP validation fails", "404 if any referenced server ID does not exist", "409 if network/IP conflicts require operator acknowledgement", "500 if CTDB or samba provisioning fails on a host" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure at least one server is specified and CephFS is configured before retrying."
          }, {
            "code" : "404",
            "action" : "Refresh the server list and resubmit valid IDs."
          }, {
            "code" : "409",
            "action" : "Review the warning presented via ignorableWarnings and confirm the IP layout before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log for the failing node; fix the issue then re-run the creation."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB cluster provisioning"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Wait for the ManagedTask to finish, then verify CTDB health and share accessibility.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/active-directory-authentication" : {
      "post" : {
        "summary" : "Create a new SMB cluster using Active Directory for authentication.",
        "operationId" : "SmbServiceResource_addActiveDirectorySmbGateway",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Active Directory SMB gateway configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ActiveDirectorySmbGatewayServiceRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Deploy an Active Directory-integrated SMB cluster with CTDB high availability.",
          "usage" : [ "Use when administrators need domain-joined SMB access to CephFS shares.", "Recreate the cluster on new hardware while keeping AD as the identity provider." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "servers[]",
            "in" : "body",
            "description" : "Server/NIC/VLAN tuples including AD credentials for each node.",
            "required" : true,
            "example" : "[{\"server\":21,\"nic\":7,\"vlan\":null,\"domainAdminUser\":\"Administrator\"}]"
          }, {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Shared DNS name for the cluster; may be blank for per-host joins.",
            "required" : true,
            "example" : "smb.prod.example.com"
          }, {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Floating IPs managed by CTDB.",
            "required" : true,
            "example" : "[\"192.168.30.50\",\"192.168.30.51\"]"
          }, {
            "name" : "joinWithSssd",
            "in" : "body",
            "description" : "Join the domain via sssd (alternative to adcli).",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "shares[]",
            "in" : "body",
            "description" : "Optional shares to create immediately.",
            "required" : false,
            "example" : "[{\"name\":\"home\",\"path\":\"/cephfs/home\"}]"
          } ],
          "failure_modes" : [ "400 if CephFS is missing, servers are omitted, or AD credentials are incomplete", "404 if any server ID is invalid", "409 if network/DNS validation raises ignorable warnings", "500 if AD join or CTDB provisioning fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure CephFS is configured and supply credentials for every server."
          }, {
            "code" : "404",
            "action" : "Refresh the server inventory and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Review the warning surfaced via ignorableWarnings and acknowledge before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log to address AD or CTDB failures prior to re-running."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 86400,
            "note" : "SMB+AD cluster provisioning"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name", "/services/smb/{serviceId}/servers" ],
          "postprocessing_hint" : "Once the task completes, verify CTDB health and domain membership before exposing shares.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}" : {
      "patch" : {
        "summary" : "Update an SMB cluster.",
        "operationId" : "SmbServiceResource_updateSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update SMB cluster metadata, virtual IPs, or credentials.",
          "usage" : [ "Adjust virtual IP assignments after changing network topology.", "Rotate admin/readonly passwords following security policies." ],
          "response_shape" : "ManagedThreadTask",
          "request_parameters" : [ {
            "name" : "virtualIps[]",
            "in" : "body",
            "description" : "Optional new set of CTDB floating IPs.",
            "required" : false,
            "example" : "[\"192.168.20.100\",\"192.168.20.101\"]"
          }, {
            "name" : "adminPassword",
            "in" : "body",
            "description" : "Optional new croit admin password for SMB shares.",
            "required" : false,
            "example" : ""
          }, {
            "name" : "readonlyPassword",
            "in" : "body",
            "description" : "Optional new readonly password.",
            "required" : false,
            "example" : ""
          }, {
            "name" : "domainController",
            "in" : "body",
            "description" : "Optional AD domain controller hostname.",
            "required" : false,
            "example" : "dc01"
          }, {
            "name" : "dnsServers[]",
            "in" : "body",
            "description" : "Optional DNS servers for SMB nodes.",
            "required" : false,
            "example" : "[\"192.168.20.10\",\"192.168.20.11\"]"
          }, {
            "name" : "description",
            "in" : "body",
            "description" : "Optional UI description for the cluster.",
            "required" : false,
            "example" : "Production SMB cluster"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if virtual IP validation fails or required passwords are missing for updates", "404 if the cluster ID cannot be found", "500 if Samba/CTDB reconfiguration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Review ignorableWarnings for IP conflicts and provide all required credentials."
          }, {
            "code" : "404",
            "action" : "Refresh the SMB service list before retrying."
          }, {
            "code" : "500",
            "action" : "Check task logs and underlying nodes; rerun after issues are resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "SMB cluster updates"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/service-dns-name" ],
          "postprocessing_hint" : "Monitor the ManagedThreadTask until completion and verify CTDB status afterward.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get SMB cluster config and state.",
        "operationId" : "SmbServiceResource_getSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SmbGatewayServiceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve full configuration and runtime state for a specific SMB gateway cluster.",
          "usage" : [ "Call when opening the SMB cluster detail view to display servers, shares, and AD metadata.", "Re-query after updating share configuration or joining/leaving AD to verify the applied settings." ],
          "response_shape" : "SmbGatewayServiceResponse",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Identifier of the SMB service returned by GET /services.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the SMB cluster does not exist", "503 if CTDB health data is currently unavailable" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm the serviceId before retrying."
          }, {
            "code" : "503",
            "action" : "Retry after CTDB stabilises; consider checking server_state cache for broader issues."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "SMB cluster detail"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/services", "/gateways/smb/servers", "/gateways/smb/shares" ],
          "postprocessing_hint" : "Surface healthy=false servers and missing virtual IPs prominently to prompt operator remediation.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Delete an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGateway",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Tear down an SMB cluster, removing all servers and shares managed by croit.",
          "usage" : [ "Call when decommissioning the SMB service or migrating to a fresh deployment.", "Use after draining shares and clients to ensure the cluster is fully removed." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the SMB cluster no longer exists", "500 if another management action currently locks the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the SMB service inventory; only retry when the cluster is still listed."
          }, {
            "code" : "500",
            "action" : "Wait for outstanding tasks to finish, then delete again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "SMB cluster removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers" : {
      "post" : {
        "summary" : "Add a server to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB gateway server configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SmbGatewayServerRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Scale an SMB cluster by onboarding a new node with Samba and CTDB services.",
          "usage" : [ "Add capacity after provisioning additional servers.", "Re-add a node following maintenance once it is ready to rejoin the cluster." ],
          "response_shape" : "ManagedTask",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "body",
            "description" : "Server ID to add.",
            "required" : true,
            "example" : "24"
          }, {
            "name" : "nic",
            "in" : "body",
            "description" : "NIC ID for CTDB/public traffic.",
            "required" : true,
            "example" : "9"
          }, {
            "name" : "vlan",
            "in" : "body",
            "description" : "Optional VLAN ID for the CTDB interface.",
            "required" : false,
            "example" : "30"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "Domain admin account (required for AD clusters).",
            "required" : false,
            "example" : "Administrator"
          }, {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "Password for the domain admin account.",
            "required" : false,
            "example" : ""
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if validation fails (missing credentials, unhealthy cluster state)", "404 if the server or cluster ID is invalid", "409 if IP validation surfaces conflicts", "500 if CTDB or AD join fails on the new server" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure all existing nodes are healthy and provide required credentials."
          }, {
            "code" : "404",
            "action" : "Refresh the cluster/server lists and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Review ignorableWarnings and acknowledge conflicts before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect the ManagedTask log, resolve host issues, then rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node onboarding"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/servers/{serverId}", "/services/smb/{serviceId}/service-dns-name" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/servers/{serverId}" : {
      "delete" : {
        "summary" : "Remove a server from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayServer",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serverId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a single server from the SMB cluster while keeping the cluster online.",
          "usage" : [ "Call before draining a node for maintenance or replacement.", "Use to rebalance the cluster after reducing capacity requirements." ],
          "response_shape" : "ManagedThreadTask?",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "serverId",
            "in" : "path",
            "description" : "Server ID as returned by GET /services/smb/{serviceId}.",
            "required" : true,
            "example" : "23"
          } ],
          "failure_modes" : [ "400 if attempting to remove the final server (operation disallowed)", "404 if the server is not associated with the cluster", "500 if another cluster task is running" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Use DELETE /services/smb/{serviceId} to dismantle the remaining cluster."
          }, {
            "code" : "404",
            "action" : "Refresh the server list to locate a valid ID before retrying."
          }, {
            "code" : "500",
            "action" : "Allow in-flight tasks to complete and run the removal again."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB node removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/{serviceId}/servers" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/service-dns-name" : {
      "post" : {
        "summary" : "Change the service DNS name of an SMB cluster.",
        "operationId" : "SmbServiceResource_changeServiceDnsName",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "DNS name update configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SambaServiceDNSNameUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update the shared DNS name under which an AD-integrated SMB cluster registers.",
          "usage" : [ "Call after receiving a new service DNS entry or correcting a previous configuration.", "Rejoin the cluster to AD with a fresh name following recovery exercises." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "serviceDnsName",
            "in" : "body",
            "description" : "Target DNS name for the cluster (non-empty unless sssd mode allows otherwise).",
            "required" : true,
            "example" : "smb.prod.example.com"
          }, {
            "name" : "domainAdminUser",
            "in" : "body",
            "description" : "Domain admin account used to perform the join.",
            "required" : true,
            "example" : "Administrator"
          }, {
            "name" : "domainAdminPassword",
            "in" : "body",
            "description" : "Password for the domain admin account.",
            "required" : true,
            "example" : ""
          }, {
            "name" : "joinServer",
            "in" : "body",
            "description" : "Optional server ID to execute the AD join from.",
            "required" : false,
            "example" : "21"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "400 if the cluster is not AD-enabled, credentials are missing, or removing the DNS name is unsupported", "404 if joinServer is provided but not part of the cluster", "500 if Active Directory join operations fail" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Confirm the cluster uses AD and provide the required domain credentials."
          }, {
            "code" : "404",
            "action" : "List cluster servers and retry with a valid joinServer."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log for AD errors; fix and rerun."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 3600,
            "note" : "SMB DNS updates"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}", "/services/smb/active-directory-authentication" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares" : {
      "post" : {
        "summary" : "Add a share to an SMB cluster.",
        "operationId" : "SmbServiceResource_addSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new Samba share backed by CephFS within the cluster.",
          "usage" : [ "Expose additional datasets to SMB clients without restarting services.", "Provision temporary maintenance shares for support operations." ],
          "response_shape" : "GeneratedId",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "Share name presented to clients.",
            "required" : true,
            "example" : "projects"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "CephFS path exported by the share.",
            "required" : true,
            "example" : "/cephfs/projects"
          }, {
            "name" : "readOnly",
            "in" : "body",
            "description" : "Optional read-only setting.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          } ],
          "failure_modes" : [ "404 if the cluster ID does not exist", "409 if a share with the same name already exists", "500 if Samba fails to reload the configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the cluster list and retry with a valid ID."
          }, {
            "code" : "409",
            "action" : "Rename or remove the conflicting share before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Samba/CTDB logs and re-run after resolving errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "SMB share creation"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares/{shareId}", "/services/smb/{serviceId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/smb/{serviceId}/shares/{shareId}" : {
      "put" : {
        "summary" : "Replace a share on an SMB cluster.",
        "operationId" : "SmbServiceResource_replaceSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "SMB share replacement configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/NewSmbGatewayShare"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace an existing SMB share definition with new parameters.",
          "usage" : [ "Update share paths or permissions without deleting and recreating the share.", "Align share configuration with policy changes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "name",
            "in" : "body",
            "description" : "New share name (overwrites existing).",
            "required" : true,
            "example" : "projects"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "CephFS path exported by the share.",
            "required" : true,
            "example" : "/cephfs/projects"
          }, {
            "name" : "readOnly",
            "in" : "body",
            "description" : "Optional read-only flag.",
            "required" : false,
            "example" : "false"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster ID.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share identifier to replace.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the share ID does not exist", "500 if Samba fails to apply the new configuration" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List shares to confirm the ID before retrying."
          }, {
            "code" : "500",
            "action" : "Inspect Samba logs and re-run after correcting configuration errors."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share update"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a share from an SMB cluster.",
        "operationId" : "SmbServiceResource_deleteSmbGatewayShare",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "shareId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an SMB share definition from the cluster configuration.",
          "usage" : [ "Call when retiring a dataset or before recreating the share with new settings.", "Use to revoke access quickly while leaving the cluster online." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "SMB cluster identifier.",
            "required" : true,
            "example" : "5"
          }, {
            "name" : "shareId",
            "in" : "path",
            "description" : "Share ID from GET /services/smb/{serviceId}/shares.",
            "required" : true,
            "example" : "12"
          } ],
          "failure_modes" : [ "404 if the share ID does not exist on the cluster" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the share list and retry with a current identifier."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 18,
            "window_seconds" : 3600,
            "note" : "SMB share removal"
          },
          "related_endpoints" : [ "/services/smb/{serviceId}/shares", "/services/smb/{serviceId}/shares/{shareId}" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/start" : {
      "post" : {
        "summary" : "Start services or OSDs.",
        "operationId" : "ServiceResource_startMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start multiple services or OSD daemons in parallel via the service manager.",
          "usage" : [ "Bring a set of daemons online after maintenance windows.", "Automate recovery workflows that re-enable services across nodes." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to start.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services or OSD placement (nullable).",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "Set true when the entry represents an OSD daemon.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "404 if any service/server mapping is invalid", "409 if the service manager rejects concurrent starts" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service list via GET /services before resubmitting."
          }, {
            "code" : "409",
            "action" : "Wait for other control tasks to complete or split the batch."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service starts"
          },
          "related_endpoints" : [ "/services/stop", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Poll GET /services to confirm each entry reports a running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/stop" : {
      "post" : {
        "summary" : "Stop services or OSDs.",
        "operationId" : "ServiceResource_stopMultipleServices",
        "tags" : [ "services" ],
        "requestBody" : {
          "description" : "Service control requests",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "items" : {
                  "$ref" : "#/components/schemas/ServiceControlRequest"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop multiple services or OSD daemons in one request.",
          "usage" : [ "Gracefully shut down daemons prior to maintenance windows.", "Evacuate services from a node before hardware work." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "[].id",
            "in" : "body",
            "description" : "Service ID or OSD daemon ID to stop.",
            "required" : true,
            "example" : "87"
          }, {
            "name" : "[].server",
            "in" : "body",
            "description" : "Server ID for multi-server services/OSDs.",
            "required" : false,
            "example" : "12"
          }, {
            "name" : "[].isOsd",
            "in" : "body",
            "description" : "True when the entry represents an OSD daemon.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "404 if any referenced service/server combination is unknown", "409 if the service manager prevents concurrent stops" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm current IDs before retrying."
          }, {
            "code" : "409",
            "action" : "Sequence the stops or wait for other control operations to complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stops"
          },
          "related_endpoints" : [ "/services/start", "/services/restart", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services to ensure the daemons report a stopped state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service.",
        "operationId" : "ServiceResource_restartService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service instance, optionally targeting a specific server.",
          "usage" : [ "Apply configuration changes that require a daemon restart.", "Recover a misbehaving service without touching others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/server combination is unknown", "409 if another control action is already queued for the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "List current services via GET /services and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for ongoing operations to finish before rerunning the restart."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services/rolling-restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/start" : {
      "post" : {
        "summary" : "Start a service.",
        "operationId" : "ServiceResource_startService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service on its assigned server (or a specific server for multi-instance services).",
          "usage" : [ "Bring a daemon back online after targeted maintenance.", "Recover a service that was previously stopped by operators." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to start.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service or server pairing is invalid", "409 if another control task already manipulates the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Retrieve the current service inventory and retry with valid IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other service control operations to complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service start"
          },
          "related_endpoints" : [ "/services/{id}/stop", "/services/{id}/restart", "/services/start" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service.",
        "operationId" : "ServiceResource_stopService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service instance on demand.",
          "usage" : [ "Quiesce a daemon before performing host maintenance.", "Temporarily disable a service causing issues without touching others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID to stop.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/server pairing cannot be found", "409 if another control task is already acting on the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services and retry with up-to-date IDs."
          }, {
            "code" : "409",
            "action" : "Wait for other tasks to finish before issuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Operator-triggered service stop"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/restart", "/services/stop" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{serviceId}" : {
      "patch" : {
        "summary" : "Update a service.",
        "operationId" : "ServiceResource_updateService",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Service update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ServiceUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update mutable properties of a service (description, ports, DNS, etc.).",
          "usage" : [ "Adjust RGW service ports or DNS after network changes.", "Revise the display description for operators." ],
          "response_shape" : "ManagedThreadTask?",
          "request_parameters" : [ {
            "name" : "description",
            "in" : "body",
            "description" : "Optional description shown in the UI.",
            "required" : false,
            "example" : "RGW on node12"
          }, {
            "name" : "port",
            "in" : "body",
            "description" : "Optional plain HTTP port (RGW only).",
            "required" : false,
            "example" : "8080"
          }, {
            "name" : "sslPort",
            "in" : "body",
            "description" : "Optional HTTPS port (RGW only).",
            "required" : false,
            "example" : "8443"
          }, {
            "name" : "rgwDnsName",
            "in" : "body",
            "description" : "Optional DNS name for RGW services.",
            "required" : false,
            "example" : "rgw.example.com"
          }, {
            "name" : "rgwZone",
            "in" : "body",
            "description" : "Optional RGW zone to assign.",
            "required" : false,
            "example" : "us-east"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service ID to update.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service ID is unknown", "409 if concurrent operations hold the service lock", "500 if backend updates fail" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Reload the service list before retrying."
          }, {
            "code" : "409",
            "action" : "Wait for other control operations to finish before resubmitting."
          }, {
            "code" : "500",
            "action" : "Review the ManagedThreadTask log; correct configuration issues, then retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 24,
            "window_seconds" : 3600,
            "note" : "Service metadata update"
          },
          "related_endpoints" : [ "/services/{id}/start", "/services/{id}/stop", "/services" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a service.",
        "operationId" : "ServiceResource_deleteServices",
        "tags" : [ "services" ],
        "parameters" : [ {
          "name" : "serviceId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove a service (or remove a server from a multi-server service).",
          "usage" : [ "Invoke when decomissioning daemons or shrinking multi-server services.", "If the service spans multiple servers, provide the server query parameter to detach only that node." ],
          "response_shape" : "ManagedTask?",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services; omit to delete the entire service.",
            "required" : false,
            "example" : "7"
          } ],
          "path_parameters" : [ {
            "name" : "serviceId",
            "in" : "path",
            "description" : "Service identifier from GET /services.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the service does not exist", "409 if the daemon refuses to delete the service" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh GET /services to confirm the id and retry."
          }, {
            "code" : "409",
            "action" : "Inspect daemon logs; ensure the service is stopped before deletion."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Service lifecycle"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/services", "/services/{id}/stop", "/services/restart" ],
          "postprocessing_hint" : "If a ManagedTask is returned, stream /tasks/{id} until completion.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/restart" : {
      "post" : {
        "summary" : "Restart a service or OSD.",
        "operationId" : "ServiceResource_restartServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a single service or OSD daemon, optionally targeting a specific server instance.",
          "usage" : [ "Bounce an unhealthy daemon without impacting peers.", "Restart an OSD after storage maintenance." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain of the target (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID to restart.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the service/OSD (or specified server) cannot be found", "409 if another control task prevents the restart" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service inventory and retry with valid identifiers."
          }, {
            "code" : "409",
            "action" : "Wait for other operations to complete before reissuing the restart."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service restart"
          },
          "related_endpoints" : [ "/services/start", "/services/stop", "/services/rolling-restart" ],
          "postprocessing_hint" : "Check GET /services/{type}/{id} or monitor tasks to confirm the daemon returns to running state.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/start" : {
      "post" : {
        "summary" : "Start a service or OSD.",
        "operationId" : "ServiceResource_startServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a single service or OSD daemon, specifying whether the ID refers to a service or an OSD.",
          "usage" : [ "Bring an individual daemon online after maintenance.", "Start an OSD process once its device is available." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "osds"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "42"
          } ],
          "failure_modes" : [ "404 if the target ID or server reference is invalid", "409 if a conflicting control task is in progress" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify IDs via GET /services or GET /osds before retrying."
          }, {
            "code" : "409",
            "action" : "Retry once other control tasks complete."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD start"
          },
          "related_endpoints" : [ "/services/{type}/{id}/stop", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/services/{type}/{id}/stop" : {
      "post" : {
        "summary" : "Stop a service or OSD.",
        "operationId" : "ServiceResource_stopServiceOrOsd",
        "tags" : [ "services" ],
        "parameters" : [ {
          "description" : "The service ID, or in case of an OSD the daemon ID.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "type",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/ServiceTypePath"
          }
        }, {
          "description" : "Required for multi-server services",
          "name" : "server",
          "in" : "query",
          "schema" : {
            "type" : [ "integer", "null" ],
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a single service or OSD daemon designated by type and ID.",
          "usage" : [ "Suspend a daemon before performing maintenance on its host or storage.", "Temporarily disable an OSD without affecting others." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "server",
            "in" : "query",
            "description" : "Optional server ID for multi-server services (query parameter).",
            "required" : false,
            "example" : "12"
          } ],
          "path_parameters" : [ {
            "name" : "type",
            "in" : "path",
            "description" : "Domain selector (services or osds).",
            "required" : true,
            "example" : "services"
          }, {
            "name" : "id",
            "in" : "path",
            "description" : "Service ID or OSD daemon ID.",
            "required" : true,
            "example" : "87"
          } ],
          "failure_modes" : [ "404 if the identifier or server mapping does not exist", "409 if another control task is already operating on the daemon" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh the service/OSD inventory prior to retrying."
          }, {
            "code" : "409",
            "action" : "Wait for concurrent operations to finish before issuing the stop."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Individual service/OSD stop"
          },
          "related_endpoints" : [ "/services/{type}/{id}/start", "/services/{type}/{id}/restart" ],
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/available-ceph-versions" : {
      "get" : {
        "summary" : "Get a list of supported Ceph releases.",
        "operationId" : "SetupResource_getAvailableCephVersions",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephRelease"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover all Ceph release versions supported by this croit installation for version planning.",
          "usage" : [ "Call to view supported Ceph versions before configuring cluster version.", "Use to understand upgrade path options for Ceph cluster management." ],
          "response_shape" : "Array<CephRelease>",
          "failure_modes" : [ "500 if release metadata access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check system configuration and Ceph release metadata availability."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Supported versions listing"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/ceph-default" ],
          "postprocessing_hint" : "Use version names from response for Ceph version configuration; some versions may require container switching.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/ceph-default" : {
      "get" : {
        "summary" : "Get the default ceph release for this container as a lowercase string.",
        "operationId" : "SetupResource_getCephDefaultRelease",
        "tags" : [ "setup" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the default Ceph release version built into this croit container.",
          "usage" : [ "Call to determine the container's native Ceph version for compatibility planning.", "Use to understand container switching requirements for different Ceph versions." ],
          "response_shape" : "String (lowercase release name)",
          "failure_modes" : [ "500 if container metadata access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check container configuration and metadata availability."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Container information"
          },
          "cache_hint" : "long-term",
          "related_endpoints" : [ "/setup/available-ceph-versions", "/setup/ceph-version" ],
          "postprocessing_hint" : "Returns lowercase version name (e.g., 'reef'); this is the version optimized for this container.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/setup/ceph-version" : {
      "post" : {
        "summary" : "Set the Ceph version for a fresh deployment or import.",
        "operationId" : "SetupResource_setCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Ceph version configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephVersionConfiguration"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the Ceph version that croit expects the cluster to be running, enabling version-specific features and compatibility.",
          "usage" : [ "Call during initial setup to set expected Ceph version before cluster creation.", "Use to update backend expectations when Ceph cluster version has been manually changed." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "No cluster operations in progress; Valid Ceph version specified; Container switching possible if needed",
            "post_action" : "Ceph version configured; Container switched if required; Images updated; Task advisor refreshed"
          },
          "request_parameters" : [ {
            "name" : "cephVersion",
            "in" : "body",
            "description" : "Ceph release version to configure (e.g., QUINCY, REEF, SQUID).",
            "required" : true,
            "example" : "REEF"
          } ],
          "failure_modes" : [ "400 if cluster upgrade or croit update is currently in progress", "500 if container switch fails during version change" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Wait for ongoing operations to complete; check cluster lock status."
          }, {
            "code" : "500",
            "action" : "Check container availability; verify system resources; review container switch logs."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Ceph version configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/available-ceph-versions" ],
          "postprocessing_hint" : "Version change may trigger container switch; monitor task progress; warns about functionality risks if cluster version differs.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Changing Ceph version may require container switch and can affect functionality if cluster version differs"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the currently configured Ceph version.",
        "operationId" : "SetupResource_getCephVersion",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/CephVersionConfiguration"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the currently configured Ceph version that croit expects the cluster to be running.",
          "usage" : [ "Call to verify current Ceph version configuration before making changes.", "Use to check version compatibility for cluster operations." ],
          "response_shape" : "CephVersionConfiguration",
          "failure_modes" : [ "500 if configuration access fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check croit configuration file access and system health."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 50,
            "window_seconds" : 300,
            "note" : "Version information retrieval"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/setup/ceph-version", "/setup/available-ceph-versions" ],
          "postprocessing_hint" : "Response includes currently configured Ceph release; may differ from actual cluster version if manually changed.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/import-cluster" : {
      "post" : {
        "summary" : "Imports an existing Ceph cluster.",
        "operationId" : "SetupResource_importCluster",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Cluster import request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/ClusterImportRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Import an existing Ceph cluster by connecting to monitors and retrieving cluster configuration.",
          "usage" : [ "Call during initial setup to connect croit to an existing Ceph cluster.", "Use when integrating croit management with a manually deployed Ceph cluster." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Ceph cluster is running; Admin key has full permissions; Monitor addresses are reachable; Croit not yet initialized",
            "post_action" : "Cluster FSID retrieved; Monitor list updated; Admin key stored; Essential keyrings created; Crush rules checked"
          },
          "request_parameters" : [ {
            "name" : "adminKey",
            "in" : "body",
            "description" : "Base64-encoded Ceph admin authentication key for cluster access.",
            "required" : true,
            "example" : "AQBvaBZeKCRwABAA..."
          }, {
            "name" : "mons",
            "in" : "body",
            "description" : "List of Ceph monitor IP addresses or hostnames for cluster connection.",
            "required" : true,
            "example" : "[\"192.168.1.10\", \"192.168.1.11\", \"192.168.1.12\"]"
          } ],
          "failure_modes" : [ "400 if cluster is already initialized", "500 if unable to connect to monitors or authenticate with admin key", "500 if cluster FSID cannot be retrieved" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Check if cluster setup is already complete; only use during initial setup."
          }, {
            "code" : "500",
            "action" : "Verify monitor addresses are reachable; validate admin key format and permissions; check Ceph cluster health."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 3600,
            "note" : "Cluster import operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/ceph-version" ],
          "postprocessing_hint" : "Import process validates connectivity, retrieves cluster metadata, creates essential keyrings, and updates images; cluster becomes manageable through croit.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Importing will permanently configure croit for this specific Ceph cluster"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/list-interfaces" : {
      "get" : {
        "summary" : "List all interfaces on the management node.",
        "operationId" : "SetupResource_getManagementInterfaceCandidates",
        "tags" : [ "setup" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/InterfaceResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Discover available network interfaces on the management node for PXE and management traffic configuration.",
          "usage" : [ "Call during initial setup to view available network interfaces before selecting management interface.", "Use to verify current network configuration and available interface options." ],
          "response_shape" : "InterfaceResponse",
          "failure_modes" : [ "500 if network interface discovery fails" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check system network configuration and interface availability."
          } ],
          "retry_strategy" : "automatic",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Interface discovery"
          },
          "cache_hint" : "short-term",
          "related_endpoints" : [ "/setup/main-ip" ],
          "postprocessing_hint" : "Use interfaceName from response for management interface configuration; currentInterface shows active management interface.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/main-ip" : {
      "post" : {
        "summary" : "Set's the interface used for PXE booting.",
        "operationId" : "SetupResource_setMainIp",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Main IP configuration request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/MainIpRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Configure the primary network interface and IP address used for PXE booting and server management.",
          "usage" : [ "Call during initial cluster setup to define the management network interface.", "Use to update the management IP when network configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Interface exists on system; IP is valid IPv4; Network configuration is ready for change",
            "post_action" : "Management IP updated; Network services restarted; Task advisor checks network configuration"
          },
          "request_parameters" : [ {
            "name" : "interfaceName",
            "in" : "body",
            "description" : "Network interface name (e.g., eth0, ens3) for management traffic.",
            "required" : true,
            "example" : "eth0"
          }, {
            "name" : "ip",
            "in" : "body",
            "description" : "IPv4 address to assign to the management interface.",
            "required" : true,
            "example" : "192.168.1.100"
          } ],
          "failure_modes" : [ "400 if specified interface does not exist on the system", "400 if IP address format is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify interface exists using GET /setup/list-interfaces; ensure IP address is valid IPv4 format."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Management IP configuration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/list-interfaces" ],
          "postprocessing_hint" : "Management interface change triggers network service restart; new IP becomes active for PXE and management traffic.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-backup" : {
      "post" : {
        "summary" : "Restore from an encrypted cloud backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "description" : "Backup restore request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/BackupRestoreRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restore croit configuration from an encrypted cloud backup stored on portal.croit.io during initial setup.",
          "usage" : [ "Call during disaster recovery to restore cluster configuration from cloud backup.", "Use when setting up a replacement management node with existing cluster data." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Internet connectivity available; Valid API token; Encryption key available; Backup exists on portal",
            "post_action" : "Backup downloaded; Configuration decrypted and restored; Database imported; Services restarted"
          },
          "request_parameters" : [ {
            "name" : "encryptionKey",
            "in" : "body",
            "description" : "UUID encryption key used to decrypt the cloud backup.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          }, {
            "name" : "croitApiToken",
            "in" : "body",
            "description" : "Authentication token for accessing portal.croit.io backup service.",
            "required" : true,
            "example" : "api_token_123..."
          }, {
            "name" : "backupUuid",
            "in" : "body",
            "description" : "UUID identifier of the backup to restore from cloud storage.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "400 if croit is running in offline mode", "400 if backup download fails from portal.croit.io", "500 if backup decryption fails with provided key" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure internet connectivity and valid API token; verify backup UUID exists on portal.croit.io."
          }, {
            "code" : "500",
            "action" : "Check encryption key matches the backup; verify backup file integrity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 7200,
            "note" : "Cloud backup restoration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/restore-unencrypted-backup" ],
          "postprocessing_hint" : "Restoration runs as managed task; monitor progress in task manager; restart may be required after completion.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Backup restoration will overwrite current configuration and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/setup/restore-unencrypted-backup" : {
      "post" : {
        "summary" : "Restore from an unencrypted backup. This should only be done during setup.",
        "operationId" : "SetupResource_restoreFromUnencryptedBackup",
        "tags" : [ "setup" ],
        "requestBody" : {
          "content" : {
            "multipart/form-data" : {
              "schema" : {
                "$ref" : "#/components/schemas/UnencryptedBackupRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restore croit configuration from an unencrypted backup file uploaded during initial setup.",
          "usage" : [ "Call during disaster recovery to restore from local backup file.", "Use when cloud backup is unavailable or when working with legacy backup formats." ],
          "response_shape" : "ManagedTask",
          "workflow_guidance" : {
            "pre_check" : "Valid backup ZIP file uploaded; File contains database.sql; Sufficient disk space available",
            "post_action" : "Backup file buffered; Database restored; Configuration imported; Services restarted"
          },
          "request_parameters" : [ {
            "name" : "file",
            "in" : "form",
            "description" : "Unencrypted croit backup ZIP file containing database.sql and configuration.",
            "required" : true,
            "example" : "backup-2024-01-15.zip"
          } ],
          "failure_modes" : [ "400 if uploaded file is not a valid ZIP archive", "400 if backup file missing required database.sql", "500 if database import fails during restoration" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify backup file is valid ZIP format; ensure database.sql exists in archive."
          }, {
            "code" : "500",
            "action" : "Check database schema compatibility; verify backup file integrity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 7200,
            "note" : "Backup file restoration"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/setup/restore-backup" ],
          "postprocessing_hint" : "File is buffered completely before restoration starts; restoration runs as managed task; monitor progress in task manager.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "Backup restoration will overwrite current configuration and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs" : {
      "get" : {
        "summary" : "Get all CephFS snapshot jobs.",
        "operationId" : "CephFsSnapshotResource_getCephFsSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseCephFSSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List scheduled CephFS snapshot jobs and their status for monitoring or editing.",
          "usage" : [ "Render the snapshot schedule table in the UI", "Refresh after creating or updating snapshot jobs" ],
          "response_shape" : "OptionalPaginationResponse<CephFSSnapshotSchedule>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON to limit or sort snapshot schedules.",
            "required" : false,
            "example" : "{\"limit\":20}"
          } ],
          "failure_modes" : [ "200 [] when no snapshot jobs are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show guidance that snapshots can be scheduled via POST /snapshot-schedule/cephfs."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Snapshot schedule polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs/{id}", "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Display failedSnapshots prominently if present for active schedules.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_addCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new automated CephFS snapshot schedule to protect filesystem data.",
          "usage" : [ "Call when setting up backup schedules for critical CephFS data.", "Use to establish periodic snapshot retention policies for disaster recovery." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "CephFS snapshots enabled; Cron expression valid; Path exists and accessible",
            "post_action" : "Snapshot schedule created and activated; Retention policy applied"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron schedule expression for snapshot timing.",
            "required" : true,
            "example" : "0 2 * * *"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether the schedule is active.",
            "required" : true,
            "example" : "true"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "Prefix for snapshot names.",
            "required" : true,
            "example" : "daily-backup"
          }, {
            "name" : "path",
            "in" : "body",
            "description" : "CephFS path to snapshot.",
            "required" : true,
            "example" : "/data"
          }, {
            "name" : "retentionDays",
            "in" : "body",
            "description" : "Number of days to retain snapshots.",
            "required" : true,
            "example" : "30"
          } ],
          "failure_modes" : [ "400 if snapshot prefix is blank or snapshots are not enabled on filesystem", "500 if snapshot schedule creation fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify snapshot prefix is not empty and CephFS snapshots are enabled."
          }, {
            "code" : "500",
            "action" : "Check CephFS cluster status and retry after resolving issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule creation"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs", "/snapshot-schedule/cephfs/{id}" ],
          "postprocessing_hint" : "Verify schedule appears in GET /snapshot-schedule/cephfs with correct configuration.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/cephfs/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_updateCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Updated CephFS snapshot schedule configuration",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/CephFsSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Modify settings of an existing CephFS snapshot schedule without recreating it.",
          "usage" : [ "Call when adjusting snapshot timing, retention, or target paths for an existing schedule.", "Use to enable/disable schedules temporarily without losing configuration." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; New values pass validation; CephFS snapshots enabled",
            "post_action" : "Schedule updated with new settings; Changes take effect on next scheduled run"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "New cron schedule expression (optional, keeps existing if null).",
            "required" : false,
            "example" : "0 3 * * *"
          }, {
            "name" : "enabled",
            "in" : "body",
            "description" : "Whether to enable/disable the schedule (optional).",
            "required" : false,
            "example" : "false"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "New snapshot name prefix (optional).",
            "required" : false,
            "example" : "weekly-backup"
          }, {
            "name" : "maxSnapshots",
            "in" : "body",
            "description" : "New retention count (optional, 1-100).",
            "required" : false,
            "example" : "14"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "New list of CephFS paths to snapshot (optional).",
            "required" : false,
            "example" : "[\"/data\", \"/home\"]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to update.",
            "required" : true,
            "example" : "15"
          } ],
          "failure_modes" : [ "404 if the snapshot schedule doesn't exist", "400 if validation fails on updated values" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify schedule ID exists with GET /snapshot-schedule/cephfs before updating."
          }, {
            "code" : "400",
            "action" : "Check that maxSnapshots is between 1-100 and cron expression is valid."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule updates"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs", "/snapshot-schedule/cephfs/{id}" ],
          "postprocessing_hint" : "Verify changes with GET /snapshot-schedule/cephfs; disabled schedules stop creating new snapshots but retain existing ones.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a CephFS snapshot job.",
        "operationId" : "CephFsSnapshotResource_removeCephFsSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove an automated CephFS snapshot schedule to stop future snapshot creation.",
          "usage" : [ "Call when decommissioning snapshot schedules that are no longer needed.", "Use to clean up schedules for paths that have been deleted or moved." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; No critical snapshots in progress",
            "post_action" : "Schedule removed; Future snapshots cancelled; Existing snapshots preserved"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to remove.",
            "required" : true,
            "example" : "15"
          } ],
          "failure_modes" : [ "404 if the snapshot schedule ID does not exist", "500 if schedule removal fails" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify schedule ID exists with GET /snapshot-schedule/cephfs before retrying."
          }, {
            "code" : "500",
            "action" : "Check CephFS cluster status and retry after resolving issues."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule removal"
          },
          "related_endpoints" : [ "/snapshot-schedule/cephfs" ],
          "postprocessing_hint" : "Confirm removal with GET /snapshot-schedule/cephfs to verify schedule no longer appears.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd" : {
      "get" : {
        "summary" : "Get all RBD snapshot jobs.",
        "operationId" : "RbdSnapshotResource_getRbdSnapshotJobs",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseRbdSnapshotSchedule"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve all configured RBD snapshot schedules with their current status and configuration details.",
          "usage" : [ "Call to display snapshot schedule dashboard and monitor automated backup jobs.", "Use to review retention policies and verify snapshot schedule coverage across RBD images." ],
          "response_shape" : "OptionalPaginationResponse<RbdSnapshotSchedule>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large schedule lists.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "failure_modes" : [ "200 with empty list if no snapshot schedules are configured", "500 if snapshot scheduler service is unavailable" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Empty list indicates no automated snapshots configured; create schedules via POST /snapshot-schedule/rbd."
          }, {
            "code" : "500",
            "action" : "Check snapshot scheduler service health; verify system resources for job processing."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Snapshot schedule queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/snapshot-schedule/rbd/{id}", "/rbd" ],
          "postprocessing_hint" : "Group schedules by pool; highlight disabled or failing schedules; show next scheduled run times; display retention policy summaries.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Schedule a new RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_addRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "requestBody" : {
          "description" : "RBD snapshot schedule creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleCreateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a scheduled RBD snapshot job with automatic retention management for data protection.",
          "usage" : [ "Call to establish regular backup schedules for RBD images in specified pools.", "Use to implement data protection policies with automated snapshot lifecycle management." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid cron expression; Snapshot prefix format correct; Target pools/images exist; Scheduler service available",
            "post_action" : "Snapshot schedule created; Cron job registered; Retention policy active; First snapshot scheduled"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Cron expression defining the snapshot schedule (e.g., '0 2 * * *' for daily at 2 AM).",
            "required" : true,
            "example" : "0 2 * * *"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "Prefix for snapshot names (alphanumeric and hyphens only).",
            "required" : true,
            "example" : "daily"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "List of pool/image paths to include in snapshot schedule.",
            "required" : true,
            "example" : "[{\"pool\": \"rbd\", \"image\": \"vm-disk-1\"}]"
          }, {
            "name" : "retentionPolicy",
            "in" : "body",
            "description" : "Snapshot retention settings controlling cleanup of old snapshots.",
            "required" : true,
            "example" : "{\"keepDaily\": 7, \"keepWeekly\": 4}"
          } ],
          "failure_modes" : [ "400 if cron expression is invalid or snapshot prefix contains illegal characters", "400 if retention policy is malformed or paths are invalid", "500 if scheduler registration fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate cron syntax; ensure prefix uses only alphanumeric and hyphen characters; verify pool/image paths exist."
          }, {
            "code" : "500",
            "action" : "Check scheduler service health; verify sufficient system resources for snapshot operations."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule becomes active immediately; first snapshot created according to cron schedule; retention policy applies to future snapshots.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/snapshot-schedule/rbd/{id}" : {
      "patch" : {
        "summary" : "Update the schedule settings of an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_updateRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to update.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "RBD snapshot schedule update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/RbdSnapshotScheduleUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update configuration of an existing RBD snapshot schedule including timing, retention, and target paths.",
          "usage" : [ "Call when snapshot schedule requirements change and need adjustment without recreating.", "Use to modify retention policies, timing, or target images while preserving schedule history." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; Valid cron expression; Snapshot prefix format correct; Target paths exist",
            "post_action" : "Schedule configuration updated; Next snapshots use new settings; Retention policy applies to future snapshots"
          },
          "request_parameters" : [ {
            "name" : "cron",
            "in" : "body",
            "description" : "Updated cron expression for schedule timing.",
            "required" : false,
            "example" : "0 3 * * *"
          }, {
            "name" : "snapshotPrefix",
            "in" : "body",
            "description" : "Updated prefix for snapshot names.",
            "required" : false,
            "example" : "nightly"
          }, {
            "name" : "paths",
            "in" : "body",
            "description" : "Updated list of pool/image paths to snapshot.",
            "required" : false,
            "example" : "[{\"pool\": \"rbd\", \"image\": \"vm-disk-2\"}]"
          }, {
            "name" : "retentionPolicy",
            "in" : "body",
            "description" : "Updated retention settings for snapshot cleanup.",
            "required" : false,
            "example" : "{\"keepDaily\": 14, \"keepWeekly\": 8}"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to update.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if cron expression is invalid or snapshot prefix contains illegal characters", "400 if retention policy is malformed or paths reference non-existent pools/images", "404 if snapshot schedule ID does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate cron syntax; ensure prefix uses alphanumeric and hyphen characters; verify target paths exist."
          }, {
            "code" : "404",
            "action" : "Verify schedule ID exists; refresh schedule list; check if schedule was deleted."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 15,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule changes take effect for next scheduled run; existing snapshots unaffected; verify new schedule timing is correct.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove an RBD snapshot job.",
        "operationId" : "RbdSnapshotResource_removeRbdSnapshotJob",
        "tags" : [ "snapshot-schedule" ],
        "parameters" : [ {
          "description" : "The schedule to delete.",
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "boolean"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently delete an RBD snapshot schedule and stop all future automated snapshots for the configured paths.",
          "usage" : [ "Call when snapshot schedule is no longer needed and automated backups should cease.", "Use to clean up obsolete schedules when backup strategies change or RBD images are decommissioned." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Schedule exists; No active snapshot operations depend on this schedule; Admin permissions verified",
            "post_action" : "Schedule deleted; Future snapshots cancelled; Existing snapshots preserved; Scheduler updated"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Snapshot schedule ID to delete.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "404 if snapshot schedule ID does not exist or has already been deleted", "500 if scheduler service fails to remove the job" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Schedule may have been already deleted; refresh schedule list to verify current state."
          }, {
            "code" : "500",
            "action" : "Check snapshot scheduler service health; verify job removal permissions."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Snapshot schedule deletion"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/snapshot-schedule/rbd", "/snapshot-schedule/rbd/{id}" ],
          "postprocessing_hint" : "Schedule removal is immediate; existing snapshots remain untouched; verify no dependent backup strategies rely on this schedule.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting snapshot schedules stops all future automated backups for configured RBD images"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats" : {
      "get" : {
        "summary" : "Get a graph by name.",
        "description" : "\n\t\t\tSee resources/statistics/graphite-queries.yml for available graphs.\n\n\t\t\tSome queries like server-specific stats expect template parameter which are passed with\n\t\t\t<code>template-{name}</code> query parameters. Example:\n\n\t\t\t<code>/stats?graph=server-disk-load&startTime=-600&maxDataPoints=50&template-server-id=1</code>\n\n\t\t\tstartTime and endTime should be in the same format, i.e., either both > 0 or both <= 0\n\t\t\t",
        "operationId" : "StatsResource_getStatsAuthed",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "description" : "End time of the graph, default = 0. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "endTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "The graph to query.",
          "name" : "graph",
          "in" : "query",
          "schema" : {
            "type" : "string"
          },
          "required" : true
        }, {
          "description" : "Maximum number of data points to return to thin out graphs over long time ranges. Default = 500",
          "name" : "maxDataPoints",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        }, {
          "description" : "Start time of the graph. Either an absolute UNIX timestamp in seconds or a negative value in seconds for x seconds ago.",
          "name" : "startTime",
          "in" : "query",
          "schema" : {
            "type" : "integer",
            "format" : "int64"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GraphResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve time-series metrics for dashboards using predefined graphite graph IDs.",
          "usage" : [ "Call when rendering monitoring charts; reuse cached data between dashboards if time range unchanged", "Limit polling to no more than once per refresh interval configured for the graph" ],
          "response_shape" : "GraphResponse",
          "request_parameters" : [ {
            "name" : "graph",
            "in" : "query",
            "description" : "Graph identifier defined in resources/statistics/graphite-queries.yml.",
            "required" : true,
            "example" : "server-disk-load"
          }, {
            "name" : "startTime",
            "in" : "query",
            "description" : "Unix timestamp (seconds) or negative offset indicating the start of the time window.",
            "required" : true,
            "example" : "-600"
          }, {
            "name" : "endTime",
            "in" : "query",
            "description" : "Unix timestamp (seconds) or negative offset for the end of the window (default 0).",
            "required" : false,
            "default" : "0"
          }, {
            "name" : "maxDataPoints",
            "in" : "query",
            "description" : "Maximum data points to return; higher values increase payload size (default 500).",
            "required" : false,
            "default" : "500"
          } ],
          "common_parameters" : {
            "template-*" : "Supply graph-specific template variables like template-server-id=1."
          },
          "failure_modes" : [ "400 if template parameters are missing or invalid", "404 if the graph identifier is unknown" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Validate parameters client-side and provide friendly error messaging."
          }, {
            "code" : "404",
            "action" : "Fallback to a default graph list and prompt selection again."
          } ],
          "rate_limit" : {
            "limit" : 120,
            "window_seconds" : 300,
            "note" : "Dashboard polling"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/stats/server-names", "/stats/pool-names", "/stats/s3-user-names" ],
          "postprocessing_hint" : "Downsample or merge series client-side if visualization cannot display all datapoints.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/cephfs-monitored-dirs" : {
      "put" : {
        "summary" : "Set the CephFS directories that are monitored for statistics.",
        "description" : "Replaces the currently configured set of directories.",
        "operationId" : "StatsResource_updateCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "CephFS directories to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "type" : "string"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the list of CephFS directories being tracked for utilization statistics.",
          "usage" : [ "Update monitored directories when onboarding new projects or retiring old ones.", "Automate stats configuration during environment provisioning." ],
          "response_shape" : "void",
          "request_parameters" : [ {
            "name" : "dirs",
            "in" : "body",
            "description" : "Set of absolute directories to monitor (root '/' added automatically).",
            "required" : true,
            "example" : "[\"/home\", \"/analytics\"]"
          } ],
          "failure_modes" : [ "400 if the request body is invalid JSON" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Send a valid JSON array of absolute directory paths."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 3600,
            "note" : "CephFS monitor reconfiguration"
          },
          "cache_hint" : "no-cache",
          "postprocessing_hint" : "Refresh GET /stats/cephfs-monitored-dirs to confirm the new directory list.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get CephFS directories that are monitored for statistics.",
        "operationId" : "StatsResource_getCephfsMonitoredDirectories",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/CephFsMonitoredDir"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Expose the list of CephFS directories currently tracked by utilization metrics.",
          "usage" : [ "Show monitored directories in the CephFS stats configuration UI", "Verify directory watch list after administrators update it" ],
          "response_shape" : "array<CephFsMonitoredDir>",
          "failure_modes" : [ "200 [] when no directories are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display guidance for adding directories via PUT /stats/cephfs-monitored-dirs."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/cephfs-monitored-dirs" ],
          "postprocessing_hint" : "Sort directories alphabetically and ensure '/' appears first.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/monitored-rbds" : {
      "put" : {
        "summary" : "Set the Rbd images that are monitored for statistics.",
        "description" : "Replaces the currently configured set of Rbd images.",
        "operationId" : "StatsResource_updateRbdMonitoredImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Replace the entire list of RBD images being monitored for I/O statistics.",
          "usage" : [ "Call when performing bulk reconfiguration of RBD monitoring.", "Use to synchronize monitoring configuration with external management systems." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "All specified RBD images exist; Statistics collection service available",
            "post_action" : "Monitoring list completely replaced; I/O collection starts for new images and stops for removed ones"
          },
          "request_parameters" : [ {
            "name" : "rbds",
            "in" : "body",
            "description" : "Complete set of MonitoredRbd objects to monitor (replaces existing list).",
            "required" : true,
            "example" : "[{\"poolName\":\"rbd\",\"imageName\":\"vm-disk-1\"},{\"poolName\":\"rbd\",\"imageName\":\"vm-disk-2\"}]"
          } ],
          "failure_modes" : [ "400 if any RBD image specification is invalid or images don't exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify all RBD images exist in their respective pools before replacing the monitoring list."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "Bulk RBD monitoring reconfiguration"
          },
          "related_endpoints" : [ "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Verify new configuration with GET /stats/monitored-rbds; previously monitored images not in the new list will stop being tracked.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "This operation replaces the entire monitoring list and may stop collection for currently monitored images"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get the Rbd images that are monitored for statistics.",
        "operationId" : "StatsResource_getMonitoredRbds",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/MonitoredRbd"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RBD images currently tracked for RBD I/O statistics.",
          "usage" : [ "Display the monitored RBD list in the stats configuration UI", "Confirm that requested images are being collected" ],
          "response_shape" : "array<String>",
          "failure_modes" : [ "200 [] when no images are being monitored" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Explain how to add images via POST /stats/monitored-rbds."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "Monitor configuration caching"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats", "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Display items sorted and grouped by pool for readability.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "delete" : {
        "summary" : "Remove images from the set of monitored Rbds.",
        "operationId" : "StatsResource_deleteMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Remove RBD images from monitoring to stop I/O statistics collection.",
          "usage" : [ "Call when decommissioning RBD images or reducing monitoring overhead.", "Use to selectively remove images while preserving monitoring for others." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Images are currently being monitored; Request format is valid",
            "post_action" : "Images removed from monitoring; I/O statistics collection stops for specified images"
          },
          "request_parameters" : [ {
            "name" : "rbds",
            "in" : "body",
            "description" : "Set of MonitoredRbd objects specifying which images to stop tracking.",
            "required" : true,
            "example" : "[{\"poolName\":\"rbd\",\"imageName\":\"old-vm-disk\"}]"
          } ],
          "failure_modes" : [ "400 if RBD image specification is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Ensure RBD image names and pool names are correctly specified."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "RBD monitoring changes"
          },
          "related_endpoints" : [ "/stats/monitored-rbds" ],
          "postprocessing_hint" : "Confirm removal by checking GET /stats/monitored-rbds; historical data is preserved.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "post" : {
        "summary" : "Add images to the set of monitored Rbds.",
        "operationId" : "StatsResource_addMonitoredRbdImages",
        "tags" : [ "stats" ],
        "requestBody" : {
          "description" : "Additional Rbd images to monitor continuously.",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array",
                "uniqueItems" : true,
                "items" : {
                  "$ref" : "#/components/schemas/MonitoredRbd"
                }
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Add RBD images to the monitoring list for I/O statistics collection.",
          "usage" : [ "Call when new critical RBD images need performance tracking.", "Use to incrementally expand monitoring without affecting existing tracked images." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "RBD images exist; Pool names are valid; Statistics collection is enabled",
            "post_action" : "Images added to monitoring; I/O statistics collection begins for new images"
          },
          "request_parameters" : [ {
            "name" : "rbds",
            "in" : "body",
            "description" : "Set of MonitoredRbd objects specifying pool and image names to track.",
            "required" : true,
            "example" : "[{\"poolName\":\"rbd\",\"imageName\":\"vm-disk-1\"}]"
          } ],
          "failure_modes" : [ "400 if RBD image specification is invalid or image doesn't exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify RBD images exist in the specified pools before adding to monitoring."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "RBD monitoring changes"
          },
          "related_endpoints" : [ "/stats/monitored-rbds", "/stats" ],
          "postprocessing_hint" : "Verify new images appear in GET /stats/monitored-rbds; I/O data collection starts immediately.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/stats/pool-names" : {
      "get" : {
        "summary" : "Get available Ceph pools for statistics.",
        "operationId" : "StatsResource_getPoolNames",
        "tags" : [ "stats" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponsePoolStatsInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide pool identifiers and metadata for stats template selection.",
          "usage" : [ "Populate pool selection widgets before querying pool graphs", "Use quota fields to pre-select pools nearing limits" ],
          "response_shape" : "OptionalPaginationResponse<PoolStatsInfo>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional PaginationRequest JSON for sorting/filtering pools.",
            "required" : false,
            "example" : "{\"limit\":50,\"where\":[{\"displayName\":{\"_ilike\":\"%rbd%\"}}]}"
          } ],
          "failure_modes" : [ "200 [] when no pools are configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Notify the user that no pools exist and provide a link to pool management."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/pools", "/stats" ],
          "postprocessing_hint" : "Map queryName to `template-pool-name` parameter values in stats calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-bucket-names" : {
      "get" : {
        "summary" : "Get available S3 buckets for statistics.",
        "operationId" : "StatsResource_getS3BucketNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3BucketName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List RGW buckets with quotas for use as template parameters in S3 graphs.",
          "usage" : [ "Populate S3 bucket selectors before requesting usage charts", "Refresh after new buckets are created or quotas change" ],
          "response_shape" : "array<S3BucketName>",
          "failure_modes" : [ "200 [] when RGW is configured but no buckets exist", "200 [] when RGW is not configured" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a hint that no buckets are available and allow creation in RGW UI."
          } ],
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 600,
            "note" : "S3 selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-user-names", "/stats" ],
          "postprocessing_hint" : "Use queryName when calling /stats?graph=... with template-s3-bucket-name.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/s3-user-names" : {
      "get" : {
        "summary" : "Get available S3 users for statistics.",
        "description" : "This API is somewhat expensive if there are a lot of S3 users, don't call this too often.",
        "operationId" : "StatsResource_getS3UserNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/S3UserName"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Return RGW user identifiers for stats templates (e.g. bandwidth per user).",
          "usage" : [ "Populate user pickers in S3 usage dashboards", "Request sparingly on large clusters due to cost" ],
          "response_shape" : "array<S3UserName>",
          "failure_modes" : [ "200 [] when no RGW users exist" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Indicate that no users are available and suggest user creation if required."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 600,
            "note" : "Expensive RGW user listing"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/stats/s3-bucket-names", "/stats" ],
          "postprocessing_hint" : "Normalize queryName by substituting '.' and '@' when building template parameters.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/stats/server-names" : {
      "get" : {
        "summary" : "Get available server names for statistics.",
        "operationId" : "StatsResource_getServerNames",
        "tags" : [ "stats" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/ServerNameAndId"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List server identifiers used as template parameters for stats queries.",
          "usage" : [ "Populate server selectors before fetching graphs", "Refresh when the hardware inventory changes" ],
          "response_shape" : "array<ServerNameAndId>",
          "failure_modes" : [ "200 [] when no servers are registered" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty state noting that no servers are yet detected."
          } ],
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 600,
            "note" : "Selector population"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/servers", "/stats" ],
          "postprocessing_hint" : "Sort by hostname before presenting in dropdowns.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/status" : {
      "get" : {
        "summary" : "Backend status and health check.",
        "description" : "Returns aggregated health data that indicates whether the croit backend is operational.",
        "operationId" : "BackendStatusResource_getBackendStatus",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/BackendStatus"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Check whether the croit backend is healthy before executing workflows.",
          "usage" : [ "Call before write operations or when rendering global status widgets", "Treat non-OK health results as degraded service" ],
          "response_shape" : "BackendStatus",
          "workflow_guidance" : {
            "pre_check" : "Ensure caller is authenticated with at least viewer privileges.",
            "post_action" : "Escalate alerts to the UI if status.health != 'OK'."
          },
          "failure_modes" : [ "503 if the backend is unreachable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry with exponential backoff (max 3 attempts) then alert operations."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 60,
            "note" : "Shared global polling budget"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/cluster/status" ],
          "postprocessing_hint" : "Highlight health warnings prominently; avoid storing raw payload in logs.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/status/croit-version" : {
      "get" : {
        "summary" : "Get croit version.",
        "description" : "Retrieves the currently running croit software version as a semantic version string.",
        "operationId" : "BackendStatusResource_getCroitVersionParsed",
        "tags" : [ "status" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "string"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Determine the running croit software version for diagnostics and support.",
          "usage" : [ "Fetch once when composing system diagnostics or about dialogs", "Attach version metadata to support bundles" ],
          "response_shape" : "string",
          "workflow_guidance" : {
            "pre_check" : "Ensure viewer-level access.",
            "post_action" : "Cache version in session or telemetry payload."
          },
          "failure_modes" : [ "503 if backend temporarily unavailable" ],
          "error_handling" : [ {
            "code" : "503",
            "action" : "Retry after 10 seconds or fall back to cached value."
          } ],
          "rate_limit" : {
            "limit" : 6,
            "window_seconds" : 60,
            "note" : "Version rarely changes"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/status" ],
          "postprocessing_hint" : "Store value client-side to avoid repeated calls.",
          "idempotent" : true,
          "requires_confirmation" : false
        }
      }
    },
    "/supervisor" : {
      "get" : {
        "summary" : "Inspect supervised services status.",
        "operationId" : "SupervisorResource_listProcesses",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseSupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve status and health information for all supervised services managed by the supervisor system.",
          "usage" : [ "Call to monitor overall system health and identify services requiring attention.", "Use to display service dashboard and track service uptime across the cluster." ],
          "response_shape" : "OptionalPaginationResponse<SupervisorModuleJson>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination for large service lists.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "failure_modes" : [ "200 with service list (never empty - system services always present)", "500 if supervisor system is not responding" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check supervisor daemon health; verify system resources; restart supervisor service if necessary."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 300,
            "note" : "Service status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/supervisor/{name}" ],
          "postprocessing_hint" : "Highlight failed or stopped services; group by service type; show restart counts and last activity timestamps.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}" : {
      "get" : {
        "summary" : "Get details of a specific supervised service.",
        "operationId" : "SupervisorResource_getProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SupervisorModuleJson"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve detailed status, configuration, and operational metrics for a specific supervised service.",
          "usage" : [ "Call when investigating service issues or monitoring specific service performance.", "Use to get detailed logs, process information, and configuration details for troubleshooting." ],
          "response_shape" : "SupervisorModuleJson",
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to inspect (e.g., 'dhcp', 'tftp', 'ipmi', 'mariadb').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "404 if supervised service with specified name does not exist" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Check available services via GET /supervisor; verify service name spelling and availability."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 100,
            "window_seconds" : 300,
            "note" : "Individual service queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 15,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}/start", "/supervisor/{name}/stop", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Display process ID, uptime, memory usage, and recent log entries; highlight error conditions and configuration issues.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/supervisor/{name}/restart" : {
      "post" : {
        "summary" : "Restart a specific supervised service.",
        "operationId" : "SupervisorResource_restartProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Restart a supervised service to apply configuration changes or recover from service issues.",
          "usage" : [ "Call after configuration changes that require service restart.", "Use to recover from service hangs or memory leaks without manual stop/start sequence." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Admin confirms restart impact",
            "post_action" : "Service stopped gracefully; New process started; Service reloads configuration; Status updated"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to restart (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "404 if supervised service with specified name does not exist", "400 if service is disabled" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Check available services via GET /supervisor; verify service name spelling."
          }, {
            "code" : "400",
            "action" : "Check service status and enable service if disabled before attempting restart."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 8,
            "window_seconds" : 300,
            "note" : "Service restart operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/start", "/supervisor/{name}/stop" ],
          "postprocessing_hint" : "Restart combines stop and start operations; monitor service status for successful restart; configuration changes take effect immediately.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Restarting services may cause temporary service interruption; MariaDB restart requires special confirmation"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/start" : {
      "post" : {
        "summary" : "Start a supervised service.",
        "operationId" : "SupervisorResource_startProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Start a stopped or failed supervised service to restore its functionality.",
          "usage" : [ "Call when a service is stopped and needs to be brought back online.", "Use to recover from service failures or after maintenance operations." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Service is currently stopped",
            "post_action" : "Service start initiated; Process spawned; Service status changes to running"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to start (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "404 if supervised service with specified name does not exist", "400 if service is disabled or already running" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Check available services via GET /supervisor; verify service name spelling."
          }, {
            "code" : "400",
            "action" : "Check service status; enable service if disabled; verify service is actually stopped."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Service management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/stop", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Service starts asynchronously; check service status to confirm successful startup; logs available in service details.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/supervisor/{name}/stop" : {
      "post" : {
        "summary" : "Stop a supervised service.",
        "operationId" : "SupervisorResource_stopProcess",
        "tags" : [ "supervisor" ],
        "parameters" : [ {
          "name" : "name",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Stop a running supervised service for maintenance, troubleshooting, or resource management.",
          "usage" : [ "Call when service needs maintenance or is consuming excessive resources.", "Use to temporarily disable services during troubleshooting or configuration changes." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Service exists; Service is not disabled; Service is currently running; Service is not critical system service",
            "post_action" : "Service stop initiated; Process terminated gracefully; Service status changes to stopped"
          },
          "path_parameters" : [ {
            "name" : "name",
            "in" : "path",
            "description" : "Name of the supervised service to stop (e.g., 'dhcp', 'tftp', 'ipmi').",
            "required" : true,
            "example" : "dhcp"
          } ],
          "failure_modes" : [ "404 if supervised service with specified name does not exist", "400 if service is disabled, already stopped, or is critical service like MariaDB" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Check available services via GET /supervisor; verify service name spelling."
          }, {
            "code" : "400",
            "action" : "Check service status; critical services like MariaDB cannot be stopped through this endpoint."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Service management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/supervisor", "/supervisor/{name}", "/supervisor/{name}/start", "/supervisor/{name}/restart" ],
          "postprocessing_hint" : "Service stops gracefully with timeout; check service status to confirm shutdown; dependent services may be affected.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/info" : {
      "get" : {
        "summary" : "Collect some support info for debugging purposes.",
        "operationId" : "SupportResource_getSupportInfo",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Generate comprehensive diagnostic package containing cluster logs, configuration, and system state for support analysis.",
          "usage" : [ "Call when preparing to contact support or when detailed system analysis is needed.", "Use to create diagnostic archive before making configuration changes or troubleshooting complex issues." ],
          "response_shape" : "application/octet-stream (zip file)",
          "workflow_guidance" : {
            "pre_check" : "Sufficient disk space; Cluster components accessible; Admin permissions verified",
            "post_action" : "Diagnostic package created; Logs collected; Configuration captured; Archive ready for analysis"
          },
          "failure_modes" : [ "500 if log collection fails due to disk space or permission issues", "500 if system state cannot be retrieved from cluster components" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check available disk space; verify cluster component accessibility; ensure sufficient permissions for log access."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 2,
            "window_seconds" : 1800,
            "note" : "Support info generation (resource intensive)"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn" ],
          "postprocessing_hint" : "Archive contains logs, configuration files, and cluster state; download completes when generation finishes; share with support team for analysis.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Support info collection is resource intensive and may contain sensitive cluster information"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn" : {
      "get" : {
        "summary" : "Check if connected to croit VPN.",
        "operationId" : "SupportResource_getVPNConnection",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/VPNConnectionInfo"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Check current VPN connection status and configuration for croit support infrastructure.",
          "usage" : [ "Call to verify if support VPN is active and accessible for remote assistance.", "Use to display VPN dashboard and monitor connection health before support sessions." ],
          "response_shape" : "VPNConnectionInfo",
          "failure_modes" : [ "200 with disconnected status if VPN is not active", "200 with offline status if cluster is in offline mode" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Response always succeeds; check status.connected field to determine VPN state; use POST /support/vpn/connect to establish connection."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "VPN status queries"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/support/vpn/connect", "/support/vpn/disconnect" ],
          "postprocessing_hint" : "Display connection status prominently; show hostname configuration; highlight when VPN is active to indicate remote access is enabled.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/support/vpn/connect" : {
      "post" : {
        "summary" : "Connect to the croit VPN.",
        "operationId" : "SupportResource_connectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/VPNConnectionRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Establish secure VPN connection to croit support infrastructure for remote assistance and debugging.",
          "usage" : [ "Call when remote support is needed for troubleshooting complex cluster issues.", "Use to enable croit support team access for emergency assistance or advanced configuration." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster registered; Internet connectivity; No concurrent VPN operations; Valid hostname if provided",
            "post_action" : "VPN container started; Connection established; API notified; Support team can access cluster"
          },
          "request_parameters" : [ {
            "name" : "hostname",
            "in" : "body",
            "description" : "Optional hostname for VPN identification (auto-generated if not provided).",
            "required" : false,
            "example" : "cluster-production-01"
          }, {
            "name" : "info",
            "in" : "body",
            "description" : "Optional context information like ticket number (max 50 characters).",
            "required" : false,
            "example" : "Ticket #12345"
          } ],
          "failure_modes" : [ "400 if croit is running in offline mode", "400 if hostname is invalid or VPN configuration is incomplete", "409 if VPN connection is already being configured by another user", "500 if croit API is unreachable or VPN container fails to start" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Check hostname format; ensure cluster is online mode; verify VPN configuration."
          }, {
            "code" : "409",
            "action" : "Wait for concurrent VPN operation to complete; retry after current operation finishes."
          }, {
            "code" : "500",
            "action" : "Check internet connectivity; verify croit API accessibility; check container runtime status."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 3,
            "window_seconds" : 1800,
            "note" : "VPN connection attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn", "/support/vpn/disconnect" ],
          "postprocessing_hint" : "Connection runs as managed task; monitor task progress; VPN status visible via GET /support/vpn; disconnect when support session ends.",
          "idempotent" : false,
          "requires_confirmation" : true,
          "confirmation_reason" : "VPN connection enables remote access by croit support team"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/support/vpn/disconnect" : {
      "post" : {
        "summary" : "Disconnect to the croit VPN.",
        "operationId" : "SupportResource_disconnectVPN",
        "tags" : [ "support" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Terminate VPN connection to croit support infrastructure and revoke remote access permissions.",
          "usage" : [ "Call when support session is complete to ensure security by closing remote access.", "Use to immediately disconnect support team access if no longer needed." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "VPN connection exists; No concurrent VPN operations; Container runtime accessible",
            "post_action" : "VPN container stopped; Connection terminated; API notified; Remote access revoked"
          },
          "failure_modes" : [ "400 if croit is running in offline mode", "409 if VPN connection is already being configured by another user", "500 if VPN container fails to stop or croit API is unreachable" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "VPN operations not available in offline mode; no action needed if already offline."
          }, {
            "code" : "409",
            "action" : "Wait for concurrent VPN operation to complete; retry after current operation finishes."
          }, {
            "code" : "500",
            "action" : "Check container runtime status; manually stop VPN container if API fails; verify internet connectivity."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 900,
            "note" : "VPN disconnection attempts"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/support/vpn", "/support/vpn/connect" ],
          "postprocessing_hint" : "Disconnection runs as managed task; monitor task progress; VPN status updated via GET /support/vpn; security restored.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/survey" : {
      "patch" : {
        "summary" : "Enable or disable the croit hardware survey.",
        "operationId" : "SurveyResource_updateSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Survey configuration update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/SurveyUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Enable or disable participation in the croit hardware survey for anonymous cluster statistics collection.",
          "usage" : [ "Call when changing privacy preferences for cluster data sharing with croit.io.", "Use to opt in or out of anonymous hardware and configuration reporting for product improvement." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Valid enabled value provided; Admin permissions verified",
            "post_action" : "Survey participation setting updated; Next survey cycles use new preference"
          },
          "request_parameters" : [ {
            "name" : "enabled",
            "in" : "body",
            "description" : "Set to true to enable survey participation, false to disable.",
            "required" : false,
            "example" : "true"
          } ],
          "failure_modes" : [ "400 if request format is invalid" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide a valid boolean value for enabled field."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Survey preference updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/survey", "/survey/preview" ],
          "postprocessing_hint" : "Setting change is immediate; survey data transmission starts/stops with next scheduled collection; preview what data is shared via GET /survey/preview.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "get" : {
        "summary" : "Get survey configuration",
        "operationId" : "SurveyResource_getSurveyConfig",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyConfigResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current configuration status for croit hardware survey participation.",
          "usage" : [ "Call to display survey participation status in privacy settings or administration dashboard.", "Use to check if cluster is sharing anonymous hardware data with croit.io for product improvement." ],
          "response_shape" : "SurveyConfigResponse",
          "failure_modes" : [ "200 always succeeds with current survey configuration" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Response always successful; check enabled field to determine survey participation status."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Survey configuration queries"
          },
          "cache_hint" : "medium-lived",
          "recommended_poll_interval" : {
            "value" : 300,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/survey/preview", "/survey" ],
          "postprocessing_hint" : "Display survey participation status prominently; link to privacy policy; show data preview option if enabled.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/feedback" : {
      "post" : {
        "summary" : "Report feedback to croit.io.",
        "operationId" : "SurveyResource_postFeedback",
        "tags" : [ "survey" ],
        "requestBody" : {
          "description" : "Feedback data",
          "content" : {
            "application/json" : {
              "schema" : {
                "type" : "array"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Send user feedback, bug reports, or support requests to croit.io with optional cluster diagnostics.",
          "usage" : [ "Call when users encounter issues and want to report them to croit support.", "Use to send feature requests or general feedback about the croit platform." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Cluster is registered; Internet connectivity available; Not in offline mode",
            "post_action" : "Feedback submitted to croit.io; Support info collected if requested; Task tracks upload progress"
          },
          "request_parameters" : [ {
            "name" : "feedback",
            "in" : "body",
            "description" : "JSON object containing feedback text, optional screenshot, and collection flags.",
            "required" : true,
            "example" : "{\"message\": \"Bug report\", \"collectInfo\": true}"
          }, {
            "name" : "feedback.screenshot",
            "in" : "body",
            "description" : "Optional base64-encoded screenshot data URL.",
            "required" : false,
            "example" : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="
          }, {
            "name" : "feedback.collectInfo",
            "in" : "body",
            "description" : "Include basic cluster diagnostics with feedback.",
            "required" : false,
            "example" : "true"
          }, {
            "name" : "feedback.collectAllInfo",
            "in" : "body",
            "description" : "Include comprehensive diagnostics and logs with feedback.",
            "required" : false,
            "example" : "false"
          } ],
          "failure_modes" : [ "400 if croit is running in offline mode", "500 if cluster is not registered or communication with croit.io fails" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Feedback submission requires internet connectivity; cannot be used in offline mode."
          }, {
            "code" : "500",
            "action" : "Check cluster registration status; verify internet connectivity to croit.io; retry after network issues resolved."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Feedback submissions"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/survey", "/support/info" ],
          "postprocessing_hint" : "Feedback submission runs as managed task; support info collection may take several minutes; cancellation prompts for feedback-only submission.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/survey/preview" : {
      "get" : {
        "summary" : "Preview what is sent to croit.io if survey is enabled.",
        "operationId" : "SurveyResource_previewSurveyData",
        "tags" : [ "survey" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/SurveyReport"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Preview anonymous hardware and configuration data that would be shared with croit.io through the survey program.",
          "usage" : [ "Call to show users exactly what data is collected before enabling survey participation.", "Use for transparency in privacy settings to build trust in data sharing practices." ],
          "response_shape" : "SurveyReport",
          "failure_modes" : [ "500 if cluster data collection fails due to component accessibility issues" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check cluster component accessibility; verify monitoring services are running; ensure sufficient permissions for data collection."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Survey data preview"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 120,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/survey" ],
          "postprocessing_hint" : "Present data in readable format; highlight anonymization; explain what information helps improve croit products; emphasize no sensitive data included.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor" : {
      "post" : {
        "summary" : "Force a refresh of the recommendation list",
        "operationId" : "TaskAdvisorResource_refreshTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Force immediate refresh of task advisor recommendations by running all health checks and analysis.",
          "usage" : [ "Call when cluster configuration has changed and fresh recommendations are needed.", "Use after resolving issues to validate that warnings have been cleared." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Cluster is accessible; Health checks can be performed",
            "post_action" : "All advisor checks run; Recommendations updated; Obsolete warnings cleared"
          },
          "failure_modes" : [ "500 if health checks fail due to cluster connectivity issues" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check cluster connectivity; verify Ceph monitors are accessible; retry after resolving cluster issues."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 300,
            "note" : "Manual advisor refresh"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor" ],
          "postprocessing_hint" : "Refresh runs synchronously; new recommendations available immediately; re-fetch advisor list to see updated results.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "get" : {
        "summary" : "Get a list of all recommendation tasks",
        "operationId" : "TaskAdvisorResource_getTasks",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/RecommendationResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve current task-advisor recommendations for administrators.",
          "usage" : [ "Call to populate the task-advisor dashboard when the page loads.", "Poll periodically (e.g. every 60s) to surface new findings or auto-mitigations." ],
          "response_shape" : "array<RecommendationResponse>",
          "failure_modes" : [ "200 [] when no recommendations are currently available" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Display an empty-state card explaining that no actions are required."
          } ],
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Advisor dashboard refresh"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 60,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/task-advisor", "/task-advisor/suggestions/{suggestionId}", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Sort recommendations by updatedAt descending and badge muted entries so operators can restore them.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/task-advisor/retry-backup" : {
      "post" : {
        "summary" : "Retry the backup on mon disks.",
        "operationId" : "TaskAdvisorResource_retryBackupOnMonDisk",
        "tags" : [ "task-advisor" ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retry failed backup operation on monitor disks to resolve backup-related advisor warnings.",
          "usage" : [ "Call when task advisor shows backup failure warnings that need immediate resolution.", "Use to manually trigger backup retry after resolving disk space or connectivity issues." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Previous backup failure detected; Disk space available; Backup destination accessible",
            "post_action" : "Backup operation retried; Advisor recommendations updated; Backup failure warning cleared if successful"
          },
          "failure_modes" : [ "500 if backup still fails due to persistent disk or connectivity issues" ],
          "error_handling" : [ {
            "code" : "500",
            "action" : "Check monitor disk space; verify backup destination accessibility; resolve underlying storage issues before retry."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Backup retry operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor" ],
          "postprocessing_hint" : "Retry executes immediately; backup success clears related advisor warnings; refresh advisor to see updated status.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/suggestions/{suggestionId}" : {
      "post" : {
        "summary" : "Apply a suggestion from an advisor recommendation",
        "operationId" : "TaskAdvisorResource_applySuggestion",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "suggestionId",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/ManagedThreadTask"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Execute a specific automated fix suggestion from task advisor to resolve cluster issues or warnings.",
          "usage" : [ "Call to apply automatic remediation for advisor recommendations with available fixes.", "Use when manual resolution is complex and advisor provides automated solution." ],
          "response_shape" : "ManagedThreadTask",
          "workflow_guidance" : {
            "pre_check" : "Suggestion exists; Cluster state allows automated fix; Required permissions available",
            "post_action" : "Automated fix executed; Task tracks progress; Recommendation cleared if successful; Cluster state updated"
          },
          "path_parameters" : [ {
            "name" : "suggestionId",
            "in" : "path",
            "description" : "UUID of the suggestion to apply from advisor recommendation.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "404 if suggestion ID does not exist or has already been applied", "500 if automated fix fails due to cluster state or permission issues" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Refresh advisor recommendations; verify suggestion ID exists and is still applicable."
          }, {
            "code" : "500",
            "action" : "Check cluster health; verify permissions; review automated fix logs for specific failure cause."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 1800,
            "note" : "Automated fix execution"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/tasks/{id}" ],
          "postprocessing_hint" : "Fix runs as managed task; monitor task progress; recommendation removed if successful; cluster changes take effect immediately.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/task-advisor/{taskUuid}" : {
      "patch" : {
        "summary" : "Hide a task from the recommendation list",
        "operationId" : "TaskAdvisorResource_patchTask",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskAdvisorUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Hide or show task advisor recommendations to control which warnings are displayed to administrators.",
          "usage" : [ "Call when specific recommendations are not relevant to current operations and should be hidden.", "Use to manage recommendation visibility without deleting the underlying issue detection." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task recommendation exists; Valid hide value provided; Admin permissions verified",
            "post_action" : "Recommendation visibility updated; UI reflects new display state; Underlying issue detection continues"
          },
          "request_parameters" : [ {
            "name" : "hide",
            "in" : "body",
            "description" : "Set to true to hide recommendation, false to show it.",
            "required" : true,
            "example" : "true"
          } ],
          "path_parameters" : [ {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "UUID of the task advisor recommendation to update.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          } ],
          "failure_modes" : [ "404 if task UUID does not exist in current recommendations" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify task UUID exists in advisor recommendations; refresh advisor list; check if recommendation expired."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 3600,
            "note" : "Advisor recommendation updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Visibility change is immediate; hidden recommendations can be shown again later; underlying checks continue regardless of visibility.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Remove a task identified by UUID",
        "operationId" : "TaskAdvisorResource_deleteTaskByUuid",
        "tags" : [ "task-advisor" ],
        "parameters" : [ {
          "name" : "taskUuid",
          "in" : "path",
          "required" : true,
          "schema" : {
            "$ref" : "#/components/schemas/UUID"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Permanently remove a task advisor recommendation to stop it from appearing in future scans.",
          "usage" : [ "Call when a recommendation is no longer applicable due to architectural or policy changes.", "Use to clean up obsolete recommendations that cannot be resolved through normal means." ],
          "response_shape" : "void",
          "path_parameters" : [ {
            "name" : "taskUuid",
            "in" : "path",
            "description" : "Task advisor recommendation UUID to permanently delete.",
            "required" : true,
            "example" : "550e8400-e29b-41d4-a716-446655440000"
          } ],
          "failure_modes" : [ "404 if task UUID does not exist or has already been deleted" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Task may have been already deleted or UUID is invalid; refresh recommendation list."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 3600,
            "note" : "Recommendation cleanup"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/task-advisor", "/task-advisor/{taskUuid}" ],
          "postprocessing_hint" : "Recommendation removed permanently; refresh task advisor dashboard to confirm removal.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting recommendations permanently removes them from future advisor scans"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks" : {
      "get" : {
        "summary" : "Fetch a list of tasks.",
        "operationId" : "TaskResource_getAllTasks",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "$ref" : "#/components/schemas/PaginationRequest"
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/PaginationResponseTaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Paginate through historical and active tasks with optional filtering and sorting.",
          "usage" : [ "Load the task history view with pagination controls.", "Filter tasks by state or name when auditing recent maintenance operations." ],
          "response_shape" : "PaginationResponse<TaskResponse>",
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "PaginationRequest JSON supporting where/order/limit clauses (e.g. {\"limit\":50,\"where\":[{\"state\":{\"_eq\":\"FAILED\"}}]}).",
            "required" : true,
            "example" : "{\"limit\":25,\"order\":[{\"startedAt\":\"desc\"}]}"
          } ],
          "common_parameters" : {
            "pagination.where.state" : "Filter to RUNNING/FAILED to focus on tasks needing action.",
            "pagination.order.startedAt" : "Sort descending to view the newest tasks first."
          },
          "failure_modes" : [ "200 with data=[] when no tasks match the filter" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Relax filters or expand the time range before retrying."
          } ],
          "retry_strategy" : "manual_refresh",
          "rate_limit" : {
            "limit" : 12,
            "window_seconds" : 300,
            "note" : "Task history pagination"
          },
          "cache_hint" : "long-lived",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Use `total` and `limit` to drive pagination UI; hide sensitive task names from non-admin users as returned.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/active" : {
      "get" : {
        "summary" : "Get all currently active tasks (running or waiting).",
        "operationId" : "TaskResource_getAllActiveTasks",
        "tags" : [ "tasks" ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "List all tasks that are currently RUNNING or WAITING.",
          "usage" : [ "Drive dashboards that show live operational activity.", "Poll after submitting work to present users with any tasks that still require monitoring or interaction." ],
          "response_shape" : "array<TaskResponse>",
          "failure_modes" : [ "200 [] when there are no active tasks" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Show a no-active-tasks message and stop polling until new tasks are created."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "Active task overview"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 5,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks", "/tasks/status", "/tasks/{id}" ],
          "postprocessing_hint" : "Sort by startedAt descending and flag WAITING tasks that might require manual approval (question != null).",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/status" : {
      "get" : {
        "summary" : "Get tasks with status.",
        "operationId" : "TaskResource_getTaskStatuses",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "query",
          "schema" : {
            "type" : "array",
            "items" : {
              "type" : "integer",
              "format" : "int32"
            }
          },
          "required" : true
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "type" : "array",
                  "items" : {
                    "$ref" : "#/components/schemas/TaskResponse"
                  }
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Fetch status snapshots for multiple tasks in one request.",
          "usage" : [ "Poll in bulk when coordinating several concurrent background jobs.", "Use after starting a batch of tasks to detect which ones still require attention." ],
          "response_shape" : "array<TaskResponse>",
          "request_parameters" : [ {
            "name" : "id",
            "in" : "query",
            "description" : "Repeatable query parameter listing task ids to inspect (e.g. id=12&id=34).",
            "required" : true,
            "example" : "id=101&id=202"
          } ],
          "failure_modes" : [ "200 [] when none of the supplied task ids are active or visible" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "If expected tasks are missing, query GET /tasks/{id} individually or reload the task history."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Batch status polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Map responses by id; treat missing entries as completed, purged, or permission filtered tasks.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}" : {
      "get" : {
        "summary" : "Get task.",
        "operationId" : "TaskResource_getTaskStatus",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/TaskResponse"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve the latest status snapshot for a single long-running task.",
          "usage" : [ "Call immediately after an endpoint returns a ManagedTask to track its execution until completion.", "Use while showing a task detail drawer to stream progress, log output, and pending questions." ],
          "response_shape" : "TaskResponse",
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier returned when the task was started.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "404 if the task id is unknown or filtered (e.g. non-admins requesting sensitive tasks)" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Confirm the id, ensure sufficient permissions, then fall back to GET /tasks/status for batch checks."
          } ],
          "retry_strategy" : "short_interval_polling",
          "rate_limit" : {
            "limit" : 60,
            "window_seconds" : 60,
            "note" : "Task detail polling"
          },
          "cache_hint" : "no-cache",
          "recommended_poll_interval" : {
            "value" : 3,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/tasks/status", "/tasks/{id}/cancel", "/tasks/{id}/answer" ],
          "postprocessing_hint" : "Stop polling once done=true; treat statusCode 0 as success, -256 as user cancel, others as failure, and surface question tokens when present.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    },
    "/tasks/{id}/answer" : {
      "post" : {
        "summary" : "Answer task question.",
        "operationId" : "TaskResource_answerQuestion",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Task question answer",
          "content" : {
            "*/*" : {
              "schema" : {
                "$ref" : "#/components/schemas/TaskQuestionAnswer"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Provide an answer to a task question to allow the task to continue execution.",
          "usage" : [ "Call when a task is waiting for user input and shows a question in its status.", "Use to respond to confirmation prompts or provide configuration choices for running tasks." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task exists; Task has pending question; Answer token is current; Response is valid option",
            "post_action" : "Answer recorded; Task resumes execution; Question cleared from task status"
          },
          "request_parameters" : [ {
            "name" : "token",
            "in" : "body",
            "description" : "Question token from the task status to ensure answer matches current question.",
            "required" : true,
            "example" : "123e4567-e89b-12d3-a456-426614174000"
          }, {
            "name" : "response",
            "in" : "body",
            "description" : "Answer text matching one of the available response options.",
            "required" : true,
            "example" : "yes"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier that has a pending question.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "400 if question token is invalid or question has already been answered", "400 if response does not match available options", "404 if task does not exist or has no pending question" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Refresh task status to get current question token; verify response matches available options."
          }, {
            "code" : "404",
            "action" : "Check task exists and has question field populated in status response."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 300,
            "note" : "Task question responses"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Answer submission immediately unblocks task execution; monitor task status for progress continuation; question disappears after answer.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/tasks/{id}/cancel" : {
      "post" : {
        "summary" : "Cancel task.",
        "operationId" : "TaskResource_cancelTask",
        "tags" : [ "tasks" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Created"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Cancel a running or waiting task to stop its execution and free system resources.",
          "usage" : [ "Call when a long-running task needs to be stopped due to changed requirements or errors.", "Use to abort tasks that are stuck waiting for user input or taking too long to complete." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "Task exists; Task is running or waiting; User has admin permissions",
            "post_action" : "Cancellation signal sent; Task will terminate gracefully; Status becomes cancelled"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "Numeric task identifier to cancel.",
            "required" : true,
            "example" : "1234"
          } ],
          "failure_modes" : [ "404 if task ID does not exist or is not visible to current user", "400 if task is already completed or cannot be cancelled" ],
          "error_handling" : [ {
            "code" : "404",
            "action" : "Verify task ID exists and is accessible; check task may have already completed."
          }, {
            "code" : "400",
            "action" : "Task may be in final state; refresh task status to confirm current state."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 20,
            "window_seconds" : 300,
            "note" : "Task cancellation requests"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/tasks/{id}", "/tasks/active" ],
          "postprocessing_hint" : "Task cancellation is asynchronous; monitor task status to confirm termination; cancelled tasks show statusCode -256.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users" : {
      "get" : {
        "summary" : "List all known users (local, LDAP and OIDC included).",
        "operationId" : "UserResource_getUsers",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "pagination",
          "in" : "query",
          "schema" : {
            "anyOf" : [ {
              "$ref" : "#/components/schemas/PaginationRequest"
            }, {
              "type" : "null"
            } ]
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/OptionalPaginationResponseAccount"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Retrieve a comprehensive list of all user accounts from local database, LDAP, and OIDC providers.",
          "usage" : [ "Call to display user management dashboards and overview screens.", "Use for audit purposes to see all users with access to the system." ],
          "response_shape" : "OptionalPaginationResponse<Account>",
          "workflow_guidance" : {
            "pre_check" : "Authentication providers (LDAP/OIDC) are accessible if configured",
            "post_action" : "Filter or paginate results for display; differentiate local vs external users"
          },
          "request_parameters" : [ {
            "name" : "pagination",
            "in" : "query",
            "description" : "Optional pagination parameters to limit and offset results.",
            "required" : false,
            "example" : "{\"limit\": 50, \"offset\": 0}"
          } ],
          "failure_modes" : [ "200 with partial results if LDAP/OIDC providers are temporarily unavailable", "500 if database access fails" ],
          "error_handling" : [ {
            "code" : "200",
            "action" : "Check response for provider warnings; external users may be missing during provider outages."
          }, {
            "code" : "500",
            "action" : "Database connectivity issue; retry or check system health."
          } ],
          "retry_strategy" : "exponential_backoff",
          "rate_limit" : {
            "limit" : 30,
            "window_seconds" : 60,
            "note" : "User listing operations"
          },
          "cache_hint" : "short-lived",
          "recommended_poll_interval" : {
            "value" : 30,
            "unit" : "seconds"
          },
          "related_endpoints" : [ "/users/{id}", "/users/{id}/password" ],
          "postprocessing_hint" : "Combines local accounts with external provider data; excludes API tokens; accounts from external providers have negative IDs; pagination applies to merged results.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      },
      "post" : {
        "summary" : "Create a new croit user. Returns the ID of the new user.",
        "operationId" : "UserResource_createUser",
        "tags" : [ "users" ],
        "requestBody" : {
          "description" : "User creation request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/AccountRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "200" : {
            "description" : "OK",
            "content" : {
              "application/json" : {
                "schema" : {
                  "$ref" : "#/components/schemas/GeneratedId"
                }
              }
            }
          }
        },
        "x-llm-hints" : {
          "purpose" : "Create a new local croit user account with specified username and role permissions.",
          "usage" : [ "Call when adding new users to the local authentication system.", "Use to provision user accounts with appropriate viewer or admin access levels." ],
          "response_shape" : "GeneratedId",
          "workflow_guidance" : {
            "pre_check" : "Username is unique; Valid role configuration; Not using API token authentication",
            "post_action" : "User account created; Username and roles stored; Account ID returned for reference"
          },
          "request_parameters" : [ {
            "name" : "username",
            "in" : "body",
            "description" : "Unique username for the new account.",
            "required" : true,
            "example" : "john.doe"
          }, {
            "name" : "roles",
            "in" : "body",
            "description" : "List of role permissions to assign (admin users need both ADMIN and VIEWER roles).",
            "required" : true,
            "example" : "[\"VIEWER\", \"ADMIN\"]"
          } ],
          "failure_modes" : [ "400 if username already exists or is invalid format", "400 if role configuration is invalid", "403 if called by an API token user" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Choose unique username; ensure admin users have both ADMIN and VIEWER roles; verify username format."
          }, {
            "code" : "403",
            "action" : "User creation is restricted to interactive user sessions; API tokens cannot create users."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User account creation"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Account creation is immediate; new user can log in with generated credentials; admin users require both ADMIN and VIEWER roles.",
          "idempotent" : false,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/oidc/{id}/users/{subject}" : {
      "patch" : {
        "summary" : "Update roles of an OIDC user.",
        "operationId" : "UserResource_updateOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "description" : "OIDC user update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for an OIDC user account without affecting their identity provider authentication.",
          "usage" : [ "Call when OIDC user responsibilities change and need different access levels in croit.", "Use to manage role assignments for users authenticated through external identity providers." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "OIDC provider exists; User subject exists; Valid role configuration; Interactive session used",
            "post_action" : "OIDC user roles updated; Changes effective immediately; Identity provider authentication unchanged"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "New list of roles to assign (admin users need both ADMIN and VIEWER roles).",
            "required" : false,
            "example" : "[\"VIEWER\", \"ADMIN\"]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "OIDC provider ID that authenticates this user.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "User subject identifier from the OIDC provider.",
            "required" : true,
            "example" : "user@company.com"
          } ],
          "failure_modes" : [ "400 if OIDC provider or user subject does not exist", "400 if role configuration is invalid", "403 if called by an API token instead of user session" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify OIDC provider exists; confirm user subject is correct; ensure admin users have both roles."
          }, {
            "code" : "403",
            "action" : "User management restricted to interactive sessions; API tokens cannot modify users."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "OIDC user role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/oidc/{id}/users/{subject}" ],
          "postprocessing_hint" : "Role changes are immediate; affects croit permissions only; OIDC authentication and identity remain unchanged.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete an OIDC user.",
        "operationId" : "UserResource_deleteOidcUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        }, {
          "name" : "subject",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "string"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete an OIDC user and immediately invalidate all their active sessions.",
          "usage" : [ "Call when removing OIDC users who no longer need access to the system.", "Use to clean up user accounts when users are removed from the identity provider." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "OIDC user exists; Provider configuration is valid; Admin has interactive session",
            "post_action" : "OIDC user deleted; All user sessions immediately invalidated; User cannot authenticate via OIDC"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "OIDC provider ID that manages this user.",
            "required" : true,
            "example" : "1"
          }, {
            "name" : "subject",
            "in" : "path",
            "description" : "Unique subject identifier from the OIDC provider.",
            "required" : true,
            "example" : "user123@company.com"
          } ],
          "failure_modes" : [ "403 if called by an API token instead of user session", "404 if OIDC user or provider does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when managing OIDC user accounts."
          }, {
            "code" : "404",
            "action" : "User may have already been deleted or OIDC provider configuration changed."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "OIDC user management"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/oidc/{id}/users/{subject}" ],
          "postprocessing_hint" : "Session invalidation happens immediately; user will be logged out of all active sessions; only affects croit access (OIDC provider unchanged).",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting OIDC users will immediately terminate all their sessions and remove access"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}" : {
      "patch" : {
        "summary" : "Update a local croit user.",
        "operationId" : "UserResource_updateUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "User update request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/UserUpdateRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Update role permissions for a local croit user account while ensuring at least one admin remains.",
          "usage" : [ "Call when user responsibilities change and need different access levels.", "Use to grant or revoke permissions while maintaining administrative access to the system." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Valid role configuration; Admin safety preserved; Interactive session used",
            "post_action" : "User roles updated; Changes effective immediately; Admin protection maintained"
          },
          "request_parameters" : [ {
            "name" : "roles",
            "in" : "body",
            "description" : "New list of roles to assign (admin users need both ADMIN and VIEWER roles).",
            "required" : false,
            "example" : "[\"VIEWER\", \"ADMIN\"]"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "User account ID to update.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if user ID does not exist or role configuration is invalid", "400 if removing admin role would leave no admin users", "403 if called by an API token instead of user session" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Verify user exists; ensure admin users have both roles; maintain at least one admin in system."
          }, {
            "code" : "403",
            "action" : "User management restricted to interactive sessions; API tokens cannot modify users."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User role updates"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Role changes are immediate; user may lose current access; system ensures at least one admin remains active.",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Role changes affect user permissions immediately and must preserve admin access"
        },
        "x-required-permissions" : [ "admin" ]
      },
      "delete" : {
        "summary" : "Delete a local croit user account.",
        "operationId" : "UserResource_deleteUser",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Delete a local croit user account while ensuring at least one admin user remains.",
          "usage" : [ "Call when removing users who no longer need access to the system.", "Use for cleanup when decommissioning user accounts from local authentication." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; At least one other local admin account exists if deleting admin; Interactive session required",
            "post_action" : "User account deleted; User sessions invalidated; User cannot log in with local credentials"
          },
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "User ID to delete from the local database.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "403 if called by an API token instead of user session", "400 if attempting to delete the last admin account", "404 if the specified user ID does not exist" ],
          "error_handling" : [ {
            "code" : "403",
            "action" : "Use an interactive admin session for security when managing user accounts."
          }, {
            "code" : "400",
            "action" : "Create another local admin account before deleting the last one; LDAP/OIDC accounts are unaffected."
          }, {
            "code" : "404",
            "action" : "User may have already been deleted; refresh user list to verify."
          } ],
          "retry_strategy" : "none",
          "rate_limit" : {
            "limit" : 10,
            "window_seconds" : 3600,
            "note" : "User management operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Account deletion is immediate; existing sessions remain valid until expiry; only affects local accounts (LDAP/OIDC users managed externally).",
          "idempotent" : true,
          "requires_confirmation" : true,
          "confirmation_reason" : "Deleting user accounts will permanently remove their access and cannot be undone"
        },
        "x-required-permissions" : [ "admin" ]
      }
    },
    "/users/{id}/password" : {
      "put" : {
        "summary" : "Change the password of a local croit user.",
        "operationId" : "UserResource_setPassword",
        "tags" : [ "users" ],
        "parameters" : [ {
          "name" : "id",
          "in" : "path",
          "required" : true,
          "schema" : {
            "type" : "integer",
            "format" : "int32"
          }
        } ],
        "requestBody" : {
          "description" : "Password change request",
          "content" : {
            "application/json" : {
              "schema" : {
                "$ref" : "#/components/schemas/PasswordChangeRequest"
              }
            }
          },
          "required" : true
        },
        "responses" : {
          "204" : {
            "description" : "No Content"
          }
        },
        "x-llm-hints" : {
          "purpose" : "Change the password for a local croit user account with appropriate authorization checks.",
          "usage" : [ "Call when users need to update their passwords or admins need to reset user passwords.", "Use for password security maintenance allowing self-service password changes and admin resets." ],
          "response_shape" : "void",
          "workflow_guidance" : {
            "pre_check" : "User exists; Account is local (not LDAP); Interactive session; Admin permissions for other users",
            "post_action" : "Password updated securely; User can login with new password; Password change logged"
          },
          "request_parameters" : [ {
            "name" : "password",
            "in" : "body",
            "description" : "New password for the user account (cannot be blank).",
            "required" : true,
            "example" : "newSecurePassword123!"
          } ],
          "path_parameters" : [ {
            "name" : "id",
            "in" : "path",
            "description" : "User account ID for password change.",
            "required" : true,
            "example" : "123"
          } ],
          "failure_modes" : [ "400 if password is blank or user is LDAP-managed", "403 if called by API token or non-admin changing another user's password", "404 if user ID does not exist" ],
          "error_handling" : [ {
            "code" : "400",
            "action" : "Provide non-blank password; cannot change passwords for LDAP-managed users."
          }, {
            "code" : "403",
            "action" : "Use interactive session; only admins can change other users' passwords; users can change their own password."
          }, {
            "code" : "404",
            "action" : "Verify user ID exists and is a local (non-LDAP) account."
          } ],
          "retry_strategy" : "manual_retry",
          "rate_limit" : {
            "limit" : 5,
            "window_seconds" : 3600,
            "note" : "Password change operations"
          },
          "cache_hint" : "no-cache",
          "related_endpoints" : [ "/users", "/users/{id}" ],
          "postprocessing_hint" : "Password change is immediate; user must use new password for next login; password is securely hashed and stored; operation is audited.",
          "idempotent" : true,
          "requires_confirmation" : false
        },
        "x-required-permissions" : [ "viewer" ]
      }
    }
  },
  "info" : {
    "title" : "Croit platform API",
    "version" : "1.0",
    "description" : "API documentation for the croit platform."
  }
}